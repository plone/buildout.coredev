Repository: plone.restapi


Branch: refs/heads/master
Date: 2020-08-20T22:31:18+02:00
Author: Andrea Cecchi (cekk) <andrea.cecchi85@gmail.com>
Commit: https://github.com/plone/plone.restapi/commit/ba0aae1e2f840eb0ca47379de276a8753838d054

Handle generic blocks transformers and add "smart fields"  concept (#952)

* index special field into searchableText

* initial generic implementation

* initial generic implementation

* add generic transforms and fix tests because text blocks only have href fields

* add generic transforms and fix tests because text blocks only have href fields

* blacked

* reformatted with black

* add changelog

* handle text block when it's empty

* Add a bit of documentation about smart fields

* Update blocks.py

* flake8 fixes

* black

Co-authored-by: Tiberiu Ichim &lt;tiberiu.ichim@gmail.com&gt;
Co-authored-by: Tiberiu Ichim &lt;tiberiuichim@users.noreply.github.com&gt;
Co-authored-by: Timo Stollenwerk &lt;stollenwerk@kitconcept.com&gt;

Files changed:
A news/952.feature
M docs/source/blocks.rst
M src/plone/restapi/deserializer/blocks.py
M src/plone/restapi/deserializer/configure.zcml
M src/plone/restapi/indexers.py
M src/plone/restapi/serializer/blocks.py
M src/plone/restapi/serializer/configure.zcml
M src/plone/restapi/tests/test_blocks_deserializer.py
M src/plone/restapi/tests/test_blocks_searchable_text.py
M src/plone/restapi/tests/test_blocks_serializer.py
M src/plone/restapi/tests/test_resolveuid.py

b'diff --git a/docs/source/blocks.rst b/docs/source/blocks.rst\nindex 6c6b92130..0c46a5947 100644\n--- a/docs/source/blocks.rst\n+++ b/docs/source/blocks.rst\n@@ -146,6 +146,20 @@ Then register as a subscription adapter::\n   <subscriber factory=".blocks.DatabaseQueryDeserializeTransformer"\n     provides="plone.restapi.interfaces.IBlockFieldDeserializationTransformer"/>\n \n+Generic block transformers and smart fields\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+You can create a block transformer that applies to all blocks, by using `None`\n+as the value for `block_type`. The `order` field still applies, though. Using\n+the generic block transfomers enables us to create **smart block fields**,\n+which are handled differently. For example, any internal link stored as `url`\n+or `href` in a block value is converted (and stored) as a resolveuid-based URL,\n+then resolved back to a full URL on block serialization.\n+\n+Another **smart field** is the `searchableText` field in a block value. It\n+needs to be a plain text value and it will be used in the `SearchableText`\n+value for the context item.\n+\n SearchableText indexing for blocks\n ----------------------------------\n \ndiff --git a/news/952.feature b/news/952.feature\nnew file mode 100644\nindex 000000000..0a818663b\n--- /dev/null\n+++ b/news/952.feature\n@@ -0,0 +1,3 @@\n+- Improved blocks transformers: now we can handle generic transformers [cekk]\n+- Add generic block transformer for handle resolveuid in all blocks that have a *url* or *href* field [cekk]\n+- Add "smart fields" concept: if block has a *searchableText* field, this will be indexed in Plone [cekk, tiberiuichim]\ndiff --git a/src/plone/restapi/deserializer/blocks.py b/src/plone/restapi/deserializer/blocks.py\nindex 333d13c44..ecd4b4d0b 100644\n--- a/src/plone/restapi/deserializer/blocks.py\n+++ b/src/plone/restapi/deserializer/blocks.py\n@@ -16,20 +16,37 @@\n from zope.publisher.interfaces.browser import IBrowserRequest\n \n \n-def path2uid(context, path):\n+def path2uid(context, link):\n     # unrestrictedTraverse requires a string on py3. see:\n     # https://github.com/zopefoundation/Zope/issues/674\n-    if not isinstance(path, str):\n-        path = path.decode("utf-8")\n-    obj = context.unrestrictedTraverse(path, None)\n+    if not link:\n+        return ""\n+    portal = getMultiAdapter(\n+        (context, context.REQUEST), name="plone_portal_state"\n+    ).portal()\n+    portal_url = portal.portal_url()\n+    portal_path = "/".join(portal.getPhysicalPath())\n+    path = link\n+    context_url = context.absolute_url()\n+    relative_up = len(context_url.split("/")) - len(portal_url.split("/"))\n+    if path.startswith(portal_url):\n+        path = path[len(portal_url) + 1 :]\n+    if not path.startswith(portal_path):\n+        path = "{portal_path}/{path}".format(\n+            portal_path=portal_path, path=path.lstrip("/")\n+        )\n+    obj = portal.unrestrictedTraverse(path, None)\n     if obj is None:\n-        return None, None\n+        return link\n     segments = path.split("/")\n     suffix = ""\n     while not IUUIDAware.providedBy(obj):\n         obj = aq_parent(obj)\n         suffix += "/" + segments.pop()\n-    return IUUID(obj), suffix\n+    href = relative_up * "../" + "resolveuid/" + IUUID(obj)\n+    if suffix:\n+        href += suffix\n+    return href\n \n \n @implementer(IFieldDeserializer)\n@@ -43,15 +60,12 @@ def __call__(self, value):\n             for id, block_value in value.items():\n                 block_type = block_value.get("@type", "")\n \n-                handlers = [\n-                    h\n-                    for h in subscribers(\n-                        (self.context, self.request),\n-                        IBlockFieldDeserializationTransformer,\n-                    )\n-                    if h.block_type == block_type\n-                ]\n-\n+                handlers = []\n+                for h in subscribers(\n+                    (self.context, self.request), IBlockFieldDeserializationTransformer\n+                ):\n+                    if h.block_type == block_type or h.block_type is None:\n+                        handlers.append(h)\n                 for handler in sorted(handlers, key=lambda h: h.order):\n                     block_value = handler(block_value)\n \n@@ -60,6 +74,31 @@ def __call__(self, value):\n         return value\n \n \n+@adapter(IBlocks, IBrowserRequest)\n+@implementer(IBlockFieldDeserializationTransformer)\n+class ResolveUIDDeserializer(object):\n+    """ The "url" smart block field.\n+\n+    This is a generic handler. In all blocks, it converts any "url"\n+    field from using resolveuid to an "absolute" URL\n+    """\n+\n+    order = 1\n+    block_type = None\n+\n+    def __init__(self, context, request):\n+        self.context = context\n+        self.request = request\n+\n+    def __call__(self, block):\n+        # Convert absolute links to resolveuid\n+        for field in ["url", "href"]:\n+            link = block.get(field, "")\n+            if link:\n+                block[field] = path2uid(context=self.context, link=link)\n+        return block\n+\n+\n @adapter(IBlocks, IBrowserRequest)\n @implementer(IBlockFieldDeserializationTransformer)\n class TextBlockDeserializer(object):\n@@ -74,28 +113,11 @@ def __call__(self, block):\n         # Convert absolute links to resolveuid\n         # Assumes in-place mutations\n \n-        portal = getMultiAdapter(\n-            (self.context, self.request), name="plone_portal_state"\n-        ).portal()\n-        portal_url = portal.absolute_url()\n-        context_url = self.context.absolute_url()\n-        relative_up = len(context_url.split("/")) - len(portal_url.split("/"))\n         entity_map = block.get("text", {}).get("entityMap", {})\n         for entity in entity_map.values():\n             if entity.get("type") == "LINK":\n-                href = entity.get("data", {}).get("url", "")\n-                before = href  # noqa\n-                if href and href.startswith(portal_url):\n-                    path = href[len(portal_url) + 1 :].encode("utf8")\n-                    uid, suffix = path2uid(portal, path)\n-                    if uid:\n-                        href = relative_up * "../" + "resolveuid/" + uid\n-                        if suffix:\n-                            href += suffix\n-                        entity["data"]["href"] = href\n-                        entity["data"]["url"] = href\n-                    print("DESERIALIZE " + before + " -> " + href)  # noqa\n-\n+                href = entity.get("data", {}).get("href", "")\n+                entity["data"]["href"] = path2uid(context=self.context, link=href)\n         return block\n \n \n@@ -109,17 +131,17 @@ def __init__(self, context, request):\n         self.context = context\n         self.request = request\n \n-    def __call__(self, value):\n+    def __call__(self, block):\n \n         portal_transforms = api.portal.get_tool(name="portal_transforms")\n-        raw_html = value.get("html", "")\n+        raw_html = block.get("html", "")\n         data = portal_transforms.convertTo(\n             "text/x-html-safe", raw_html, mimetype="text/html"\n         )\n         html = data.getData()\n-        value["html"] = html\n+        block["html"] = html\n \n-        return value\n+        return block\n \n \n @adapter(IBlocks, IBrowserRequest)\n@@ -132,23 +154,7 @@ def __init__(self, context, request):\n         self.context = context\n         self.request = request\n \n-    def __call__(self, value):\n-        portal = getMultiAdapter(\n-            (self.context, self.request), name="plone_portal_state"\n-        ).portal()\n-        portal_url = portal.absolute_url()\n-        context_url = self.context.absolute_url()\n-        relative_up = len(context_url.split("/")) - len(portal_url.split("/"))\n-\n-        href = value.get("url", "")\n-\n-        if href and href.startswith(portal_url):\n-            path = href[len(portal_url) + 1 :].encode("utf8")\n-            uid, suffix = path2uid(portal, path)\n-            if uid:\n-                href = relative_up * "../" + "resolveuid/" + uid\n-                if suffix:\n-                    href += suffix\n-\n-        value["url"] = href\n-        return value\n+    def __call__(self, block):\n+        url = block.get("url", "")\n+        block["url"] = path2uid(context=self.context, link=url)\n+        return block\ndiff --git a/src/plone/restapi/deserializer/configure.zcml b/src/plone/restapi/deserializer/configure.zcml\nindex 854e154e7..192924757 100644\n--- a/src/plone/restapi/deserializer/configure.zcml\n+++ b/src/plone/restapi/deserializer/configure.zcml\n@@ -24,6 +24,8 @@\n     provides="plone.restapi.interfaces.IBlockFieldDeserializationTransformer"/>\n   <subscriber factory=".blocks.ImageBlockDeserializer"\n     provides="plone.restapi.interfaces.IBlockFieldDeserializationTransformer"/>\n+  <subscriber factory=".blocks.ResolveUIDDeserializer"\n+    provides="plone.restapi.interfaces.IBlockFieldDeserializationTransformer"/>\n \n   <adapter factory=".local_roles.DeserializeFromJson"\n            name="local_roles"/>\ndiff --git a/src/plone/restapi/indexers.py b/src/plone/restapi/indexers.py\nindex 6f86c9a96..588f126b8 100644\n--- a/src/plone/restapi/indexers.py\n+++ b/src/plone/restapi/indexers.py\n@@ -21,7 +21,7 @@\n \n def _extract_text(block):\n     result = ""\n-    for paragraph in block.get("text").get("blocks"):\n+    for paragraph in block.get("text", {}).get("blocks", {}):\n         text = paragraph["text"]\n         if six.PY2:\n             if isinstance(text, six.text_type):\n@@ -47,12 +47,17 @@ def __call__(self, value):\n @indexer(IBlocks)\n def SearchableText_blocks(obj):\n     request = getRequest()\n-\n     blocks = obj.blocks\n     blocks_text = []\n \n     for block in blocks.values():\n \n+        searchableText = block.get("searchableText", "")\n+        if searchableText:\n+            # TODO: should we evaluate in some way this value? maybe passing\n+            # it into html/plain text transformer?\n+            blocks_text.append(searchableText)\n+\n         block_type = block.get("@type", "")\n         adapter = queryMultiAdapter(\n             (obj, request), IBlockSearchableText, name=block_type\ndiff --git a/src/plone/restapi/serializer/blocks.py b/src/plone/restapi/serializer/blocks.py\nindex 4376c4ad7..bf0ac71e0 100644\n--- a/src/plone/restapi/serializer/blocks.py\n+++ b/src/plone/restapi/serializer/blocks.py\n@@ -22,6 +22,30 @@\n RESOLVEUID_RE = re.compile("^[./]*resolve[Uu]id/([^/]*)/?(.*)$")\n \n \n+def uid_to_url(path):\n+    if not path:\n+        return ""\n+    match = RESOLVEUID_RE.match(path)\n+    if match is None:\n+        return path\n+\n+    uid, suffix = match.groups()\n+    href = uuidToURL(uid)\n+    if href is None:\n+        return path\n+    if suffix:\n+        href += "/" + suffix\n+    else:\n+        target_object = uuidToObject(uid)\n+        if target_object:\n+            adapter = queryMultiAdapter(\n+                (target_object, target_object.REQUEST), IObjectPrimaryFieldTarget\n+            )\n+            if adapter and adapter():\n+                href = adapter()\n+    return href\n+\n+\n @adapter(IJSONField, IBlocks, Interface)\n @implementer(IFieldSerializer)\n class BlocksJSONFieldSerializer(DefaultFieldSerializer):\n@@ -31,15 +55,12 @@ def __call__(self):\n         if self.field.getName() == "blocks":\n             for id, block_value in value.items():\n                 block_type = block_value.get("@type", "")\n-\n-                handlers = [\n-                    h\n-                    for h in subscribers(\n-                        (self.context, self.request),\n-                        IBlockFieldSerializationTransformer,\n-                    )\n-                    if h.block_type == block_type\n-                ]\n+                handlers = []\n+                for h in subscribers(\n+                    (self.context, self.request), IBlockFieldSerializationTransformer\n+                ):\n+                    if h.block_type == block_type or h.block_type is None:\n+                        handlers.append(h)\n \n                 for handler in sorted(handlers, key=lambda h: h.order):\n                     block_value = handler(block_value)\n@@ -49,6 +70,23 @@ def __call__(self):\n         return json_compatible(value)\n \n \n+@implementer(IBlockFieldSerializationTransformer)\n+@adapter(IBlocks, IBrowserRequest)\n+class ResolveUIDSerializer(object):\n+    order = 1\n+    block_type = None\n+\n+    def __init__(self, context, request):\n+        self.context = context\n+        self.request = request\n+\n+    def __call__(self, value):\n+        for field in ["url", "href"]:\n+            if field in value.keys():\n+                value[field] = uid_to_url(value.get(field, ""))\n+        return value\n+\n+\n @implementer(IBlockFieldSerializationTransformer)\n @adapter(IBlocks, IBrowserRequest)\n class TextBlockSerializer(object):\n@@ -65,31 +103,6 @@ def __call__(self, value):\n         for entity in entity_map.values():\n             if entity.get("type") != "LINK":\n                 continue\n-            href = entity.get("data", {}).get("url", "")\n-            before = href  # noqa\n-            if href:\n-                match = RESOLVEUID_RE.match(href)\n-                if match is not None:\n-                    uid, suffix = match.groups()\n-                    href = uuidToURL(uid)\n-                    if href is None:\n-                        continue\n-                    if suffix:\n-                        href += "/" + suffix\n-                    else:\n-                        primary_field_url = self.get_primary_field_target_url(uid)\n-                        href = primary_field_url if primary_field_url else href\n-                    entity["data"]["href"] = href\n-                    entity["data"]["url"] = href\n-                    print("SERIALIZE " + before + " -> " + href)  # noqa\n+            href = entity.get("data", {}).get("href", "")\n+            entity["data"]["href"] = uid_to_url(href)\n         return value\n-\n-    def get_primary_field_target_url(self, uid):\n-        target_object = uuidToObject(uid)\n-        if not target_object:\n-            return\n-        adapter = queryMultiAdapter(\n-            (target_object, self.request), IObjectPrimaryFieldTarget\n-        )\n-        if adapter:\n-            return adapter()\ndiff --git a/src/plone/restapi/serializer/configure.zcml b/src/plone/restapi/serializer/configure.zcml\nindex 7c6a96b75..19bee244f 100644\n--- a/src/plone/restapi/serializer/configure.zcml\n+++ b/src/plone/restapi/serializer/configure.zcml\n@@ -28,6 +28,8 @@\n     <adapter factory=".blocks.BlocksJSONFieldSerializer" />\n     <subscriber factory=".blocks.TextBlockSerializer"\n       provides="plone.restapi.interfaces.IBlockFieldSerializationTransformer"/>\n+    <subscriber factory=".blocks.ResolveUIDSerializer"\n+      provides="plone.restapi.interfaces.IBlockFieldSerializationTransformer"/>\n \n     <configure zcml:condition="installed Products.Archetypes">\n         <adapter factory=".atcontent.SerializeToJson" />\ndiff --git a/src/plone/restapi/tests/test_blocks_deserializer.py b/src/plone/restapi/tests/test_blocks_deserializer.py\nindex f9dc4a7fd..16f46af0a 100644\n--- a/src/plone/restapi/tests/test_blocks_deserializer.py\n+++ b/src/plone/restapi/tests/test_blocks_deserializer.py\n@@ -155,3 +155,31 @@ def test_blocks_image_href(self):\n         self.assertEqual(\n             self.portal.doc1.blocks["123"]["url"], "http://example.com/1.jpg"\n         )\n+\n+    def test_blocks_custom_block_resolve_standard_fields(self):\n+        self.deserialize(\n+            blocks={"123": {"@type": "foo", "url": self.portal.doc1.absolute_url()}}\n+        )\n+        doc_uid = IUUID(self.portal.doc1)\n+\n+        self.assertEqual(\n+            self.portal.doc1.blocks["123"]["url"], "../resolveuid/{}".format(doc_uid)\n+        )\n+\n+        self.deserialize(\n+            blocks={"123": {"@type": "foo", "href": self.portal.doc1.absolute_url()}}\n+        )\n+        doc_uid = IUUID(self.portal.doc1)\n+\n+        self.assertEqual(\n+            self.portal.doc1.blocks["123"]["href"], "../resolveuid/{}".format(doc_uid)\n+        )\n+\n+    def test_blocks_custom_block_doesnt_resolve_non_standard_fields(self):\n+        self.deserialize(\n+            blocks={"123": {"@type": "foo", "link": self.portal.doc1.absolute_url()}}\n+        )\n+\n+        self.assertEqual(\n+            self.portal.doc1.blocks["123"]["link"], self.portal.doc1.absolute_url()\n+        )\ndiff --git a/src/plone/restapi/tests/test_blocks_searchable_text.py b/src/plone/restapi/tests/test_blocks_searchable_text.py\nindex 2ffef4034..1f488a830 100644\n--- a/src/plone/restapi/tests/test_blocks_searchable_text.py\n+++ b/src/plone/restapi/tests/test_blocks_searchable_text.py\n@@ -148,7 +148,56 @@ def __call__(self, value):\n         from plone.indexer.interfaces import IIndexableObject\n \n         wrapper = queryMultiAdapter(\n-            (self.doc, self.portal.portal_catalog,), IIndexableObject\n+            (self.doc, self.portal.portal_catalog), IIndexableObject\n         )\n \n         assert "discovered: sample text" in wrapper.SearchableText\n+\n+    def test_index_searchableText_value(self):\n+        response = self.api_session.patch(\n+            "/doc",\n+            json={\n+                "blocks": {\n+                    "uuid1": {\n+                        "@type": "text",\n+                        "text": {\n+                            "blocks": [\n+                                {\n+                                    "data": {},\n+                                    "depth": 0,\n+                                    "entityRanges": [],\n+                                    "inlineStyleRanges": [],\n+                                    "key": "acv4f",\n+                                    "text": "Plone " "text " "for " "block ",\n+                                    "type": "unstyled",\n+                                }\n+                            ],\n+                            "entityMap": {},\n+                        },\n+                    },\n+                    "uuid2": {\n+                        "@type": "custom_type",\n+                        "searchableText": "custom text foo",\n+                    },\n+                }\n+            },\n+        )\n+\n+        self.assertEqual(response.status_code, 204)\n+\n+        query = {"SearchableText": "Volto", "metadata_fields": "Title"}\n+        response = self.api_session.get("/@search", params=query)\n+        json_response = response.json()\n+        self.assertEqual(json_response["items_total"], 0)\n+\n+        query = {"SearchableText": "Plone", "metadata_fields": "Title"}\n+        response = self.api_session.get("/@search", params=query)\n+        json_response = response.json()\n+        self.assertEqual(json_response["items_total"], 1)\n+        self.assertEqual(json_response["items"][0]["Title"], "A document")\n+\n+        query = {"SearchableText": "custom", "metadata_fields": "Title"}\n+        response = self.api_session.get("/@search", params=query)\n+        json_response = response.json()\n+        self.assertEqual(json_response["items_total"], 1)\n+        self.assertEqual(json_response["items"][0]["Title"], "A document")\ndiff --git a/src/plone/restapi/tests/test_blocks_serializer.py b/src/plone/restapi/tests/test_blocks_serializer.py\nindex 4d8c81ca0..f464c0ec1 100644\n--- a/src/plone/restapi/tests/test_blocks_serializer.py\n+++ b/src/plone/restapi/tests/test_blocks_serializer.py\n@@ -32,9 +32,7 @@ def setUp(self):\n         behavior_list.append("volto.blocks")\n         fti.behaviors = tuple(behavior_list)\n \n-        self.portal.invokeFactory(\n-            "Document", id=u"doc1",\n-        )\n+        self.portal.invokeFactory("Document", id=u"doc1")\n         self.image = self.portal[\n             self.portal.invokeFactory("Image", id="image-1", title="Target image")\n         ]\ndiff --git a/src/plone/restapi/tests/test_resolveuid.py b/src/plone/restapi/tests/test_resolveuid.py\nindex 13503b707..1e09d9c36 100644\n--- a/src/plone/restapi/tests/test_resolveuid.py\n+++ b/src/plone/restapi/tests/test_resolveuid.py\n@@ -103,7 +103,7 @@ def test_blocks_field_serialization_resolves_uids(self):\n         self.assertEqual(\n             value["effbdcdc-253c-41a7-841e-5edb3b56ce32"]["text"]["entityMap"]["0"][\n                 "data"\n-            ]["url"],\n+            ]["href"],\n             self.doc2.absolute_url(),\n         )\n \n@@ -137,10 +137,31 @@ def test_resolveuid_keeps_suffix(self):\n         self.assertEqual(\n             value["effbdcdc-253c-41a7-841e-5edb3b56ce32"]["text"]["entityMap"]["0"][\n                 "data"\n-            ]["url"],\n+            ]["href"],\n             self.doc2.absolute_url() + "/view",\n         )\n \n+    def test_resolveuid_gets_serialized_for_standard_fields(self):\n+        uid = IUUID(self.doc2)\n+        blocks = {"aaa": {"@type": "foo", "url": "../resolveuid/{}/view".format(uid)}}\n+        value = self.serialize("blocks", blocks)\n+        self.assertEqual(value["aaa"]["url"], self.doc2.absolute_url() + "/view")\n+\n+        blocks = {"aaa": {"@type": "foo", "href": "../resolveuid/{}/view".format(uid)}}\n+        value = self.serialize("blocks", blocks)\n+        self.assertEqual(value["aaa"]["href"], self.doc2.absolute_url() + "/view")\n+\n+    def test_resolveuid_serialize_take_care_of_primary_fields(self):\n+        logout()\n+        uid = IUUID(self.doc_primary_field_url)\n+        blocks = {"aaa": {"@type": "foo", "url": "../resolveuid/{}".format(uid)}}\n+        value = self.serialize("blocks", blocks)\n+        self.assertEqual(\n+            value["aaa"]["url"],\n+            self.doc_primary_field_url.absolute_url()\n+            + "/@@download/test_primary_namedfile_field",\n+        )\n+\n     def test_keeps_resolveuid_link_if_unknown_uid(self):\n         uid = "0000"\n         blocks = {\n@@ -219,10 +240,10 @@ def test_blocks_field_serialization_doesnt_update_stored_values(self):\n         self.assertNotEqual(\n             value["effbdcdc-253c-41a7-841e-5edb3b56ce32"]["text"]["entityMap"]["0"][\n                 "data"\n-            ]["url"],\n+            ]["href"],\n             blocks["effbdcdc-253c-41a7-841e-5edb3b56ce32"]["text"]["entityMap"]["0"][\n                 "data"\n-            ]["url"],\n+            ]["href"],\n         )\n \n     def test_blocks_field_deserialization_resolves_paths_to_uids(self):\n@@ -267,7 +288,7 @@ def test_blocks_field_deserialization_resolves_paths_to_uids(self):\n         self.assertEqual(\n             value["effbdcdc-253c-41a7-841e-5edb3b56ce32"]["text"]["entityMap"]["0"][\n                 "data"\n-            ]["url"],\n+            ]["href"],\n             "../resolveuid/{}".format(uid),\n         )\n \n@@ -334,7 +355,7 @@ def test_path_keeps_suffix(self):\n         self.assertEqual(\n             value["effbdcdc-253c-41a7-841e-5edb3b56ce32"]["text"]["entityMap"]["0"][\n                 "data"\n-            ]["url"],\n+            ]["href"],\n             "../resolveuid/{}/view".format(uid),\n         )\n \n@@ -382,7 +403,7 @@ def test_blocks_field_serialization_resolves_uids_with_primary_field_url(self):\n         self.assertEqual(\n             value["effbdcdc-253c-41a7-841e-5edb3b56ce32"]["text"]["entityMap"]["0"][\n                 "data"\n-            ]["url"],\n+            ]["href"],\n             self.doc_primary_field_url.absolute_url()\n             + "/@@download/test_primary_namedfile_field",\n         )\n@@ -431,7 +452,7 @@ def test_blocks_field_serialization_resolves_uids_primary_url_with_edit_permissi\n         self.assertEqual(\n             value["effbdcdc-253c-41a7-841e-5edb3b56ce32"]["text"]["entityMap"]["0"][\n                 "data"\n-            ]["url"],\n+            ]["href"],\n             self.doc_primary_field_url.absolute_url(),\n         )\n \n@@ -465,6 +486,6 @@ def test_resolveuid_with_primary_field_url_keeps_suffix(self):\n         self.assertEqual(\n             value["effbdcdc-253c-41a7-841e-5edb3b56ce32"]["text"]["entityMap"]["0"][\n                 "data"\n-            ]["url"],\n+            ]["href"],\n             self.doc2.absolute_url() + "/view",\n         )\n'

