Repository: plone.restapi


Branch: refs/heads/master
Date: 2023-06-26T16:32:01-07:00
Author: David Glick (davisagli) <david@glicksoftware.com>
Commit: https://github.com/plone/plone.restapi/commit/a29583a51b58b0245ce0d58acf1e518f49367131

Centralize logic for finding all blocks (#1648)

* Centralize block visiting logic

* use generator instead of callback

* lint

* fix zcml for Plone 5

* fix types

* remove unused imports

* Use block visitors for SearchableText indexing

* Depth-first traversal, to match existing behavior

* changelog

* test that visit_blocks returns blocks in the expected order

* docs

Files changed:
A news/1648.feature
A src/plone/restapi/blocks.py
A src/plone/restapi/tests/test_blocks.py
M docs/source/usage/blocks.md
M src/plone/restapi/blocks_linkintegrity.py
M src/plone/restapi/configure.zcml
M src/plone/restapi/deserializer/blocks.py
M src/plone/restapi/indexers.py
M src/plone/restapi/interfaces.py
M src/plone/restapi/serializer/blocks.py
M src/plone/restapi/serializer/site.py

b'diff --git a/docs/source/usage/blocks.md b/docs/source/usage/blocks.md\nindex 5751b737e..995192a84 100644\n--- a/docs/source/usage/blocks.md\n+++ b/docs/source/usage/blocks.md\n@@ -231,3 +231,16 @@ This adapter needs to be registered as a named adapter, where the name is the sa\n ```xml\n <adapter name="image" factory=".indexers.ImageBlockSearchableText" />\n ```\n+\n+## Visit all blocks\n+\n+Since blocks can be contained inside other blocks,\n+it is not always obvious how to find all of the blocks stored on a content item.\n+The `visit_blocks` utility function will iterate over all blocks:\n+\n+```python\n+from plone.restapi.blocks import visit_blocks\n+\n+for block in visit_blocks(context, context.blocks):\n+    print(block)\n+```\ndiff --git a/news/1648.feature b/news/1648.feature\nnew file mode 100644\nindex 000000000..9b7d880cf\n--- /dev/null\n+++ b/news/1648.feature\n@@ -0,0 +1 @@\n+Add `visit_blocks` util for finding all nested blocks. @davisagli\ndiff --git a/src/plone/restapi/blocks.py b/src/plone/restapi/blocks.py\nnew file mode 100644\nindex 000000000..c3d9171dc\n--- /dev/null\n+++ b/src/plone/restapi/blocks.py\n@@ -0,0 +1,75 @@\n+from zope.component import adapter\n+from zope.component import subscribers\n+from zope.interface import implementer\n+from zope.interface import Interface\n+from zope.globalrequest import getRequest\n+from zope.publisher.interfaces.browser import IBrowserRequest\n+from plone.restapi.interfaces import IBlockVisitor\n+\n+\n+def visit_blocks(context, blocks):\n+    """Generator yielding all blocks, including nested blocks.\n+\n+    context: Content item where these blocks are stored.\n+    blocks: A dict mapping block ids to a dict of block data.\n+    """\n+    request = getRequest()\n+    visitors = subscribers((context, request), IBlockVisitor)\n+\n+    def _visit_subblocks(block):\n+        for visitor in visitors:\n+            for subblock in visitor(block):\n+                yield from _visit_subblocks(subblock)\n+        yield block\n+\n+    for block in blocks.values():\n+        yield from _visit_subblocks(block)\n+\n+\n+def visit_subblocks(context, block):\n+    """Generator yielding the immediate subblocks of a block.\n+\n+    context: Context item where this block is stored\n+    block: A dict of block data\n+    """\n+    request = getRequest()\n+    visitors = subscribers((context, request), IBlockVisitor)\n+    for visitor in visitors:\n+        for subblock in visitor(block):\n+            yield subblock\n+\n+\n+def iter_block_transform_handlers(context, block_value, interface):\n+    """Find valid handlers for a particular block transformation.\n+\n+    Looks for adapters of the context and request to this interface.\n+    Then skips any that are disabled or don\'t match the block type,\n+    and returns the remaining handlers sorted by `order`.\n+    """\n+    block_type = block_value.get("@type", "")\n+    handlers = []\n+    for handler in subscribers((context, getRequest()), interface):\n+        if handler.block_type == block_type or handler.block_type is None:\n+            handler.blockid = id\n+            handlers.append(handler)\n+    for handler in sorted(handlers, key=lambda h: h.order):\n+        if not getattr(handler, "disabled", False):\n+            yield handler\n+\n+\n+@implementer(IBlockVisitor)\n+@adapter(Interface, IBrowserRequest)\n+class NestedBlocksVisitor:\n+    """Visit nested blocks."""\n+\n+    def __init__(self, context, request):\n+        pass\n+\n+    def __call__(self, block_value):\n+        """Visit nested blocks in ["data"]["blocks"] or ["blocks"]"""\n+        if "data" in block_value:\n+            if isinstance(block_value["data"], dict):\n+                if "blocks" in block_value["data"]:\n+                    yield from block_value["data"]["blocks"].values()\n+        if "blocks" in block_value:\n+            yield from block_value["blocks"].values()\ndiff --git a/src/plone/restapi/blocks_linkintegrity.py b/src/plone/restapi/blocks_linkintegrity.py\nindex 2b80eb39b..f6c365dd8 100644\n--- a/src/plone/restapi/blocks_linkintegrity.py\n+++ b/src/plone/restapi/blocks_linkintegrity.py\n@@ -2,11 +2,10 @@\n from plone.app.linkintegrity.interfaces import IRetriever\n from plone.app.linkintegrity.retriever import DXGeneral\n from plone.restapi.behaviors import IBlocks\n+from plone.restapi.blocks import iter_block_transform_handlers, visit_blocks\n from plone.restapi.deserializer.blocks import iterate_children\n from plone.restapi.interfaces import IBlockFieldLinkIntegrityRetriever\n from zope.component import adapter\n-from zope.component import subscribers\n-from zope.globalrequest import getRequest\n from zope.interface import implementer\n from zope.publisher.interfaces.browser import IBrowserRequest\n \n@@ -22,22 +21,11 @@ def retrieveLinks(self):\n         blocks = getattr(self.context, "blocks", {})\n         if not blocks:\n             return links\n-        request = getattr(self.context, "REQUEST", None)\n-        if request is None:\n-            # context does not have full acquisition chain\n-            request = getRequest()\n-        for block in blocks.values():\n-            block_type = block.get("@type", None)\n-            handlers = []\n-            for h in subscribers(\n-                (self.context, request),\n-                IBlockFieldLinkIntegrityRetriever,\n+        for block in visit_blocks(self.context, blocks):\n+            for handler in iter_block_transform_handlers(\n+                self.context, block, IBlockFieldLinkIntegrityRetriever\n             ):\n-                if h.block_type == block_type or h.block_type is None:\n-                    handlers.append(h)\n-            for handler in sorted(handlers, key=lambda h: h.order):\n                 links |= set(handler(block))\n-\n         return links\n \n \ndiff --git a/src/plone/restapi/configure.zcml b/src/plone/restapi/configure.zcml\nindex e3202531e..2f79ec0c7 100644\n--- a/src/plone/restapi/configure.zcml\n+++ b/src/plone/restapi/configure.zcml\n@@ -130,6 +130,11 @@\n       name="plone.restapi"\n       />\n \n+  <subscriber\n+      factory=".blocks.NestedBlocksVisitor"\n+      provides="plone.restapi.interfaces.IBlockVisitor"\n+      />\n+\n   <!-- blocks link integrity -->\n   <adapter factory=".blocks_linkintegrity.BlocksRetriever" />\n \ndiff --git a/src/plone/restapi/deserializer/blocks.py b/src/plone/restapi/deserializer/blocks.py\nindex 0fe4dfb04..99199f78a 100644\n--- a/src/plone/restapi/deserializer/blocks.py\n+++ b/src/plone/restapi/deserializer/blocks.py\n@@ -3,13 +3,13 @@\n from plone import api\n from plone.restapi.bbb import IPloneSiteRoot\n from plone.restapi.behaviors import IBlocks\n+from plone.restapi.blocks import iter_block_transform_handlers, visit_blocks\n from plone.restapi.deserializer.dxfields import DefaultFieldDeserializer\n from plone.restapi.deserializer.utils import path2uid\n from plone.restapi.interfaces import IBlockFieldDeserializationTransformer\n from plone.restapi.interfaces import IFieldDeserializer\n from plone.schema import IJSONField\n from zope.component import adapter\n-from zope.component import subscribers\n from zope.interface import implementer\n from zope.publisher.interfaces.browser import IBrowserRequest\n \n@@ -32,60 +32,17 @@ def iterate_children(value):\n @implementer(IFieldDeserializer)\n @adapter(IJSONField, IBlocks, IBrowserRequest)\n class BlocksJSONFieldDeserializer(DefaultFieldDeserializer):\n-    def _transform(self, blocks):\n-        for id, block_value in blocks.items():\n-            self.handle_subblocks(block_value)\n-            block_type = block_value.get("@type", "")\n-            handlers = []\n-            for h in subscribers(\n-                (self.context, self.request),\n-                IBlockFieldDeserializationTransformer,\n-            ):\n-                if h.block_type == block_type or h.block_type is None:\n-                    h.blockid = id\n-                    handlers.append(h)\n-\n-            for handler in sorted(handlers, key=lambda h: h.order):\n-                block_value = handler(block_value)\n-\n-            blocks[id] = block_value\n-\n-        return blocks\n-\n-    def handle_subblocks(self, block_value):\n-        if "data" in block_value:\n-            if isinstance(block_value["data"], dict):\n-                if "blocks" in block_value["data"]:\n-                    block_value["data"]["blocks"] = self._transform(\n-                        block_value["data"]["blocks"]\n-                    )\n-\n-        if "blocks" in block_value:\n-            block_value["blocks"] = self._transform(block_value["blocks"])\n-\n     def __call__(self, value):\n         value = super().__call__(value)\n-\n         if self.field.getName() == "blocks":\n-            for id, block_value in value.items():\n-                self.handle_subblocks(block_value)\n-                block_type = block_value.get("@type", "")\n-\n-                handlers = []\n-                for h in subscribers(\n-                    (self.context, self.request),\n-                    IBlockFieldDeserializationTransformer,\n+            for block in visit_blocks(self.context, value):\n+                new_block = block.copy()\n+                for handler in iter_block_transform_handlers(\n+                    self.context, block, IBlockFieldDeserializationTransformer\n                 ):\n-                    if h.block_type == block_type or h.block_type is None:\n-                        h.blockid = id\n-                        handlers.append(h)\n-\n-                for handler in sorted(handlers, key=lambda h: h.order):\n-                    if not getattr(handler, "disabled", False):\n-                        block_value = handler(block_value)\n-\n-                value[id] = block_value\n-\n+                    new_block = handler(new_block)\n+                block.clear()\n+                block.update(new_block)\n         return value\n \n \ndiff --git a/src/plone/restapi/indexers.py b/src/plone/restapi/indexers.py\nindex b7dd49c8d..cfb65587e 100644\n--- a/src/plone/restapi/indexers.py\n+++ b/src/plone/restapi/indexers.py\n@@ -8,6 +8,7 @@\n from plone.app.contenttypes.indexers import SearchableText\n from plone.indexer.decorator import indexer\n from plone.restapi.behaviors import IBlocks\n+from plone.restapi.blocks import visit_subblocks\n from plone.restapi.interfaces import IBlockSearchableText\n from zope.component import adapter\n from zope.component import queryMultiAdapter\n@@ -70,21 +71,6 @@ def __call__(self, block):\n         return block.get("plaintext", "")\n \n \n-def extract_subblocks(block):\n-    """Extract subblocks from a block.\n-\n-    :param block: Dictionary with block information.\n-    :returns: A list with subblocks, if present, or an empty list.\n-    """\n-    if "data" in block and "blocks" in block["data"]:\n-        raw_blocks = block["data"]["blocks"]\n-    elif "blocks" in block:\n-        raw_blocks = block["blocks"]\n-    else:\n-        raw_blocks = None\n-    return list(raw_blocks.values()) if isinstance(raw_blocks, dict) else []\n-\n-\n def extract_text(block, obj, request):\n     """Extract text information from a block.\n \n@@ -115,8 +101,7 @@ def extract_text(block, obj, request):\n     adapter = queryMultiAdapter((obj, request), IBlockSearchableText, name=block_type)\n     result = adapter(block) if adapter is not None else ""\n     if not result:\n-        subblocks = extract_subblocks(block)\n-        for subblock in subblocks:\n+        for subblock in visit_subblocks(obj, block):\n             tmp_result = extract_text(subblock, obj, request)\n             result = f"{result}\\n{tmp_result}"\n     return result\ndiff --git a/src/plone/restapi/interfaces.py b/src/plone/restapi/interfaces.py\nindex 47427dd9a..5c2aa337e 100644\n--- a/src/plone/restapi/interfaces.py\n+++ b/src/plone/restapi/interfaces.py\n@@ -83,41 +83,47 @@ def __call__(value):\n         """Convert the provided JSON value to a field value."""\n \n \n-class IBlockFieldDeserializationTransformer(Interface):\n-    """Convert/adjust raw block deserialized value into block value."""\n+class IBlockTransformer(Interface):\n+    """Transform a block value.\n+\n+    Meant to be looked up as an adapter of context and request.\n+    The list of transformers is filtered by block_type and sorted by order.\n+    Disabled transformers are ignored.\n+\n+    Block transformers for specific use cases extend this interface.\n+    """\n \n     block_type = Attribute(\n-        "A string with the type of block, the @type from " "the block value"\n+        "A string with the type of block, the @type from the block value"\n     )\n     order = Attribute(\n-        "A number used in sorting value transformers. " "Smaller is executed first"\n+        "A number used in sorting value transformers. Smaller is executed first"\n     )\n     disabled = Attribute("Boolean that disables the transformer if required")\n \n-    def __init__(field, context, request):\n-        """Adapts context and the request."""\n+    def __call__(value):\n+        """Do the transform."""\n+\n+\n+class IBlockFieldDeserializationTransformer(IBlockTransformer):\n+    """Convert/adjust raw block deserialized value into block value."""\n \n     def __call__(value):\n         """Convert the provided raw Python value to a block value."""\n \n \n-class IBlockFieldSerializationTransformer(Interface):\n+class IBlockFieldSerializationTransformer(IBlockTransformer):\n     """Transform block value before final JSON serialization"""\n \n-    block_type = Attribute(\n-        "A string with the type of block, the @type from " "the block value"\n-    )\n-    order = Attribute(\n-        "A number used in sorting value transformers for the "\n-        "same block. Smaller is executed first"\n-    )\n-    disabled = Attribute("Boolean that disables the transformer if required")\n+    def __call__(value):\n+        """Convert the provided raw Python value to a block value."""\n \n-    def __init__(field, context, request):\n-        """Adapts context and the request."""\n+\n+class IBlockFieldLinkIntegrityRetriever(Interface):\n+    """Retrieve internal links set in current block."""\n \n     def __call__(value):\n-        """Convert the provided raw Python value to a block value."""\n+        """Return a list of internal links set in this block."""\n \n \n class IExpandableElement(Interface):\n@@ -210,20 +216,6 @@ def __call__(value):\n         """Extract text from the block value. Returns text"""\n \n \n-class IBlockFieldLinkIntegrityRetriever(Interface):\n-    """Retrieve internal links set in current block."""\n-\n-    block_type = Attribute(\n-        "A string with the type of block, the @type from " "the block value"\n-    )\n-\n-    def __init__(field, context, request):\n-        """Adapts context and the request."""\n-\n-    def __call__(value):\n-        """Return a list of internal links set in this block."""\n-\n-\n class IJSONSummarySerializerMetadata(Interface):\n     """Configure JSONSummary serializer."""\n \n@@ -238,3 +230,13 @@ def non_metadata_attributes():\n \n     def blocklisted_attributes():\n         """Returns a set with attributes blocked during serialization."""\n+\n+\n+class IBlockVisitor(Interface):\n+    """Find sub-blocks\n+\n+    Used by the visit_blocks utility.\n+    """\n+\n+    def __call__(self, block):\n+        """Return an iterable of sub-blocks found inside `block`."""\ndiff --git a/src/plone/restapi/serializer/blocks.py b/src/plone/restapi/serializer/blocks.py\nindex e239233eb..e42e6baf3 100644\n--- a/src/plone/restapi/serializer/blocks.py\n+++ b/src/plone/restapi/serializer/blocks.py\n@@ -1,6 +1,7 @@\n from copy import deepcopy\n from plone.restapi.bbb import IPloneSiteRoot\n from plone.restapi.behaviors import IBlocks\n+from plone.restapi.blocks import visit_blocks, iter_block_transform_handlers\n from plone.restapi.deserializer.blocks import iterate_children\n from plone.restapi.deserializer.blocks import SlateBlockTransformer\n from plone.restapi.deserializer.blocks import transform_links\n@@ -11,8 +12,6 @@\n from plone.restapi.serializer.utils import uid_to_url\n from plone.schema import IJSONField\n from zope.component import adapter\n-from zope.component import subscribers\n-from zope.globalrequest import getRequest\n from zope.interface import implementer\n from zope.interface import Interface\n from zope.publisher.interfaces.browser import IBrowserRequest\n@@ -21,57 +20,6 @@\n import os\n \n \n-def _transform(blocks, context):\n-    for id, block_value in blocks.items():\n-        handle_subblocks(block_value, context)\n-        block_type = block_value.get("@type", "")\n-        handlers = []\n-        for h in subscribers(\n-            (context, getRequest()),\n-            IBlockFieldSerializationTransformer,\n-        ):\n-            if h.block_type == block_type or h.block_type is None:\n-                h.blockid = id\n-                handlers.append(h)\n-\n-        for handler in sorted(handlers, key=lambda h: h.order):\n-            block_value = handler(block_value)\n-\n-        blocks[id] = block_value\n-\n-    return blocks\n-\n-\n-def handle_subblocks(block_value, context):\n-    if "data" in block_value:\n-        if isinstance(block_value["data"], dict):\n-            if "blocks" in block_value["data"]:\n-                block_value["data"]["blocks"] = _transform(\n-                    block_value["data"]["blocks"], context\n-                )\n-\n-    if "blocks" in block_value:\n-        block_value["blocks"] = _transform(block_value["blocks"], context)\n-\n-    return block_value\n-\n-\n-def apply_block_serialization_transforms(block_value, context):\n-    block_value = handle_subblocks(block_value, context)\n-    block_type = block_value.get("@type", "")\n-    handlers = []\n-    for h in subscribers((context, getRequest()), IBlockFieldSerializationTransformer):\n-        if h.block_type == block_type or h.block_type is None:\n-            h.blockid = id\n-            handlers.append(h)\n-\n-    for handler in sorted(handlers, key=lambda h: h.order):\n-        if not getattr(handler, "disabled", False):\n-            block_value = handler(block_value)\n-\n-    return block_value\n-\n-\n @adapter(IJSONField, IBlocks, Interface)\n @implementer(IFieldSerializer)\n class BlocksJSONFieldSerializer(DefaultFieldSerializer):\n@@ -79,11 +27,14 @@ def __call__(self):\n         value = copy.deepcopy(self.get_value())\n \n         if self.field.getName() == "blocks":\n-            for id, block_value in value.items():\n-                value[id] = apply_block_serialization_transforms(\n-                    block_value, self.context\n-                )\n-\n+            for block in visit_blocks(self.context, value):\n+                new_block = block.copy()\n+                for handler in iter_block_transform_handlers(\n+                    self.context, block, IBlockFieldSerializationTransformer\n+                ):\n+                    new_block = handler(new_block)\n+                block.clear()\n+                block.update(new_block)\n         return json_compatible(value)\n \n \ndiff --git a/src/plone/restapi/serializer/site.py b/src/plone/restapi/serializer/site.py\nindex a25464e67..afb778608 100644\n--- a/src/plone/restapi/serializer/site.py\n+++ b/src/plone/restapi/serializer/site.py\n@@ -4,10 +4,11 @@\n from plone.dexterity.utils import iterSchemata\n from plone.restapi.batching import HypermediaBatch\n from plone.restapi.bbb import IPloneSiteRoot\n+from plone.restapi.blocks import visit_blocks, iter_block_transform_handlers\n from plone.restapi.interfaces import IFieldSerializer\n from plone.restapi.interfaces import ISerializeToJson\n from plone.restapi.interfaces import ISerializeToJsonSummary\n-from plone.restapi.serializer.blocks import apply_block_serialization_transforms\n+from plone.restapi.interfaces import IBlockFieldSerializationTransformer\n from plone.restapi.serializer.converters import json_compatible\n from plone.restapi.serializer.expansion import expandable_elements\n from plone.restapi.services.locking import lock_info\n@@ -140,8 +141,12 @@ def check_permission(self, permission_name, obj):\n     def serialize_blocks(self):\n         # This is only for below 6\n         blocks = json.loads(getattr(self.context, "blocks", "{}"))\n-        if not blocks:\n-            return blocks\n-        for id, block_value in blocks.items():\n-            blocks[id] = apply_block_serialization_transforms(block_value, self.context)\n+        for block in visit_blocks(self.context, blocks):\n+            new_block = block.copy()\n+            for handler in iter_block_transform_handlers(\n+                self.context, block, IBlockFieldSerializationTransformer\n+            ):\n+                new_block = handler(new_block)\n+            block.clear()\n+            block.update(new_block)\n         return blocks\ndiff --git a/src/plone/restapi/tests/test_blocks.py b/src/plone/restapi/tests/test_blocks.py\nnew file mode 100644\nindex 000000000..9dc839f98\n--- /dev/null\n+++ b/src/plone/restapi/tests/test_blocks.py\n@@ -0,0 +1,39 @@\n+from plone.dexterity.interfaces import IDexterityFTI\n+from plone.restapi.blocks import visit_blocks\n+from plone.restapi.testing import PLONE_RESTAPI_DX_INTEGRATION_TESTING\n+from zope.component import queryUtility\n+import unittest\n+\n+\n+class TestBlocksVisitor(unittest.TestCase):\n+\n+    layer = PLONE_RESTAPI_DX_INTEGRATION_TESTING\n+\n+    def setUp(self):\n+        self.app = self.layer["app"]\n+        self.portal = self.layer["portal"]\n+        self.request = self.layer["request"]\n+\n+        fti = queryUtility(IDexterityFTI, name="Document")\n+        behavior_list = [a for a in fti.behaviors]\n+        behavior_list.append("volto.blocks")\n+        fti.behaviors = tuple(behavior_list)\n+\n+        self.doc = self.portal.invokeFactory("Document", id="doc1")\n+\n+    def test_visit_blocks(self):\n+        visited = []\n+        blocks = {\n+            "123": {\n+                "@id": "block1",\n+                "blocks": {\n+                    "456": {\n+                        "@id": "block2",\n+                    }\n+                },\n+            }\n+        }\n+        for block in visit_blocks(self.doc, blocks):\n+            visited.append(block["@id"])\n+        # depth-first traversal\n+        self.assertEqual(visited, ["block2", "block1"])\n'

