Repository: plone.app.widgets


Branch: refs/heads/master
Date: 2022-12-01T12:11:52+01:00
Author: Peter Mathis (petschki) <peter.mathis@kombinat.at>
Commit: https://github.com/plone/plone.app.widgets/commit/7e5d09168f939349e8d3cfb44bceccb39fdc7e4b

Deprecate base classes and utils. Notice about removal and new location.

Files changed:
M plone/app/widgets/base.py
M plone/app/widgets/utils.py

b'diff --git a/plone/app/widgets/base.py b/plone/app/widgets/base.py\nindex 7d8b0328..79f89413 100644\n--- a/plone/app/widgets/base.py\n+++ b/plone/app/widgets/base.py\n@@ -1,354 +1,16 @@\n # -*- coding: utf-8 -*-\n-\n-from copy import deepcopy\n-from lxml import etree\n-\n-import json\n-import collections\n-import six\n-\n-\n-def el_attrib(name):\n-    """Helper property methods to get/set/delete element property.\n-\n-    :param name: [required] Name of the element property.\n-    :type name: string\n-\n-    :returns: Property with getter/setter/deletter.\n-    :rtype: property\n-    """\n-\n-    def _get(self):\n-        if name in self.el.attrib:\n-            value = self.el.attrib[name]\n-            if value.strip().startswith(\'[\') or value.strip().startswith(\'{\'):\n-                value = json.loads(value)\n-            return value\n-\n-    def _set(self, value):\n-        if value is None:\n-            return\n-        if isinstance(value, (list, tuple)):\n-            value = \' \'.join(value)\n-        if isinstance(value, (dict, set)):\n-            value = json.dumps(value)\n-        if isinstance(value, six.binary_type):\n-            value = value.decode(\'utf8\')\n-        self.el.attrib[name] = value\n-\n-    def _del(self):\n-        if name in self.el.attrib:\n-            del self.el.attrib[name]\n-\n-    return property(_get, _set, _del)\n-\n-\n-def dict_merge(dict_a, dict_b):\n-    """Helper method which merges two dictionaries.\n-\n-    Recursively merges dict\'s. not just simple a[\'key\'] = b[\'key\'], if\n-    both a and b have a key who\'s value is a dict then dict_merge is called\n-    on both values and the result stored in the returned dictionary.\n-\n-    http://www.xormedia.com/recursively-merge-dictionaries-in-python\n-\n-    :param dict_a: [required] First dictiornary.\n-    :type dict_a: dict\n-\n-    :param dict_b: [required] Second dictiornary.\n-    :type dict_b: dict\n-\n-    :returns: Merged dictionary.\n-    :rtype: dict\n-    """\n-\n-    if not isinstance(dict_b, dict):\n-        return dict_b\n-    result = deepcopy(dict_a)\n-    for k, v in six.iteritems(dict_b):\n-        if k in result and isinstance(result[k], dict):\n-                result[k] = dict_merge(result[k], v)\n-        else:\n-            result[k] = deepcopy(v)\n-    return result\n-\n-\n-class BaseWidget(object):\n-    """Basic patterns widget."""\n-\n-    _klass_prefix = \'pat-\'\n-    klass = el_attrib(\'class\')\n-\n-    def __init__(self, el, pattern, pattern_options={}):\n-        """\n-        :param el: [required] element type (eg. input, div, textarea, a, ...).\n-        :type el: string\n-\n-        :param pattern: [required] Pattern name.\n-        :type pattern: string\n-\n-        :param pattern_options: Patterns options.\n-        :type pattern_options: dict\n-        """\n-\n-        self.pattern = pattern\n-        self.el = etree.Element(el)\n-        if pattern:\n-            self.klass = self._klass_prefix + pattern\n-        self.pattern_options = pattern_options\n-\n-    def update(self):\n-        """Updating pattern_options in element `data-*` attribute."""\n-        if self.pattern_options:\n-            self.el.attrib[\'data-\' + self._klass_prefix + self.pattern] = \\\n-                json.dumps(self.pattern_options)\n-\n-    def render(self):\n-        """Renders the widget\n-\n-        :returns: Widget\'s HTML.\n-        :rtype: string\n-        """\n-\n-        self.update()\n-        return etree.tostring(self.el, encoding=six.text_type)\n-\n-\n-class InputWidget(BaseWidget):\n-    """Widget with `input` element."""\n-\n-    type = el_attrib(\'type\')\n-    value = el_attrib(\'value\')\n-    name = el_attrib(\'name\')\n-\n-    def __init__(self, pattern, pattern_options={}, type=\'text\', name=None,\n-                 value=None):\n-        """\n-        :param pattern: [required] Pattern name.\n-        :type pattern: string\n-\n-        :param pattern_options: Patterns options.\n-        :type pattern_options: dict\n-\n-        :param type: `type` attribute of element.\n-        :type type: string\n-\n-        :param name: `name` attribute of element.\n-        :type name: string\n-\n-        :param value: `value` attribute of element.\n-        :type value: string\n-        """\n-        super(InputWidget, self).__init__(\'input\', pattern, pattern_options)\n-        self.type = type\n-        if name is not None:\n-            self.name = name\n-        if value is not None:\n-            self.value = value\n-\n-\n-class SelectWidget(BaseWidget):\n-    """Widget with `select` element."""\n-\n-    name = el_attrib(\'name\')\n-    _multiple = el_attrib(\'multiple\')\n-\n-    def __init__(self, pattern, pattern_options={}, items=[], name=None,\n-                 value=None, multiple=False):\n-        """\n-        :param pattern: [required] Pattern name.\n-        :type pattern: string\n-\n-        :param pattern_options: Patterns options.\n-        :type pattern_options: dict\n-\n-        :param items: List of value and title pairs which represents possible\n-                      options to choose from.\n-        :type items: list\n-\n-        :param name: `name` attribute of element.\n-        :type name: string\n-\n-        :param value: `value` attribute of element.\n-        :type value: string\n-\n-        :param multiple: `multiple` attribute of element.\n-        :type multiple: bool\n-        """\n-        super(SelectWidget, self).__init__(\'select\', pattern, pattern_options)\n-        self.el.text = \'\'\n-        self.items = items\n-        self.multiple = multiple\n-        if name is not None:\n-            self.name = name\n-        if value is not None:\n-            self.value = value\n-\n-    def _get_items(self):\n-        """Get list of possible options.\n-\n-        :returns: List of value and title pairs.\n-        :rtype: list\n-        """\n-        if self.el.find(\'optgroup\') is not None:\n-            return collections.OrderedDict(\n-                (group.attrib[\'label\'], [\n-                    (option.attrib[\'value\'], option.text)\n-                    for option in group.iter("option")])\n-                for group in self.el.iter("optgroup"))\n-        else:\n-            return [\n-                (option.attrib[\'value\'], option.text)\n-                for option in self.el.iter("option")]\n-\n-    def _set_items(self, value):\n-        """Set options for element.\n-\n-        :param value: List of value and title pairs which represents possible\n-                      options to choose from.\n-        :type value: list\n-        """\n-        def addOptions(el, options):\n-            """\n-            Add <option> elements for each vocab item.\n-            """\n-            for token, title in options:\n-                option = etree.SubElement(el, \'option\')\n-                option.attrib[\'value\'] = token\n-                option.text = title\n-\n-        if isinstance(value, dict):\n-            for group_label, options in value.items():\n-                group = etree.SubElement(self.el, \'optgroup\')\n-                group.attrib[\'label\'] = group_label\n-                addOptions(group, options)\n-        else:\n-            for token, title in value:\n-                option = etree.SubElement(self.el, \'option\')\n-                option.attrib[\'value\'] = token\n-                option.text = title\n-\n-    def _del_items(self):\n-        """Removing options from inside of elements."""\n-        for group in self.el.iter("optgroup"):\n-            self.el.remove(group)\n-        for element in self.el.iter("option"):\n-            self.el.remove(element)\n-\n-    items = property(_get_items, _set_items, _del_items)\n-\n-    def _get_value(self):\n-        """Return selected option(s).\n-\n-        :returns: Returns list of selected option(s) values.\n-        :rtype: list\n-        """\n-        value = []\n-        for element in self.el.iter("option"):\n-            if \'selected\' in element.attrib and \\\n-                    element.attrib[\'selected\'] == \'selected\':\n-                value.append(element.attrib[\'value\'])\n-        return value\n-\n-    def _set_value(self, value):\n-        """Select option(s).\n-\n-        :param value: We are expecting option\'s value which should be selected.\n-        :type value: list or string\n-        """\n-        if isinstance(value, six.string_types):\n-            value = [value]\n-\n-        for element in self.el.iter("option"):\n-            if element.attrib[\'value\'] in value:\n-                element.attrib[\'selected\'] = \'selected\'\n-            elif \'selected\' in element.attrib and \\\n-                    element.attrib[\'selected\'] == \'selected\':\n-                del element.attrib[\'selected\']\n-\n-    def _del_value(self):\n-        """Unselect all selected options.\n-        """\n-        for element in self.el.iter("option"):\n-            if \'selected\' in element.attrib and \\\n-               element.attrib[\'selected\'] == \'selected\':\n-                del element.attrib[\'selected\']\n-\n-    value = property(_get_value, _set_value, _del_value)\n-\n-    def _get_multiple(self):\n-        """Does element allows multiple items to be selected.\n-\n-        :returns: `True` if allows multiple elements to be selected, otherwise\n-                  `False`.\n-        :rtype: bool\n-        """\n-        if self._multiple == \'multiple\':\n-            return True\n-        return False\n-\n-    def _set_multiple(self, value):\n-        """Make element accept multiple values.\n-\n-        :param value: `True` if you want to set element as `multiple`,\n-                      otherwise `False`\n-        :type value: bool\n-        """\n-        if value:\n-            self._multiple = \'multiple\'\n-        else:\n-            self._del_multiple()\n-\n-    def _del_multiple(self):\n-        """Remove `multiple` attribute from element."""\n-        del self._multiple\n-\n-    multiple = property(_get_multiple, _set_multiple, _del_multiple)\n-\n-\n-class TextareaWidget(BaseWidget):\n-    """Widget with `textarea` element."""\n-\n-    name = el_attrib(\'name\')\n-\n-    def __init__(self, pattern, pattern_options={}, name=None, value=None):\n-        """\n-        :param pattern: [required] Pattern name.\n-        :type pattern: string\n-\n-        :param pattern_options: Patterns options.\n-        :type pattern_options: dict\n-\n-        :param name: `name` attribute of element.\n-        :type name: string\n-\n-        :param value: `value` of element.\n-        :type value: string\n-        """\n-        super(TextareaWidget, self).__init__(\'textarea\', pattern,\n-                                             pattern_options)\n-        self.el.text = \'\'\n-        if name is not None:\n-            self.name = name\n-        if value is not None:\n-            self.value = value\n-\n-    def _get_value(self):\n-        """\n-        :returns: Value of element.\n-        :rtype: string\n-        """\n-        return self.el.text\n-\n-    def _set_value(self, value):\n-        """\n-        :param value: Set value of element.\n-        :type value: string\n-        """\n-        self.el.text = value\n-\n-    def _del_value(self):\n-        """Set empty string as value of element."""\n-        self.el.text = \'\'\n-\n-    value = property(_get_value, _set_value, _del_value)\n+import zope.deferredimport\n+\n+\n+zope.deferredimport.deprecated(\n+    "Import from plone.app.z3cform.utils instead (this package will be removed in Plone 7)",\n+    el_attrib=\'plone.app.z3cform.utils:el_attrib\',\n+    dict_merge=\'plone.app.z3cform.utils:dict_merge\',\n+)\n+zope.deferredimport.deprecated(\n+    "Import from plone.app.z3cform.widgets.patterns instead (this package will be removed in Plone 7)",\n+    BaseWidget=\'plone.app.z3cform.widgets.patterns:BaseWidget\',\n+    InputWidget=\'plone.app.z3cform.widgets.patterns:InputWidget\',\n+    SelectWidget=\'plone.app.z3cform.widgets.patterns:SelectWidget\',\n+    TextareaWidget=\'plone.app.z3cform.widgets.patterns:TextareaWidget\',\n+)\ndiff --git a/plone/app/widgets/utils.py b/plone/app/widgets/utils.py\nindex 2e2dc15a..5d16ebd1 100644\n--- a/plone/app/widgets/utils.py\n+++ b/plone/app/widgets/utils.py\n@@ -1,253 +1,32 @@\n # -*- coding: utf-8 -*-\n-from Acquisition import aq_base\n-from Acquisition import aq_parent\n-from datetime import datetime\n-from OFS.interfaces import IFolder\n-from OFS.interfaces import ISimpleItem\n-from plone.app.layout.navigation.root import getNavigationRootObject\n-from Products.CMFCore.interfaces import ISiteRoot\n-from Products.CMFCore.utils import getToolByName\n-from Products.CMFPlone.utils import get_top_site_from_url\n-from z3c.form.interfaces import IForm\n-from zope.component import ComponentLookupError\n-from zope.component import getMultiAdapter\n-from zope.component import providedBy\n-from zope.component import queryUtility\n-from zope.component.hooks import getSite\n-from zope.deprecation import deprecate\n-from zope.globalrequest import getRequest\n-from zope.i18n import translate\n-from zope.i18nmessageid import MessageFactory\n-from zope.schema.interfaces import IVocabularyFactory\n-\n-import logging\n-import json\n import zope.deferredimport\n \n \n-logger = logging.getLogger("plone.app.widgets.utils")\n-\n-\n-_ = MessageFactory(\'plone\')\n-\n-\n zope.deferredimport.deprecated(\n-    \'Import first_weekday from plone.app.event.base instead\',\n-    first_weekday=\'plone.app.event.base:first_weekday\',\n+    "Import from plone.app.z3cform.widgets.base instead (this package will be removed in Plone 7)",\n+    NotImplemented=\'plone.app.z3cform.widgets.base:PatternNotImplemented\',\n+)\n+zope.deferredimport.deprecated(\n+    "Import from plone.app.z3cform.widgets.datetime instead (this package will be removed in Plone 7)",\n+    get_date_options=\'plone.app.z3cform.widgets.datetime:get_date_options\',\n+    get_datetime_options=\'plone.app.z3cform.widgets.datetime:get_date_options\',\n+)\n+zope.deferredimport.deprecated(\n+    "Import from plone.app.z3cform.widgets.relateditems instead (this package will be removed in Plone 7)",\n+    get_relateditems_options=\'plone.app.z3cform.widgets.relateditems:get_relateditems_options\',\n+)\n+zope.deferredimport.deprecated(\n+    "Import from plone.app.z3cform.widgets.querystring instead (this package will be removed in Plone 7)",\n+    get_querystring_options=\'plone.app.z3cform.widgets.querystring:get_querystring_options\',\n+)\n+zope.deferredimport.deprecated(\n+    "Import from plone.app.z3cform.widgets.richtext instead (this package will be removed in Plone 7)",\n+    get_tinymce_options=\'plone.app.z3cform.widgets.richtext:get_tinymce_options\',\n+)\n+zope.deferredimport.deprecated(\n+    "Import from plone.app.z3cform.utils instead (this package will be removed in Plone 7)",\n+    get_portal=\'plone.app.z3cform.utils:get_portal\',\n+    get_portal_url=\'plone.app.z3cform.utils:get_portal_url\',\n+    get_context_url=\'plone.app.z3cform.utils:get_context_url\',\n+    get_Widget_form=\'plone.app.z3cform.utils:get_Widget_form\',\n )\n-\n-\n-class NotImplemented(Exception):\n-    """Raised when method/property is not implemented"""\n-\n-\n-def get_date_options(request):\n-    calendar = request.locale.dates.calendars[\'gregorian\']\n-    today = datetime.today()\n-    return {\n-        \'behavior\': \'native\',\n-        \'week-numbers\': \'show\',\n-        \'first-day\': calendar.week.get(\'firstDay\') == 1 and 1 or 0,\n-        \'today\': translate(_(u"Today"), context=request),\n-        \'clear\': translate(_(u"Clear"), context=request),\n-    }\n-\n-\n-def get_datetime_options(request):\n-    options = get_date_options(request)\n-    return options\n-\n-\n-@deprecate("features were moved into the AjaxSelectWidget, remove in Plone 6")\n-def get_ajaxselect_options(context, value, separator, vocabulary_name,\n-                           vocabulary_view, field_name=None):\n-    # code now part of the widget, let it in here for BBB and remove in Plone 6\n-    options = {\'separator\': separator}\n-    if vocabulary_name:\n-        options[\'vocabularyUrl\'] = \'{}/{}?name={}\'.format(\n-            get_context_url(context), vocabulary_view, vocabulary_name)\n-        if field_name:\n-            options[\'vocabularyUrl\'] += \'&field={}\'.format(field_name)\n-        if value:\n-            vocabulary = queryUtility(IVocabularyFactory, vocabulary_name)\n-            if vocabulary:\n-                options[\'initialValues\'] = {}\n-                vocabulary = vocabulary(context)\n-                # Catalog\n-                if vocabulary_name == \'plone.app.vocabularies.Catalog\':\n-                    uids = value.split(separator)\n-                    try:\n-                        catalog = getToolByName(context, \'portal_catalog\')\n-                    except AttributeError:\n-                        catalog = getToolByName(getSite(), \'portal_catalog\')\n-                    for item in catalog(UID=uids):\n-                        options[\'initialValues\'][item.UID] = item.Title\n-                else:\n-                    for value in value.split(separator):\n-                        try:\n-                            term = vocabulary.getTerm(value)\n-                            options[\'initialValues\'][term.token] = term.title\n-                        except LookupError:\n-                            options[\'initialValues\'][value] = value\n-    return options\n-\n-\n-def get_relateditems_options(context, value, separator, vocabulary_name,\n-                             vocabulary_view, field_name=None,\n-                             include_recently_added=True):\n-\n-    if IForm.providedBy(context):\n-        context = context.context\n-\n-    request = getRequest()\n-    site = get_top_site_from_url(context, request)\n-    options = {\n-        \'separator\': separator,\n-    }\n-    if not vocabulary_name:\n-        # we need a vocabulary!\n-        raise ValueError(\'RelatedItems needs a vocabulary\')\n-    options[\'vocabularyUrl\'] = \'{0}/{1}?name={2}\'.format(\n-        get_context_url(site), vocabulary_view, vocabulary_name,\n-    )\n-    if field_name:\n-        options[\'vocabularyUrl\'] += \'&field={0}\'.format(field_name)\n-    if value:\n-        options[\'initialValues\'] = {}\n-        catalog = False\n-        if vocabulary_name == \'plone.app.vocabularies.Catalog\':\n-            catalog = getToolByName(getSite(), \'portal_catalog\')\n-        for value in value.split(separator):\n-            title = value\n-            if catalog:\n-                result = catalog(UID=value)\n-                title = result[0].Title if result else value\n-            options[\'initialValues\'][value] = title\n-\n-    nav_root = getNavigationRootObject(context, site)\n-\n-    if not ISimpleItem.providedBy(context):\n-        context = nav_root\n-\n-    # basePath - start to search/browse in here.\n-    base_path_context = context\n-    if not IFolder.providedBy(base_path_context):\n-        base_path_context = aq_parent(base_path_context)\n-    if not base_path_context:\n-        base_path_context = nav_root\n-    options[\'basePath\'] = \'/\'.join(base_path_context.getPhysicalPath())\n-\n-    # rootPath - Only display breadcrumb elements deeper than this path.\n-    options[\'rootPath\'] = \'/\'.join(site.getPhysicalPath()) if site else \'/\'\n-\n-    # rootUrl: Visible URL up to the rootPath. This is prepended to the\n-    # currentPath to generate submission URLs.\n-    options[\'rootUrl\'] = site.absolute_url() if site else \'\'\n-\n-    # contextPath - current edited object. Will not be available to select.\n-    options[\'contextPath\'] = \'/\'.join(context.getPhysicalPath())\n-\n-    if base_path_context != nav_root:\n-        options[\'favorites\'] = [\n-            {\n-                \'title\': _(u\'Current Content\'),\n-                \'path\': \'/\'.join(base_path_context.getPhysicalPath())\n-            }, {\n-                \'title\': _(u\'Start Page\'),\n-                \'path\': \'/\'.join(nav_root.getPhysicalPath())\n-            }\n-        ]\n-\n-    if include_recently_added:\n-        # Options for recently used key\n-        tool = getToolByName(context, \'portal_membership\')\n-        user = tool.getAuthenticatedMember()\n-        options[\'recentlyUsed\'] = False  # Keep that off in Plone 5.1\n-        options[\'recentlyUsedKey\'] = (u\'relateditems_recentlyused_%s_%s\' % (\n-            field_name or \'\',\n-            user.id\n-        ))  # use string substitution with %s here for automatic str casting.\n-\n-    return options\n-\n-\n-def get_querystring_options(context, querystring_view):\n-    portal_url = get_portal_url(context)\n-    try:\n-        base_url = context.absolute_url()\n-    except AttributeError:\n-        base_url = portal_url\n-    return {\n-        \'indexOptionsUrl\': \'{}/{}\'.format(portal_url, querystring_view),\n-        \'previewURL\': \'%s/@@querybuilder_html_results\' % base_url,\n-        \'previewCountURL\': \'%s/@@querybuildernumberofresults\' % base_url,\n-        \'patternDateOptions\': get_date_options(getRequest()),\n-        \'patternAjaxSelectOptions\': {\'separator\': \';\'},\n-        \'patternRelateditemsOptions\': get_relateditems_options(\n-            context,\n-            None,\n-            \';\',\n-            \'plone.app.vocabularies.Catalog\',\n-            \'@@getVocabulary\',\n-            \'relatedItems\',\n-            include_recently_added=False\n-        )\n-    }\n-\n-\n-def get_tinymce_options(context, field, request):\n-    """\n-    We\'re just going to be looking up settings from\n-    plone pattern options\n-    """\n-    options = {}\n-    try:\n-        pattern_options = getMultiAdapter(\n-            (context, request, field),\n-            name="plone_settings").tinymce()[\'data-pat-tinymce\']\n-        options = json.loads(pattern_options)\n-    except (ComponentLookupError, AttributeError):\n-        logger.warning("Can not load tinymce pattern options!", exc_info=True)\n-    return options\n-\n-\n-def get_portal():\n-    closest_site = getSite()\n-    if closest_site is not None:\n-        for potential_portal in closest_site.aq_chain:\n-            if ISiteRoot in providedBy(potential_portal):\n-                return potential_portal\n-\n-\n-def get_portal_url(context):\n-    portal = get_portal()\n-    if portal:\n-        root = getNavigationRootObject(context, portal)\n-        if root:\n-            try:\n-                return root.absolute_url()\n-            except AttributeError:\n-                return portal.absolute_url()\n-        else:\n-            return portal.absolute_url()\n-    return \'\'\n-\n-\n-def get_context_url(context):\n-    if IForm.providedBy(context):\n-        # Use the request URL if we are looking at an addform\n-        url = context.request.get(\'URL\')\n-    elif hasattr(context, \'absolute_url\'):\n-        url = context.absolute_url\n-        if callable(url):\n-            url = url()\n-    else:\n-        url = get_portal_url(context)\n-    return url\n-\n-\n-def get_widget_form(widget):\n-    form = getattr(widget, \'form\', None)\n-    if getattr(aq_base(form), \'parentForm\', None) is not None:\n-        form = form.parentForm\n-    return form\n'

Repository: plone.app.widgets


Branch: refs/heads/master
Date: 2022-12-01T12:13:54+01:00
Author: Peter Mathis (petschki) <peter.mathis@kombinat.at>
Commit: https://github.com/plone/plone.app.widgets/commit/d6ecd068bcf8a3817d2102e9cebab4f0c1e6a05b

changenote

Files changed:
A news/220.breaking

b'diff --git a/news/220.breaking b/news/220.breaking\nnew file mode 100644\nindex 00000000..a049742d\n--- /dev/null\n+++ b/news/220.breaking\n@@ -0,0 +1,3 @@\n+Make this package deprecated. Widget base classes moved to ``plone.app.z3cform.widgets.patterns``.\n+Also see ``plone.app.widgets.utils`` for informatino about moving utility methods to their new location.\n+[petschki]\n'

Repository: plone.app.widgets


Branch: refs/heads/master
Date: 2023-04-24T14:09:50+02:00
Author: Peter Mathis (petschki) <petschki@users.noreply.github.com>
Commit: https://github.com/plone/plone.app.widgets/commit/60edab3e71d8704b8d6198ad8115cfff6213edec

Merge branch 'master' into deprecate-package

Files changed:
M CHANGES.rst
M setup.py

b"diff --git a/CHANGES.rst b/CHANGES.rst\nindex e88e1673..4775ef5d 100644\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -8,6 +8,28 @@ Changelog\n \n .. towncrier release notes start\n \n+4.0.1 (2023-02-22)\n+------------------\n+\n+Bug fixes:\n+\n+\n+- Depend on plone.base (#222)\n+\n+\n+4.0.0 (2022-12-05)\n+------------------\n+\n+Bug fixes:\n+\n+\n+- Final release for Plone 6.0.0.\n+  Note that new code should not use this package, if possible.\n+  Prefer using code from ``plone.app.z3cform``.\n+  But some code still needs to be moved there, see `issue 220 <https://github.com/plone/plone.app.widgets/issues/220>`_.\n+  [maurits] (#600)\n+\n+\n 4.0.0b1 (2022-08-30)\n --------------------\n \ndiff --git a/setup.py b/setup.py\nindex 5416f1aa..03456d27 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -1,6 +1,6 @@\n from setuptools import setup, find_packages\n \n-version = '4.0.0b2.dev0'\n+version = '4.0.2.dev0'\n \n setup(\n     name='plone.app.widgets',\n@@ -31,11 +31,12 @@\n     namespace_packages=['plone', 'plone.app'],\n     include_package_data=True,\n     zip_safe=False,\n+    python_requires='>=3.8',\n     install_requires=[\n         'setuptools',\n         # needed because users vocabulary was added here\n         'plone.app.vocabularies>=2.1.12',\n-        'Products.CMFPlone>=5.2',\n+        'plone.base',\n         'six',\n     ],\n     extras_require={\n"

Repository: plone.app.widgets


Branch: refs/heads/master
Date: 2023-07-11T12:09:13+02:00
Author: Johannes Raggam (thet) <thetetet@gmail.com>
Commit: https://github.com/plone/plone.app.widgets/commit/f06a5fd35724be53956a0616d3981754a636b24a

Update news/220.breaking

Files changed:
M news/220.breaking

b'diff --git a/news/220.breaking b/news/220.breaking\nindex a049742d..2f4b6f7f 100644\n--- a/news/220.breaking\n+++ b/news/220.breaking\n@@ -1,3 +1,3 @@\n Make this package deprecated. Widget base classes moved to ``plone.app.z3cform.widgets.patterns``.\n-Also see ``plone.app.widgets.utils`` for informatino about moving utility methods to their new location.\n+Also see ``plone.app.widgets.utils`` for information about moving utility methods to their new location.\n [petschki]\n'

Repository: plone.app.widgets


Branch: refs/heads/master
Date: 2023-07-11T12:09:38+02:00
Author: Johannes Raggam (thet) <thetetet@gmail.com>
Commit: https://github.com/plone/plone.app.widgets/commit/538560071f35889b8c6d09a509b48b346be12d7b

Merge pull request #221 from plone/deprecate-package

Deprecate package

Files changed:
A news/220.breaking
M plone/app/widgets/base.py
M plone/app/widgets/utils.py

b'diff --git a/news/220.breaking b/news/220.breaking\nnew file mode 100644\nindex 00000000..2f4b6f7f\n--- /dev/null\n+++ b/news/220.breaking\n@@ -0,0 +1,3 @@\n+Make this package deprecated. Widget base classes moved to ``plone.app.z3cform.widgets.patterns``.\n+Also see ``plone.app.widgets.utils`` for information about moving utility methods to their new location.\n+[petschki]\ndiff --git a/plone/app/widgets/base.py b/plone/app/widgets/base.py\nindex 7d8b0328..79f89413 100644\n--- a/plone/app/widgets/base.py\n+++ b/plone/app/widgets/base.py\n@@ -1,354 +1,16 @@\n # -*- coding: utf-8 -*-\n-\n-from copy import deepcopy\n-from lxml import etree\n-\n-import json\n-import collections\n-import six\n-\n-\n-def el_attrib(name):\n-    """Helper property methods to get/set/delete element property.\n-\n-    :param name: [required] Name of the element property.\n-    :type name: string\n-\n-    :returns: Property with getter/setter/deletter.\n-    :rtype: property\n-    """\n-\n-    def _get(self):\n-        if name in self.el.attrib:\n-            value = self.el.attrib[name]\n-            if value.strip().startswith(\'[\') or value.strip().startswith(\'{\'):\n-                value = json.loads(value)\n-            return value\n-\n-    def _set(self, value):\n-        if value is None:\n-            return\n-        if isinstance(value, (list, tuple)):\n-            value = \' \'.join(value)\n-        if isinstance(value, (dict, set)):\n-            value = json.dumps(value)\n-        if isinstance(value, six.binary_type):\n-            value = value.decode(\'utf8\')\n-        self.el.attrib[name] = value\n-\n-    def _del(self):\n-        if name in self.el.attrib:\n-            del self.el.attrib[name]\n-\n-    return property(_get, _set, _del)\n-\n-\n-def dict_merge(dict_a, dict_b):\n-    """Helper method which merges two dictionaries.\n-\n-    Recursively merges dict\'s. not just simple a[\'key\'] = b[\'key\'], if\n-    both a and b have a key who\'s value is a dict then dict_merge is called\n-    on both values and the result stored in the returned dictionary.\n-\n-    http://www.xormedia.com/recursively-merge-dictionaries-in-python\n-\n-    :param dict_a: [required] First dictiornary.\n-    :type dict_a: dict\n-\n-    :param dict_b: [required] Second dictiornary.\n-    :type dict_b: dict\n-\n-    :returns: Merged dictionary.\n-    :rtype: dict\n-    """\n-\n-    if not isinstance(dict_b, dict):\n-        return dict_b\n-    result = deepcopy(dict_a)\n-    for k, v in six.iteritems(dict_b):\n-        if k in result and isinstance(result[k], dict):\n-                result[k] = dict_merge(result[k], v)\n-        else:\n-            result[k] = deepcopy(v)\n-    return result\n-\n-\n-class BaseWidget(object):\n-    """Basic patterns widget."""\n-\n-    _klass_prefix = \'pat-\'\n-    klass = el_attrib(\'class\')\n-\n-    def __init__(self, el, pattern, pattern_options={}):\n-        """\n-        :param el: [required] element type (eg. input, div, textarea, a, ...).\n-        :type el: string\n-\n-        :param pattern: [required] Pattern name.\n-        :type pattern: string\n-\n-        :param pattern_options: Patterns options.\n-        :type pattern_options: dict\n-        """\n-\n-        self.pattern = pattern\n-        self.el = etree.Element(el)\n-        if pattern:\n-            self.klass = self._klass_prefix + pattern\n-        self.pattern_options = pattern_options\n-\n-    def update(self):\n-        """Updating pattern_options in element `data-*` attribute."""\n-        if self.pattern_options:\n-            self.el.attrib[\'data-\' + self._klass_prefix + self.pattern] = \\\n-                json.dumps(self.pattern_options)\n-\n-    def render(self):\n-        """Renders the widget\n-\n-        :returns: Widget\'s HTML.\n-        :rtype: string\n-        """\n-\n-        self.update()\n-        return etree.tostring(self.el, encoding=six.text_type)\n-\n-\n-class InputWidget(BaseWidget):\n-    """Widget with `input` element."""\n-\n-    type = el_attrib(\'type\')\n-    value = el_attrib(\'value\')\n-    name = el_attrib(\'name\')\n-\n-    def __init__(self, pattern, pattern_options={}, type=\'text\', name=None,\n-                 value=None):\n-        """\n-        :param pattern: [required] Pattern name.\n-        :type pattern: string\n-\n-        :param pattern_options: Patterns options.\n-        :type pattern_options: dict\n-\n-        :param type: `type` attribute of element.\n-        :type type: string\n-\n-        :param name: `name` attribute of element.\n-        :type name: string\n-\n-        :param value: `value` attribute of element.\n-        :type value: string\n-        """\n-        super(InputWidget, self).__init__(\'input\', pattern, pattern_options)\n-        self.type = type\n-        if name is not None:\n-            self.name = name\n-        if value is not None:\n-            self.value = value\n-\n-\n-class SelectWidget(BaseWidget):\n-    """Widget with `select` element."""\n-\n-    name = el_attrib(\'name\')\n-    _multiple = el_attrib(\'multiple\')\n-\n-    def __init__(self, pattern, pattern_options={}, items=[], name=None,\n-                 value=None, multiple=False):\n-        """\n-        :param pattern: [required] Pattern name.\n-        :type pattern: string\n-\n-        :param pattern_options: Patterns options.\n-        :type pattern_options: dict\n-\n-        :param items: List of value and title pairs which represents possible\n-                      options to choose from.\n-        :type items: list\n-\n-        :param name: `name` attribute of element.\n-        :type name: string\n-\n-        :param value: `value` attribute of element.\n-        :type value: string\n-\n-        :param multiple: `multiple` attribute of element.\n-        :type multiple: bool\n-        """\n-        super(SelectWidget, self).__init__(\'select\', pattern, pattern_options)\n-        self.el.text = \'\'\n-        self.items = items\n-        self.multiple = multiple\n-        if name is not None:\n-            self.name = name\n-        if value is not None:\n-            self.value = value\n-\n-    def _get_items(self):\n-        """Get list of possible options.\n-\n-        :returns: List of value and title pairs.\n-        :rtype: list\n-        """\n-        if self.el.find(\'optgroup\') is not None:\n-            return collections.OrderedDict(\n-                (group.attrib[\'label\'], [\n-                    (option.attrib[\'value\'], option.text)\n-                    for option in group.iter("option")])\n-                for group in self.el.iter("optgroup"))\n-        else:\n-            return [\n-                (option.attrib[\'value\'], option.text)\n-                for option in self.el.iter("option")]\n-\n-    def _set_items(self, value):\n-        """Set options for element.\n-\n-        :param value: List of value and title pairs which represents possible\n-                      options to choose from.\n-        :type value: list\n-        """\n-        def addOptions(el, options):\n-            """\n-            Add <option> elements for each vocab item.\n-            """\n-            for token, title in options:\n-                option = etree.SubElement(el, \'option\')\n-                option.attrib[\'value\'] = token\n-                option.text = title\n-\n-        if isinstance(value, dict):\n-            for group_label, options in value.items():\n-                group = etree.SubElement(self.el, \'optgroup\')\n-                group.attrib[\'label\'] = group_label\n-                addOptions(group, options)\n-        else:\n-            for token, title in value:\n-                option = etree.SubElement(self.el, \'option\')\n-                option.attrib[\'value\'] = token\n-                option.text = title\n-\n-    def _del_items(self):\n-        """Removing options from inside of elements."""\n-        for group in self.el.iter("optgroup"):\n-            self.el.remove(group)\n-        for element in self.el.iter("option"):\n-            self.el.remove(element)\n-\n-    items = property(_get_items, _set_items, _del_items)\n-\n-    def _get_value(self):\n-        """Return selected option(s).\n-\n-        :returns: Returns list of selected option(s) values.\n-        :rtype: list\n-        """\n-        value = []\n-        for element in self.el.iter("option"):\n-            if \'selected\' in element.attrib and \\\n-                    element.attrib[\'selected\'] == \'selected\':\n-                value.append(element.attrib[\'value\'])\n-        return value\n-\n-    def _set_value(self, value):\n-        """Select option(s).\n-\n-        :param value: We are expecting option\'s value which should be selected.\n-        :type value: list or string\n-        """\n-        if isinstance(value, six.string_types):\n-            value = [value]\n-\n-        for element in self.el.iter("option"):\n-            if element.attrib[\'value\'] in value:\n-                element.attrib[\'selected\'] = \'selected\'\n-            elif \'selected\' in element.attrib and \\\n-                    element.attrib[\'selected\'] == \'selected\':\n-                del element.attrib[\'selected\']\n-\n-    def _del_value(self):\n-        """Unselect all selected options.\n-        """\n-        for element in self.el.iter("option"):\n-            if \'selected\' in element.attrib and \\\n-               element.attrib[\'selected\'] == \'selected\':\n-                del element.attrib[\'selected\']\n-\n-    value = property(_get_value, _set_value, _del_value)\n-\n-    def _get_multiple(self):\n-        """Does element allows multiple items to be selected.\n-\n-        :returns: `True` if allows multiple elements to be selected, otherwise\n-                  `False`.\n-        :rtype: bool\n-        """\n-        if self._multiple == \'multiple\':\n-            return True\n-        return False\n-\n-    def _set_multiple(self, value):\n-        """Make element accept multiple values.\n-\n-        :param value: `True` if you want to set element as `multiple`,\n-                      otherwise `False`\n-        :type value: bool\n-        """\n-        if value:\n-            self._multiple = \'multiple\'\n-        else:\n-            self._del_multiple()\n-\n-    def _del_multiple(self):\n-        """Remove `multiple` attribute from element."""\n-        del self._multiple\n-\n-    multiple = property(_get_multiple, _set_multiple, _del_multiple)\n-\n-\n-class TextareaWidget(BaseWidget):\n-    """Widget with `textarea` element."""\n-\n-    name = el_attrib(\'name\')\n-\n-    def __init__(self, pattern, pattern_options={}, name=None, value=None):\n-        """\n-        :param pattern: [required] Pattern name.\n-        :type pattern: string\n-\n-        :param pattern_options: Patterns options.\n-        :type pattern_options: dict\n-\n-        :param name: `name` attribute of element.\n-        :type name: string\n-\n-        :param value: `value` of element.\n-        :type value: string\n-        """\n-        super(TextareaWidget, self).__init__(\'textarea\', pattern,\n-                                             pattern_options)\n-        self.el.text = \'\'\n-        if name is not None:\n-            self.name = name\n-        if value is not None:\n-            self.value = value\n-\n-    def _get_value(self):\n-        """\n-        :returns: Value of element.\n-        :rtype: string\n-        """\n-        return self.el.text\n-\n-    def _set_value(self, value):\n-        """\n-        :param value: Set value of element.\n-        :type value: string\n-        """\n-        self.el.text = value\n-\n-    def _del_value(self):\n-        """Set empty string as value of element."""\n-        self.el.text = \'\'\n-\n-    value = property(_get_value, _set_value, _del_value)\n+import zope.deferredimport\n+\n+\n+zope.deferredimport.deprecated(\n+    "Import from plone.app.z3cform.utils instead (this package will be removed in Plone 7)",\n+    el_attrib=\'plone.app.z3cform.utils:el_attrib\',\n+    dict_merge=\'plone.app.z3cform.utils:dict_merge\',\n+)\n+zope.deferredimport.deprecated(\n+    "Import from plone.app.z3cform.widgets.patterns instead (this package will be removed in Plone 7)",\n+    BaseWidget=\'plone.app.z3cform.widgets.patterns:BaseWidget\',\n+    InputWidget=\'plone.app.z3cform.widgets.patterns:InputWidget\',\n+    SelectWidget=\'plone.app.z3cform.widgets.patterns:SelectWidget\',\n+    TextareaWidget=\'plone.app.z3cform.widgets.patterns:TextareaWidget\',\n+)\ndiff --git a/plone/app/widgets/utils.py b/plone/app/widgets/utils.py\nindex 56cac5a6..5d16ebd1 100644\n--- a/plone/app/widgets/utils.py\n+++ b/plone/app/widgets/utils.py\n@@ -1,253 +1,32 @@\n # -*- coding: utf-8 -*-\n-from Acquisition import aq_base\n-from Acquisition import aq_parent\n-from datetime import datetime\n-from OFS.interfaces import IFolder\n-from OFS.interfaces import ISimpleItem\n-from plone.app.layout.navigation.root import getNavigationRootObject\n-from plone.base.utils import get_top_site_from_url\n-from Products.CMFCore.interfaces import ISiteRoot\n-from Products.CMFCore.utils import getToolByName\n-from z3c.form.interfaces import IForm\n-from zope.component import ComponentLookupError\n-from zope.component import getMultiAdapter\n-from zope.component import providedBy\n-from zope.component import queryUtility\n-from zope.component.hooks import getSite\n-from zope.deprecation import deprecate\n-from zope.globalrequest import getRequest\n-from zope.i18n import translate\n-from zope.i18nmessageid import MessageFactory\n-from zope.schema.interfaces import IVocabularyFactory\n-\n-import logging\n-import json\n import zope.deferredimport\n \n \n-logger = logging.getLogger("plone.app.widgets.utils")\n-\n-\n-_ = MessageFactory(\'plone\')\n-\n-\n zope.deferredimport.deprecated(\n-    \'Import first_weekday from plone.app.event.base instead\',\n-    first_weekday=\'plone.app.event.base:first_weekday\',\n+    "Import from plone.app.z3cform.widgets.base instead (this package will be removed in Plone 7)",\n+    NotImplemented=\'plone.app.z3cform.widgets.base:PatternNotImplemented\',\n+)\n+zope.deferredimport.deprecated(\n+    "Import from plone.app.z3cform.widgets.datetime instead (this package will be removed in Plone 7)",\n+    get_date_options=\'plone.app.z3cform.widgets.datetime:get_date_options\',\n+    get_datetime_options=\'plone.app.z3cform.widgets.datetime:get_date_options\',\n+)\n+zope.deferredimport.deprecated(\n+    "Import from plone.app.z3cform.widgets.relateditems instead (this package will be removed in Plone 7)",\n+    get_relateditems_options=\'plone.app.z3cform.widgets.relateditems:get_relateditems_options\',\n+)\n+zope.deferredimport.deprecated(\n+    "Import from plone.app.z3cform.widgets.querystring instead (this package will be removed in Plone 7)",\n+    get_querystring_options=\'plone.app.z3cform.widgets.querystring:get_querystring_options\',\n+)\n+zope.deferredimport.deprecated(\n+    "Import from plone.app.z3cform.widgets.richtext instead (this package will be removed in Plone 7)",\n+    get_tinymce_options=\'plone.app.z3cform.widgets.richtext:get_tinymce_options\',\n+)\n+zope.deferredimport.deprecated(\n+    "Import from plone.app.z3cform.utils instead (this package will be removed in Plone 7)",\n+    get_portal=\'plone.app.z3cform.utils:get_portal\',\n+    get_portal_url=\'plone.app.z3cform.utils:get_portal_url\',\n+    get_context_url=\'plone.app.z3cform.utils:get_context_url\',\n+    get_Widget_form=\'plone.app.z3cform.utils:get_Widget_form\',\n )\n-\n-\n-class NotImplemented(Exception):\n-    """Raised when method/property is not implemented"""\n-\n-\n-def get_date_options(request):\n-    calendar = request.locale.dates.calendars[\'gregorian\']\n-    today = datetime.today()\n-    return {\n-        \'behavior\': \'native\',\n-        \'week-numbers\': \'show\',\n-        \'first-day\': calendar.week.get(\'firstDay\') == 1 and 1 or 0,\n-        \'today\': translate(_(u"Today"), context=request),\n-        \'clear\': translate(_(u"Clear"), context=request),\n-    }\n-\n-\n-def get_datetime_options(request):\n-    options = get_date_options(request)\n-    return options\n-\n-\n-@deprecate("features were moved into the AjaxSelectWidget, remove in Plone 6")\n-def get_ajaxselect_options(context, value, separator, vocabulary_name,\n-                           vocabulary_view, field_name=None):\n-    # code now part of the widget, let it in here for BBB and remove in Plone 6\n-    options = {\'separator\': separator}\n-    if vocabulary_name:\n-        options[\'vocabularyUrl\'] = \'{}/{}?name={}\'.format(\n-            get_context_url(context), vocabulary_view, vocabulary_name)\n-        if field_name:\n-            options[\'vocabularyUrl\'] += \'&field={}\'.format(field_name)\n-        if value:\n-            vocabulary = queryUtility(IVocabularyFactory, vocabulary_name)\n-            if vocabulary:\n-                options[\'initialValues\'] = {}\n-                vocabulary = vocabulary(context)\n-                # Catalog\n-                if vocabulary_name == \'plone.app.vocabularies.Catalog\':\n-                    uids = value.split(separator)\n-                    try:\n-                        catalog = getToolByName(context, \'portal_catalog\')\n-                    except AttributeError:\n-                        catalog = getToolByName(getSite(), \'portal_catalog\')\n-                    for item in catalog(UID=uids):\n-                        options[\'initialValues\'][item.UID] = item.Title\n-                else:\n-                    for value in value.split(separator):\n-                        try:\n-                            term = vocabulary.getTerm(value)\n-                            options[\'initialValues\'][term.token] = term.title\n-                        except LookupError:\n-                            options[\'initialValues\'][value] = value\n-    return options\n-\n-\n-def get_relateditems_options(context, value, separator, vocabulary_name,\n-                             vocabulary_view, field_name=None,\n-                             include_recently_added=True):\n-\n-    if IForm.providedBy(context):\n-        context = context.context\n-\n-    request = getRequest()\n-    site = get_top_site_from_url(context, request)\n-    options = {\n-        \'separator\': separator,\n-    }\n-    if not vocabulary_name:\n-        # we need a vocabulary!\n-        raise ValueError(\'RelatedItems needs a vocabulary\')\n-    options[\'vocabularyUrl\'] = \'{0}/{1}?name={2}\'.format(\n-        get_context_url(site), vocabulary_view, vocabulary_name,\n-    )\n-    if field_name:\n-        options[\'vocabularyUrl\'] += \'&field={0}\'.format(field_name)\n-    if value:\n-        options[\'initialValues\'] = {}\n-        catalog = False\n-        if vocabulary_name == \'plone.app.vocabularies.Catalog\':\n-            catalog = getToolByName(getSite(), \'portal_catalog\')\n-        for value in value.split(separator):\n-            title = value\n-            if catalog:\n-                result = catalog(UID=value)\n-                title = result[0].Title if result else value\n-            options[\'initialValues\'][value] = title\n-\n-    nav_root = getNavigationRootObject(context, site)\n-\n-    if not ISimpleItem.providedBy(context):\n-        context = nav_root\n-\n-    # basePath - start to search/browse in here.\n-    base_path_context = context\n-    if not IFolder.providedBy(base_path_context):\n-        base_path_context = aq_parent(base_path_context)\n-    if not base_path_context:\n-        base_path_context = nav_root\n-    options[\'basePath\'] = \'/\'.join(base_path_context.getPhysicalPath())\n-\n-    # rootPath - Only display breadcrumb elements deeper than this path.\n-    options[\'rootPath\'] = \'/\'.join(site.getPhysicalPath()) if site else \'/\'\n-\n-    # rootUrl: Visible URL up to the rootPath. This is prepended to the\n-    # currentPath to generate submission URLs.\n-    options[\'rootUrl\'] = site.absolute_url() if site else \'\'\n-\n-    # contextPath - current edited object. Will not be available to select.\n-    options[\'contextPath\'] = \'/\'.join(context.getPhysicalPath())\n-\n-    if base_path_context != nav_root:\n-        options[\'favorites\'] = [\n-            {\n-                \'title\': _(u\'Current Content\'),\n-                \'path\': \'/\'.join(base_path_context.getPhysicalPath())\n-            }, {\n-                \'title\': _(u\'Start Page\'),\n-                \'path\': \'/\'.join(nav_root.getPhysicalPath())\n-            }\n-        ]\n-\n-    if include_recently_added:\n-        # Options for recently used key\n-        tool = getToolByName(context, \'portal_membership\')\n-        user = tool.getAuthenticatedMember()\n-        options[\'recentlyUsed\'] = False  # Keep that off in Plone 5.1\n-        options[\'recentlyUsedKey\'] = (u\'relateditems_recentlyused_%s_%s\' % (\n-            field_name or \'\',\n-            user.id\n-        ))  # use string substitution with %s here for automatic str casting.\n-\n-    return options\n-\n-\n-def get_querystring_options(context, querystring_view):\n-    portal_url = get_portal_url(context)\n-    try:\n-        base_url = context.absolute_url()\n-    except AttributeError:\n-        base_url = portal_url\n-    return {\n-        \'indexOptionsUrl\': \'{}/{}\'.format(portal_url, querystring_view),\n-        \'previewURL\': \'%s/@@querybuilder_html_results\' % base_url,\n-        \'previewCountURL\': \'%s/@@querybuildernumberofresults\' % base_url,\n-        \'patternDateOptions\': get_date_options(getRequest()),\n-        \'patternAjaxSelectOptions\': {\'separator\': \';\'},\n-        \'patternRelateditemsOptions\': get_relateditems_options(\n-            context,\n-            None,\n-            \';\',\n-            \'plone.app.vocabularies.Catalog\',\n-            \'@@getVocabulary\',\n-            \'relatedItems\',\n-            include_recently_added=False\n-        )\n-    }\n-\n-\n-def get_tinymce_options(context, field, request):\n-    """\n-    We\'re just going to be looking up settings from\n-    plone pattern options\n-    """\n-    options = {}\n-    try:\n-        pattern_options = getMultiAdapter(\n-            (context, request, field),\n-            name="plone_settings").tinymce()[\'data-pat-tinymce\']\n-        options = json.loads(pattern_options)\n-    except (ComponentLookupError, AttributeError):\n-        logger.warning("Can not load tinymce pattern options!", exc_info=True)\n-    return options\n-\n-\n-def get_portal():\n-    closest_site = getSite()\n-    if closest_site is not None:\n-        for potential_portal in closest_site.aq_chain:\n-            if ISiteRoot in providedBy(potential_portal):\n-                return potential_portal\n-\n-\n-def get_portal_url(context):\n-    portal = get_portal()\n-    if portal:\n-        root = getNavigationRootObject(context, portal)\n-        if root:\n-            try:\n-                return root.absolute_url()\n-            except AttributeError:\n-                return portal.absolute_url()\n-        else:\n-            return portal.absolute_url()\n-    return \'\'\n-\n-\n-def get_context_url(context):\n-    if IForm.providedBy(context):\n-        # Use the request URL if we are looking at an addform\n-        url = context.request.get(\'URL\')\n-    elif hasattr(context, \'absolute_url\'):\n-        url = context.absolute_url\n-        if callable(url):\n-            url = url()\n-    else:\n-        url = get_portal_url(context)\n-    return url\n-\n-\n-def get_widget_form(widget):\n-    form = getattr(widget, \'form\', None)\n-    if getattr(aq_base(form), \'parentForm\', None) is not None:\n-        form = form.parentForm\n-    return form\n'

