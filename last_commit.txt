Repository: plone.restapi


Branch: refs/heads/master
Date: 2023-07-11T10:45:42+02:00
Author: David Glick (davisagli) <david@glicksoftware.com>
Commit: https://github.com/plone/plone.restapi/commit/cff29fd238a8323bcf9d426d4a30894a944ac277

Update image scales in blocks data when serializing internal links (#1642)

* Add image scales to blocks data when serializing internal links

* put image_scales adjacent to the url (better backwards compatibility)

* Remove unintended changes, try to fix tests in Plone 5

* fix test

---------

Co-authored-by: Piero Nicolli &lt;pnicolli@users.noreply.github.com&gt;

Files changed:
A news/1642.feature
M src/plone/restapi/deserializer/blocks.py
M src/plone/restapi/serializer/blocks.py
M src/plone/restapi/serializer/utils.py
M src/plone/restapi/tests/test_blocks_deserializer.py
M src/plone/restapi/tests/test_blocks_serializer.py

b'diff --git a/news/1642.feature b/news/1642.feature\nnew file mode 100644\nindex 000000000..bf5f1a7dc\n--- /dev/null\n+++ b/news/1642.feature\n@@ -0,0 +1,2 @@\n+When serializing blocks, `image_scales` is now added to blocks that contain a resolveuid-based `url`.\n+When deserializing blocks, `image_scales` is removed. @davisagli\ndiff --git a/src/plone/restapi/deserializer/blocks.py b/src/plone/restapi/deserializer/blocks.py\nindex 99199f78a..a4746eb4b 100644\n--- a/src/plone/restapi/deserializer/blocks.py\n+++ b/src/plone/restapi/deserializer/blocks.py\n@@ -75,14 +75,9 @@ def _process_data(self, data, field=None):\n             if data.get("@type", None) == "URL" and data.get("value", None):\n                 data["value"] = path2uid(context=self.context, link=data["value"])\n             elif data.get("@id", None):\n-                item_clone = deepcopy(data)\n-                item_clone["@id"] = path2uid(\n-                    context=self.context, link=item_clone["@id"]\n-                )\n-                return {\n-                    field: self._process_data(data=value, field=field)\n-                    for field, value in item_clone.items()\n-                }\n+                data = deepcopy(data)\n+                data["@id"] = path2uid(context=self.context, link=data["@id"])\n+            data.pop("image_scales", None)\n             return {\n                 field: self._process_data(data=value, field=field)\n                 for field, value in data.items()\ndiff --git a/src/plone/restapi/serializer/blocks.py b/src/plone/restapi/serializer/blocks.py\nindex e42e6baf3..5a8733580 100644\n--- a/src/plone/restapi/serializer/blocks.py\n+++ b/src/plone/restapi/serializer/blocks.py\n@@ -1,4 +1,3 @@\n-from copy import deepcopy\n from plone.restapi.bbb import IPloneSiteRoot\n from plone.restapi.behaviors import IBlocks\n from plone.restapi.blocks import visit_blocks, iter_block_transform_handlers\n@@ -9,7 +8,7 @@\n from plone.restapi.interfaces import IFieldSerializer\n from plone.restapi.serializer.converters import json_compatible\n from plone.restapi.serializer.dxfields import DefaultFieldSerializer\n-from plone.restapi.serializer.utils import uid_to_url\n+from plone.restapi.serializer.utils import resolve_uid, uid_to_url\n from plone.schema import IJSONField\n from zope.component import adapter\n from zope.interface import implementer\n@@ -57,19 +56,27 @@ def _process_data(self, data, field=None):\n         if isinstance(data, list):\n             return [self._process_data(data=value, field=field) for value in data]\n         if isinstance(data, dict):\n-            if data.get("@type", None) == "URL" and data.get("value", None):\n-                data["value"] = uid_to_url(data["value"])\n-            elif data.get("@id", None):\n-                item_clone = deepcopy(data)\n-                item_clone["@id"] = uid_to_url(item_clone["@id"])\n-                return {\n-                    field: self._process_data(data=value, field=field)\n-                    for field, value in item_clone.items()\n-                }\n-            return {\n-                field: self._process_data(data=value, field=field)\n+            fields = ["value"] if data.get("@type") == "URL" else []\n+            fields.append("@id")\n+            fields.extend(self.fields)\n+            newdata = {}\n+            for field in fields:\n+                if field not in data or not isinstance(data[field], str):\n+                    continue\n+                newdata[field], brain = resolve_uid(data[field])\n+                if brain is not None and "image_scales" not in newdata:\n+                    newdata["image_scales"] = getattr(brain, "image_scales", None)\n+            result = {\n+                field: (\n+                    newdata[field]\n+                    if field in newdata\n+                    else self._process_data(data=newdata.get(field, value), field=field)\n+                )\n                 for field, value in data.items()\n             }\n+            if newdata.get("image_scales"):\n+                result["image_scales"] = newdata["image_scales"]\n+            return result\n         return data\n \n \ndiff --git a/src/plone/restapi/serializer/utils.py b/src/plone/restapi/serializer/utils.py\nindex f47541663..c2f89e4e2 100644\n--- a/src/plone/restapi/serializer/utils.py\n+++ b/src/plone/restapi/serializer/utils.py\n@@ -11,26 +11,25 @@\n RESOLVEUID_RE = re.compile("^[./]*resolve[Uu]id/([^/]*)/?(.*)$")\n \n \n-def uid_to_url(path):\n-    """turns a resolveuid url into a real url.\n+def resolve_uid(path):\n+    """Resolves a resolveuid URL into a tuple of absolute URL and catalog brain.\n \n-    This uses the catalog first, but wake up the object to check if there is\n-    an IObjectPrimaryFieldTarget on this object. If so, it will return the\n-    target url instead of the object url.\n+    If the original path is not found (including external URLs),\n+    it will be returned unchanged and the brain will be None.\n     """\n     if not path:\n-        return ""\n+        return "", None\n     match = RESOLVEUID_RE.match(path)\n     if match is None:\n-        return path\n+        return path, None\n \n     uid, suffix = match.groups()\n     brain = uuidToCatalogBrain(uid)\n     if brain is None:\n-        return path\n+        return path, None\n     href = brain.getURL()\n     if suffix:\n-        return href + "/" + suffix\n+        return href + "/" + suffix, brain\n     target_object = brain._unrestrictedGetObject()\n     adapter = queryMultiAdapter(\n         (target_object, target_object.REQUEST),\n@@ -39,8 +38,13 @@ def uid_to_url(path):\n     if adapter:\n         a_href = adapter()\n         if a_href:\n-            return a_href\n-    return href\n+            return a_href, None\n+    return href, brain\n+\n+\n+def uid_to_url(path):\n+    path, brain = resolve_uid(path)\n+    return path\n \n \n def get_portal_type_title(portal_type):\ndiff --git a/src/plone/restapi/tests/test_blocks_deserializer.py b/src/plone/restapi/tests/test_blocks_deserializer.py\nindex a51b984e9..37a4e6ecd 100644\n--- a/src/plone/restapi/tests/test_blocks_deserializer.py\n+++ b/src/plone/restapi/tests/test_blocks_deserializer.py\n@@ -597,3 +597,9 @@ def test_slate_table_block_deserializer(self):\n         cell = rows[1]["cells"][0]\n         link = cell["value"][0]["children"][1]["data"]["url"]\n         self.assertTrue(link.startswith("../resolveuid/"))\n+\n+    def test_deserialize_url_with_image_scales(self):\n+        blocks = {"123": {"url": self.image.absolute_url(), "image_scales": {}}}\n+        res = self.deserialize(blocks=blocks)\n+        self.assertTrue(res.blocks["123"]["url"].startswith("../resolveuid/"))\n+        self.assertNotIn("image_scales", res.blocks["123"])\ndiff --git a/src/plone/restapi/tests/test_blocks_serializer.py b/src/plone/restapi/tests/test_blocks_serializer.py\nindex 1b197f923..a72abb09d 100644\n--- a/src/plone/restapi/tests/test_blocks_serializer.py\n+++ b/src/plone/restapi/tests/test_blocks_serializer.py\n@@ -1,6 +1,8 @@\n+from importlib import import_module\n from plone.dexterity.interfaces import IDexterityFTI\n from plone.dexterity.interfaces import IDexterityItem\n from plone.dexterity.utils import iterSchemata\n+from plone.namedfile.file import NamedBlobImage\n from plone.restapi.behaviors import IBlocks\n from plone.restapi.interfaces import IBlockFieldSerializationTransformer\n from plone.restapi.interfaces import IFieldSerializer\n@@ -15,9 +17,17 @@\n from zope.interface import implementer\n from zope.publisher.interfaces.browser import IBrowserRequest\n \n+import pathlib\n import unittest\n \n \n+HAS_PLONE_6 = getattr(\n+    import_module("Products.CMFPlone.factory"), "PLONE60MARKER", False\n+)\n+IMAGE_PATH = (pathlib.Path(__file__).parent / "image.png").resolve()\n+IMAGE_DATA = IMAGE_PATH.read_bytes()\n+\n+\n class TestBlocksSerializer(unittest.TestCase):\n \n     layer = PLONE_RESTAPI_DX_INTEGRATION_TESTING\n@@ -36,6 +46,8 @@ def setUp(self):\n         self.image = self.portal[\n             self.portal.invokeFactory("Image", id="image-1", title="Target image")\n         ]\n+        self.image.image = NamedBlobImage(data=IMAGE_DATA, filename="test.jpg")\n+        self.image.reindexObject()\n \n     def serialize(self, context, blocks):\n         fieldname = "blocks"\n@@ -377,3 +389,16 @@ def test_slate_table_block_link_serializer(self):\n         cell = rows[1]["cells"][0]\n         link = cell["value"][0]["children"][1]["data"]["url"]\n         self.assertTrue(link, self.portal.absolute_url() + "/doc1")\n+\n+    @unittest.skipUnless(\n+        HAS_PLONE_6,\n+        "image_scales were added to the catalog in Plone 6",\n+    )\n+    def test_image_scales_serializer(self):\n+        image_uid = self.image.UID()\n+        res = self.serialize(\n+            context=self.portal["doc1"],\n+            blocks={"123": {"@type": "image", "url": f"../resolveuid/{image_uid}"}},\n+        )\n+        self.assertEqual(res["123"]["url"], self.image.absolute_url())\n+        self.assertIn("image_scales", res["123"])\n'

