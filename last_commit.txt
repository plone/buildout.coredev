Repository: plone.app.folder


Branch: refs/heads/master
Date: 2020-10-08T22:54:21+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.app.folder/commit/026b0030ea437cf971a345b3f0492e1e483105b7

Removed ancient migration code for upgrading BTree folder from Plone 3 to 4.

The code, or at least the tests, are incompatible with the latest `zope.interface`.
See https://github.com/plone/plone.app.folder/issues/24
and the remarks in this coredev commit that updated to zope.interface 5.1.1:
https://github.com/plone/buildout.coredev/commit/daefdc903c29041f4b7315a4e8a55f8c59ce5c97

Current plone.app.folder is only for Plone 5.2, so the code is not needed.
The migrate-btrees view is referenced nowhere in the code.

Files changed:
A news/24.bugfix
M src/plone/app/folder/configure.zcml
D src/plone/app/folder/migration.py
D src/plone/app/folder/tests/test_migration.py

b'diff --git a/news/24.bugfix b/news/24.bugfix\nnew file mode 100644\nindex 0000000..a2fed22\n--- /dev/null\n+++ b/news/24.bugfix\n@@ -0,0 +1,4 @@\n+Removed ancient migration code for upgrading BTree folder from Plone 3 to 4.\n+The code, or at least the tests, are incompatible with the latest ``zope.interface``.\n+Current plone.app.folder is only for Plone 5.2, so the code is not needed.\n+[maurits]\ndiff --git a/src/plone/app/folder/configure.zcml b/src/plone/app/folder/configure.zcml\nindex 52a6934..967f392 100644\n--- a/src/plone/app/folder/configure.zcml\n+++ b/src/plone/app/folder/configure.zcml\n@@ -1,7 +1,6 @@\n <configure\n     xmlns="http://namespaces.zope.org/zope"\n     xmlns:five="http://namespaces.zope.org/five"\n-    xmlns:browser="http://namespaces.zope.org/browser"\n     xmlns:zcml="http://namespaces.zope.org/zcml"\n     i18n_domain="plone.app.folder">\n \n@@ -17,11 +16,4 @@\n \n     </configure>\n \n-    <browser:page\n-        for="*"\n-        name="migrate-btrees"\n-        class=".migration.BTreeMigrationView"\n-        permission="cmf.ManagePortal"\n-        />\n-\n </configure>\ndiff --git a/src/plone/app/folder/migration.py b/src/plone/app/folder/migration.py\ndeleted file mode 100644\nindex 43ec285..0000000\n--- a/src/plone/app/folder/migration.py\n+++ /dev/null\n@@ -1,93 +0,0 @@\n-# -*- coding: utf-8 -*-\n-from Acquisition import aq_base\n-from logging import getLogger\n-from plone.app.folder.utils import checkpointIterator\n-from plone.app.folder.utils import findObjects\n-from plone.app.folder.utils import timer\n-from Products.BTreeFolder2.BTreeFolder2 import BTreeFolder2Base as BTreeFolder\n-from Products.Five.browser import BrowserView\n-from time import clock\n-from time import strftime\n-from transaction import get\n-\n-\n-logger = getLogger(__name__)\n-\n-\n-class BTreeMigrationView(BrowserView):\n-    """ helper view for btree-migration;  all old-style folder, which\n-        are btree-based now (implementation-wise) will be migration\n-        in term of their internal data structures being updated """\n-\n-    def mklog(self):\n-        """ helper to prepend a time stamp to the output """\n-        write = self.request.RESPONSE.write\n-\n-        def log(msg, timestamp=True, cr=True):\n-            if timestamp:\n-                msg = strftime(\'%Y/%m/%d-%H:%M:%S \') + msg\n-            if cr:\n-                msg += \'\\n\'\n-            write(msg)\n-        return log\n-\n-    def migrate(self, folder):\n-        """ migrate existing data structure from a regular folder to a btree\n-            folder;  the folder needs to be btree-based already """\n-        folder = aq_base(folder)\n-        assert isinstance(folder, BTreeFolder)\n-        assert folder.getId()       # make sure the object is properly loaded\n-\n-        def has(key):\n-            return key in folder.__dict__\n-\n-        if has(\'_tree\') and not has(\'_objects\'):\n-            return False            # already migrated...\n-        folder._initBTrees()        # create _tree, _count, _mt_index\n-        for info in folder._objects:\n-            name = info[\'id\']\n-            # _setOb will notify the ordering adapter itself,\n-            # so we don\'t need to care about storing order information here...\n-            folder._setOb(name, aq_base(getattr(folder, name)))\n-            delattr(folder, name)\n-        if has(\'_objects\'):\n-            delattr(folder, \'_objects\')\n-        return True\n-\n-    def postprocess(self, obj):\n-        # This is a hook for other migration code and is used in\n-        # plone.app.upgrade\n-        pass\n-\n-    def __call__(self, batch=1000, dryrun=False):\n-        """ find all btree-based folder below the context, potentially\n-            migrate them & provide some logging and statistics doing so """\n-        log = self.mklog()\n-        log(\'migrating btree-based folders from %r:\' % self.context)\n-        real = timer()          # real time\n-        lap = timer()           # real lap time (for intermediate commits)\n-        cpu = timer(clock)      # cpu time\n-        processed = 0\n-\n-        def checkPoint():\n-            msg = \'intermediate commit \'\\\n-                  \'(%d objects processed, last batch in %s)...\'\n-            log(msg % (processed, next(lap)))\n-            trx = get()\n-            trx.note(u\'migrated %d btree-folders\' % processed)\n-            trx.savepoint()\n-        cpi = checkpointIterator(checkPoint, batch)\n-        for path, obj in findObjects(self.context):\n-            if isinstance(obj, BTreeFolder):\n-                if self.migrate(obj):\n-                    processed += 1\n-                    next(cpi)\n-            self.postprocess(obj)\n-\n-        checkPoint()                # commit last batch\n-        if dryrun:\n-            get().abort()           # abort on test-run...\n-        msg = \'processed %d object(s) in %s (%s cpu time).\'\n-        msg = msg % (processed, next(real), next(cpu))\n-        log(msg)\n-        logger.info(msg)\ndiff --git a/src/plone/app/folder/tests/test_migration.py b/src/plone/app/folder/tests/test_migration.py\ndeleted file mode 100644\nindex dee1e5b..0000000\n--- a/src/plone/app/folder/tests/test_migration.py\n+++ /dev/null\n@@ -1,237 +0,0 @@\n-# -*- coding: utf-8 -*-\n-from Acquisition import aq_base\n-from Acquisition import aq_parent\n-from Products.ATContentTypes.content.document import ATDocument\n-from Products.BTreeFolder2.BTreeFolder2 import BTreeFolder2Base as BTreeFolder\n-from plone.app.folder.tests.content import _createObjectByType\n-from plone.app.folder.migration import BTreeMigrationView\n-from plone.app.folder.tests.base import IntegrationTestCase\n-from plone.app.folder.tests.content import NonBTreeFolder\n-from plone.app.folder.tests.content import OrderableFolder\n-from plone.app.folder.tests.content import create\n-from plone.app.folder.tests.layer import IntegrationLayer\n-from plone.app.folder.utils import findObjects\n-from plone.folder.interfaces import IOrderable\n-from plone.folder.interfaces import IOrdering\n-from zope.component import getMultiAdapter\n-from zope.interface import classImplements\n-from zope.publisher.browser import TestRequest\n-\n-import re\n-import transaction\n-\n-\n-def reverseMigrate(folder):\n-    """ helper to replace the given regular folder with one based on\n-        btrees;  the intention is to create the state that would be found\n-        before migration, i.e. a now btree-based folder still holding the\n-        data structures from a regular one;  all (regular) subfolders\n-        will be replaced recursively """\n-    for name, obj in reversed(list(findObjects(folder))):\n-        if isinstance(obj, NonBTreeFolder):\n-            parent = aq_parent(obj)\n-            data = obj.__dict__.copy()\n-            data[\'id\'] = oid = obj.getId()\n-            new = OrderableFolder(oid)\n-            new.__dict__ = data\n-            setattr(parent, oid, new)\n-\n-\n-def isSaneBTreeFolder(folder):\n-    """ sanity-check the given btree folder """\n-    folder = aq_base(folder)\n-    contains = folder.__dict__.__contains__\n-    state = isinstance(folder, BTreeFolder) and contains(\'_tree\') \\\n-        and not contains(\'_objects\')     # it\'s a class variable\n-    if state:\n-        try:\n-            # objects must not live directly on the folder (but in the btree)\n-            for oid in folder.objectIds():\n-                if not hasattr(folder, oid) or contains(oid):\n-                    return False\n-        except AttributeError:\n-            return False\n-    return state\n-\n-\n-def makeResponse(request):\n-    """ create a fake request and set up logging of output """\n-    headers = {}\n-    output = []\n-\n-    class Response:\n-        def setHeader(self, header, value):\n-            headers[header] = value\n-\n-        def write(self, msg):\n-            output.append(msg.strip())\n-    request.RESPONSE = Response()\n-    return headers, output, request\n-\n-\n-def getView(context, name, **kw):\n-    headers, output, request = makeResponse(TestRequest(**kw))\n-    view = getMultiAdapter((context, request), name=name)\n-    return view, headers, output, request\n-\n-\n-class TestMigrationHelpers(IntegrationTestCase):\n-    """ test helper functions for btree migration """\n-\n-    layer = IntegrationLayer\n-\n-    def testReverseMigrate(self):\n-        folder = create(\'Folder\', self.portal, \'folder\', title=\'Foo\')\n-        create(\'Document\', folder, \'doc1\')\n-        create(\'Event\', folder, \'event1\')\n-        reverseMigrate(folder)\n-        btree = aq_base(self.portal.folder)\n-        self.assertTrue(isinstance(btree, BTreeFolder))\n-        self.assertTrue(\'_objects\' in btree.__dict__)\n-        self.assertTrue(hasattr(btree, \'_tree\'))\n-        self.assertFalse(\'_tree\' in btree.__dict__)\n-        self.assertEqual(btree._tree, None)\n-        self.assertEqual(\n-            btree._objects,\n-            (\n-                dict(id=\'doc1\', meta_type=\'ATDocument\'),\n-                dict(id=\'event1\', meta_type=\'ATEvent\')\n-            )\n-        )\n-        self.assertEqual(btree.getId(), \'folder\')\n-        self.assertEqual(btree.Title(), \'Foo\')\n-\n-    def testNestedReverseMigrate(self):\n-        folder = create(\'Folder\', self.portal, \'foo\')\n-        create(\'Folder\', folder, \'bar\')\n-        reverseMigrate(folder)\n-        foo = aq_base(self.portal.foo)\n-        self.assertTrue(isinstance(foo, BTreeFolder))\n-        self.assertTrue(\'_objects\' in foo.__dict__)\n-        self.assertTrue(hasattr(foo, \'_tree\'))\n-        self.assertFalse(\'_tree\' in foo.__dict__)\n-        self.assertEqual(foo._tree, None)\n-        self.assertEqual(\n-            foo._objects,\n-            (dict(id=\'bar\', meta_type=\'NonBTreeFolder\'), )\n-        )\n-        bar = aq_base(getattr(foo, \'bar\'))\n-        self.assertTrue(isinstance(bar, BTreeFolder))\n-        self.assertFalse(\'_objects\' in bar.__dict__)   # no sub-objects\n-        self.assertEqual(bar._objects, ())\n-        self.assertTrue(hasattr(bar, \'_tree\'))\n-        self.assertFalse(\'_tree\' in bar.__dict__)\n-        self.assertEqual(bar._tree, None)\n-        self.assertEqual(bar._objects, ())\n-\n-    def testIsSaneBTreeFolder(self):\n-        # positive case\n-        _createObjectByType(\'Folder\', self.portal, \'btree\')\n-        self.assertTrue(isSaneBTreeFolder(self.portal.btree))\n-        # negative case\n-        create(\'Folder\', self.portal, \'folder\')\n-        self.assertFalse(isSaneBTreeFolder(self.portal.folder))\n-        reverseMigrate(self.portal.folder)\n-        self.assertFalse(isSaneBTreeFolder(self.portal.folder))\n-\n-\n-class TestBTreeMigration(IntegrationTestCase):\n-    """ test BTree migration tests migration between Folder and\n-        btree-based folder """\n-\n-    layer = IntegrationLayer\n-\n-    def afterSetUp(self):\n-        classImplements(ATDocument, IOrderable)\n-        # have to delete previously created content manually\n-        # because of test isolation problems\n-        if \'test\' in self.portal:\n-            del self.portal[\'test\']\n-            transaction.commit()\n-\n-    def makeUnmigratedFolder(self, context, name, **kw):\n-        """ create a folder in an unmigrated state """\n-        folder = create(\'Folder\', context, name, **kw)\n-        reverseMigrate(folder)\n-        self.assertFalse(isSaneBTreeFolder(folder))\n-        return context[name]\n-\n-    def testBTreeMigration(self):\n-        # create (unmigrated) btree folder\n-        folder = self.makeUnmigratedFolder(self.portal, \'test\', title=\'Foo\')\n-        view = BTreeMigrationView(self.portal, self.app.REQUEST)\n-        self.assertTrue(view.migrate(folder))\n-        folder = self.portal.test       # get the object again...\n-        self.assertTrue(isSaneBTreeFolder(folder))\n-        self.assertEqual(folder.getId(), \'test\')\n-        self.assertEqual(folder.Title(), \'Foo\')\n-        # a second migration should be skipped\n-        self.assertFalse(view.migrate(folder))\n-\n-    def getNumber(self, output):\n-        self.assertTrue(len(output) >= 3)\n-        self.assertTrue(\'migrating btree-based folders\' in output[0])\n-        self.assertTrue(\'intermediate commit\' in output[-2])\n-        last = output[-1]\n-        self.assertTrue(\'processed\' in last)\n-        matches = re.match(r\'.*processed (.*) object.*\', last).groups()\n-        return int(matches[0])\n-\n-    def testMigrationView(self):\n-        folder = self.makeUnmigratedFolder(self.portal, \'test\', title=\'Foo\')\n-        view, headers, output, request = getView(folder, \'migrate-btrees\')\n-        view()      # call the view, triggering the migration\n-        num = self.getNumber(output)\n-        self.assertEqual(num, 1)\n-        folder = self.portal.test               # get the object again...\n-        self.assertTrue(isSaneBTreeFolder(folder))\n-        self.assertEqual(folder.getId(), \'test\')\n-        self.assertEqual(folder.Title(), \'Foo\')\n-\n-    def testMigrationViewWithSubobjects(self):\n-        # set up an (unmigrated) folder with subobjects\n-        folder = create(\'Folder\', self.portal, \'test\', title=\'Foo\')\n-        create(\'Document\', folder, \'doc1\')\n-        create(\'Event\', folder, \'event1\')\n-        reverseMigrate(folder)\n-        folder = self.portal.test               # get the object again...\n-        self.assertFalse(isSaneBTreeFolder(folder))\n-        # now test its migration...\n-        view, headers, output, request = getView(self.portal, \'migrate-btrees\')\n-        view()      # call the view, triggering the migration\n-        num = self.getNumber(output)\n-        self.assertEqual(num, 1)\n-        folder = self.portal.test               # get the object again...\n-        self.assertTrue(isSaneBTreeFolder(folder))\n-        self.assertEqual(folder.getId(), \'test\')\n-        self.assertEqual(folder.Title(), \'Foo\')\n-        self.assertEqual(len(folder.objectValues()), 2)\n-        self.assertEqual(set(folder.objectIds()), set([\'doc1\', \'event1\']))\n-        self.assertEqual(IOrdering(folder).idsInOrder(), [\'doc1\', \'event1\'])\n-\n-    def testMigrationViewForMultipleFolders(self):\n-        self.makeUnmigratedFolder(self.portal, \'folder1\')\n-        self.makeUnmigratedFolder(self.portal, \'folder2\')\n-        view, headers, output, request = getView(self.portal, \'migrate-btrees\')\n-        view()      # call the view, triggering the migration\n-        num = self.getNumber(output)\n-        self.assertEqual(num, 2)\n-        self.assertTrue(isSaneBTreeFolder(self.portal.folder1))\n-        self.assertTrue(isSaneBTreeFolder(self.portal.folder2))\n-\n-    def testMigrationViewForNestedFolders(self):\n-        # nested folders have to be "unmigrated" in bottom-up...\n-        folder = create(\'Folder\', self.portal, \'test\')\n-        create(\'Folder\', self.portal.test, \'foo\')\n-        create(\'Folder\', self.portal.test, \'bar\')\n-        reverseMigrate(folder)\n-        self.assertFalse(isSaneBTreeFolder(folder))\n-        # start the migration\n-        view, headers, output, request = getView(self.portal, \'migrate-btrees\')\n-        view()      # call the view, triggering the migration\n-        num = self.getNumber(output)\n-        self.assertEqual(num, 3)\n-        self.assertTrue(isSaneBTreeFolder(self.portal.test))\n-        self.assertTrue(isSaneBTreeFolder(self.portal.test.foo))\n-        self.assertTrue(isSaneBTreeFolder(self.portal.test.bar))\n-\n'

Repository: plone.app.folder


Branch: refs/heads/master
Date: 2020-10-09T12:49:33+02:00
Author: Maurits van Rees (mauritsvanrees) <m.van.rees@zestsoftware.nl>
Commit: https://github.com/plone/plone.app.folder/commit/bb6cdecffffd42eaa5c8a372a483d2e1dbb232fd

Merge pull request #25 from plone/maurits/remove-ancient-plone-3-to-4-migration-code

Removed migration code for upgrading folders from Plone 3 to 4

Files changed:
A news/24.bugfix
M src/plone/app/folder/configure.zcml
D src/plone/app/folder/migration.py
D src/plone/app/folder/tests/test_migration.py

b'diff --git a/news/24.bugfix b/news/24.bugfix\nnew file mode 100644\nindex 0000000..a2fed22\n--- /dev/null\n+++ b/news/24.bugfix\n@@ -0,0 +1,4 @@\n+Removed ancient migration code for upgrading BTree folder from Plone 3 to 4.\n+The code, or at least the tests, are incompatible with the latest ``zope.interface``.\n+Current plone.app.folder is only for Plone 5.2, so the code is not needed.\n+[maurits]\ndiff --git a/src/plone/app/folder/configure.zcml b/src/plone/app/folder/configure.zcml\nindex 52a6934..967f392 100644\n--- a/src/plone/app/folder/configure.zcml\n+++ b/src/plone/app/folder/configure.zcml\n@@ -1,7 +1,6 @@\n <configure\n     xmlns="http://namespaces.zope.org/zope"\n     xmlns:five="http://namespaces.zope.org/five"\n-    xmlns:browser="http://namespaces.zope.org/browser"\n     xmlns:zcml="http://namespaces.zope.org/zcml"\n     i18n_domain="plone.app.folder">\n \n@@ -17,11 +16,4 @@\n \n     </configure>\n \n-    <browser:page\n-        for="*"\n-        name="migrate-btrees"\n-        class=".migration.BTreeMigrationView"\n-        permission="cmf.ManagePortal"\n-        />\n-\n </configure>\ndiff --git a/src/plone/app/folder/migration.py b/src/plone/app/folder/migration.py\ndeleted file mode 100644\nindex 43ec285..0000000\n--- a/src/plone/app/folder/migration.py\n+++ /dev/null\n@@ -1,93 +0,0 @@\n-# -*- coding: utf-8 -*-\n-from Acquisition import aq_base\n-from logging import getLogger\n-from plone.app.folder.utils import checkpointIterator\n-from plone.app.folder.utils import findObjects\n-from plone.app.folder.utils import timer\n-from Products.BTreeFolder2.BTreeFolder2 import BTreeFolder2Base as BTreeFolder\n-from Products.Five.browser import BrowserView\n-from time import clock\n-from time import strftime\n-from transaction import get\n-\n-\n-logger = getLogger(__name__)\n-\n-\n-class BTreeMigrationView(BrowserView):\n-    """ helper view for btree-migration;  all old-style folder, which\n-        are btree-based now (implementation-wise) will be migration\n-        in term of their internal data structures being updated """\n-\n-    def mklog(self):\n-        """ helper to prepend a time stamp to the output """\n-        write = self.request.RESPONSE.write\n-\n-        def log(msg, timestamp=True, cr=True):\n-            if timestamp:\n-                msg = strftime(\'%Y/%m/%d-%H:%M:%S \') + msg\n-            if cr:\n-                msg += \'\\n\'\n-            write(msg)\n-        return log\n-\n-    def migrate(self, folder):\n-        """ migrate existing data structure from a regular folder to a btree\n-            folder;  the folder needs to be btree-based already """\n-        folder = aq_base(folder)\n-        assert isinstance(folder, BTreeFolder)\n-        assert folder.getId()       # make sure the object is properly loaded\n-\n-        def has(key):\n-            return key in folder.__dict__\n-\n-        if has(\'_tree\') and not has(\'_objects\'):\n-            return False            # already migrated...\n-        folder._initBTrees()        # create _tree, _count, _mt_index\n-        for info in folder._objects:\n-            name = info[\'id\']\n-            # _setOb will notify the ordering adapter itself,\n-            # so we don\'t need to care about storing order information here...\n-            folder._setOb(name, aq_base(getattr(folder, name)))\n-            delattr(folder, name)\n-        if has(\'_objects\'):\n-            delattr(folder, \'_objects\')\n-        return True\n-\n-    def postprocess(self, obj):\n-        # This is a hook for other migration code and is used in\n-        # plone.app.upgrade\n-        pass\n-\n-    def __call__(self, batch=1000, dryrun=False):\n-        """ find all btree-based folder below the context, potentially\n-            migrate them & provide some logging and statistics doing so """\n-        log = self.mklog()\n-        log(\'migrating btree-based folders from %r:\' % self.context)\n-        real = timer()          # real time\n-        lap = timer()           # real lap time (for intermediate commits)\n-        cpu = timer(clock)      # cpu time\n-        processed = 0\n-\n-        def checkPoint():\n-            msg = \'intermediate commit \'\\\n-                  \'(%d objects processed, last batch in %s)...\'\n-            log(msg % (processed, next(lap)))\n-            trx = get()\n-            trx.note(u\'migrated %d btree-folders\' % processed)\n-            trx.savepoint()\n-        cpi = checkpointIterator(checkPoint, batch)\n-        for path, obj in findObjects(self.context):\n-            if isinstance(obj, BTreeFolder):\n-                if self.migrate(obj):\n-                    processed += 1\n-                    next(cpi)\n-            self.postprocess(obj)\n-\n-        checkPoint()                # commit last batch\n-        if dryrun:\n-            get().abort()           # abort on test-run...\n-        msg = \'processed %d object(s) in %s (%s cpu time).\'\n-        msg = msg % (processed, next(real), next(cpu))\n-        log(msg)\n-        logger.info(msg)\ndiff --git a/src/plone/app/folder/tests/test_migration.py b/src/plone/app/folder/tests/test_migration.py\ndeleted file mode 100644\nindex dee1e5b..0000000\n--- a/src/plone/app/folder/tests/test_migration.py\n+++ /dev/null\n@@ -1,237 +0,0 @@\n-# -*- coding: utf-8 -*-\n-from Acquisition import aq_base\n-from Acquisition import aq_parent\n-from Products.ATContentTypes.content.document import ATDocument\n-from Products.BTreeFolder2.BTreeFolder2 import BTreeFolder2Base as BTreeFolder\n-from plone.app.folder.tests.content import _createObjectByType\n-from plone.app.folder.migration import BTreeMigrationView\n-from plone.app.folder.tests.base import IntegrationTestCase\n-from plone.app.folder.tests.content import NonBTreeFolder\n-from plone.app.folder.tests.content import OrderableFolder\n-from plone.app.folder.tests.content import create\n-from plone.app.folder.tests.layer import IntegrationLayer\n-from plone.app.folder.utils import findObjects\n-from plone.folder.interfaces import IOrderable\n-from plone.folder.interfaces import IOrdering\n-from zope.component import getMultiAdapter\n-from zope.interface import classImplements\n-from zope.publisher.browser import TestRequest\n-\n-import re\n-import transaction\n-\n-\n-def reverseMigrate(folder):\n-    """ helper to replace the given regular folder with one based on\n-        btrees;  the intention is to create the state that would be found\n-        before migration, i.e. a now btree-based folder still holding the\n-        data structures from a regular one;  all (regular) subfolders\n-        will be replaced recursively """\n-    for name, obj in reversed(list(findObjects(folder))):\n-        if isinstance(obj, NonBTreeFolder):\n-            parent = aq_parent(obj)\n-            data = obj.__dict__.copy()\n-            data[\'id\'] = oid = obj.getId()\n-            new = OrderableFolder(oid)\n-            new.__dict__ = data\n-            setattr(parent, oid, new)\n-\n-\n-def isSaneBTreeFolder(folder):\n-    """ sanity-check the given btree folder """\n-    folder = aq_base(folder)\n-    contains = folder.__dict__.__contains__\n-    state = isinstance(folder, BTreeFolder) and contains(\'_tree\') \\\n-        and not contains(\'_objects\')     # it\'s a class variable\n-    if state:\n-        try:\n-            # objects must not live directly on the folder (but in the btree)\n-            for oid in folder.objectIds():\n-                if not hasattr(folder, oid) or contains(oid):\n-                    return False\n-        except AttributeError:\n-            return False\n-    return state\n-\n-\n-def makeResponse(request):\n-    """ create a fake request and set up logging of output """\n-    headers = {}\n-    output = []\n-\n-    class Response:\n-        def setHeader(self, header, value):\n-            headers[header] = value\n-\n-        def write(self, msg):\n-            output.append(msg.strip())\n-    request.RESPONSE = Response()\n-    return headers, output, request\n-\n-\n-def getView(context, name, **kw):\n-    headers, output, request = makeResponse(TestRequest(**kw))\n-    view = getMultiAdapter((context, request), name=name)\n-    return view, headers, output, request\n-\n-\n-class TestMigrationHelpers(IntegrationTestCase):\n-    """ test helper functions for btree migration """\n-\n-    layer = IntegrationLayer\n-\n-    def testReverseMigrate(self):\n-        folder = create(\'Folder\', self.portal, \'folder\', title=\'Foo\')\n-        create(\'Document\', folder, \'doc1\')\n-        create(\'Event\', folder, \'event1\')\n-        reverseMigrate(folder)\n-        btree = aq_base(self.portal.folder)\n-        self.assertTrue(isinstance(btree, BTreeFolder))\n-        self.assertTrue(\'_objects\' in btree.__dict__)\n-        self.assertTrue(hasattr(btree, \'_tree\'))\n-        self.assertFalse(\'_tree\' in btree.__dict__)\n-        self.assertEqual(btree._tree, None)\n-        self.assertEqual(\n-            btree._objects,\n-            (\n-                dict(id=\'doc1\', meta_type=\'ATDocument\'),\n-                dict(id=\'event1\', meta_type=\'ATEvent\')\n-            )\n-        )\n-        self.assertEqual(btree.getId(), \'folder\')\n-        self.assertEqual(btree.Title(), \'Foo\')\n-\n-    def testNestedReverseMigrate(self):\n-        folder = create(\'Folder\', self.portal, \'foo\')\n-        create(\'Folder\', folder, \'bar\')\n-        reverseMigrate(folder)\n-        foo = aq_base(self.portal.foo)\n-        self.assertTrue(isinstance(foo, BTreeFolder))\n-        self.assertTrue(\'_objects\' in foo.__dict__)\n-        self.assertTrue(hasattr(foo, \'_tree\'))\n-        self.assertFalse(\'_tree\' in foo.__dict__)\n-        self.assertEqual(foo._tree, None)\n-        self.assertEqual(\n-            foo._objects,\n-            (dict(id=\'bar\', meta_type=\'NonBTreeFolder\'), )\n-        )\n-        bar = aq_base(getattr(foo, \'bar\'))\n-        self.assertTrue(isinstance(bar, BTreeFolder))\n-        self.assertFalse(\'_objects\' in bar.__dict__)   # no sub-objects\n-        self.assertEqual(bar._objects, ())\n-        self.assertTrue(hasattr(bar, \'_tree\'))\n-        self.assertFalse(\'_tree\' in bar.__dict__)\n-        self.assertEqual(bar._tree, None)\n-        self.assertEqual(bar._objects, ())\n-\n-    def testIsSaneBTreeFolder(self):\n-        # positive case\n-        _createObjectByType(\'Folder\', self.portal, \'btree\')\n-        self.assertTrue(isSaneBTreeFolder(self.portal.btree))\n-        # negative case\n-        create(\'Folder\', self.portal, \'folder\')\n-        self.assertFalse(isSaneBTreeFolder(self.portal.folder))\n-        reverseMigrate(self.portal.folder)\n-        self.assertFalse(isSaneBTreeFolder(self.portal.folder))\n-\n-\n-class TestBTreeMigration(IntegrationTestCase):\n-    """ test BTree migration tests migration between Folder and\n-        btree-based folder """\n-\n-    layer = IntegrationLayer\n-\n-    def afterSetUp(self):\n-        classImplements(ATDocument, IOrderable)\n-        # have to delete previously created content manually\n-        # because of test isolation problems\n-        if \'test\' in self.portal:\n-            del self.portal[\'test\']\n-            transaction.commit()\n-\n-    def makeUnmigratedFolder(self, context, name, **kw):\n-        """ create a folder in an unmigrated state """\n-        folder = create(\'Folder\', context, name, **kw)\n-        reverseMigrate(folder)\n-        self.assertFalse(isSaneBTreeFolder(folder))\n-        return context[name]\n-\n-    def testBTreeMigration(self):\n-        # create (unmigrated) btree folder\n-        folder = self.makeUnmigratedFolder(self.portal, \'test\', title=\'Foo\')\n-        view = BTreeMigrationView(self.portal, self.app.REQUEST)\n-        self.assertTrue(view.migrate(folder))\n-        folder = self.portal.test       # get the object again...\n-        self.assertTrue(isSaneBTreeFolder(folder))\n-        self.assertEqual(folder.getId(), \'test\')\n-        self.assertEqual(folder.Title(), \'Foo\')\n-        # a second migration should be skipped\n-        self.assertFalse(view.migrate(folder))\n-\n-    def getNumber(self, output):\n-        self.assertTrue(len(output) >= 3)\n-        self.assertTrue(\'migrating btree-based folders\' in output[0])\n-        self.assertTrue(\'intermediate commit\' in output[-2])\n-        last = output[-1]\n-        self.assertTrue(\'processed\' in last)\n-        matches = re.match(r\'.*processed (.*) object.*\', last).groups()\n-        return int(matches[0])\n-\n-    def testMigrationView(self):\n-        folder = self.makeUnmigratedFolder(self.portal, \'test\', title=\'Foo\')\n-        view, headers, output, request = getView(folder, \'migrate-btrees\')\n-        view()      # call the view, triggering the migration\n-        num = self.getNumber(output)\n-        self.assertEqual(num, 1)\n-        folder = self.portal.test               # get the object again...\n-        self.assertTrue(isSaneBTreeFolder(folder))\n-        self.assertEqual(folder.getId(), \'test\')\n-        self.assertEqual(folder.Title(), \'Foo\')\n-\n-    def testMigrationViewWithSubobjects(self):\n-        # set up an (unmigrated) folder with subobjects\n-        folder = create(\'Folder\', self.portal, \'test\', title=\'Foo\')\n-        create(\'Document\', folder, \'doc1\')\n-        create(\'Event\', folder, \'event1\')\n-        reverseMigrate(folder)\n-        folder = self.portal.test               # get the object again...\n-        self.assertFalse(isSaneBTreeFolder(folder))\n-        # now test its migration...\n-        view, headers, output, request = getView(self.portal, \'migrate-btrees\')\n-        view()      # call the view, triggering the migration\n-        num = self.getNumber(output)\n-        self.assertEqual(num, 1)\n-        folder = self.portal.test               # get the object again...\n-        self.assertTrue(isSaneBTreeFolder(folder))\n-        self.assertEqual(folder.getId(), \'test\')\n-        self.assertEqual(folder.Title(), \'Foo\')\n-        self.assertEqual(len(folder.objectValues()), 2)\n-        self.assertEqual(set(folder.objectIds()), set([\'doc1\', \'event1\']))\n-        self.assertEqual(IOrdering(folder).idsInOrder(), [\'doc1\', \'event1\'])\n-\n-    def testMigrationViewForMultipleFolders(self):\n-        self.makeUnmigratedFolder(self.portal, \'folder1\')\n-        self.makeUnmigratedFolder(self.portal, \'folder2\')\n-        view, headers, output, request = getView(self.portal, \'migrate-btrees\')\n-        view()      # call the view, triggering the migration\n-        num = self.getNumber(output)\n-        self.assertEqual(num, 2)\n-        self.assertTrue(isSaneBTreeFolder(self.portal.folder1))\n-        self.assertTrue(isSaneBTreeFolder(self.portal.folder2))\n-\n-    def testMigrationViewForNestedFolders(self):\n-        # nested folders have to be "unmigrated" in bottom-up...\n-        folder = create(\'Folder\', self.portal, \'test\')\n-        create(\'Folder\', self.portal.test, \'foo\')\n-        create(\'Folder\', self.portal.test, \'bar\')\n-        reverseMigrate(folder)\n-        self.assertFalse(isSaneBTreeFolder(folder))\n-        # start the migration\n-        view, headers, output, request = getView(self.portal, \'migrate-btrees\')\n-        view()      # call the view, triggering the migration\n-        num = self.getNumber(output)\n-        self.assertEqual(num, 3)\n-        self.assertTrue(isSaneBTreeFolder(self.portal.test))\n-        self.assertTrue(isSaneBTreeFolder(self.portal.test.foo))\n-        self.assertTrue(isSaneBTreeFolder(self.portal.test.bar))\n-\n'

