Repository: plone.namedfile


Branch: refs/heads/master
Date: 2019-12-09T09:44:23+01:00
Author: mauro (mamico) <mauro.amico@unibo.it>
Commit: https://github.com/plone/plone.namedfile/commit/004f99c3a19e75fd69cbc93ee6fdd57209bee6d4

initial range implementation

Files changed:
M plone/namedfile/browser.py
M plone/namedfile/file.py
M plone/namedfile/usage.rst
M plone/namedfile/utils/__init__.py

b'diff --git a/plone/namedfile/browser.py b/plone/namedfile/browser.py\nindex 63da817..e27360e 100644\n--- a/plone/namedfile/browser.py\n+++ b/plone/namedfile/browser.py\n@@ -7,6 +7,8 @@\n from zope.interface import implementer\n from zope.publisher.interfaces import IPublishTraverse\n from zope.publisher.interfaces import NotFound\n+from ZPublisher.HTTPRangeSupport import expandRanges\n+from ZPublisher.HTTPRangeSupport import parseRange\n \n \n @implementer(IPublishTraverse)\n@@ -30,20 +32,72 @@ def __init__(self, context, request):\n         self.filename = None\n \n     def publishTraverse(self, request, name):\n-\n         if self.fieldname is None:  # ../@@download/fieldname\n             self.fieldname = name\n         elif self.filename is None:  # ../@@download/fieldname/filename\n             self.filename = name\n         else:\n             raise NotFound(self, name, request)\n-\n         return self\n \n     def __call__(self):\n         file = self._getFile()\n         self.set_headers(file)\n-        return stream_data(file)\n+        request_range = self.handle_request_range(file)\n+        return stream_data(file, **request_range)\n+\n+    def handle_request_range(self, file):\n+        # check if we have a range in the request\n+        ranges = None\n+        range = self.request.headers.get(\'Range\', None)\n+        if_range = self.request.headers.get(\'If-Range\', None)\n+        if range is not None:\n+            ranges = parseRange(range)\n+            if if_range is not None:\n+                # TODO: if_range not yet implemented\n+                ranges = None\n+                # Only send ranges if the data isn\'t modified, otherwise send\n+                # the whole object. Support both ETags and Last-Modified dates!\n+            #     if len(if_range) > 1 and if_range[:2] == \'ts\':\n+            #         # ETag:\n+            #         if if_range != instance.http__etag():\n+            #             # Modified, so send a normal response. We delete\n+            #             # the ranges, which causes us to skip to the 200\n+            #             # response.\n+            #             ranges = None\n+            #     else:\n+            #         # Date\n+            #         date = if_range.split(\';\')[0]\n+            #         try:\n+            #             mod_since = long(DateTime(date).timeTime())\n+            #         except Exception:\n+            #             mod_since = None\n+            #         if mod_since is not None:\n+            #             if instance._p_mtime:\n+            #                 last_mod = long(instance._p_mtime)\n+            #             else:\n+            #                 last_mod = 0\n+            #             if last_mod > mod_since:\n+            #                 # Modified, so send a normal response. We delete\n+            #                 # the ranges, which causes us to skip to the 200\n+            #                 # response.\n+            #                 ranges = None\n+            #     RESPONSE.setHeader(\'Accept-Ranges\', \'bytes\')\n+            # XXX: multipart ranges not implemented\n+            if ranges and len(ranges) == 1:\n+                try:\n+                    length = file.getSize()\n+                    [(start, end)] = expandRanges(ranges, length)\n+                    size = end - start\n+                    self.request.response.setHeader(\'Content-Length\', size)\n+                    self.request.response.setHeader(\n+                        \'Content-Range\',\n+                        \'bytes {0}-{1}/{2}\'.format(start, end - 1, length))\n+                    self.request.response.setStatus(206)  # Partial content\n+                    return dict(start=start, end=end)\n+                except ValueError:\n+                    return {}\n+        return {}\n \n     def set_headers(self, file):\n         if not self.filename:\ndiff --git a/plone/namedfile/file.py b/plone/namedfile/file.py\nindex b9f51c2..6d0bf52 100644\n--- a/plone/namedfile/file.py\n+++ b/plone/namedfile/file.py\n@@ -17,6 +17,7 @@\n from zope.component import getUtility\n from zope.interface import implementer\n from zope.schema.fieldproperty import FieldProperty\n+from ZPublisher import HTTPRangeSupport\n \n import piexif\n import six\n@@ -311,7 +312,7 @@ def getImageSize(self):\n     data = property(NamedFile._getData, _setData)\n \n \n-@implementer(INamedBlobFile)\n+@implementer(INamedBlobFile, HTTPRangeSupport.HTTPRangeInterface)\n class NamedBlobFile(Persistent):\n     """A file stored in a ZODB BLOB, with a filename"""\n \ndiff --git a/plone/namedfile/usage.rst b/plone/namedfile/usage.rst\nindex f55ab21..6f6ce31 100644\n--- a/plone/namedfile/usage.rst\n+++ b/plone/namedfile/usage.rst\n@@ -214,6 +214,37 @@ We will test this with a dummy request, faking traversal::\n     >>> request.response.getHeader(\'Content-Disposition\')\n     "attachment; filename*=UTF-8\'\'zpt.gif"\n \n+Range support\n+-------------\n+\n+Checking for partial requests support::\n+\n+    >>> request = TestRequest()\n+    >>> download = Download(container, request).publishTraverse(request, \'blobimage\')\n+    >>> data = download()\n+    >>> request.response.getHeader(\'Content-Length\')\n+    \'341\'\n+    >>> request.response.getHeader(\'Accept-Ranges\')\n+    \'bytes\'\n+\n+Request a specific range::\n+\n+    >>> request = TestRequest(environ={\'HTTP_RANGE\': \'bytes=0-99\'})\n+    >>> download = Download(container, request).publishTraverse(request, \'blobimage\')\n+    >>> data = download()\n+    >>> request.response.getStatus()\n+    206\n+    >>> len(hasattr(data, \'read\') and data.read() or data)\n+    100\n+\n+The Content-Length header now indicates the size of the requested range (and not the full size of the image).\n+The Content-Range response header indicates where in the full resource this partial message belongs.::\n+\n+    >>> request.response.getHeader(\'Content-Length\')\n+    \'100\'\n+    >>> request.response.getHeader(\'Content-Range\')\n+    \'bytes 0-99/341\'\n+\n \n Display-file view\n -----------------\ndiff --git a/plone/namedfile/utils/__init__.py b/plone/namedfile/utils/__init__.py\nindex 68a96ed..8eff489 100644\n--- a/plone/namedfile/utils/__init__.py\n+++ b/plone/namedfile/utils/__init__.py\n@@ -29,11 +29,38 @@\n \n try:\n     # use this to stream data if we can\n+    from ZPublisher.Iterators import IStreamIterator\n     from ZPublisher.Iterators import filestream_iterator\n except ImportError:\n     filestream_iterator = None\n \n \n+if filestream_iterator is not None:\n+    class filestream_range_iterator(filestream_iterator):\n+        """\n+        A FileIO subclass which implements an iterator that returns a\n+        fixed-sized sequence of bytes.\n+        """\n+\n+        def __init__(self, name, mode=\'rb\', bufsize=-1, streamsize=1 << 16, start=0, end=None):\n+            super(filestream_iterator, self).__init__(name, mode, bufsize, streamsize)\n+            self.start = start\n+            self.end = end\n+            self.seek(start, 0)\n+\n+        def __next__(self):\n+            if self.end is None:\n+                bytes = self.streamsize\n+            else:\n+                bytes = max(min(self.end - self.tell(), self.streamsize), 0)\n+            data = self.read(bytes)\n+            if not data:\n+                raise StopIteration\n+            return data\n+\n+        next = __next__\n+\n+\n def safe_basename(filename):\n     """Get the basename of the given filename, regardless of which platform\n     (Windows or Unix) it originated from.\n@@ -74,6 +101,7 @@ def set_headers(file, response, filename=None):\n \n     response.setHeader(\'Content-Type\', contenttype)\n     response.setHeader(\'Content-Length\', file.getSize())\n+    response.setHeader(\'Accept-Ranges\', \'bytes\')\n \n     if filename is not None:\n         if not isinstance(filename, six.text_type):\n@@ -85,17 +113,15 @@ def set_headers(file, response, filename=None):\n         )\n \n \n-def stream_data(file):\n+def stream_data(file, start=0, end=None):\n     """Return the given file as a stream if possible.\n     """\n-\n     if IBlobby.providedBy(file):\n         if file._blob._p_blob_uncommitted:\n-            return file.data\n+            return file.data[start:end]\n         if filestream_iterator is not None:\n-            return filestream_iterator(file._blob.committed(), \'rb\')\n-\n-    return file.data\n+            return filestream_range_iterator(file._blob.committed(), \'rb\', start, end)\n+    return file.data[start:end]\n \n \n def _ensure_data(image):\n'

Repository: plone.namedfile


Branch: refs/heads/master
Date: 2019-12-13T17:15:05+01:00
Author: mauro (mamico) <mauro.amico@unibo.it>
Commit: https://github.com/plone/plone.namedfile/commit/7b41f31d3f0ad689bf46980f1e54831782fb7c76

fix iterator

Files changed:
M plone/namedfile/utils/__init__.py

b'diff --git a/plone/namedfile/utils/__init__.py b/plone/namedfile/utils/__init__.py\nindex 8eff489..a659705 100644\n--- a/plone/namedfile/utils/__init__.py\n+++ b/plone/namedfile/utils/__init__.py\n@@ -9,6 +9,7 @@\n from six.moves import urllib\n from zope.component import queryUtility\n from zope.deprecation import deprecate\n+from zope.interface import implementer\n \n import mimetypes\n import os.path\n@@ -36,6 +37,7 @@\n \n \n if filestream_iterator is not None:\n+    @implementer(IStreamIterator)\n     class filestream_range_iterator(filestream_iterator):\n         """\n         A FileIO subclass which implements an iterator that returns a\n@@ -43,7 +45,7 @@ class filestream_range_iterator(filestream_iterator):\n         """\n \n         def __init__(self, name, mode=\'rb\', bufsize=-1, streamsize=1 << 16, start=0, end=None):\n-            super(filestream_iterator, self).__init__(name, mode, bufsize, streamsize)\n+            super(filestream_range_iterator, self).__init__(name, mode, bufsize, streamsize)\n             self.start = start\n             self.end = end\n             self.seek(start, 0)\n@@ -120,7 +122,7 @@ def stream_data(file, start=0, end=None):\n         if file._blob._p_blob_uncommitted:\n             return file.data[start:end]\n         if filestream_iterator is not None:\n-            return filestream_range_iterator(file._blob.committed(), \'rb\', start, end)\n+            return filestream_range_iterator(file._blob.committed(), \'rb\', start=start, end=end)\n     return file.data[start:end]\n \n \n'

Repository: plone.namedfile


Branch: refs/heads/master
Date: 2019-12-15T18:52:10+01:00
Author: mauro (mamico) <mauro.amico@unibo.it>
Commit: https://github.com/plone/plone.namedfile/commit/0d8f27d190b97aaef389880041b1aa150ebe9a2a

fix filestream_iterator

Files changed:
M plone/namedfile/browser.py
M plone/namedfile/utils/__init__.py

b'diff --git a/plone/namedfile/browser.py b/plone/namedfile/browser.py\nindex e27360e..61d78e9 100644\n--- a/plone/namedfile/browser.py\n+++ b/plone/namedfile/browser.py\n@@ -49,8 +49,8 @@ def __call__(self):\n     def handle_request_range(self, file):\n         # check if we have a range in the request\n         ranges = None\n-        range = self.request.headers.get(\'Range\', None)\n-        if_range = self.request.headers.get(\'If-Range\', None)\n+        range = self.request.getHeader(\'Range\', None)\n+        if_range = self.request.getHeader(\'If-Range\', None)\n         if range is not None:\n             ranges = parseRange(range)\n             if if_range is not None:\ndiff --git a/plone/namedfile/utils/__init__.py b/plone/namedfile/utils/__init__.py\nindex a659705..ca0ca94 100644\n--- a/plone/namedfile/utils/__init__.py\n+++ b/plone/namedfile/utils/__init__.py\n@@ -1,4 +1,5 @@\n # -*- coding: utf-8 -*-\n+from io import FileIO\n from logging import getLogger\n from plone.namedfile.interfaces import IBlobby\n from plone.namedfile.utils.jpeg_utils import process_jpeg\n@@ -7,6 +8,7 @@\n from plone.registry.interfaces import IRegistry\n from six import BytesIO\n from six.moves import urllib\n+from ZPublisher.Iterators import IStreamIterator\n from zope.component import queryUtility\n from zope.deprecation import deprecate\n from zope.interface import implementer\n@@ -28,39 +30,43 @@\n     log.info(\'IImagingSchema for high pixel density scales not available.\')\n \n \n-try:\n-    # use this to stream data if we can\n-    from ZPublisher.Iterators import IStreamIterator\n-    from ZPublisher.Iterators import filestream_iterator\n-except ImportError:\n-    filestream_iterator = None\n+@implementer(IStreamIterator)\n+class filestream_range_iterator(object):\n+    """\n+    A class that mimics FileIO and implements an iterator that returns a\n+    fixed-sized sequence of bytes. Beginning from `start` to `end`.\n \n+    BBB: due to a possible bug in Zope>4, <=4.1.3, couldn\'t be subclass of FileIO\n+         as Iterators.filestream_iterator\n+    """\n+\n+    def __init__(self, name, mode=\'rb\', bufsize=-1, streamsize=1 << 16, start=0, end=None):\n+        self._io = FileIO(name, mode=mode)\n+        self.streamsize = streamsize\n+        self.start = start\n+        self.end = end\n+        self._io.seek(start, 0)\n+\n+    def __next__(self):\n+        if self.end is None:\n+            bytes = self.streamsize\n+        else:\n+            bytes = max(min(self.end - self._io.tell(), self.streamsize), 0)\n+        data = self._io.read(bytes)\n+        if not data:\n+            raise StopIteration\n+        return data\n \n-if filestream_iterator is not None:\n-    @implementer(IStreamIterator)\n-    class filestream_range_iterator(filestream_iterator):\n-        """\n-        A FileIO subclass which implements an iterator that returns a\n-        fixed-sized sequence of bytes.\n-        """\n+    next = __next__\n \n-        def __init__(self, name, mode=\'rb\', bufsize=-1, streamsize=1 << 16, start=0, end=None):\n-            super(filestream_range_iterator, self).__init__(name, mode, bufsize, streamsize)\n-            self.start = start\n-            self.end = end\n-            self.seek(start, 0)\n+    def close(self):\n+        self._io.close()\n \n-        def __next__(self):\n-            if self.end is None:\n-                bytes = self.streamsize\n-            else:\n-                bytes = max(min(self.end - self.tell(), self.streamsize), 0)\n-            data = self.read(bytes)\n-            if not data:\n-                raise StopIteration\n-            return data\n+    # BBB: is it necessary to implement __len__ ?\n+    # def __len__(self)\n \n-        next = __next__\n+    def read(self, size=-1):\n+        return self._io.read(size)\n \n \n def safe_basename(filename):\n@@ -121,8 +127,7 @@ def stream_data(file, start=0, end=None):\n     if IBlobby.providedBy(file):\n         if file._blob._p_blob_uncommitted:\n             return file.data[start:end]\n-        if filestream_iterator is not None:\n-            return filestream_range_iterator(file._blob.committed(), \'rb\', start=start, end=end)\n+        return filestream_range_iterator(file._blob.committed(), \'rb\', start=start, end=end)\n     return file.data[start:end]\n \n \n'

Repository: plone.namedfile


Branch: refs/heads/master
Date: 2020-01-06T12:58:37+01:00
Author: mauro (mamico) <mauro.amico@unibo.it>
Commit: https://github.com/plone/plone.namedfile/commit/b22168d770a2bfcc0cd400d939e507ec42a60529

implements if-range

Files changed:
M plone/namedfile/browser.py
M setup.py

b'diff --git a/plone/namedfile/browser.py b/plone/namedfile/browser.py\nindex 61d78e9..071d674 100644\n--- a/plone/namedfile/browser.py\n+++ b/plone/namedfile/browser.py\n@@ -1,9 +1,13 @@\n # -*- coding: utf-8 -*-\n from AccessControl.ZopeGuards import guarded_getattr\n+from plone.app.caching.operations.utils import ETAG_ANNOTATION_KEY\n+from plone.app.caching.operations.utils import formatDateTime\n+from plone.app.caching.operations.utils import getLastModifiedAnnotation\n from plone.namedfile.utils import set_headers\n from plone.namedfile.utils import stream_data\n from plone.rfc822.interfaces import IPrimaryFieldInfo\n from Products.Five.browser import BrowserView\n+from zope.annotation.interfaces import IAnnotations\n from zope.interface import implementer\n from zope.publisher.interfaces import IPublishTraverse\n from zope.publisher.interfaces import NotFound\n@@ -11,6 +15,19 @@\n from ZPublisher.HTTPRangeSupport import parseRange\n \n \n+_marker = object()\n+\n+\n+def getEtagAnnotation(request):\n+    # try to get etag from p.a.caching annotation\n+    annotations = IAnnotations(request, None)\n+    if annotations is not None:\n+        etag = annotations.get(ETAG_ANNOTATION_KEY, _marker)\n+        if etag is not _marker:\n+            return etag\n+    return None\n+\n+\n @implementer(IPublishTraverse)\n class Download(BrowserView):\n     """Download a file, via ../context/@@download/fieldname/filename\n@@ -49,40 +66,22 @@ def __call__(self):\n     def handle_request_range(self, file):\n         # check if we have a range in the request\n         ranges = None\n-        range = self.request.getHeader(\'Range\', None)\n+        header_range = self.request.getHeader(\'Range\', None)\n         if_range = self.request.getHeader(\'If-Range\', None)\n-        if range is not None:\n-            ranges = parseRange(range)\n+        if header_range is not None:\n+            ranges = parseRange(header_range)\n             if if_range is not None:\n-                # TODO: if_range not yet implemented\n-                ranges = None\n+                if_range = if_range.strip(\'"\')\n                 # Only send ranges if the data isn\'t modified, otherwise send\n                 # the whole object. Support both ETags and Last-Modified dates!\n-            #     if len(if_range) > 1 and if_range[:2] == \'ts\':\n-            #         # ETag:\n-            #         if if_range != instance.http__etag():\n-            #             # Modified, so send a normal response. We delete\n-            #             # the ranges, which causes us to skip to the 200\n-            #             # response.\n-            #             ranges = None\n-            #     else:\n-            #         # Date\n-            #         date = if_range.split(\';\')[0]\n-            #         try:\n-            #             mod_since = long(DateTime(date).timeTime())\n-            #         except Exception:\n-            #             mod_since = None\n-            #         if mod_since is not None:\n-            #             if instance._p_mtime:\n-            #                 last_mod = long(instance._p_mtime)\n-            #             else:\n-            #                 last_mod = 0\n-            #             if last_mod > mod_since:\n-            #                 # Modified, so send a normal response. We delete\n-            #                 # the ranges, which causes us to skip to the 200\n-            #                 # response.\n-            #                 ranges = None\n-            #     RESPONSE.setHeader(\'Accept-Ranges\', \'bytes\')\n+                etag = getEtagAnnotation(self.request)\n+                lastModified = getLastModifiedAnnotation(self.context, self.request)\n+                if lastModified:\n+                    lastModified = formatDateTime(lastModified)\n+                if if_range != lastModified and if_range != etag:\n+                    # We delete the ranges, which causes us to skip to the 200\n+                    # response.\n+                    ranges = None\n             # XXX: multipart ranges not implemented\n             if ranges and len(ranges) == 1:\n                 try:\ndiff --git a/setup.py b/setup.py\nindex e8d82b1..64a3b5f 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -43,6 +43,7 @@\n     zip_safe=False,\n     install_requires=[\n         \'piexif\',\n+        \'plone.app.caching\',\n         \'plone.rfc822>=2.0a1\',\n         \'plone.scale[storage] >=1.4.999\',\n         \'plone.schemaeditor\',\n'

Repository: plone.namedfile


Branch: refs/heads/master
Date: 2020-01-07T18:26:48+01:00
Author: mauro (mamico) <mauro.amico@unibo.it>
Commit: https://github.com/plone/plone.namedfile/commit/f4d248ea1c3b7a459f2cf5628a39dfd5c1c13804

changelog

Files changed:
A news/86.feature

b'diff --git a/news/86.feature b/news/86.feature\nnew file mode 100644\nindex 0000000..3ac4fbd\n--- /dev/null\n+++ b/news/86.feature\n@@ -0,0 +1,2 @@\n+- Range support (https://developer.mozilla.org/en-US/docs/Web/HTTP/Range_requests)\n+  [mamico]\n'

Repository: plone.namedfile


Branch: refs/heads/master
Date: 2020-01-08T14:14:54+01:00
Author: mauro (mamico) <mauro.amico@unibo.it>
Commit: https://github.com/plone/plone.namedfile/commit/3b05e796e34589500e4c067b43ef192bc55dd99d

fix p.a.caching test regression

Files changed:
M plone/namedfile/utils/__init__.py

b'diff --git a/plone/namedfile/utils/__init__.py b/plone/namedfile/utils/__init__.py\nindex ca0ca94..01db7f6 100644\n--- a/plone/namedfile/utils/__init__.py\n+++ b/plone/namedfile/utils/__init__.py\n@@ -19,6 +19,10 @@\n import PIL.Image\n import six\n import struct\n+if six.PY3:  # pragma: no cover\n+    from collections.abc import Iterable\n+else:  # pragma: no cover\n+    from collections import Iterable\n \n \n log = getLogger(__name__)\n@@ -31,7 +35,7 @@\n \n \n @implementer(IStreamIterator)\n-class filestream_range_iterator(object):\n+class filestream_range_iterator(Iterable):\n     """\n     A class that mimics FileIO and implements an iterator that returns a\n     fixed-sized sequence of bytes. Beginning from `start` to `end`.\n@@ -47,6 +51,11 @@ def __init__(self, name, mode=\'rb\', bufsize=-1, streamsize=1 << 16, start=0, end\n         self.end = end\n         self._io.seek(start, 0)\n \n+    def __iter__(self):\n+        if self._io.closed:\n+            raise ValueError("I/O operation on closed file.")\n+        return self\n+\n     def __next__(self):\n         if self.end is None:\n             bytes = self.streamsize\n'

Repository: plone.namedfile


Branch: refs/heads/master
Date: 2020-01-26T12:35:13+01:00
Author: mauro (mamico) <mauro.amico@unibo.it>
Commit: https://github.com/plone/plone.namedfile/commit/36fce466cab8843e1e600372b171e920e759fa0e

remove if-range support from here

Files changed:
M plone/namedfile/browser.py
M setup.py

b'diff --git a/plone/namedfile/browser.py b/plone/namedfile/browser.py\nindex 071d674..012797f 100644\n--- a/plone/namedfile/browser.py\n+++ b/plone/namedfile/browser.py\n@@ -1,8 +1,5 @@\n # -*- coding: utf-8 -*-\n from AccessControl.ZopeGuards import guarded_getattr\n-from plone.app.caching.operations.utils import ETAG_ANNOTATION_KEY\n-from plone.app.caching.operations.utils import formatDateTime\n-from plone.app.caching.operations.utils import getLastModifiedAnnotation\n from plone.namedfile.utils import set_headers\n from plone.namedfile.utils import stream_data\n from plone.rfc822.interfaces import IPrimaryFieldInfo\n@@ -15,19 +12,6 @@\n from ZPublisher.HTTPRangeSupport import parseRange\n \n \n-_marker = object()\n-\n-\n-def getEtagAnnotation(request):\n-    # try to get etag from p.a.caching annotation\n-    annotations = IAnnotations(request, None)\n-    if annotations is not None:\n-        etag = annotations.get(ETAG_ANNOTATION_KEY, _marker)\n-        if etag is not _marker:\n-            return etag\n-    return None\n-\n-\n @implementer(IPublishTraverse)\n class Download(BrowserView):\n     """Download a file, via ../context/@@download/fieldname/filename\n@@ -71,17 +55,9 @@ def handle_request_range(self, file):\n         if header_range is not None:\n             ranges = parseRange(header_range)\n             if if_range is not None:\n-                if_range = if_range.strip(\'"\')\n-                # Only send ranges if the data isn\'t modified, otherwise send\n-                # the whole object. Support both ETags and Last-Modified dates!\n-                etag = getEtagAnnotation(self.request)\n-                lastModified = getLastModifiedAnnotation(self.context, self.request)\n-                if lastModified:\n-                    lastModified = formatDateTime(lastModified)\n-                if if_range != lastModified and if_range != etag:\n-                    # We delete the ranges, which causes us to skip to the 200\n-                    # response.\n-                    ranges = None\n+                # We delete the ranges, which causes us to skip to the 200\n+                # response.\n+                return {}\n             # XXX: multipart ranges not implemented\n             if ranges and len(ranges) == 1:\n                 try:\ndiff --git a/setup.py b/setup.py\nindex 64a3b5f..e8d82b1 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -43,7 +43,6 @@\n     zip_safe=False,\n     install_requires=[\n         \'piexif\',\n-        \'plone.app.caching\',\n         \'plone.rfc822>=2.0a1\',\n         \'plone.scale[storage] >=1.4.999\',\n         \'plone.schemaeditor\',\n'

Repository: plone.namedfile


Branch: refs/heads/master
Date: 2020-05-23T16:35:16+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.namedfile/commit/eff794135411dae6866bbf86d32b41f33b2f7459

Merge pull request #86 from plone/range

Range Support

Files changed:
A news/86.feature
M plone/namedfile/browser.py
M plone/namedfile/file.py
M plone/namedfile/usage.rst
M plone/namedfile/utils/__init__.py

b'diff --git a/news/86.feature b/news/86.feature\nnew file mode 100644\nindex 0000000..3ac4fbd\n--- /dev/null\n+++ b/news/86.feature\n@@ -0,0 +1,2 @@\n+- Range support (https://developer.mozilla.org/en-US/docs/Web/HTTP/Range_requests)\n+  [mamico]\ndiff --git a/plone/namedfile/browser.py b/plone/namedfile/browser.py\nindex 63da817..012797f 100644\n--- a/plone/namedfile/browser.py\n+++ b/plone/namedfile/browser.py\n@@ -4,9 +4,12 @@\n from plone.namedfile.utils import stream_data\n from plone.rfc822.interfaces import IPrimaryFieldInfo\n from Products.Five.browser import BrowserView\n+from zope.annotation.interfaces import IAnnotations\n from zope.interface import implementer\n from zope.publisher.interfaces import IPublishTraverse\n from zope.publisher.interfaces import NotFound\n+from ZPublisher.HTTPRangeSupport import expandRanges\n+from ZPublisher.HTTPRangeSupport import parseRange\n \n \n @implementer(IPublishTraverse)\n@@ -30,20 +33,46 @@ def __init__(self, context, request):\n         self.filename = None\n \n     def publishTraverse(self, request, name):\n-\n         if self.fieldname is None:  # ../@@download/fieldname\n             self.fieldname = name\n         elif self.filename is None:  # ../@@download/fieldname/filename\n             self.filename = name\n         else:\n             raise NotFound(self, name, request)\n-\n         return self\n \n     def __call__(self):\n         file = self._getFile()\n         self.set_headers(file)\n-        return stream_data(file)\n+        request_range = self.handle_request_range(file)\n+        return stream_data(file, **request_range)\n+\n+    def handle_request_range(self, file):\n+        # check if we have a range in the request\n+        ranges = None\n+        header_range = self.request.getHeader(\'Range\', None)\n+        if_range = self.request.getHeader(\'If-Range\', None)\n+        if header_range is not None:\n+            ranges = parseRange(header_range)\n+            if if_range is not None:\n+                # We delete the ranges, which causes us to skip to the 200\n+                # response.\n+                return {}\n+            # XXX: multipart ranges not implemented\n+            if ranges and len(ranges) == 1:\n+                try:\n+                    length = file.getSize()\n+                    [(start, end)] = expandRanges(ranges, length)\n+                    size = end - start\n+                    self.request.response.setHeader(\'Content-Length\', size)\n+                    self.request.response.setHeader(\n+                        \'Content-Range\',\n+                        \'bytes {0}-{1}/{2}\'.format(start, end - 1, length))\n+                    self.request.response.setStatus(206)  # Partial content\n+                    return dict(start=start, end=end)\n+                except ValueError:\n+                    return {}\n+        return {}\n \n     def set_headers(self, file):\n         if not self.filename:\ndiff --git a/plone/namedfile/file.py b/plone/namedfile/file.py\nindex b9f51c2..6d0bf52 100644\n--- a/plone/namedfile/file.py\n+++ b/plone/namedfile/file.py\n@@ -17,6 +17,7 @@\n from zope.component import getUtility\n from zope.interface import implementer\n from zope.schema.fieldproperty import FieldProperty\n+from ZPublisher import HTTPRangeSupport\n \n import piexif\n import six\n@@ -311,7 +312,7 @@ def getImageSize(self):\n     data = property(NamedFile._getData, _setData)\n \n \n-@implementer(INamedBlobFile)\n+@implementer(INamedBlobFile, HTTPRangeSupport.HTTPRangeInterface)\n class NamedBlobFile(Persistent):\n     """A file stored in a ZODB BLOB, with a filename"""\n \ndiff --git a/plone/namedfile/usage.rst b/plone/namedfile/usage.rst\nindex f55ab21..6f6ce31 100644\n--- a/plone/namedfile/usage.rst\n+++ b/plone/namedfile/usage.rst\n@@ -214,6 +214,37 @@ We will test this with a dummy request, faking traversal::\n     >>> request.response.getHeader(\'Content-Disposition\')\n     "attachment; filename*=UTF-8\'\'zpt.gif"\n \n+Range support\n+-------------\n+\n+Checking for partial requests support::\n+\n+    >>> request = TestRequest()\n+    >>> download = Download(container, request).publishTraverse(request, \'blobimage\')\n+    >>> data = download()\n+    >>> request.response.getHeader(\'Content-Length\')\n+    \'341\'\n+    >>> request.response.getHeader(\'Accept-Ranges\')\n+    \'bytes\'\n+\n+Request a specific range::\n+\n+    >>> request = TestRequest(environ={\'HTTP_RANGE\': \'bytes=0-99\'})\n+    >>> download = Download(container, request).publishTraverse(request, \'blobimage\')\n+    >>> data = download()\n+    >>> request.response.getStatus()\n+    206\n+    >>> len(hasattr(data, \'read\') and data.read() or data)\n+    100\n+\n+The Content-Length header now indicates the size of the requested range (and not the full size of the image).\n+The Content-Range response header indicates where in the full resource this partial message belongs.::\n+\n+    >>> request.response.getHeader(\'Content-Length\')\n+    \'100\'\n+    >>> request.response.getHeader(\'Content-Range\')\n+    \'bytes 0-99/341\'\n+\n \n Display-file view\n -----------------\ndiff --git a/plone/namedfile/utils/__init__.py b/plone/namedfile/utils/__init__.py\nindex 68a96ed..01db7f6 100644\n--- a/plone/namedfile/utils/__init__.py\n+++ b/plone/namedfile/utils/__init__.py\n@@ -1,4 +1,5 @@\n # -*- coding: utf-8 -*-\n+from io import FileIO\n from logging import getLogger\n from plone.namedfile.interfaces import IBlobby\n from plone.namedfile.utils.jpeg_utils import process_jpeg\n@@ -7,8 +8,10 @@\n from plone.registry.interfaces import IRegistry\n from six import BytesIO\n from six.moves import urllib\n+from ZPublisher.Iterators import IStreamIterator\n from zope.component import queryUtility\n from zope.deprecation import deprecate\n+from zope.interface import implementer\n \n import mimetypes\n import os.path\n@@ -16,6 +19,10 @@\n import PIL.Image\n import six\n import struct\n+if six.PY3:  # pragma: no cover\n+    from collections.abc import Iterable\n+else:  # pragma: no cover\n+    from collections import Iterable\n \n \n log = getLogger(__name__)\n@@ -27,11 +34,48 @@\n     log.info(\'IImagingSchema for high pixel density scales not available.\')\n \n \n-try:\n-    # use this to stream data if we can\n-    from ZPublisher.Iterators import filestream_iterator\n-except ImportError:\n-    filestream_iterator = None\n+@implementer(IStreamIterator)\n+class filestream_range_iterator(Iterable):\n+    """\n+    A class that mimics FileIO and implements an iterator that returns a\n+    fixed-sized sequence of bytes. Beginning from `start` to `end`.\n+\n+    BBB: due to a possible bug in Zope>4, <=4.1.3, couldn\'t be subclass of FileIO\n+         as Iterators.filestream_iterator\n+    """\n+\n+    def __init__(self, name, mode=\'rb\', bufsize=-1, streamsize=1 << 16, start=0, end=None):\n+        self._io = FileIO(name, mode=mode)\n+        self.streamsize = streamsize\n+        self.start = start\n+        self.end = end\n+        self._io.seek(start, 0)\n+\n+    def __iter__(self):\n+        if self._io.closed:\n+            raise ValueError("I/O operation on closed file.")\n+        return self\n+\n+    def __next__(self):\n+        if self.end is None:\n+            bytes = self.streamsize\n+        else:\n+            bytes = max(min(self.end - self._io.tell(), self.streamsize), 0)\n+        data = self._io.read(bytes)\n+        if not data:\n+            raise StopIteration\n+        return data\n+\n+    next = __next__\n+\n+    def close(self):\n+        self._io.close()\n+\n+    # BBB: is it necessary to implement __len__ ?\n+    # def __len__(self)\n+\n+    def read(self, size=-1):\n+        return self._io.read(size)\n \n \n def safe_basename(filename):\n@@ -74,6 +118,7 @@ def set_headers(file, response, filename=None):\n \n     response.setHeader(\'Content-Type\', contenttype)\n     response.setHeader(\'Content-Length\', file.getSize())\n+    response.setHeader(\'Accept-Ranges\', \'bytes\')\n \n     if filename is not None:\n         if not isinstance(filename, six.text_type):\n@@ -85,17 +130,14 @@ def set_headers(file, response, filename=None):\n         )\n \n \n-def stream_data(file):\n+def stream_data(file, start=0, end=None):\n     """Return the given file as a stream if possible.\n     """\n-\n     if IBlobby.providedBy(file):\n         if file._blob._p_blob_uncommitted:\n-            return file.data\n-        if filestream_iterator is not None:\n-            return filestream_iterator(file._blob.committed(), \'rb\')\n-\n-    return file.data\n+            return file.data[start:end]\n+        return filestream_range_iterator(file._blob.committed(), \'rb\', start=start, end=end)\n+    return file.data[start:end]\n \n \n def _ensure_data(image):\n'

