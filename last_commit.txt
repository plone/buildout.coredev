Repository: plone.restapi


Branch: refs/heads/master
Date: 2020-05-04T15:21:34+02:00
Author: Mikel Larreategi (erral) <mlarreategi@codesyntax.com>
Commit: https://github.com/plone/plone.restapi/commit/2a5accbe46cef96d6c327b48edee013a2c6e22af

adapt imagefield serializer tests to the original image scale handling fixes in plone.namedfile (#925)

Files changed:
A news/932.bugfix
M src/plone/restapi/tests/test_dxfield_serializer.py

b'diff --git a/news/932.bugfix b/news/932.bugfix\nnew file mode 100644\nindex 00000000..a7199113\n--- /dev/null\n+++ b/news/932.bugfix\n@@ -0,0 +1,2 @@\n+Adapt tests to the new way of handling original image urls\n+[erral]\n\\ No newline at end of file\ndiff --git a/src/plone/restapi/tests/test_dxfield_serializer.py b/src/plone/restapi/tests/test_dxfield_serializer.py\nindex 6ae6d9fd..b3266836 100644\n--- a/src/plone/restapi/tests/test_dxfield_serializer.py\n+++ b/src/plone/restapi/tests/test_dxfield_serializer.py\n@@ -22,12 +22,7 @@\n \n import os\n import six\n-\n-\n-if PLONE_VERSION.base_version >= "5.1":\n-    GIF_SCALE_FORMAT = "png"\n-else:\n-    GIF_SCALE_FORMAT = "jpeg"\n+import unittest\n \n \n class TestDexterityFieldSerializing(TestCase):\n@@ -238,7 +233,121 @@ def test_namedfile_field_serialization_returns_dict(self):\n             value,\n         )\n \n+    def test_namedblobfile_field_serialization_returns_dict(self):\n+        value = self.serialize(\n+            "test_namedblobfile_field",\n+            NamedBlobFile(\n+                data=u"Spam and eggs", contentType=u"text/plain", filename=u"test.txt"\n+            ),\n+        )\n+        self.assertTrue(isinstance(value, dict), "Not a <dict>")\n+\n+        download_url = u"/".join(\n+            [self.doc1.absolute_url(), u"@@download/test_namedblobfile_field"]\n+        )\n+        self.assertEqual(\n+            {\n+                u"filename": u"test.txt",\n+                u"content-type": u"text/plain",\n+                u"size": 13,\n+                u"download": download_url,\n+            },\n+            value,\n+        )\n+\n+    def test_relationchoice_field_serialization_returns_summary_dict(self):\n+        doc2 = self.portal[\n+            self.portal.invokeFactory(\n+                "DXTestDocument",\n+                id="doc2",\n+                title="Referenceable Document",\n+                description="Description 2",\n+            )\n+        ]\n+        value = self.serialize("test_relationchoice_field", doc2)\n+        self.assertEqual(\n+            {\n+                "@id": "http://nohost/plone/doc2",\n+                "@type": "DXTestDocument",\n+                "title": "Referenceable Document",\n+                "description": "Description 2",\n+                "review_state": "private",\n+            },\n+            value,\n+        )\n+\n+    def test_relationlist_field_serialization_returns_list(self):\n+        doc2 = self.portal[\n+            self.portal.invokeFactory(\n+                "DXTestDocument",\n+                id="doc2",\n+                title="Referenceable Document",\n+                description="Description 2",\n+            )\n+        ]\n+        doc3 = self.portal[\n+            self.portal.invokeFactory(\n+                "DXTestDocument",\n+                id="doc3",\n+                title="Referenceable Document",\n+                description="Description 3",\n+            )\n+        ]\n+        value = self.serialize("test_relationlist_field", [doc2, doc3])\n+        self.assertTrue(isinstance(value, list), "Not a <list>")\n+        self.assertEqual(\n+            [\n+                {\n+                    "@id": "http://nohost/plone/doc2",\n+                    "@type": "DXTestDocument",\n+                    "title": "Referenceable Document",\n+                    "description": "Description 2",\n+                    "review_state": "private",\n+                },\n+                {\n+                    "@id": "http://nohost/plone/doc3",\n+                    "@type": "DXTestDocument",\n+                    "title": "Referenceable Document",\n+                    "description": "Description 3",\n+                    "review_state": "private",\n+                },\n+            ],\n+            value,\n+        )\n+\n+\n+@unittest.skipUnless(\n+    PLONE_VERSION.base_version < "5.1",\n+    "Plone < 5.1: original image url is a scaled image in JPEG format because we test with a GIF image",\n+)\n+class TestDexterityImageFieldsSerializingOriginalScaledInJPEG(TestCase):\n+    layer = PLONE_RESTAPI_DX_INTEGRATION_TESTING\n+    maxDiff = None\n+\n+    def setUp(self):\n+        self.portal = self.layer["portal"]\n+        self.request = self.layer["request"]\n+\n+        self.doc1 = self.portal[\n+            self.portal.invokeFactory(\n+                "DXTestDocument", id="doc1", title="Test Document"\n+            )\n+        ]\n+\n+    def serialize(self, fieldname, value):\n+        for schema in iterSchemata(self.doc1):\n+            if fieldname in schema:\n+                field = schema.get(fieldname)\n+                break\n+        dm = getMultiAdapter((self.doc1, field), IDataManager)\n+        dm.set(value)\n+        serializer = getMultiAdapter((field, self.doc1, self.request), IFieldSerializer)\n+        return serializer()\n+\n     def test_namedimage_field_serialization_returns_dict(self):\n+        """In Plone < 5.1 the image returned when requesting an image\n+           scale with the same width and height of the original image is\n+           a Pillow-generated image scale in JPEG format"""\n         image_file = os.path.join(os.path.dirname(__file__), u"1024x768.gif")\n         with open(image_file, "rb") as f:\n             image_data = f.read()\n@@ -254,24 +363,51 @@ def test_namedimage_field_serialization_returns_dict(self):\n \n             scale_url_uuid = "uuid_1"\n             obj_url = self.doc1.absolute_url()\n-            download_url = u"{}/@@images/{}.{}".format(\n-                obj_url, scale_url_uuid, GIF_SCALE_FORMAT\n+\n+            # Original image is still a "scale"\n+            # scaled images are converted to JPEG in Plone < 5.1\n+            original_download_url = u"{}/@@images/{}.{}".format(\n+                obj_url, scale_url_uuid, "jpeg"\n+            )\n+\n+            scale_download_url = u"{}/@@images/{}.{}".format(\n+                obj_url, scale_url_uuid, "jpeg"\n             )\n             scales = {\n-                u"listing": {u"download": download_url, u"width": 16, u"height": 12},\n-                u"icon": {u"download": download_url, u"width": 32, u"height": 24},\n-                u"tile": {u"download": download_url, u"width": 64, u"height": 48},\n-                u"thumb": {u"download": download_url, u"width": 128, u"height": 96},\n-                u"mini": {u"download": download_url, u"width": 200, u"height": 150},\n-                u"preview": {u"download": download_url, u"width": 400, u"height": 300},\n-                u"large": {u"download": download_url, u"width": 768, u"height": 576},\n+                u"listing": {\n+                    u"download": scale_download_url,\n+                    u"width": 16,\n+                    u"height": 12,\n+                },\n+                u"icon": {u"download": scale_download_url, u"width": 32, u"height": 24},\n+                u"tile": {u"download": scale_download_url, u"width": 64, u"height": 48},\n+                u"thumb": {\n+                    u"download": scale_download_url,\n+                    u"width": 128,\n+                    u"height": 96,\n+                },\n+                u"mini": {\n+                    u"download": scale_download_url,\n+                    u"width": 200,\n+                    u"height": 150,\n+                },\n+                u"preview": {\n+                    u"download": scale_download_url,\n+                    u"width": 400,\n+                    u"height": 300,\n+                },\n+                u"large": {\n+                    u"download": scale_download_url,\n+                    u"width": 768,\n+                    u"height": 576,\n+                },\n             }\n             self.assertEqual(\n                 {\n                     u"filename": u"1024x768.gif",\n                     u"content-type": u"image/gif",\n                     u"size": 1514,\n-                    u"download": download_url,\n+                    u"download": original_download_url,\n                     u"width": 1024,\n                     u"height": 768,\n                     u"scales": scales,\n@@ -280,6 +416,8 @@ def test_namedimage_field_serialization_returns_dict(self):\n             )\n \n     def test_namedimage_field_serialization_doesnt_choke_on_corrupt_image(self):\n+        """ Original image url will be None because the original image is corrupted\n+            and the created url should be an image scale """\n         image_data = b"INVALID IMAGE DATA"\n         fn = "test_namedimage_field"\n         with patch.object(storage, "uuid4", return_value="uuid_1"):\n@@ -289,6 +427,7 @@ def test_namedimage_field_serialization_doesnt_choke_on_corrupt_image(self):\n                     data=image_data, contentType=u"image/gif", filename=u"1024x768.gif"\n                 ),\n             )\n+\n         self.assertEqual(\n             {\n                 u"content-type": u"image/gif",\n@@ -302,29 +441,233 @@ def test_namedimage_field_serialization_doesnt_choke_on_corrupt_image(self):\n             value,\n         )\n \n-    def test_namedblobfile_field_serialization_returns_dict(self):\n-        value = self.serialize(\n-            "test_namedblobfile_field",\n-            NamedBlobFile(\n-                data=u"Spam and eggs", contentType=u"text/plain", filename=u"test.txt"\n-            ),\n-        )\n-        self.assertTrue(isinstance(value, dict), "Not a <dict>")\n+    def test_namedblobimage_field_serialization_returns_dict(self):\n+        """In Plone < 5.1 the image returned when requesting an image\n+           scale with the same width and height of the original image is\n+           a Pillow-generated image scale in JPEG format"""\n+        image_file = os.path.join(os.path.dirname(__file__), u"1024x768.gif")\n+        with open(image_file, "rb") as f:\n+            image_data = f.read()\n+        fn = "test_namedblobimage_field"\n+        with patch.object(storage, "uuid4", return_value="uuid_1"):\n+            value = self.serialize(\n+                fn,\n+                NamedBlobImage(\n+                    data=image_data, contentType=u"image/gif", filename=u"1024x768.gif"\n+                ),\n+            )\n+            self.assertTrue(isinstance(value, dict), "Not a <dict>")\n \n-        download_url = u"/".join(\n-            [self.doc1.absolute_url(), u"@@download/test_namedblobfile_field"]\n+            scale_url_uuid = "uuid_1"\n+            obj_url = self.doc1.absolute_url()\n+\n+            # Original image is still a "scale"\n+            # scaled images are converted to JPEG in Plone < 5.1\n+            original_download_url = u"{}/@@images/{}.{}".format(\n+                obj_url, scale_url_uuid, "jpeg"\n+            )\n+\n+            scale_download_url = u"{}/@@images/{}.{}".format(\n+                obj_url, scale_url_uuid, "jpeg"\n+            )\n+            scales = {\n+                u"listing": {\n+                    u"download": scale_download_url,\n+                    u"width": 16,\n+                    u"height": 12,\n+                },\n+                u"icon": {u"download": scale_download_url, u"width": 32, u"height": 24},\n+                u"tile": {u"download": scale_download_url, u"width": 64, u"height": 48},\n+                u"thumb": {\n+                    u"download": scale_download_url,\n+                    u"width": 128,\n+                    u"height": 96,\n+                },\n+                u"mini": {\n+                    u"download": scale_download_url,\n+                    u"width": 200,\n+                    u"height": 150,\n+                },\n+                u"preview": {\n+                    u"download": scale_download_url,\n+                    u"width": 400,\n+                    u"height": 300,\n+                },\n+                u"large": {\n+                    u"download": scale_download_url,\n+                    u"width": 768,\n+                    u"height": 576,\n+                },\n+            }\n+            self.assertEqual(\n+                {\n+                    u"filename": u"1024x768.gif",\n+                    u"content-type": u"image/gif",\n+                    u"size": 1514,\n+                    u"download": original_download_url,\n+                    u"width": 1024,\n+                    u"height": 768,\n+                    u"scales": scales,\n+                },\n+                value,\n+            )\n+\n+    def test_namedblobimage_field_serialization_doesnt_choke_on_corrupt_image(self):\n+        """ Original image url will be None because the original image is corrupted\n+            and the created url should be an image scale """\n+        image_data = b"INVALID IMAGE DATA"\n+        fn = "test_namedblobimage_field"\n+        with patch.object(storage, "uuid4", return_value="uuid_1"):\n+            value = self.serialize(\n+                fn,\n+                NamedBlobImage(\n+                    data=image_data, contentType=u"image/gif", filename=u"1024x768.gif"\n+                ),\n+            )\n+\n+        self.assertEqual(\n+            {\n+                u"content-type": u"image/gif",\n+                u"download": None,\n+                u"filename": u"1024x768.gif",\n+                u"height": -1,\n+                u"scales": {},\n+                u"size": 18,\n+                u"width": -1,\n+            },\n+            value,\n         )\n+\n+\n+@unittest.skipUnless(\n+    PLONE_VERSION.base_version == "5.1",\n+    "Plone 5.1: original image url is a scaled image in PNG format because we test with a GIF image",\n+)\n+class TestDexterityImageFieldSerializingOriginalScaledInPNG(TestCase):\n+    layer = PLONE_RESTAPI_DX_INTEGRATION_TESTING\n+    maxDiff = None\n+\n+    def setUp(self):\n+        self.portal = self.layer["portal"]\n+        self.request = self.layer["request"]\n+\n+        self.doc1 = self.portal[\n+            self.portal.invokeFactory(\n+                "DXTestDocument", id="doc1", title="Test Document"\n+            )\n+        ]\n+\n+    def serialize(self, fieldname, value):\n+        for schema in iterSchemata(self.doc1):\n+            if fieldname in schema:\n+                field = schema.get(fieldname)\n+                break\n+        dm = getMultiAdapter((self.doc1, field), IDataManager)\n+        dm.set(value)\n+        serializer = getMultiAdapter((field, self.doc1, self.request), IFieldSerializer)\n+        return serializer()\n+\n+    def test_namedimage_field_serialization_returns_dict(self):\n+        """In Plone == 5.1 the image returned when requesting an image\n+           scale with the same width and height of the original image is\n+           a Pillow-generated image scale in PNG format"""\n+        image_file = os.path.join(os.path.dirname(__file__), u"1024x768.gif")\n+        with open(image_file, "rb") as f:\n+            image_data = f.read()\n+        fn = "test_namedimage_field"\n+        with patch.object(storage, "uuid4", return_value="uuid_1"):\n+            value = self.serialize(\n+                fn,\n+                NamedImage(\n+                    data=image_data, contentType=u"image/gif", filename=u"1024x768.gif"\n+                ),\n+            )\n+            self.assertTrue(isinstance(value, dict), "Not a <dict>")\n+\n+            scale_url_uuid = "uuid_1"\n+            obj_url = self.doc1.absolute_url()\n+\n+            # Original image is still a "scale"\n+            # scaled images are converted to PNG in Plone = 5.1\n+            original_download_url = u"{}/@@images/{}.{}".format(\n+                obj_url, scale_url_uuid, "png"\n+            )\n+\n+            scale_download_url = u"{}/@@images/{}.{}".format(\n+                obj_url, scale_url_uuid, "jpeg"\n+            )\n+            scales = {\n+                u"listing": {\n+                    u"download": scale_download_url,\n+                    u"width": 16,\n+                    u"height": 12,\n+                },\n+                u"icon": {u"download": scale_download_url, u"width": 32, u"height": 24},\n+                u"tile": {u"download": scale_download_url, u"width": 64, u"height": 48},\n+                u"thumb": {\n+                    u"download": scale_download_url,\n+                    u"width": 128,\n+                    u"height": 96,\n+                },\n+                u"mini": {\n+                    u"download": scale_download_url,\n+                    u"width": 200,\n+                    u"height": 150,\n+                },\n+                u"preview": {\n+                    u"download": scale_download_url,\n+                    u"width": 400,\n+                    u"height": 300,\n+                },\n+                u"large": {\n+                    u"download": scale_download_url,\n+                    u"width": 768,\n+                    u"height": 576,\n+                },\n+            }\n+            self.assertEqual(\n+                {\n+                    u"filename": u"1024x768.gif",\n+                    u"content-type": u"image/gif",\n+                    u"size": 1514,\n+                    u"download": original_download_url,\n+                    u"width": 1024,\n+                    u"height": 768,\n+                    u"scales": scales,\n+                },\n+                value,\n+            )\n+\n+    def test_namedimage_field_serialization_doesnt_choke_on_corrupt_image(self):\n+        """ Original image url will be None because the original image is corrupted\n+            and the created url should be an image scale """\n+        image_data = b"INVALID IMAGE DATA"\n+        fn = "test_namedimage_field"\n+        with patch.object(storage, "uuid4", return_value="uuid_1"):\n+            value = self.serialize(\n+                fn,\n+                NamedImage(\n+                    data=image_data, contentType=u"image/gif", filename=u"1024x768.gif"\n+                ),\n+            )\n+\n         self.assertEqual(\n             {\n-                u"filename": u"test.txt",\n-                u"content-type": u"text/plain",\n-                u"size": 13,\n-                u"download": download_url,\n+                u"content-type": u"image/gif",\n+                u"download": None,\n+                u"filename": u"1024x768.gif",\n+                u"height": -1,\n+                u"scales": {},\n+                u"size": 18,\n+                u"width": -1,\n             },\n             value,\n         )\n \n     def test_namedblobimage_field_serialization_returns_dict(self):\n+        """In Plone = 5.1 the image returned when requesting an image\n+           scale with the same width and height of the original image is\n+           a Pillow-generated image scale in PNG format"""\n         image_file = os.path.join(os.path.dirname(__file__), u"1024x768.gif")\n         with open(image_file, "rb") as f:\n             image_data = f.read()\n@@ -340,24 +683,51 @@ def test_namedblobimage_field_serialization_returns_dict(self):\n \n             scale_url_uuid = "uuid_1"\n             obj_url = self.doc1.absolute_url()\n-            download_url = u"{}/@@images/{}.{}".format(\n-                obj_url, scale_url_uuid, GIF_SCALE_FORMAT\n+\n+            # Original image is still a "scale"\n+            # scaled images are converted to PNG in Plone = 5.1\n+            original_download_url = u"{}/@@images/{}.{}".format(\n+                obj_url, scale_url_uuid, "png"\n+            )\n+\n+            scale_download_url = u"{}/@@images/{}.{}".format(\n+                obj_url, scale_url_uuid, "jpeg"\n             )\n             scales = {\n-                u"listing": {u"download": download_url, u"width": 16, u"height": 12},\n-                u"icon": {u"download": download_url, u"width": 32, u"height": 24},\n-                u"tile": {u"download": download_url, u"width": 64, u"height": 48},\n-                u"thumb": {u"download": download_url, u"width": 128, u"height": 96},\n-                u"mini": {u"download": download_url, u"width": 200, u"height": 150},\n-                u"preview": {u"download": download_url, u"width": 400, u"height": 300},\n-                u"large": {u"download": download_url, u"width": 768, u"height": 576},\n+                u"listing": {\n+                    u"download": scale_download_url,\n+                    u"width": 16,\n+                    u"height": 12,\n+                },\n+                u"icon": {u"download": scale_download_url, u"width": 32, u"height": 24},\n+                u"tile": {u"download": scale_download_url, u"width": 64, u"height": 48},\n+                u"thumb": {\n+                    u"download": scale_download_url,\n+                    u"width": 128,\n+                    u"height": 96,\n+                },\n+                u"mini": {\n+                    u"download": scale_download_url,\n+                    u"width": 200,\n+                    u"height": 150,\n+                },\n+                u"preview": {\n+                    u"download": scale_download_url,\n+                    u"width": 400,\n+                    u"height": 300,\n+                },\n+                u"large": {\n+                    u"download": scale_download_url,\n+                    u"width": 768,\n+                    u"height": 576,\n+                },\n             }\n             self.assertEqual(\n                 {\n                     u"filename": u"1024x768.gif",\n                     u"content-type": u"image/gif",\n                     u"size": 1514,\n-                    u"download": download_url,\n+                    u"download": original_download_url,\n                     u"width": 1024,\n                     u"height": 768,\n                     u"scales": scales,\n@@ -365,63 +735,260 @@ def test_namedblobimage_field_serialization_returns_dict(self):\n                 value,\n             )\n \n-    def test_relationchoice_field_serialization_returns_summary_dict(self):\n-        doc2 = self.portal[\n-            self.portal.invokeFactory(\n-                "DXTestDocument",\n-                id="doc2",\n-                title="Referenceable Document",\n-                description="Description 2",\n+    def test_namedblobimage_field_serialization_doesnt_choke_on_corrupt_image(self):\n+        """ Original image url will be None because the original image is corrupted\n+            and the created url should be an image scale """\n+        image_data = b"INVALID IMAGE DATA"\n+        fn = "test_namedblobimage_field"\n+        with patch.object(storage, "uuid4", return_value="uuid_1"):\n+            value = self.serialize(\n+                fn,\n+                NamedBlobImage(\n+                    data=image_data, contentType=u"image/gif", filename=u"1024x768.gif"\n+                ),\n             )\n-        ]\n-        value = self.serialize("test_relationchoice_field", doc2)\n+\n         self.assertEqual(\n             {\n-                "@id": "http://nohost/plone/doc2",\n-                "@type": "DXTestDocument",\n-                "title": "Referenceable Document",\n-                "description": "Description 2",\n-                "review_state": "private",\n+                u"content-type": u"image/gif",\n+                u"download": None,\n+                u"filename": u"1024x768.gif",\n+                u"height": -1,\n+                u"scales": {},\n+                u"size": 18,\n+                u"width": -1,\n             },\n             value,\n         )\n \n-    def test_relationlist_field_serialization_returns_list(self):\n-        doc2 = self.portal[\n+\n+@unittest.skipUnless(\n+    PLONE_VERSION.base_version >= "5.2",\n+    "Plone 5.2: original image url is the original image",\n+)\n+class TestDexterityImageFieldSerializingOriginalAndPNGScales(TestCase):\n+    layer = PLONE_RESTAPI_DX_INTEGRATION_TESTING\n+    maxDiff = None\n+\n+    def setUp(self):\n+        self.portal = self.layer["portal"]\n+        self.request = self.layer["request"]\n+\n+        self.doc1 = self.portal[\n             self.portal.invokeFactory(\n-                "DXTestDocument",\n-                id="doc2",\n-                title="Referenceable Document",\n-                description="Description 2",\n+                "DXTestDocument", id="doc1", title="Test Document"\n             )\n         ]\n-        doc3 = self.portal[\n-            self.portal.invokeFactory(\n-                "DXTestDocument",\n-                id="doc3",\n-                title="Referenceable Document",\n-                description="Description 3",\n+\n+    def serialize(self, fieldname, value):\n+        for schema in iterSchemata(self.doc1):\n+            if fieldname in schema:\n+                field = schema.get(fieldname)\n+                break\n+        dm = getMultiAdapter((self.doc1, field), IDataManager)\n+        dm.set(value)\n+        serializer = getMultiAdapter((field, self.doc1, self.request), IFieldSerializer)\n+        return serializer()\n+\n+    def test_namedimage_field_serialization_returns_dict_with_original_scale(self):\n+        """In Plone >= 5.2 the image returned when requesting an image\n+           scale with the same width and height of the original image is\n+           the actual original image in its original format """\n+        image_file = os.path.join(os.path.dirname(__file__), u"1024x768.gif")\n+        with open(image_file, "rb") as f:\n+            image_data = f.read()\n+        fn = "test_namedimage_field"\n+        with patch.object(storage, "uuid4", return_value="uuid_1"):\n+            value = self.serialize(\n+                fn,\n+                NamedImage(\n+                    data=image_data, contentType=u"image/gif", filename=u"1024x768.gif"\n+                ),\n             )\n-        ]\n-        value = self.serialize("test_relationlist_field", [doc2, doc3])\n-        self.assertTrue(isinstance(value, list), "Not a <list>")\n-        self.assertEqual(\n-            [\n+            self.assertTrue(isinstance(value, dict), "Not a <dict>")\n+\n+            scale_url_uuid = "uuid_1"\n+            obj_url = self.doc1.absolute_url()\n+\n+            # Original image is still a "scale"\n+            # scaled images are converted to PNG in Plone = 5.2\n+            original_download_url = u"{}/@@images/{}.{}".format(\n+                obj_url, scale_url_uuid, "gif"\n+            )\n+\n+            scale_download_url = u"{}/@@images/{}.{}".format(\n+                obj_url, scale_url_uuid, "png"\n+            )\n+            scales = {\n+                u"listing": {\n+                    u"download": scale_download_url,\n+                    u"width": 16,\n+                    u"height": 12,\n+                },\n+                u"icon": {u"download": scale_download_url, u"width": 32, u"height": 24},\n+                u"tile": {u"download": scale_download_url, u"width": 64, u"height": 48},\n+                u"thumb": {\n+                    u"download": scale_download_url,\n+                    u"width": 128,\n+                    u"height": 96,\n+                },\n+                u"mini": {\n+                    u"download": scale_download_url,\n+                    u"width": 200,\n+                    u"height": 150,\n+                },\n+                u"preview": {\n+                    u"download": scale_download_url,\n+                    u"width": 400,\n+                    u"height": 300,\n+                },\n+                u"large": {\n+                    u"download": scale_download_url,\n+                    u"width": 768,\n+                    u"height": 576,\n+                },\n+            }\n+            self.assertEqual(\n                 {\n-                    "@id": "http://nohost/plone/doc2",\n-                    "@type": "DXTestDocument",\n-                    "title": "Referenceable Document",\n-                    "description": "Description 2",\n-                    "review_state": "private",\n+                    u"filename": u"1024x768.gif",\n+                    u"content-type": u"image/gif",\n+                    u"size": 1514,\n+                    u"download": original_download_url,\n+                    u"width": 1024,\n+                    u"height": 768,\n+                    u"scales": scales,\n+                },\n+                value,\n+            )\n+\n+    def test_namedimage_field_serialization_doesnt_choke_on_corrupt_image(self):\n+        """ In Plone >= 5.2 the original image file is not a "scale", so its url\n+            is returned as is and we need to check it, but the scales should be empty"""\n+        image_data = b"INVALID IMAGE DATA"\n+        fn = "test_namedimage_field"\n+        with patch.object(storage, "uuid4", return_value="uuid_1"):\n+            value = self.serialize(\n+                fn,\n+                NamedImage(\n+                    data=image_data, contentType=u"image/gif", filename=u"1024x768.gif"\n+                ),\n+            )\n+\n+        obj_url = self.doc1.absolute_url()\n+        scale_url_uuid = "uuid_1"\n+        self.assertEqual(\n+            {\n+                u"content-type": u"image/gif",\n+                u"download": u"{}/@@images/{}.{}".format(\n+                    obj_url, scale_url_uuid, "gif"\n+                ),\n+                u"filename": u"1024x768.gif",\n+                u"height": -1,\n+                u"scales": {},\n+                u"size": 18,\n+                u"width": -1,\n+            },\n+            value,\n+        )\n+\n+    def test_namedblobimage_field_serialization_returns_dict_with_original_scale(self):\n+        """In Plone >= 5.2 the image returned when requesting an image\n+           scale with the same width and height of the original image is\n+           the actual original image in its original format"""\n+        image_file = os.path.join(os.path.dirname(__file__), u"1024x768.gif")\n+        with open(image_file, "rb") as f:\n+            image_data = f.read()\n+        fn = "test_namedblobimage_field"\n+        with patch.object(storage, "uuid4", return_value="uuid_1"):\n+            value = self.serialize(\n+                fn,\n+                NamedBlobImage(\n+                    data=image_data, contentType=u"image/gif", filename=u"1024x768.gif"\n+                ),\n+            )\n+            self.assertTrue(isinstance(value, dict), "Not a <dict>")\n+\n+            scale_url_uuid = "uuid_1"\n+            obj_url = self.doc1.absolute_url()\n+\n+            # Original image is still a "scale"\n+            # scaled images are converted to PNG in Plone = 5.2\n+            original_download_url = u"{}/@@images/{}.{}".format(\n+                obj_url, scale_url_uuid, "gif"\n+            )\n+\n+            scale_download_url = u"{}/@@images/{}.{}".format(\n+                obj_url, scale_url_uuid, "png"\n+            )\n+            scales = {\n+                u"listing": {\n+                    u"download": scale_download_url,\n+                    u"width": 16,\n+                    u"height": 12,\n+                },\n+                u"icon": {u"download": scale_download_url, u"width": 32, u"height": 24},\n+                u"tile": {u"download": scale_download_url, u"width": 64, u"height": 48},\n+                u"thumb": {\n+                    u"download": scale_download_url,\n+                    u"width": 128,\n+                    u"height": 96,\n                 },\n+                u"mini": {\n+                    u"download": scale_download_url,\n+                    u"width": 200,\n+                    u"height": 150,\n+                },\n+                u"preview": {\n+                    u"download": scale_download_url,\n+                    u"width": 400,\n+                    u"height": 300,\n+                },\n+                u"large": {\n+                    u"download": scale_download_url,\n+                    u"width": 768,\n+                    u"height": 576,\n+                },\n+            }\n+            self.assertEqual(\n                 {\n-                    "@id": "http://nohost/plone/doc3",\n-                    "@type": "DXTestDocument",\n-                    "title": "Referenceable Document",\n-                    "description": "Description 3",\n-                    "review_state": "private",\n+                    u"filename": u"1024x768.gif",\n+                    u"content-type": u"image/gif",\n+                    u"size": 1514,\n+                    u"download": original_download_url,\n+                    u"width": 1024,\n+                    u"height": 768,\n+                    u"scales": scales,\n                 },\n-            ],\n+                value,\n+            )\n+\n+    def test_namedblobimage_field_serialization_doesnt_choke_on_corrupt_image(self):\n+        """ In Plone >= 5.2 the original image file is not a "scale", so its url\n+            is returned as is and we need to check it, but the scales should be empty"""\n+        image_data = b"INVALID IMAGE DATA"\n+        fn = "test_namedblobimage_field"\n+        with patch.object(storage, "uuid4", return_value="uuid_1"):\n+            value = self.serialize(\n+                fn,\n+                NamedBlobImage(\n+                    data=image_data, contentType=u"image/gif", filename=u"1024x768.gif"\n+                ),\n+            )\n+\n+        obj_url = self.doc1.absolute_url()\n+        scale_url_uuid = "uuid_1"\n+        self.assertEqual(\n+            {\n+                u"content-type": u"image/gif",\n+                u"download": u"{}/@@images/{}.{}".format(\n+                    obj_url, scale_url_uuid, "gif"\n+                ),\n+                u"filename": u"1024x768.gif",\n+                u"height": -1,\n+                u"scales": {},\n+                u"size": 18,\n+                u"width": -1,\n+            },\n             value,\n         )\n \n'

