Repository: Products.CMFPlone


Branch: refs/heads/5.2.x
Date: 2021-06-29T23:55:10+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/Products.CMFPlone/commit/43ee5bb85cc602a579069b78349c0088b1667dd8

Add the expressions patch from Products.PloneHotfix20210518.

See https://plone.org/security/hotfix/20210518/remote-code-execution-via-traversal-in-expressions
and https://plone.org/security/hotfix/20210518/copy_of_remote-code-execution-via-traversal-in-expressions-2

We need this because Zope 4.6.2 is too strict for us.

Files changed:
A Products/CMFPlone/earlypatches/expressions.py
A Products/CMFPlone/tests/accesscontrol_direct.pt
A Products/CMFPlone/tests/accesscontrol_sm.pt
A Products/CMFPlone/tests/accesscontrol_sm2.pt
A Products/CMFPlone/tests/accesscontrol_via_dict.pt
A Products/CMFPlone/tests/accesscontrol_via_modules.pt
A Products/CMFPlone/tests/bad1.pt
A Products/CMFPlone/tests/bad2.pt
A Products/CMFPlone/tests/bad3.pt
A Products/CMFPlone/tests/configure.zcml
A Products/CMFPlone/tests/options_authenticator.pt
A Products/CMFPlone/tests/options_name.pt
A Products/CMFPlone/tests/options_underscore.pt
A Products/CMFPlone/tests/options_view_name.pt
A Products/CMFPlone/tests/test_expressions.py
A Products/CMFPlone/tests/view_name.pt
A news/3274.bugfix.1
A news/3274.bugfix.2
M Products/CMFPlone/earlypatches/__init__.py
M Products/CMFPlone/testing.py
D news/3274.bugfix

b'diff --git a/Products/CMFPlone/earlypatches/__init__.py b/Products/CMFPlone/earlypatches/__init__.py\nindex c25923d78d..8010715709 100644\n--- a/Products/CMFPlone/earlypatches/__init__.py\n+++ b/Products/CMFPlone/earlypatches/__init__.py\n@@ -1,2 +1,3 @@\n # misc security fixes\n from Products.CMFPlone.earlypatches import security  # noqa\n+from Products.CMFPlone.earlypatches import expressions  # noqa\ndiff --git a/Products/CMFPlone/earlypatches/expressions.py b/Products/CMFPlone/earlypatches/expressions.py\nnew file mode 100644\nindex 0000000000..59eb58d1ad\n--- /dev/null\n+++ b/Products/CMFPlone/earlypatches/expressions.py\n@@ -0,0 +1,214 @@\n+from AccessControl.SecurityManagement import getSecurityManager\n+from AccessControl.ZopeGuards import guarded_getattr\n+from AccessControl.ZopeGuards import guarded_import\n+from OFS.interfaces import ITraversable\n+from Products.PageTemplates import Expressions\n+from zExceptions import NotFound\n+from zExceptions import Unauthorized\n+from zope.traversing.adapters import traversePathElement\n+\n+import os\n+import string\n+import sys\n+import types\n+import warnings\n+\n+\n+# In the \'bobo aware\' Zope traverse methods and functions, various security checks are done.\n+# For example for content items, permission checks are done.\n+# But for non-content, for example a Python module or a dictionary, the checks were originally very lax.\n+# This could be abused.  Now we know that, we want to be as strict as possible.\n+#\n+# But being stricter breaks existing code which worked fine so far,\n+# not knowing that it tried to access code which should have been disallowed.\n+# One thing that goes wrong, is that any skin template that calls context/main_template/macros/master fails,\n+# for example when viewing a revision from CMFEditions.\n+#\n+# So with this hotfix, by necessity we are still lax/forgiving, but you can change this behavior\n+# with an environment variable: STRICT_TRAVERSE_CHECK.\n+# - STRICT_TRAVERSE_CHECK=0 mostly uses the original lax/sloppy checks.\n+#   This sadly needs to be the default.\n+# - STRICT_TRAVERSE_CHECK=1 uses the strict logic.\n+#   When you know what you are doing, you can try this.\n+# - STRICT_TRAVERSE_CHECK=2 first tries the strict logic.\n+#   If this fails, log a warning and then fallback to the original lax checks.\n+#   The idea would be to use this in development or production for a while, to see which code needs a fix.\n+try:\n+    STRICT_TRAVERSE_CHECK = int(os.getenv("STRICT_TRAVERSE_CHECK", 0))\n+except (ValueError, TypeError, AttributeError):\n+    STRICT_TRAVERSE_CHECK = 0\n+# Set of names that start with an underscore but that we want to allow anyway.\n+ALLOWED_UNDERSCORE_NAMES = set([\n+    # dunder name is used in plone.app.caching, and maybe other places\n+    "__name__",\n+    # Zope allows a single underscore to avoid a test failure\n+    "_",\n+    # Special case for plone.protect.\n+    # Fixes a NotFound error when submitting a PloneFormGen form:\n+    # https://github.com/smcmahon/Products.PloneFormGen/pull/229\n+    "_authenticator",\n+])\n+# Some objects we really do not trust, even when you have found a workaround to reach them.\n+DISALLOWED_OBJECTS = [\n+    os,\n+    sys,\n+    # string.Formatter sounds innocent, but can be abused.\n+    string.Formatter,\n+]\n+_orig_boboAwareZopeTraverse = Expressions.boboAwareZopeTraverse\n+\n+\n+def guarded_import_module(base, path_items):\n+    name = path_items[0]\n+    try:\n+        guarded_import(base.__name__, fromlist=path_items)\n+        # guarded_import will do most security checking\n+        # but will not return the imported item itself,\n+        # so we need to call getattr ourselves.\n+        # Actually, not all security checks are done, so we call guarded_getattr.\n+        for name in path_items:\n+            base = guarded_getattr(base, name)\n+    except Unauthorized:\n+        # special case for OFS/zpt/main.zpt which uses\n+        # modules/AccessControl/SecurityManagement/getSecurityManager\n+        # which should have been modules/AccessControl/getSecurityManager\n+        # Fixed in Zope 4.6.1 and 5.2.1.\n+        if name == "SecurityManagement" and path_items[-1] == "getSecurityManager":\n+            return getSecurityManager\n+        # Convert Unauthorized to prevent information disclosures\n+        raise NotFound(name)\n+    except TypeError:\n+        # During testing with security-policy-implementation python\n+        # and verbose-security on, I got this error when an Unauthorized was raised\n+        # for string.Formatter.get_field:\n+        # TypeError: descriptor \'__repr__\' of \'object\' object needs an argument\n+        # This was in the item_repr function of AccessControl.ImplPython.\n+        raise NotFound(name)\n+    if base in DISALLOWED_OBJECTS:\n+        raise NotFound(name)\n+    return base\n+\n+\n+def shared_traverse(base, path_items, request, traverse_method="restrictedTraverse"):\n+    """Shared traverse method for bobo aware zope traverse function and class method.\n+\n+    They are almost exactly the same, and it is irritating and error prone\n+    to change similar code in two places.\n+    """\n+    validate = getSecurityManager().validate\n+    path_items = list(path_items)\n+    path_items.reverse()\n+\n+    while path_items:\n+        name = path_items.pop()\n+\n+        if ITraversable.providedBy(base):\n+            base = getattr(base, traverse_method)(name)\n+        elif isinstance(base, types.ModuleType):\n+            # We should be able to handle the name and all remaining path items at once.\n+            # Use the correct order again.\n+            path_items.append(name)\n+            path_items.reverse()\n+            return guarded_import_module(base, path_items)\n+        else:\n+            found = traversePathElement(base, name, path_items,\n+                                        request=request)\n+\n+            # If traverse_method is something other than\n+            # ``restrictedTraverse`` then traversal is assumed to be\n+            # unrestricted. This emulates ``unrestrictedTraverse``\n+            if traverse_method != \'restrictedTraverse\':\n+                base = found\n+                continue\n+\n+            # Special backwards compatibility exception for the name ``_``,\n+            # which was often used for translation message factories.\n+            # Allow and continue traversal.\n+            if name == \'_\':\n+                warnings.warn(\'Traversing to the name `_` is deprecated \'\n+                              \'and will be removed in Zope 6.\',\n+                              DeprecationWarning)\n+                base = found\n+                continue\n+\n+            if name.startswith(\'_\'):\n+                if name in ALLOWED_UNDERSCORE_NAMES:\n+                    base = found\n+                    continue\n+                # All other names starting with ``_`` are disallowed.\n+                # This emulates what restrictedTraverse does.\n+                raise NotFound(name)\n+\n+            if found in DISALLOWED_OBJECTS:\n+                raise NotFound(name)\n+\n+            if STRICT_TRAVERSE_CHECK:\n+                # traversePathElement doesn\'t apply any Zope security policy,\n+                # so we validate access explicitly here.\n+                try:\n+                    validate(base, base, name, found)\n+                except Unauthorized:\n+                    if STRICT_TRAVERSE_CHECK == 2:\n+                        # only warn\n+                        warnings.warn(\n+                            \'Traversing from {0} to {1} is only allowed because STRICT_TRAVERSE_CHECK=2. \'\n+                            \'Possible security problem.\'.format(object, name))\n+                    else:\n+                        # Convert Unauthorized to prevent information disclosures\n+                        raise NotFound(name)\n+\n+            base = found\n+\n+    return base\n+\n+\n+def boboAwareZopeTraverse(object, path_items, econtext):\n+    """Traverses a sequence of names, first trying attributes then items.\n+\n+    This uses zope.traversing path traversal where possible and interacts\n+    correctly with objects providing OFS.interface.ITraversable when\n+    necessary (bobo-awareness).\n+    """\n+    request = getattr(econtext, \'request\', None)\n+    result = shared_traverse(object, path_items, request)\n+    return result\n+\n+\n+Expressions.boboAwareZopeTraverse = boboAwareZopeTraverse\n+Expressions.ZopePathExpr._TRAVERSER = staticmethod(boboAwareZopeTraverse)\n+\n+# But wait, there is also a BoboAwareZopeTraverse class.\n+from Products.PageTemplates.expression import BoboAwareZopeTraverse\n+from Products.PageTemplates.expression import TrustedBoboAwareZopeTraverse\n+\n+# We do not want to change the trusted version.  It inherits the traverse method\n+# from the untrusted class.  It may be better to give it its own method.\n+# The @classmethod makes this tricky to get right.\n+# But the following line essentially makes a copy of the traverse method\n+# without needing inheritance anymore.\n+TrustedBoboAwareZopeTraverse.traverse = TrustedBoboAwareZopeTraverse.traverse\n+\n+BoboAwareZopeTraverse._orig_traverse = BoboAwareZopeTraverse.traverse\n+\n+def traverse(cls, base, request, path_items):\n+    """See ``zope.app.pagetemplate.engine``."""\n+    # When our patching is done correctly, this only gets called for the\n+    # BoboAwareZopeTraverse class, so cls.traverse_method is always restrictedTraverse.\n+    # But let\'s be careful and just pass the attribute on.\n+    result = shared_traverse(base, path_items, request, traverse_method=cls.traverse_method)\n+    return result\n+\n+BoboAwareZopeTraverse.traverse = classmethod(traverse)\n+\n+# The TrustedBoboAwareZopeTraverse and (untrusted) BoboAwareZopeTraverse class have a problem:\n+# They have a "traverse_method" attribute, but the "traverse" method\n+# calls "cls.traverseMethod" instead, so this fails.\n+# This may mean these classes do not get called anymore, except in test_expressions.py.\n+name1 = "traverse_method"\n+name2 = "traverseMethod"\n+# First do the trusted class, because it inherits from the untrusted class.\n+# Otherwise the trusted class would have traverse_method=unrestrictedTraverse\n+# and it would inherit traverseMethod=restrictedTraverse.\n+for klass in (TrustedBoboAwareZopeTraverse, BoboAwareZopeTraverse):\n+    if hasattr(klass, name1) and not hasattr(klass, name2):\n+        setattr(klass, name2, getattr(klass, name1))\ndiff --git a/Products/CMFPlone/testing.py b/Products/CMFPlone/testing.py\nindex b7f96ed80e..d624fcde81 100644\n--- a/Products/CMFPlone/testing.py\n+++ b/Products/CMFPlone/testing.py\n@@ -32,6 +32,11 @@ def setUpZope(self, app, configurationContext):\n             Products.CMFPlone,\n             context=configurationContext\n         )\n+        xmlconfig.file(\n+            \'configure.zcml\',\n+            Products.CMFPlone.tests,\n+            context=configurationContext\n+        )\n \n     def setUpPloneSite(self, portal):\n         portal.acl_users.userFolderAddUser(\ndiff --git a/Products/CMFPlone/tests/accesscontrol_direct.pt b/Products/CMFPlone/tests/accesscontrol_direct.pt\nnew file mode 100644\nindex 0000000000..0c981337b4\n--- /dev/null\n+++ b/Products/CMFPlone/tests/accesscontrol_direct.pt\n@@ -0,0 +1 @@\n+<span tal:condition="nocall:modules/AccessControl/SecurityManagement">hacked</span>\ndiff --git a/Products/CMFPlone/tests/accesscontrol_sm.pt b/Products/CMFPlone/tests/accesscontrol_sm.pt\nnew file mode 100644\nindex 0000000000..536add7541\n--- /dev/null\n+++ b/Products/CMFPlone/tests/accesscontrol_sm.pt\n@@ -0,0 +1 @@\n+<span tal:condition="nocall:modules/AccessControl/getSecurityManager">getSecurityManager is allowed</span>\ndiff --git a/Products/CMFPlone/tests/accesscontrol_sm2.pt b/Products/CMFPlone/tests/accesscontrol_sm2.pt\nnew file mode 100644\nindex 0000000000..6be7a66cdd\n--- /dev/null\n+++ b/Products/CMFPlone/tests/accesscontrol_sm2.pt\n@@ -0,0 +1 @@\n+<span tal:condition="nocall:modules/AccessControl/SecurityManagement/getSecurityManager">getSecurityManager is still allowed</span>\ndiff --git a/Products/CMFPlone/tests/accesscontrol_via_dict.pt b/Products/CMFPlone/tests/accesscontrol_via_dict.pt\nnew file mode 100644\nindex 0000000000..46785bc666\n--- /dev/null\n+++ b/Products/CMFPlone/tests/accesscontrol_via_dict.pt\n@@ -0,0 +1,3 @@\n+<span tal:define="acc nocall:modules/AccessControl;\n+                  piggyback python:{\'unsafe\': acc}"\n+      tal:condition="nocall:piggyback/unsafe/users">hacked</span>\ndiff --git a/Products/CMFPlone/tests/accesscontrol_via_modules.pt b/Products/CMFPlone/tests/accesscontrol_via_modules.pt\nnew file mode 100644\nindex 0000000000..adb03fc5e5\n--- /dev/null\n+++ b/Products/CMFPlone/tests/accesscontrol_via_modules.pt\n@@ -0,0 +1 @@\n+<span tal:define="acc nocall:modules/AccessControl" tal:condition="nocall:acc/users">hacked</span>\ndiff --git a/Products/CMFPlone/tests/bad1.pt b/Products/CMFPlone/tests/bad1.pt\nnew file mode 100644\nindex 0000000000..856c36432e\n--- /dev/null\n+++ b/Products/CMFPlone/tests/bad1.pt\n@@ -0,0 +1,2 @@\n+Hello <span tal:define="sys nocall:random/_os/system"\n+            tal:content="python: sys(\'ls ~\')" />.\ndiff --git a/Products/CMFPlone/tests/bad2.pt b/Products/CMFPlone/tests/bad2.pt\nnew file mode 100644\nindex 0000000000..0372162e07\n--- /dev/null\n+++ b/Products/CMFPlone/tests/bad2.pt\n@@ -0,0 +1,2 @@\n+Hello <span tal:define="string python:modules[\'string\']"\n+            tal:content="string/_re/purge" />.\ndiff --git a/Products/CMFPlone/tests/bad3.pt b/Products/CMFPlone/tests/bad3.pt\nnew file mode 100644\nindex 0000000000..077d00f3f5\n--- /dev/null\n+++ b/Products/CMFPlone/tests/bad3.pt\n@@ -0,0 +1,3 @@\n+Hello <span tal:define="string nocall:modules/string;\n+                        get_field nocall:string/Formatter/get_field;\n+                        poc python:get_field(path(\'string/Formatter\'), \'0._re.purge\', [string], None)" tal:content="poc" />\ndiff --git a/Products/CMFPlone/tests/configure.zcml b/Products/CMFPlone/tests/configure.zcml\nnew file mode 100644\nindex 0000000000..2d1cf3b401\n--- /dev/null\n+++ b/Products/CMFPlone/tests/configure.zcml\n@@ -0,0 +1,13 @@\n+<configure\n+    xmlns="http://namespaces.zope.org/zope"\n+    xmlns:browser="http://namespaces.zope.org/browser"\n+    i18n_domain="plone">\n+\n+    <browser:page\n+        name="hotfix-testing-view-name"\n+        for="*"\n+        template="view_name.pt"\n+        permission="zope2.View"\n+        />\n+\n+</configure>\ndiff --git a/Products/CMFPlone/tests/options_authenticator.pt b/Products/CMFPlone/tests/options_authenticator.pt\nnew file mode 100644\nindex 0000000000..97e29c4a65\n--- /dev/null\n+++ b/Products/CMFPlone/tests/options_authenticator.pt\n@@ -0,0 +1 @@\n+<h1 tal:content="options/view/_authenticator" />\ndiff --git a/Products/CMFPlone/tests/options_name.pt b/Products/CMFPlone/tests/options_name.pt\nnew file mode 100644\nindex 0000000000..592dc3e98d\n--- /dev/null\n+++ b/Products/CMFPlone/tests/options_name.pt\n@@ -0,0 +1 @@\n+<h1 tal:content="view/__name__" />\ndiff --git a/Products/CMFPlone/tests/options_underscore.pt b/Products/CMFPlone/tests/options_underscore.pt\nnew file mode 100644\nindex 0000000000..172a01b9b1\n--- /dev/null\n+++ b/Products/CMFPlone/tests/options_underscore.pt\n@@ -0,0 +1 @@\n+<h1 tal:content="options/view/_" />\ndiff --git a/Products/CMFPlone/tests/options_view_name.pt b/Products/CMFPlone/tests/options_view_name.pt\nnew file mode 100644\nindex 0000000000..3a433ca22e\n--- /dev/null\n+++ b/Products/CMFPlone/tests/options_view_name.pt\n@@ -0,0 +1 @@\n+<h1 tal:content="options/view/__name__" />\ndiff --git a/Products/CMFPlone/tests/test_expressions.py b/Products/CMFPlone/tests/test_expressions.py\nnew file mode 100644\nindex 0000000000..48a65ac793\n--- /dev/null\n+++ b/Products/CMFPlone/tests/test_expressions.py\n@@ -0,0 +1,329 @@\n+# -*- coding: utf-8 -*-\n+from AccessControl.class_init import InitializeClass\n+from AccessControl.Permissions import view_management_screens\n+from AccessControl.SecurityInfo import ClassSecurityInfo\n+from OFS.SimpleItem import SimpleItem\n+from plone.testing.zope import Browser\n+from Products.CMFPlone.testing import PRODUCTS_CMFPLONE_FUNCTIONAL_TESTING\n+# Expressions.boboAwareZopeTraverse is a function\n+# expression(s).BoboAwareZopeTraverse is a class\n+# Import them with names that are easier to tell apart.\n+from Products.PageTemplates.expression import BoboAwareZopeTraverse as TraverseClass\n+from Products.PageTemplates.expression import TrustedBoboAwareZopeTraverse as TrustedTraverseClass\n+from Products.PageTemplates.Expressions import boboAwareZopeTraverse as traverse_function\n+from Products.PageTemplates.Expressions import trustedBoboAwareZopeTraverse as trusted_traverse_function\n+from Products.PageTemplates.PageTemplateFile import PageTemplateFile\n+from zExceptions import NotFound\n+from zExceptions import Unauthorized\n+\n+import AccessControl\n+import os\n+import random\n+import re\n+import string\n+import sys\n+import unittest\n+\n+\n+try:\n+    # Python 3.7+\n+    from random import _os\n+except ImportError:\n+    # Python 3.6- is not vulnerable.\n+    _os = None\n+\n+\n+# Path of this directory:\n+path = os.path.dirname(__file__)\n+\n+\n+class DummyView(object):\n+\n+    __name__ = "dummy-view"\n+    _authenticator = "secret"\n+    _ = "translation"\n+    # Even via weird names, some items should not be reachable:\n+    os_hack = os\n+    sys_hack = sys\n+    Formatter_hack = string.Formatter\n+\n+\n+class DummyContent(SimpleItem):\n+    """Dummy content class to show the (un)restrictedTraverse works."""\n+    security = ClassSecurityInfo()\n+\n+    @security.public\n+    def public(self):\n+        """Public method"""\n+        return "I am public"\n+\n+    @security.private\n+    def private(self):\n+        """Private method"""\n+        return "I am private"\n+\n+    @security.protected(view_management_screens)\n+    def protected(self):\n+        """Protected method"""\n+        return "I am protected"\n+\n+\n+InitializeClass(DummyContent)\n+\n+\n+class TestAttackVector(unittest.TestCase):\n+    layer = PRODUCTS_CMFPLONE_FUNCTIONAL_TESTING\n+\n+    def _makeOne(self, name):\n+        return PageTemplateFile(os.path.join(path, name)).__of__(self.layer["portal"])\n+\n+    @unittest.skipIf(_os is None, "This Python version has no random._os.")\n+    def test_template_bad1(self):\n+        template = self._makeOne("bad1.pt")\n+        # In some versions, random is not globally available, so we get a NameError.\n+        # Otherwise our patch should make sure we get a NotFound.\n+        with self.assertRaises((NotFound, NameError)):\n+            template()\n+\n+    def test_template_bad2(self):\n+        template = self._makeOne("bad2.pt")\n+        with self.assertRaises(NotFound):\n+            template()\n+\n+    def test_template_bad3(self):\n+        template = self._makeOne("bad3.pt")\n+        with self.assertRaises(NotFound):\n+            template()\n+\n+    def test_template_name(self):\n+        # Allow accessing __name__ in a skin template or TTW template.\n+        template = self._makeOne("options_view_name.pt")\n+        # Pass view in the options.\n+        self.assertIn("dummy-view", template(view=DummyView()))\n+\n+    def test_template_authenticator(self):\n+        # Allow accessing _authenticator in a skin template or TTW template.\n+        template = self._makeOne("options_authenticator.pt")\n+        # Pass view in the options.\n+        self.assertIn("secret", template(view=DummyView()))\n+\n+    def test_template_single_underscore(self):\n+        # Allow accessing \'_\' in a skin template or TTW template.\n+        # In the merge of the hotfix, Zope allows this, to avoid a test failure.\n+        template = self._makeOne("options_underscore.pt")\n+        # Pass view in the options.\n+        self.assertIn("translation", template(view=DummyView()))\n+\n+    def test_browser_template_with_name(self):\n+        # Allow accessing __name__ in a browser view template.\n+        browser = Browser(self.layer["app"])\n+        browser.handleErrors = False\n+        browser.open(self.layer["portal"].absolute_url() + "/hotfix-testing-view-name")\n+        self.assertIn("<h1>hotfix-testing-view-name</h1>", browser.contents)\n+\n+    def test_template_accesscontrol_sm(self):\n+        # Only AccessControl.getSecurityManager is allowed.\n+        template = self._makeOne("accesscontrol_sm.pt")\n+        self.assertIn("getSecurityManager is allowed", template())\n+\n+    def test_template_accesscontrol_sm2(self):\n+        # Zope main.zpt uses modules/AccessControl/SecurityManagement/getSecurityManager\n+        # which should have been modules/AccessControl/getSecurityManager.\n+        # So we need a special case for it, otherwise the ZMI is totally inaccessible.\n+        template = self._makeOne("accesscontrol_sm2.pt")\n+        self.assertIn("getSecurityManager is still allowed", template())\n+\n+    def test_template_accesscontrol_direct(self):\n+        # Via AccessControl you can access too much.\n+        template = self._makeOne("accesscontrol_direct.pt")\n+        with self.assertRaises(NotFound):\n+            template()\n+\n+    def test_template_accesscontrol_via_modules(self):\n+        template = self._makeOne("accesscontrol_via_modules.pt")\n+        with self.assertRaises(NotFound):\n+            template()\n+\n+    def test_template_accesscontrol_via_dict(self):\n+        template = self._makeOne("accesscontrol_via_dict.pt")\n+        with self.assertRaises(NotFound):\n+            template()\n+\n+\n+class TestDirectAttackVector(unittest.TestCase):\n+    layer = PRODUCTS_CMFPLONE_FUNCTIONAL_TESTING\n+\n+    @unittest.skipIf(_os is None, "This Python version has no random._os.")\n+    def test_traverse_function_random(self):\n+        with self.assertRaises(NotFound):\n+            traverse_function(random, ("_os", "system"), None)\n+        # trusted traverse should work fine\n+        result = trusted_traverse_function(random, ("_os", "system"), None)\n+        self.assertEqual(result, os.system)\n+\n+    def test_traverse_function_string(self):\n+        with self.assertRaises(NotFound):\n+            traverse_function(string, ("_re", "purge"), None)\n+        result = trusted_traverse_function(string, ("_re", "purge"), None)\n+        self.assertEqual(result, re.purge)\n+\n+    def test_traverse_function_formatter(self):\n+        with self.assertRaises(NotFound):\n+            traverse_function(string, ("Formatter",), None)\n+        result = trusted_traverse_function(string, ("Formatter",), None)\n+        self.assertEqual(result, string.Formatter)\n+\n+    def test_traverse_function_formatter_get_field(self):\n+        with self.assertRaises(NotFound):\n+            traverse_function(string, ("Formatter", "get_field"), None)\n+        result = trusted_traverse_function(string, ("Formatter", "get_field"), None)\n+        self.assertEqual(result, string.Formatter.get_field)\n+\n+    def test_traverse_function_hacked_names(self):\n+        view = DummyView()\n+        with self.assertRaises(NotFound):\n+            traverse_function(view, ("os_hack",), None)\n+        with self.assertRaises(NotFound):\n+            traverse_function(view, ("sys_hack",), None)\n+        with self.assertRaises(NotFound):\n+            traverse_function(view, ("Formatter_hack",), None)\n+        result = trusted_traverse_function(view, ("os_hack",), None)\n+        self.assertEqual(result, os)\n+        result = trusted_traverse_function(view, ("sys_hack",), None)\n+        self.assertEqual(result, sys)\n+        result = trusted_traverse_function(view, ("Formatter_hack",), None)\n+        self.assertEqual(result, string.Formatter)\n+\n+    def test_traverse_function_name(self):\n+        # We allow access to __name__ always as a special case.\n+        view = DummyView()\n+        self.assertEqual(traverse_function(view, ("__name__",), None), "dummy-view")\n+        self.assertEqual(trusted_traverse_function(view, ("__name__",), None), "dummy-view")\n+\n+    def test_traverse_function_authenticator(self):\n+        # We allow access to _authenticator always as a special case.\n+        view = DummyView()\n+        self.assertEqual(traverse_function(view, ("_authenticator",), None), "secret")\n+        self.assertEqual(trusted_traverse_function(view, ("_authenticator",), None), "secret")\n+\n+    def test_traverse_function_single_underscore(self):\n+        # We allow access to \'_\' always as a special case.\n+        view = DummyView()\n+        self.assertEqual(traverse_function(view, ("_",), None), "translation")\n+        self.assertEqual(trusted_traverse_function(view, ("_",), None), "translation")\n+\n+    def test_traverse_function_content(self):\n+        content = DummyContent("dummy")\n+        self.assertEqual(traverse_function(content, ("public",), None)(), "I am public")\n+        with self.assertRaises(Unauthorized):\n+            traverse_function(content, ("private",), None)\n+        with self.assertRaises(Unauthorized):\n+            traverse_function(content, ("protected",), None)\n+\n+        self.assertEqual(trusted_traverse_function(content, ("public",), None)(), "I am public")\n+        self.assertEqual(trusted_traverse_function(content, ("private",), None)(), "I am private")\n+        self.assertEqual(trusted_traverse_function(content, ("protected",), None)(), "I am protected")\n+\n+    def test_traverse_function_accesscontrol_getSecurityManager(self):\n+        # Only getSecurityManager is allowed.\n+        self.assertEqual(traverse_function(AccessControl, ("getSecurityManager",), None), AccessControl.getSecurityManager)\n+        self.assertEqual(trusted_traverse_function(AccessControl, ("getSecurityManager",), None), AccessControl.getSecurityManager)\n+\n+    def test_traverse_function_accesscontrol_getSecurityManager2(self):\n+        # Zope main.zpt uses modules/AccessControl/SecurityManagement/getSecurityManager\n+        # which should have been modules/AccessControl/getSecurityManager.\n+        # So we need a special case for it, otherwise the ZMI is totally inaccessible.\n+        self.assertEqual(traverse_function(AccessControl, ("SecurityManagement", "getSecurityManager"), None), AccessControl.getSecurityManager)\n+        self.assertEqual(trusted_traverse_function(AccessControl, ("SecurityManagement", "getSecurityManager",), None), AccessControl.getSecurityManager)\n+\n+    def test_traverse_function_accesscontrol_direct(self):\n+        with self.assertRaises(NotFound):\n+            traverse_function(AccessControl, ("SecurityManagement",), None)\n+        self.assertEqual(trusted_traverse_function(AccessControl, ("SecurityManagement",), None), AccessControl.SecurityManagement)\n+\n+    def test_traverse_function_accesscontrol_via_modules(self):\n+        from Products.PageTemplates.ZRPythonExpr import _SecureModuleImporter\n+\n+        modules = _SecureModuleImporter()\n+        with self.assertRaises(NotFound):\n+            traverse_function(modules, ("AccessControl", "users"), None)\n+        self.assertEqual(trusted_traverse_function(modules, ("AccessControl", "users"), None), AccessControl.users)\n+\n+    def test_traverse_function_accesscontrol_via_dict(self):\n+        piggyback = {"unsafe": AccessControl}\n+        with self.assertRaises(NotFound):\n+            traverse_function(piggyback, ("unsafe", "users"), None)\n+        self.assertEqual(trusted_traverse_function(piggyback, ("unsafe", "users"), None), AccessControl.users)\n+\n+    @unittest.skipIf(_os is None or TraverseClass is None, "This Python version has no random._os or there is no BoboAwareZopeTraverse class.")\n+    def test_traverse_class_random(self):\n+        with self.assertRaises(NotFound):\n+            # Note: here the second argument is the request.  None works in the tests.\n+            TraverseClass.traverse(random, None, ("_os", "system"))\n+        # trusted traverse should work fine\n+        result = TrustedTraverseClass.traverse(random, None, ("_os", "system"))\n+        self.assertEqual(result, os.system)\n+\n+    def test_traverse_class_string(self):\n+        with self.assertRaises(NotFound):\n+            TraverseClass.traverse(string, None, ("_re", "purge"))\n+        result = TrustedTraverseClass.traverse(string, None, ("_re", "purge"))\n+        self.assertEqual(result, re.purge)\n+\n+    def test_traverse_class_formatter(self):\n+        with self.assertRaises(NotFound):\n+            TraverseClass.traverse(string, None, ("Formatter",))\n+        result = TrustedTraverseClass.traverse(string, None, ("Formatter",))\n+        self.assertEqual(result, string.Formatter)\n+\n+    def test_traverse_class_formatter_get_field(self):\n+        with self.assertRaises(NotFound):\n+            TraverseClass.traverse(string, None, ("Formatter", "get_field"))\n+        result = TrustedTraverseClass.traverse(string, None, ("Formatter", "get_field"))\n+        self.assertEqual(result, string.Formatter.get_field)\n+\n+    def test_traverse_class_name(self):\n+        # We allow access to __name__ always as a special case.\n+        view = DummyView()\n+        self.assertEqual(TraverseClass.traverse(view, None, ("__name__",)), "dummy-view")\n+        self.assertEqual(TrustedTraverseClass.traverse(view, None, ("__name__",)), "dummy-view")\n+\n+    def test_traverse_class_content(self):\n+        content = DummyContent("dummy")\n+        self.assertEqual(TraverseClass.traverse(content, None, ("public",))(), "I am public")\n+        with self.assertRaises(Unauthorized):\n+            TraverseClass.traverse(content, None, ("private",))\n+        with self.assertRaises(Unauthorized):\n+            TraverseClass.traverse(content, None, ("protected",))\n+\n+        self.assertEqual(TrustedTraverseClass.traverse(content, None, ("public",))(), "I am public")\n+        self.assertEqual(TrustedTraverseClass.traverse(content, None, ("private",))(), "I am private")\n+        self.assertEqual(TrustedTraverseClass.traverse(content, None, ("protected",))(), "I am protected")\n+\n+    def test_traverse_class_accesscontrol_getSecurityManager(self):\n+        # AccessControl.getSecurityManager is the only item allowed.\n+        self.assertEqual(TraverseClass.traverse(AccessControl, None, ("getSecurityManager",)), AccessControl.getSecurityManager)\n+        self.assertEqual(TrustedTraverseClass.traverse(AccessControl, None, ("getSecurityManager",)), AccessControl.getSecurityManager)\n+\n+    def test_traverse_class_accesscontrol_getSecurityManager2(self):\n+        self.assertEqual(TraverseClass.traverse(AccessControl, None, ("SecurityManagement", "getSecurityManager",)), AccessControl.getSecurityManager)\n+        self.assertEqual(TrustedTraverseClass.traverse(AccessControl, None, ("SecurityManagement", "getSecurityManager",)), AccessControl.getSecurityManager)\n+\n+    def test_traverse_class_accesscontrol_direct(self):\n+        with self.assertRaises(NotFound):\n+            TraverseClass.traverse(AccessControl, None, ("SecurityManagement",))\n+        self.assertEqual(TrustedTraverseClass.traverse(AccessControl, None, ("SecurityManagement",)), AccessControl.SecurityManagement)\n+\n+    def test_traverse_class_accesscontrol_via_modules(self):\n+        from Products.PageTemplates.ZRPythonExpr import _SecureModuleImporter\n+\n+        modules = _SecureModuleImporter()\n+        with self.assertRaises(NotFound):\n+            TraverseClass.traverse(modules, None, ("AccessControl", "users"))\n+        self.assertEqual(TrustedTraverseClass.traverse(modules, None, ("AccessControl", "users")), AccessControl.users)\n+\n+    def test_traverse_class_accesscontrol_via_dict(self):\n+        piggyback = {"unsafe": AccessControl}\n+        with self.assertRaises(NotFound):\n+            TraverseClass.traverse(piggyback, None, ("unsafe", "users"))\n+        self.assertEqual(TrustedTraverseClass.traverse(piggyback, None, ("unsafe", "users")), AccessControl.users)\ndiff --git a/Products/CMFPlone/tests/view_name.pt b/Products/CMFPlone/tests/view_name.pt\nnew file mode 100644\nindex 0000000000..592dc3e98d\n--- /dev/null\n+++ b/Products/CMFPlone/tests/view_name.pt\n@@ -0,0 +1 @@\n+<h1 tal:content="view/__name__" />\ndiff --git a/news/3274.bugfix b/news/3274.bugfix.1\nsimilarity index 100%\nrename from news/3274.bugfix\nrename to news/3274.bugfix.1\ndiff --git a/news/3274.bugfix.2 b/news/3274.bugfix.2\nnew file mode 100644\nindex 0000000000..eaefaa3547\n--- /dev/null\n+++ b/news/3274.bugfix.2\n@@ -0,0 +1,3 @@\n+Add the expressions patch from `Products.PloneHotfix20210518 <https://plone.org/security/hotfix/20210518/remote-code-execution-via-traversal-in-expressions>`_.\n+We need this because Zope 4.6.2 is too strict for us.\n+[maurits]\n'

Repository: Products.CMFPlone


Branch: refs/heads/5.2.x
Date: 2021-06-30T20:26:27+02:00
Author: Maurits van Rees (mauritsvanrees) <m.van.rees@zestsoftware.nl>
Commit: https://github.com/plone/Products.CMFPlone/commit/12e6004245aa577916c95cb14b00fcf886d81ccc

Merge pull request #3284 from plone/hotfix-20210518-expressions-52

Add the expressions patch from Products.PloneHotfix20210518. [5.2]

Files changed:
A Products/CMFPlone/earlypatches/expressions.py
A Products/CMFPlone/tests/accesscontrol_direct.pt
A Products/CMFPlone/tests/accesscontrol_sm.pt
A Products/CMFPlone/tests/accesscontrol_sm2.pt
A Products/CMFPlone/tests/accesscontrol_via_dict.pt
A Products/CMFPlone/tests/accesscontrol_via_modules.pt
A Products/CMFPlone/tests/bad1.pt
A Products/CMFPlone/tests/bad2.pt
A Products/CMFPlone/tests/bad3.pt
A Products/CMFPlone/tests/configure.zcml
A Products/CMFPlone/tests/options_authenticator.pt
A Products/CMFPlone/tests/options_name.pt
A Products/CMFPlone/tests/options_underscore.pt
A Products/CMFPlone/tests/options_view_name.pt
A Products/CMFPlone/tests/test_expressions.py
A Products/CMFPlone/tests/view_name.pt
A news/3274.bugfix.1
A news/3274.bugfix.2
M Products/CMFPlone/earlypatches/__init__.py
M Products/CMFPlone/testing.py
D news/3274.bugfix

b'diff --git a/Products/CMFPlone/earlypatches/__init__.py b/Products/CMFPlone/earlypatches/__init__.py\nindex c25923d78d..8010715709 100644\n--- a/Products/CMFPlone/earlypatches/__init__.py\n+++ b/Products/CMFPlone/earlypatches/__init__.py\n@@ -1,2 +1,3 @@\n # misc security fixes\n from Products.CMFPlone.earlypatches import security  # noqa\n+from Products.CMFPlone.earlypatches import expressions  # noqa\ndiff --git a/Products/CMFPlone/earlypatches/expressions.py b/Products/CMFPlone/earlypatches/expressions.py\nnew file mode 100644\nindex 0000000000..59eb58d1ad\n--- /dev/null\n+++ b/Products/CMFPlone/earlypatches/expressions.py\n@@ -0,0 +1,214 @@\n+from AccessControl.SecurityManagement import getSecurityManager\n+from AccessControl.ZopeGuards import guarded_getattr\n+from AccessControl.ZopeGuards import guarded_import\n+from OFS.interfaces import ITraversable\n+from Products.PageTemplates import Expressions\n+from zExceptions import NotFound\n+from zExceptions import Unauthorized\n+from zope.traversing.adapters import traversePathElement\n+\n+import os\n+import string\n+import sys\n+import types\n+import warnings\n+\n+\n+# In the \'bobo aware\' Zope traverse methods and functions, various security checks are done.\n+# For example for content items, permission checks are done.\n+# But for non-content, for example a Python module or a dictionary, the checks were originally very lax.\n+# This could be abused.  Now we know that, we want to be as strict as possible.\n+#\n+# But being stricter breaks existing code which worked fine so far,\n+# not knowing that it tried to access code which should have been disallowed.\n+# One thing that goes wrong, is that any skin template that calls context/main_template/macros/master fails,\n+# for example when viewing a revision from CMFEditions.\n+#\n+# So with this hotfix, by necessity we are still lax/forgiving, but you can change this behavior\n+# with an environment variable: STRICT_TRAVERSE_CHECK.\n+# - STRICT_TRAVERSE_CHECK=0 mostly uses the original lax/sloppy checks.\n+#   This sadly needs to be the default.\n+# - STRICT_TRAVERSE_CHECK=1 uses the strict logic.\n+#   When you know what you are doing, you can try this.\n+# - STRICT_TRAVERSE_CHECK=2 first tries the strict logic.\n+#   If this fails, log a warning and then fallback to the original lax checks.\n+#   The idea would be to use this in development or production for a while, to see which code needs a fix.\n+try:\n+    STRICT_TRAVERSE_CHECK = int(os.getenv("STRICT_TRAVERSE_CHECK", 0))\n+except (ValueError, TypeError, AttributeError):\n+    STRICT_TRAVERSE_CHECK = 0\n+# Set of names that start with an underscore but that we want to allow anyway.\n+ALLOWED_UNDERSCORE_NAMES = set([\n+    # dunder name is used in plone.app.caching, and maybe other places\n+    "__name__",\n+    # Zope allows a single underscore to avoid a test failure\n+    "_",\n+    # Special case for plone.protect.\n+    # Fixes a NotFound error when submitting a PloneFormGen form:\n+    # https://github.com/smcmahon/Products.PloneFormGen/pull/229\n+    "_authenticator",\n+])\n+# Some objects we really do not trust, even when you have found a workaround to reach them.\n+DISALLOWED_OBJECTS = [\n+    os,\n+    sys,\n+    # string.Formatter sounds innocent, but can be abused.\n+    string.Formatter,\n+]\n+_orig_boboAwareZopeTraverse = Expressions.boboAwareZopeTraverse\n+\n+\n+def guarded_import_module(base, path_items):\n+    name = path_items[0]\n+    try:\n+        guarded_import(base.__name__, fromlist=path_items)\n+        # guarded_import will do most security checking\n+        # but will not return the imported item itself,\n+        # so we need to call getattr ourselves.\n+        # Actually, not all security checks are done, so we call guarded_getattr.\n+        for name in path_items:\n+            base = guarded_getattr(base, name)\n+    except Unauthorized:\n+        # special case for OFS/zpt/main.zpt which uses\n+        # modules/AccessControl/SecurityManagement/getSecurityManager\n+        # which should have been modules/AccessControl/getSecurityManager\n+        # Fixed in Zope 4.6.1 and 5.2.1.\n+        if name == "SecurityManagement" and path_items[-1] == "getSecurityManager":\n+            return getSecurityManager\n+        # Convert Unauthorized to prevent information disclosures\n+        raise NotFound(name)\n+    except TypeError:\n+        # During testing with security-policy-implementation python\n+        # and verbose-security on, I got this error when an Unauthorized was raised\n+        # for string.Formatter.get_field:\n+        # TypeError: descriptor \'__repr__\' of \'object\' object needs an argument\n+        # This was in the item_repr function of AccessControl.ImplPython.\n+        raise NotFound(name)\n+    if base in DISALLOWED_OBJECTS:\n+        raise NotFound(name)\n+    return base\n+\n+\n+def shared_traverse(base, path_items, request, traverse_method="restrictedTraverse"):\n+    """Shared traverse method for bobo aware zope traverse function and class method.\n+\n+    They are almost exactly the same, and it is irritating and error prone\n+    to change similar code in two places.\n+    """\n+    validate = getSecurityManager().validate\n+    path_items = list(path_items)\n+    path_items.reverse()\n+\n+    while path_items:\n+        name = path_items.pop()\n+\n+        if ITraversable.providedBy(base):\n+            base = getattr(base, traverse_method)(name)\n+        elif isinstance(base, types.ModuleType):\n+            # We should be able to handle the name and all remaining path items at once.\n+            # Use the correct order again.\n+            path_items.append(name)\n+            path_items.reverse()\n+            return guarded_import_module(base, path_items)\n+        else:\n+            found = traversePathElement(base, name, path_items,\n+                                        request=request)\n+\n+            # If traverse_method is something other than\n+            # ``restrictedTraverse`` then traversal is assumed to be\n+            # unrestricted. This emulates ``unrestrictedTraverse``\n+            if traverse_method != \'restrictedTraverse\':\n+                base = found\n+                continue\n+\n+            # Special backwards compatibility exception for the name ``_``,\n+            # which was often used for translation message factories.\n+            # Allow and continue traversal.\n+            if name == \'_\':\n+                warnings.warn(\'Traversing to the name `_` is deprecated \'\n+                              \'and will be removed in Zope 6.\',\n+                              DeprecationWarning)\n+                base = found\n+                continue\n+\n+            if name.startswith(\'_\'):\n+                if name in ALLOWED_UNDERSCORE_NAMES:\n+                    base = found\n+                    continue\n+                # All other names starting with ``_`` are disallowed.\n+                # This emulates what restrictedTraverse does.\n+                raise NotFound(name)\n+\n+            if found in DISALLOWED_OBJECTS:\n+                raise NotFound(name)\n+\n+            if STRICT_TRAVERSE_CHECK:\n+                # traversePathElement doesn\'t apply any Zope security policy,\n+                # so we validate access explicitly here.\n+                try:\n+                    validate(base, base, name, found)\n+                except Unauthorized:\n+                    if STRICT_TRAVERSE_CHECK == 2:\n+                        # only warn\n+                        warnings.warn(\n+                            \'Traversing from {0} to {1} is only allowed because STRICT_TRAVERSE_CHECK=2. \'\n+                            \'Possible security problem.\'.format(object, name))\n+                    else:\n+                        # Convert Unauthorized to prevent information disclosures\n+                        raise NotFound(name)\n+\n+            base = found\n+\n+    return base\n+\n+\n+def boboAwareZopeTraverse(object, path_items, econtext):\n+    """Traverses a sequence of names, first trying attributes then items.\n+\n+    This uses zope.traversing path traversal where possible and interacts\n+    correctly with objects providing OFS.interface.ITraversable when\n+    necessary (bobo-awareness).\n+    """\n+    request = getattr(econtext, \'request\', None)\n+    result = shared_traverse(object, path_items, request)\n+    return result\n+\n+\n+Expressions.boboAwareZopeTraverse = boboAwareZopeTraverse\n+Expressions.ZopePathExpr._TRAVERSER = staticmethod(boboAwareZopeTraverse)\n+\n+# But wait, there is also a BoboAwareZopeTraverse class.\n+from Products.PageTemplates.expression import BoboAwareZopeTraverse\n+from Products.PageTemplates.expression import TrustedBoboAwareZopeTraverse\n+\n+# We do not want to change the trusted version.  It inherits the traverse method\n+# from the untrusted class.  It may be better to give it its own method.\n+# The @classmethod makes this tricky to get right.\n+# But the following line essentially makes a copy of the traverse method\n+# without needing inheritance anymore.\n+TrustedBoboAwareZopeTraverse.traverse = TrustedBoboAwareZopeTraverse.traverse\n+\n+BoboAwareZopeTraverse._orig_traverse = BoboAwareZopeTraverse.traverse\n+\n+def traverse(cls, base, request, path_items):\n+    """See ``zope.app.pagetemplate.engine``."""\n+    # When our patching is done correctly, this only gets called for the\n+    # BoboAwareZopeTraverse class, so cls.traverse_method is always restrictedTraverse.\n+    # But let\'s be careful and just pass the attribute on.\n+    result = shared_traverse(base, path_items, request, traverse_method=cls.traverse_method)\n+    return result\n+\n+BoboAwareZopeTraverse.traverse = classmethod(traverse)\n+\n+# The TrustedBoboAwareZopeTraverse and (untrusted) BoboAwareZopeTraverse class have a problem:\n+# They have a "traverse_method" attribute, but the "traverse" method\n+# calls "cls.traverseMethod" instead, so this fails.\n+# This may mean these classes do not get called anymore, except in test_expressions.py.\n+name1 = "traverse_method"\n+name2 = "traverseMethod"\n+# First do the trusted class, because it inherits from the untrusted class.\n+# Otherwise the trusted class would have traverse_method=unrestrictedTraverse\n+# and it would inherit traverseMethod=restrictedTraverse.\n+for klass in (TrustedBoboAwareZopeTraverse, BoboAwareZopeTraverse):\n+    if hasattr(klass, name1) and not hasattr(klass, name2):\n+        setattr(klass, name2, getattr(klass, name1))\ndiff --git a/Products/CMFPlone/testing.py b/Products/CMFPlone/testing.py\nindex b7f96ed80e..d624fcde81 100644\n--- a/Products/CMFPlone/testing.py\n+++ b/Products/CMFPlone/testing.py\n@@ -32,6 +32,11 @@ def setUpZope(self, app, configurationContext):\n             Products.CMFPlone,\n             context=configurationContext\n         )\n+        xmlconfig.file(\n+            \'configure.zcml\',\n+            Products.CMFPlone.tests,\n+            context=configurationContext\n+        )\n \n     def setUpPloneSite(self, portal):\n         portal.acl_users.userFolderAddUser(\ndiff --git a/Products/CMFPlone/tests/accesscontrol_direct.pt b/Products/CMFPlone/tests/accesscontrol_direct.pt\nnew file mode 100644\nindex 0000000000..0c981337b4\n--- /dev/null\n+++ b/Products/CMFPlone/tests/accesscontrol_direct.pt\n@@ -0,0 +1 @@\n+<span tal:condition="nocall:modules/AccessControl/SecurityManagement">hacked</span>\ndiff --git a/Products/CMFPlone/tests/accesscontrol_sm.pt b/Products/CMFPlone/tests/accesscontrol_sm.pt\nnew file mode 100644\nindex 0000000000..536add7541\n--- /dev/null\n+++ b/Products/CMFPlone/tests/accesscontrol_sm.pt\n@@ -0,0 +1 @@\n+<span tal:condition="nocall:modules/AccessControl/getSecurityManager">getSecurityManager is allowed</span>\ndiff --git a/Products/CMFPlone/tests/accesscontrol_sm2.pt b/Products/CMFPlone/tests/accesscontrol_sm2.pt\nnew file mode 100644\nindex 0000000000..6be7a66cdd\n--- /dev/null\n+++ b/Products/CMFPlone/tests/accesscontrol_sm2.pt\n@@ -0,0 +1 @@\n+<span tal:condition="nocall:modules/AccessControl/SecurityManagement/getSecurityManager">getSecurityManager is still allowed</span>\ndiff --git a/Products/CMFPlone/tests/accesscontrol_via_dict.pt b/Products/CMFPlone/tests/accesscontrol_via_dict.pt\nnew file mode 100644\nindex 0000000000..46785bc666\n--- /dev/null\n+++ b/Products/CMFPlone/tests/accesscontrol_via_dict.pt\n@@ -0,0 +1,3 @@\n+<span tal:define="acc nocall:modules/AccessControl;\n+                  piggyback python:{\'unsafe\': acc}"\n+      tal:condition="nocall:piggyback/unsafe/users">hacked</span>\ndiff --git a/Products/CMFPlone/tests/accesscontrol_via_modules.pt b/Products/CMFPlone/tests/accesscontrol_via_modules.pt\nnew file mode 100644\nindex 0000000000..adb03fc5e5\n--- /dev/null\n+++ b/Products/CMFPlone/tests/accesscontrol_via_modules.pt\n@@ -0,0 +1 @@\n+<span tal:define="acc nocall:modules/AccessControl" tal:condition="nocall:acc/users">hacked</span>\ndiff --git a/Products/CMFPlone/tests/bad1.pt b/Products/CMFPlone/tests/bad1.pt\nnew file mode 100644\nindex 0000000000..856c36432e\n--- /dev/null\n+++ b/Products/CMFPlone/tests/bad1.pt\n@@ -0,0 +1,2 @@\n+Hello <span tal:define="sys nocall:random/_os/system"\n+            tal:content="python: sys(\'ls ~\')" />.\ndiff --git a/Products/CMFPlone/tests/bad2.pt b/Products/CMFPlone/tests/bad2.pt\nnew file mode 100644\nindex 0000000000..0372162e07\n--- /dev/null\n+++ b/Products/CMFPlone/tests/bad2.pt\n@@ -0,0 +1,2 @@\n+Hello <span tal:define="string python:modules[\'string\']"\n+            tal:content="string/_re/purge" />.\ndiff --git a/Products/CMFPlone/tests/bad3.pt b/Products/CMFPlone/tests/bad3.pt\nnew file mode 100644\nindex 0000000000..077d00f3f5\n--- /dev/null\n+++ b/Products/CMFPlone/tests/bad3.pt\n@@ -0,0 +1,3 @@\n+Hello <span tal:define="string nocall:modules/string;\n+                        get_field nocall:string/Formatter/get_field;\n+                        poc python:get_field(path(\'string/Formatter\'), \'0._re.purge\', [string], None)" tal:content="poc" />\ndiff --git a/Products/CMFPlone/tests/configure.zcml b/Products/CMFPlone/tests/configure.zcml\nnew file mode 100644\nindex 0000000000..2d1cf3b401\n--- /dev/null\n+++ b/Products/CMFPlone/tests/configure.zcml\n@@ -0,0 +1,13 @@\n+<configure\n+    xmlns="http://namespaces.zope.org/zope"\n+    xmlns:browser="http://namespaces.zope.org/browser"\n+    i18n_domain="plone">\n+\n+    <browser:page\n+        name="hotfix-testing-view-name"\n+        for="*"\n+        template="view_name.pt"\n+        permission="zope2.View"\n+        />\n+\n+</configure>\ndiff --git a/Products/CMFPlone/tests/options_authenticator.pt b/Products/CMFPlone/tests/options_authenticator.pt\nnew file mode 100644\nindex 0000000000..97e29c4a65\n--- /dev/null\n+++ b/Products/CMFPlone/tests/options_authenticator.pt\n@@ -0,0 +1 @@\n+<h1 tal:content="options/view/_authenticator" />\ndiff --git a/Products/CMFPlone/tests/options_name.pt b/Products/CMFPlone/tests/options_name.pt\nnew file mode 100644\nindex 0000000000..592dc3e98d\n--- /dev/null\n+++ b/Products/CMFPlone/tests/options_name.pt\n@@ -0,0 +1 @@\n+<h1 tal:content="view/__name__" />\ndiff --git a/Products/CMFPlone/tests/options_underscore.pt b/Products/CMFPlone/tests/options_underscore.pt\nnew file mode 100644\nindex 0000000000..172a01b9b1\n--- /dev/null\n+++ b/Products/CMFPlone/tests/options_underscore.pt\n@@ -0,0 +1 @@\n+<h1 tal:content="options/view/_" />\ndiff --git a/Products/CMFPlone/tests/options_view_name.pt b/Products/CMFPlone/tests/options_view_name.pt\nnew file mode 100644\nindex 0000000000..3a433ca22e\n--- /dev/null\n+++ b/Products/CMFPlone/tests/options_view_name.pt\n@@ -0,0 +1 @@\n+<h1 tal:content="options/view/__name__" />\ndiff --git a/Products/CMFPlone/tests/test_expressions.py b/Products/CMFPlone/tests/test_expressions.py\nnew file mode 100644\nindex 0000000000..48a65ac793\n--- /dev/null\n+++ b/Products/CMFPlone/tests/test_expressions.py\n@@ -0,0 +1,329 @@\n+# -*- coding: utf-8 -*-\n+from AccessControl.class_init import InitializeClass\n+from AccessControl.Permissions import view_management_screens\n+from AccessControl.SecurityInfo import ClassSecurityInfo\n+from OFS.SimpleItem import SimpleItem\n+from plone.testing.zope import Browser\n+from Products.CMFPlone.testing import PRODUCTS_CMFPLONE_FUNCTIONAL_TESTING\n+# Expressions.boboAwareZopeTraverse is a function\n+# expression(s).BoboAwareZopeTraverse is a class\n+# Import them with names that are easier to tell apart.\n+from Products.PageTemplates.expression import BoboAwareZopeTraverse as TraverseClass\n+from Products.PageTemplates.expression import TrustedBoboAwareZopeTraverse as TrustedTraverseClass\n+from Products.PageTemplates.Expressions import boboAwareZopeTraverse as traverse_function\n+from Products.PageTemplates.Expressions import trustedBoboAwareZopeTraverse as trusted_traverse_function\n+from Products.PageTemplates.PageTemplateFile import PageTemplateFile\n+from zExceptions import NotFound\n+from zExceptions import Unauthorized\n+\n+import AccessControl\n+import os\n+import random\n+import re\n+import string\n+import sys\n+import unittest\n+\n+\n+try:\n+    # Python 3.7+\n+    from random import _os\n+except ImportError:\n+    # Python 3.6- is not vulnerable.\n+    _os = None\n+\n+\n+# Path of this directory:\n+path = os.path.dirname(__file__)\n+\n+\n+class DummyView(object):\n+\n+    __name__ = "dummy-view"\n+    _authenticator = "secret"\n+    _ = "translation"\n+    # Even via weird names, some items should not be reachable:\n+    os_hack = os\n+    sys_hack = sys\n+    Formatter_hack = string.Formatter\n+\n+\n+class DummyContent(SimpleItem):\n+    """Dummy content class to show the (un)restrictedTraverse works."""\n+    security = ClassSecurityInfo()\n+\n+    @security.public\n+    def public(self):\n+        """Public method"""\n+        return "I am public"\n+\n+    @security.private\n+    def private(self):\n+        """Private method"""\n+        return "I am private"\n+\n+    @security.protected(view_management_screens)\n+    def protected(self):\n+        """Protected method"""\n+        return "I am protected"\n+\n+\n+InitializeClass(DummyContent)\n+\n+\n+class TestAttackVector(unittest.TestCase):\n+    layer = PRODUCTS_CMFPLONE_FUNCTIONAL_TESTING\n+\n+    def _makeOne(self, name):\n+        return PageTemplateFile(os.path.join(path, name)).__of__(self.layer["portal"])\n+\n+    @unittest.skipIf(_os is None, "This Python version has no random._os.")\n+    def test_template_bad1(self):\n+        template = self._makeOne("bad1.pt")\n+        # In some versions, random is not globally available, so we get a NameError.\n+        # Otherwise our patch should make sure we get a NotFound.\n+        with self.assertRaises((NotFound, NameError)):\n+            template()\n+\n+    def test_template_bad2(self):\n+        template = self._makeOne("bad2.pt")\n+        with self.assertRaises(NotFound):\n+            template()\n+\n+    def test_template_bad3(self):\n+        template = self._makeOne("bad3.pt")\n+        with self.assertRaises(NotFound):\n+            template()\n+\n+    def test_template_name(self):\n+        # Allow accessing __name__ in a skin template or TTW template.\n+        template = self._makeOne("options_view_name.pt")\n+        # Pass view in the options.\n+        self.assertIn("dummy-view", template(view=DummyView()))\n+\n+    def test_template_authenticator(self):\n+        # Allow accessing _authenticator in a skin template or TTW template.\n+        template = self._makeOne("options_authenticator.pt")\n+        # Pass view in the options.\n+        self.assertIn("secret", template(view=DummyView()))\n+\n+    def test_template_single_underscore(self):\n+        # Allow accessing \'_\' in a skin template or TTW template.\n+        # In the merge of the hotfix, Zope allows this, to avoid a test failure.\n+        template = self._makeOne("options_underscore.pt")\n+        # Pass view in the options.\n+        self.assertIn("translation", template(view=DummyView()))\n+\n+    def test_browser_template_with_name(self):\n+        # Allow accessing __name__ in a browser view template.\n+        browser = Browser(self.layer["app"])\n+        browser.handleErrors = False\n+        browser.open(self.layer["portal"].absolute_url() + "/hotfix-testing-view-name")\n+        self.assertIn("<h1>hotfix-testing-view-name</h1>", browser.contents)\n+\n+    def test_template_accesscontrol_sm(self):\n+        # Only AccessControl.getSecurityManager is allowed.\n+        template = self._makeOne("accesscontrol_sm.pt")\n+        self.assertIn("getSecurityManager is allowed", template())\n+\n+    def test_template_accesscontrol_sm2(self):\n+        # Zope main.zpt uses modules/AccessControl/SecurityManagement/getSecurityManager\n+        # which should have been modules/AccessControl/getSecurityManager.\n+        # So we need a special case for it, otherwise the ZMI is totally inaccessible.\n+        template = self._makeOne("accesscontrol_sm2.pt")\n+        self.assertIn("getSecurityManager is still allowed", template())\n+\n+    def test_template_accesscontrol_direct(self):\n+        # Via AccessControl you can access too much.\n+        template = self._makeOne("accesscontrol_direct.pt")\n+        with self.assertRaises(NotFound):\n+            template()\n+\n+    def test_template_accesscontrol_via_modules(self):\n+        template = self._makeOne("accesscontrol_via_modules.pt")\n+        with self.assertRaises(NotFound):\n+            template()\n+\n+    def test_template_accesscontrol_via_dict(self):\n+        template = self._makeOne("accesscontrol_via_dict.pt")\n+        with self.assertRaises(NotFound):\n+            template()\n+\n+\n+class TestDirectAttackVector(unittest.TestCase):\n+    layer = PRODUCTS_CMFPLONE_FUNCTIONAL_TESTING\n+\n+    @unittest.skipIf(_os is None, "This Python version has no random._os.")\n+    def test_traverse_function_random(self):\n+        with self.assertRaises(NotFound):\n+            traverse_function(random, ("_os", "system"), None)\n+        # trusted traverse should work fine\n+        result = trusted_traverse_function(random, ("_os", "system"), None)\n+        self.assertEqual(result, os.system)\n+\n+    def test_traverse_function_string(self):\n+        with self.assertRaises(NotFound):\n+            traverse_function(string, ("_re", "purge"), None)\n+        result = trusted_traverse_function(string, ("_re", "purge"), None)\n+        self.assertEqual(result, re.purge)\n+\n+    def test_traverse_function_formatter(self):\n+        with self.assertRaises(NotFound):\n+            traverse_function(string, ("Formatter",), None)\n+        result = trusted_traverse_function(string, ("Formatter",), None)\n+        self.assertEqual(result, string.Formatter)\n+\n+    def test_traverse_function_formatter_get_field(self):\n+        with self.assertRaises(NotFound):\n+            traverse_function(string, ("Formatter", "get_field"), None)\n+        result = trusted_traverse_function(string, ("Formatter", "get_field"), None)\n+        self.assertEqual(result, string.Formatter.get_field)\n+\n+    def test_traverse_function_hacked_names(self):\n+        view = DummyView()\n+        with self.assertRaises(NotFound):\n+            traverse_function(view, ("os_hack",), None)\n+        with self.assertRaises(NotFound):\n+            traverse_function(view, ("sys_hack",), None)\n+        with self.assertRaises(NotFound):\n+            traverse_function(view, ("Formatter_hack",), None)\n+        result = trusted_traverse_function(view, ("os_hack",), None)\n+        self.assertEqual(result, os)\n+        result = trusted_traverse_function(view, ("sys_hack",), None)\n+        self.assertEqual(result, sys)\n+        result = trusted_traverse_function(view, ("Formatter_hack",), None)\n+        self.assertEqual(result, string.Formatter)\n+\n+    def test_traverse_function_name(self):\n+        # We allow access to __name__ always as a special case.\n+        view = DummyView()\n+        self.assertEqual(traverse_function(view, ("__name__",), None), "dummy-view")\n+        self.assertEqual(trusted_traverse_function(view, ("__name__",), None), "dummy-view")\n+\n+    def test_traverse_function_authenticator(self):\n+        # We allow access to _authenticator always as a special case.\n+        view = DummyView()\n+        self.assertEqual(traverse_function(view, ("_authenticator",), None), "secret")\n+        self.assertEqual(trusted_traverse_function(view, ("_authenticator",), None), "secret")\n+\n+    def test_traverse_function_single_underscore(self):\n+        # We allow access to \'_\' always as a special case.\n+        view = DummyView()\n+        self.assertEqual(traverse_function(view, ("_",), None), "translation")\n+        self.assertEqual(trusted_traverse_function(view, ("_",), None), "translation")\n+\n+    def test_traverse_function_content(self):\n+        content = DummyContent("dummy")\n+        self.assertEqual(traverse_function(content, ("public",), None)(), "I am public")\n+        with self.assertRaises(Unauthorized):\n+            traverse_function(content, ("private",), None)\n+        with self.assertRaises(Unauthorized):\n+            traverse_function(content, ("protected",), None)\n+\n+        self.assertEqual(trusted_traverse_function(content, ("public",), None)(), "I am public")\n+        self.assertEqual(trusted_traverse_function(content, ("private",), None)(), "I am private")\n+        self.assertEqual(trusted_traverse_function(content, ("protected",), None)(), "I am protected")\n+\n+    def test_traverse_function_accesscontrol_getSecurityManager(self):\n+        # Only getSecurityManager is allowed.\n+        self.assertEqual(traverse_function(AccessControl, ("getSecurityManager",), None), AccessControl.getSecurityManager)\n+        self.assertEqual(trusted_traverse_function(AccessControl, ("getSecurityManager",), None), AccessControl.getSecurityManager)\n+\n+    def test_traverse_function_accesscontrol_getSecurityManager2(self):\n+        # Zope main.zpt uses modules/AccessControl/SecurityManagement/getSecurityManager\n+        # which should have been modules/AccessControl/getSecurityManager.\n+        # So we need a special case for it, otherwise the ZMI is totally inaccessible.\n+        self.assertEqual(traverse_function(AccessControl, ("SecurityManagement", "getSecurityManager"), None), AccessControl.getSecurityManager)\n+        self.assertEqual(trusted_traverse_function(AccessControl, ("SecurityManagement", "getSecurityManager",), None), AccessControl.getSecurityManager)\n+\n+    def test_traverse_function_accesscontrol_direct(self):\n+        with self.assertRaises(NotFound):\n+            traverse_function(AccessControl, ("SecurityManagement",), None)\n+        self.assertEqual(trusted_traverse_function(AccessControl, ("SecurityManagement",), None), AccessControl.SecurityManagement)\n+\n+    def test_traverse_function_accesscontrol_via_modules(self):\n+        from Products.PageTemplates.ZRPythonExpr import _SecureModuleImporter\n+\n+        modules = _SecureModuleImporter()\n+        with self.assertRaises(NotFound):\n+            traverse_function(modules, ("AccessControl", "users"), None)\n+        self.assertEqual(trusted_traverse_function(modules, ("AccessControl", "users"), None), AccessControl.users)\n+\n+    def test_traverse_function_accesscontrol_via_dict(self):\n+        piggyback = {"unsafe": AccessControl}\n+        with self.assertRaises(NotFound):\n+            traverse_function(piggyback, ("unsafe", "users"), None)\n+        self.assertEqual(trusted_traverse_function(piggyback, ("unsafe", "users"), None), AccessControl.users)\n+\n+    @unittest.skipIf(_os is None or TraverseClass is None, "This Python version has no random._os or there is no BoboAwareZopeTraverse class.")\n+    def test_traverse_class_random(self):\n+        with self.assertRaises(NotFound):\n+            # Note: here the second argument is the request.  None works in the tests.\n+            TraverseClass.traverse(random, None, ("_os", "system"))\n+        # trusted traverse should work fine\n+        result = TrustedTraverseClass.traverse(random, None, ("_os", "system"))\n+        self.assertEqual(result, os.system)\n+\n+    def test_traverse_class_string(self):\n+        with self.assertRaises(NotFound):\n+            TraverseClass.traverse(string, None, ("_re", "purge"))\n+        result = TrustedTraverseClass.traverse(string, None, ("_re", "purge"))\n+        self.assertEqual(result, re.purge)\n+\n+    def test_traverse_class_formatter(self):\n+        with self.assertRaises(NotFound):\n+            TraverseClass.traverse(string, None, ("Formatter",))\n+        result = TrustedTraverseClass.traverse(string, None, ("Formatter",))\n+        self.assertEqual(result, string.Formatter)\n+\n+    def test_traverse_class_formatter_get_field(self):\n+        with self.assertRaises(NotFound):\n+            TraverseClass.traverse(string, None, ("Formatter", "get_field"))\n+        result = TrustedTraverseClass.traverse(string, None, ("Formatter", "get_field"))\n+        self.assertEqual(result, string.Formatter.get_field)\n+\n+    def test_traverse_class_name(self):\n+        # We allow access to __name__ always as a special case.\n+        view = DummyView()\n+        self.assertEqual(TraverseClass.traverse(view, None, ("__name__",)), "dummy-view")\n+        self.assertEqual(TrustedTraverseClass.traverse(view, None, ("__name__",)), "dummy-view")\n+\n+    def test_traverse_class_content(self):\n+        content = DummyContent("dummy")\n+        self.assertEqual(TraverseClass.traverse(content, None, ("public",))(), "I am public")\n+        with self.assertRaises(Unauthorized):\n+            TraverseClass.traverse(content, None, ("private",))\n+        with self.assertRaises(Unauthorized):\n+            TraverseClass.traverse(content, None, ("protected",))\n+\n+        self.assertEqual(TrustedTraverseClass.traverse(content, None, ("public",))(), "I am public")\n+        self.assertEqual(TrustedTraverseClass.traverse(content, None, ("private",))(), "I am private")\n+        self.assertEqual(TrustedTraverseClass.traverse(content, None, ("protected",))(), "I am protected")\n+\n+    def test_traverse_class_accesscontrol_getSecurityManager(self):\n+        # AccessControl.getSecurityManager is the only item allowed.\n+        self.assertEqual(TraverseClass.traverse(AccessControl, None, ("getSecurityManager",)), AccessControl.getSecurityManager)\n+        self.assertEqual(TrustedTraverseClass.traverse(AccessControl, None, ("getSecurityManager",)), AccessControl.getSecurityManager)\n+\n+    def test_traverse_class_accesscontrol_getSecurityManager2(self):\n+        self.assertEqual(TraverseClass.traverse(AccessControl, None, ("SecurityManagement", "getSecurityManager",)), AccessControl.getSecurityManager)\n+        self.assertEqual(TrustedTraverseClass.traverse(AccessControl, None, ("SecurityManagement", "getSecurityManager",)), AccessControl.getSecurityManager)\n+\n+    def test_traverse_class_accesscontrol_direct(self):\n+        with self.assertRaises(NotFound):\n+            TraverseClass.traverse(AccessControl, None, ("SecurityManagement",))\n+        self.assertEqual(TrustedTraverseClass.traverse(AccessControl, None, ("SecurityManagement",)), AccessControl.SecurityManagement)\n+\n+    def test_traverse_class_accesscontrol_via_modules(self):\n+        from Products.PageTemplates.ZRPythonExpr import _SecureModuleImporter\n+\n+        modules = _SecureModuleImporter()\n+        with self.assertRaises(NotFound):\n+            TraverseClass.traverse(modules, None, ("AccessControl", "users"))\n+        self.assertEqual(TrustedTraverseClass.traverse(modules, None, ("AccessControl", "users")), AccessControl.users)\n+\n+    def test_traverse_class_accesscontrol_via_dict(self):\n+        piggyback = {"unsafe": AccessControl}\n+        with self.assertRaises(NotFound):\n+            TraverseClass.traverse(piggyback, None, ("unsafe", "users"))\n+        self.assertEqual(TrustedTraverseClass.traverse(piggyback, None, ("unsafe", "users")), AccessControl.users)\ndiff --git a/Products/CMFPlone/tests/view_name.pt b/Products/CMFPlone/tests/view_name.pt\nnew file mode 100644\nindex 0000000000..592dc3e98d\n--- /dev/null\n+++ b/Products/CMFPlone/tests/view_name.pt\n@@ -0,0 +1 @@\n+<h1 tal:content="view/__name__" />\ndiff --git a/news/3274.bugfix b/news/3274.bugfix.1\nsimilarity index 100%\nrename from news/3274.bugfix\nrename to news/3274.bugfix.1\ndiff --git a/news/3274.bugfix.2 b/news/3274.bugfix.2\nnew file mode 100644\nindex 0000000000..eaefaa3547\n--- /dev/null\n+++ b/news/3274.bugfix.2\n@@ -0,0 +1,3 @@\n+Add the expressions patch from `Products.PloneHotfix20210518 <https://plone.org/security/hotfix/20210518/remote-code-execution-via-traversal-in-expressions>`_.\n+We need this because Zope 4.6.2 is too strict for us.\n+[maurits]\n'

