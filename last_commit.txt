Repository: plone.restapi


Branch: refs/heads/master
Date: 2020-05-06T11:00:46+02:00
Author: Eric Steele (esteele) <eric@esteele.net>
Commit: https://github.com/plone/plone.restapi/commit/0e27a0303ee9c1779ee817c334a91a9d6a33cbc0

Add @addons endpoint (#556)

* Add beginnings of @addons endpoint

* Add @addon get response

* Add header

* Add @addons list response

* Add install, upgrade, uninstall on addons

* Add addons to toctree

* Don’t include paths.

* Add @id element to addons with url of its record

* Fix false, null.

* Status 200 doesn’t return content.

* 204 instead of 200

* Fix false/null

* Add get for @addons

* Add upgrade/install/uninstall methods to @addons

* Reorganize

* Move request/response examples

* Update example locations

* No need to batch the results

* Remove reinstall_products

* Handle product upgrade

* Remove unused method

* Add changelog entry.

* Move addon-lookup code into addons.py

* Flesh out tests some more

* Fix test values

* Check for prefer header, return all addons if set.

* Working install/uninstall test

* Remove unused imports

* Handle not-found addon

* Clean up Flake8 errors

* Sort imports

* Remove unused plone import from addons.py.

* Remove changelog merge message

* py3 fix.

* Flake 8

* Black

* Flake 8

* Fix tests

* Add upgrade tests

* Add upgrade tests

* Disable for Plone 4.3

Co-authored-by: Timo Stollenwerk &lt;stollenwerk@kitconcept.com&gt;
Co-authored-by: Rodrigo Ferreira de Souza &lt;rodfersou@gmail.com&gt;
Co-authored-by: Victor Fernandez de Alba &lt;sneridagh@gmail.com&gt;

Files changed:
A docs/source/addons.rst
A news/733.feature
A src/plone/restapi/services/addons/__init__.py
A src/plone/restapi/services/addons/addons.py
A src/plone/restapi/services/addons/configure.zcml
A src/plone/restapi/services/addons/get.py
A src/plone/restapi/services/addons/post.py
A src/plone/restapi/tests/http-examples/addons_get.req
A src/plone/restapi/tests/http-examples/addons_get.resp
A src/plone/restapi/tests/http-examples/addons_get_list.req
A src/plone/restapi/tests/http-examples/addons_get_list.resp
A src/plone/restapi/tests/http-examples/addons_install.req
A src/plone/restapi/tests/http-examples/addons_install.resp
A src/plone/restapi/tests/http-examples/addons_uninstall.req
A src/plone/restapi/tests/http-examples/addons_uninstall.resp
A src/plone/restapi/tests/http-examples/addons_upgrade.req
A src/plone/restapi/tests/http-examples/addons_upgrade.resp
A src/plone/restapi/tests/test_addons.py
M CONTRIBUTORS.rst
M docs/source/index.rst
M src/plone/restapi/services/configure.zcml

b'diff --git a/CONTRIBUTORS.rst b/CONTRIBUTORS.rst\nindex 231691cc..9392d420 100644\n--- a/CONTRIBUTORS.rst\n+++ b/CONTRIBUTORS.rst\n@@ -20,3 +20,4 @@\n - Luca Bellenghi\n - Giacomo Monari\n - Alin Voinea\n+- Rodrigo Ferreira de Souza\ndiff --git a/docs/source/addons.rst b/docs/source/addons.rst\nnew file mode 100644\nindex 00000000..25157f2d\n--- /dev/null\n+++ b/docs/source/addons.rst\n@@ -0,0 +1,83 @@\n+Add-ons\n+========\n+\n+Addon product records can be addressed through the ``@addons`` endpoint on the\n+Plone site. In order to address a specific record, the profile id has to be\n+passed as a path segment (e.g. `/plone/@addons/plone.session`).\n+\n+Reading or writing addons metadata require the ``cmf.ManagePortal``\n+permission.\n+\n+Reading add-ons records\n+-----------------------\n+\n+Reading a single record:\n+\n+..  http:example:: curl httpie python-requests\n+    :request: ../../src/plone/restapi/tests/http-examples/addons_get.req\n+\n+Example Response:\n+\n+.. literalinclude:: ../../src/plone/restapi/tests/http-examples/addons_get.resp\n+   :language: http\n+\n+\n+Listing add-ons records\n+-----------------------\n+\n+A list of all add-ons in the portal can be retrieved by\n+sending a GET request to the @addons endpoint:\n+\n+..  http:example:: curl httpie python-requests\n+    :request: ../../src/plone/restapi/tests/http-examples/addons_get_list.req\n+\n+Response:\n+\n+.. literalinclude:: ../../src/plone/restapi/tests/http-examples/addons_get_list.resp\n+   :language: http\n+\n+The following fields are returned:\n+\n+- @id: hypermedia link to the control panel\n+- id: the name of the add-on package\n+- title: the friendly name of the add-on package\n+- description: description of the add-on\n+- version: the current version of the add-on\n+- is_installed: is the add-on installed?\n+- has_uninstall_profile: does the add-on have an uninstall profile\n+\n+\n+Installing an addon\n+-------------------\n+\n+An individual addon can be installed by issuing a ``POST`` to the given URL:\n+\n+..  http:example:: curl httpie python-requests\n+    :request: ../../src/plone/restapi/tests/http-examples/addons_install.req\n+\n+.. literalinclude:: ../../src/plone/restapi/tests/http-examples/addons_install.resp\n+   :language: http\n+\n+\n+Uninstalling an addon\n+-------------------\n+\n+An individual addon can be uninstalled by issuing a ``POST`` to the given URL:\n+\n+..  http:example:: curl httpie python-requests\n+    :request: ../../src/plone/restapi/tests/http-examples/addons_uninstall.req\n+\n+.. literalinclude:: ../../src/plone/restapi/tests/http-examples/addons_uninstall.resp\n+   :language: http\n+\n+\n+Upgrading an addon\n+-------------------\n+\n+An individual addon can be upgraded by issuing a ``POST`` to the given URL:\n+\n+..  http:example:: curl httpie python-requests\n+    :request: ../../src/plone/restapi/tests/http-examples/addons_upgrade.req\n+\n+.. literalinclude:: ../../src/plone/restapi/tests/http-examples/addons_upgrade.resp\n+   :language: http\ndiff --git a/docs/source/index.rst b/docs/source/index.rst\nindex 18cc8eaf..a854f39e 100644\n--- a/docs/source/index.rst\n+++ b/docs/source/index.rst\n@@ -24,6 +24,7 @@ Contents\n    blocks\n    history\n    batching\n+   addons\n    comments\n    copymove\n    expansion\ndiff --git a/news/733.feature b/news/733.feature\nnew file mode 100644\nindex 00000000..4cbf72c1\n--- /dev/null\n+++ b/news/733.feature\n@@ -0,0 +1 @@\n+Add endpoints for managing addons. [esteele]\ndiff --git a/src/plone/restapi/services/addons/__init__.py b/src/plone/restapi/services/addons/__init__.py\nnew file mode 100644\nindex 00000000..e69de29b\ndiff --git a/src/plone/restapi/services/addons/addons.py b/src/plone/restapi/services/addons/addons.py\nnew file mode 100644\nindex 00000000..0d68affa\n--- /dev/null\n+++ b/src/plone/restapi/services/addons/addons.py\n@@ -0,0 +1,515 @@\n+# -*- coding: utf-8 -*-\n+\n+from plone.memoize import view\n+from Products.CMFCore.utils import getToolByName\n+from Products.CMFPlone import PloneMessageFactory as _\n+from Products.CMFPlone.interfaces import INonInstallable\n+from Products.CMFQuickInstallerTool.interfaces import (\n+    INonInstallable as QINonInstallable,\n+)\n+from Products.GenericSetup import EXTENSION\n+from Products.GenericSetup.tool import UNKNOWN\n+from zope.component import getAllUtilitiesRegisteredFor\n+\n+import logging\n+import pkg_resources\n+\n+\n+logger = logging.getLogger("Plone")\n+\n+\n+class Addons(object):\n+    """Performs install/upgrade/uninstall functions on an addon.\n+       Pulled, mostly intact, from Plone 5.1\'s products control panel.\n+       If we reach the point when plone.restapi isn\'t supporting releases\n+       prior to 5.1, we might be able to remove this as duplicate code.\n+    """\n+\n+    def __init__(self, context, request):\n+        self.context = context\n+        self.request = request\n+\n+        self.ps = getToolByName(context, "portal_setup")\n+        self.errors = {}\n+\n+    def serializeAddon(self, addon):\n+        return {\n+            "@id": "{}/@addons/{}".format(self.context.absolute_url(), addon["id"]),\n+            "id": addon["id"],\n+            "title": addon["title"],\n+            "description": addon["description"],\n+            "install_profile_id": addon["install_profile_id"],\n+            "is_installed": addon["is_installed"],\n+            "profile_type": addon["profile_type"],\n+            "uninstall_profile_id": addon["uninstall_profile_id"],\n+            "version": addon["version"],\n+            "upgrade_info": addon["upgrade_info"],\n+        }\n+\n+    def is_profile_installed(self, profile_id):\n+        return self.ps.getLastVersionForProfile(profile_id) != UNKNOWN\n+\n+    def is_product_installed(self, product_id):\n+        profile = self.get_install_profile(product_id, allow_hidden=True)\n+        if not profile:\n+            return False\n+        return self.is_profile_installed(profile["id"])\n+\n+    def _install_profile_info(self, product_id):\n+        """List extension profile infos of a given product.\n+\n+        From CMFQuickInstallerTool/QuickInstallerTool.py\n+        _install_profile_info\n+        """\n+        profiles = self.ps.listProfileInfo()\n+        # We are only interested in extension profiles for the product.\n+        # TODO Remove the manual Products.* check here. It is still needed.\n+        profiles = [\n+            prof\n+            for prof in profiles\n+            if prof["type"] == EXTENSION\n+            and (prof["product"] in (product_id, "Products.{0}".format(product_id),))\n+        ]\n+        return profiles\n+\n+    def _get_profile(self, product_id, name, strict=True, allow_hidden=False):\n+        """Return profile with given name.\n+\n+        Also return None when no profiles are found at all.\n+\n+        :param product_id: id of product/package.\n+            For example CMFPlone or plone.app.registry.\n+        :type product_id: string\n+        :param name: name of profile.\n+            Usually \'default\' or \'uninstall\'.\n+        :type name: string\n+        :param strict: When True, return None when name is not found.\n+            Otherwise fall back to the first profile.\n+        :type strict: boolean\n+        :param allow_hidden: Allow getting hidden profile.\n+            A non hidden profile is always preferred.\n+        :type allow_hidden: boolean\n+        :returns: True on success, False otherwise.\n+        :rtype: boolean\n+        """\n+        profiles = self._install_profile_info(product_id)\n+        if not profiles:\n+            return\n+        utils = getAllUtilitiesRegisteredFor(INonInstallable)\n+        hidden = []\n+        for util in utils:\n+            gnip = getattr(util, "getNonInstallableProfiles", None)\n+            if gnip is None:\n+                continue\n+            hidden.extend(gnip())\n+\n+        # We have prime candidates that we prefer, and have hidden candidates\n+        # in case allow_hidden is True.\n+        prime_candidates = []\n+        hidden_candidates = []\n+        for profile in profiles:\n+            profile_id = profile["id"]\n+            profile_id_parts = profile_id.split(":")\n+            if len(profile_id_parts) != 2:\n+                logger.error("Profile with id \'%s\' is invalid." % profile_id)\n+                continue\n+            if allow_hidden and profile_id in hidden:\n+                if profile_id_parts[1] == name:\n+                    # This will especially be true for uninstall profiles,\n+                    # which are usually hidden.\n+                    return profile\n+                hidden_candidates.append(profile)\n+                continue\n+            if profile_id_parts[1] == name:\n+                return profile\n+            prime_candidates.append(profile)\n+        if strict:\n+            return\n+        if prime_candidates:\n+            # QI used to pick the first profile.\n+            # Return the first profile after all.\n+            return prime_candidates[0]\n+        if allow_hidden and hidden_candidates:\n+            # Return the first hidden profile.\n+            return hidden_candidates[0]\n+\n+    def get_install_profile(self, product_id, allow_hidden=False):\n+        """Return the default install profile.\n+\n+        From CMFQuickInstallerTool/QuickInstallerTool.py\n+        getInstallProfile\n+\n+        :param product_id: id of product/package\n+        :type product_id: string\n+        :param allow_hidden: Allow getting otherwise hidden profile.\n+            In the UI this will be False, but you can set it to True in\n+            for example a call from plone.app.upgrade where you want to\n+            install a new core product, even though it is hidden for users.\n+        :type allow_hidden: boolean\n+        :returns: True on success, False otherwise.\n+        :rtype: boolean\n+        """\n+        return self._get_profile(\n+            product_id, "default", strict=False, allow_hidden=allow_hidden\n+        )\n+\n+    def get_uninstall_profile(self, product_id):\n+        """Return the uninstall profile.\n+\n+        Note: not used yet.\n+        """\n+        return self._get_profile(\n+            product_id, "uninstall", strict=True, allow_hidden=True\n+        )\n+\n+    def is_product_installable(self, product_id, allow_hidden=False):\n+        """Does a product have an installation profile?\n+\n+        From CMFQuickInstallerTool/QuickInstallerTool.py\n+        isProductInstallable (and the deprecated isProductAvailable)\n+\n+        :param allow_hidden: Allow installing otherwise hidden products.\n+            In the UI this will be False, but you can set it to True in\n+            for example a call from plone.app.upgrade where you want to\n+            install a new core product, even though it is hidden for users.\n+        :type allow_hidden: boolean\n+        :returns: True when product is installable, False otherwise.\n+        :rtype: boolean\n+        """\n+        if not allow_hidden:\n+            not_installable = []\n+            utils = getAllUtilitiesRegisteredFor(INonInstallable)\n+            for util in utils:\n+                gnip = getattr(util, "getNonInstallableProducts", None)\n+                if gnip is None:\n+                    continue\n+                not_installable.extend(gnip())\n+            if product_id in not_installable:\n+                return False\n+            # BBB.  For backwards compatibility, we try the INonInstallable\n+            # from the old QI as well.\n+            not_installable = []\n+            utils = getAllUtilitiesRegisteredFor(QINonInstallable)\n+            for util in utils:\n+                not_installable.extend(util.getNonInstallableProducts())\n+            if product_id in not_installable:\n+                return False\n+\n+        profile = self.get_install_profile(product_id, allow_hidden=allow_hidden)\n+        if profile is None:\n+            return\n+        try:\n+            self.ps.getProfileDependencyChain(profile["id"])\n+        except KeyError as e:\n+            # Don\'t show twice the same error: old install and profile\n+            # oldinstall is test in first in other methods we may have an extra\n+            # \'Products.\' in the namespace.\n+            #\n+            # TODO:\n+            # 1. Make sense of the previous comment.\n+            # 2. Possibly remove the special case for \'Products\'.\n+            # 3. Make sense of the next five lines: they remove \'Products.\'\n+            #    when it is there, and add it when it is not???\n+            checkname = product_id\n+            if checkname.startswith("Products."):\n+                checkname = checkname[9:]\n+            else:\n+                checkname = "Products." + checkname\n+            if checkname in self.errors:\n+                if self.errors[checkname]["value"] == e.args[0]:\n+                    return False\n+                # A new error is found, register it\n+                self.errors[product_id] = dict(\n+                    type=_(u"dependency_missing", default=u"Missing dependency"),\n+                    value=e.args[0],\n+                    product_id=product_id,\n+                )\n+            else:\n+                self.errors[product_id] = dict(\n+                    type=_(u"dependency_missing", default=u"Missing dependency"),\n+                    value=e.args[0],\n+                    product_id=product_id,\n+                )\n+            return False\n+        return True\n+\n+    def get_product_version(self, product_id):\n+        """Return the version of the product (package).\n+\n+        From CMFQuickInstallerTool/QuickInstallerTool\n+        getProductVersion\n+        That implementation used to fall back to getting the version.txt.\n+        """\n+        try:\n+            dist = pkg_resources.get_distribution(product_id)\n+            return dist.version\n+        except pkg_resources.DistributionNotFound:\n+            if "." in product_id:\n+                return ""\n+        # For CMFPlacefulWorkflow we need to try Products.CMFPlacefulWorkflow.\n+        return self.get_product_version("Products." + product_id)\n+\n+    def get_latest_upgrade_step(self, profile_id):\n+        """Get highest ordered upgrade step for profile.\n+\n+        If anything errors out then go back to "old way" by returning\n+        \'unknown\'.\n+\n+        From CMFPlone/QuickInstallerTool.py getLatestUpgradeStep\n+        """\n+        profile_version = UNKNOWN\n+        try:\n+            available = self.ps.listUpgrades(profile_id, True)\n+            if available:  # could return empty sequence\n+                latest = available[-1]\n+                profile_version = max(latest["dest"], key=pkg_resources.parse_version)\n+        except Exception:\n+            pass\n+        return profile_version\n+\n+    def upgrade_info(self, product_id):\n+        """Returns upgrade info for a product.\n+\n+        This is a dict with among others two booleans values, stating if\n+        an upgrade is required and available.\n+\n+        From CMFPlone/QuickInstaller.py upgradeInfo\n+\n+        :param product_id: id of product/package\n+        :type product_id: string\n+        :returns: dictionary with info about product\n+        :rtype: dict\n+        """\n+        available = self.is_product_installable(product_id, allow_hidden=True)\n+        if not available:\n+            return {}\n+        profile = self.get_install_profile(product_id, allow_hidden=True)\n+        if profile is None:\n+            # No GS profile, not supported.\n+            return {}\n+        profile_id = profile["id"]\n+        if not self.is_profile_installed(profile_id):\n+            return {}\n+        profile_version = str(self.ps.getVersionForProfile(profile_id))\n+        if profile_version == "latest":\n+            profile_version = self.get_latest_upgrade_step(profile_id)\n+        if profile_version == UNKNOWN:\n+            # If a profile doesn\'t have a metadata.xml use the package version.\n+            profile_version = self.get_product_version(product_id)\n+        installed_profile_version = self.ps.getLastVersionForProfile(profile_id)\n+        # getLastVersionForProfile returns the version as a tuple or unknown.\n+        if installed_profile_version != UNKNOWN:\n+            installed_profile_version = str(".".join(installed_profile_version))\n+        return dict(\n+            required=profile_version != installed_profile_version,\n+            available=len(self.ps.listUpgrades(profile_id)) > 0,\n+            hasProfile=True,  # TODO hasProfile is always True now.\n+            installedVersion=installed_profile_version,\n+            newVersion=profile_version,\n+        )\n+\n+    def upgrade_product(self, product_id):\n+        """Run the upgrade steps for a product.\n+\n+        Returns True on success, False otherwise.\n+        """\n+        profile = self.get_install_profile(product_id, allow_hidden=True)\n+        if profile is None:\n+            logger.error("Could not upgrade %s, no profile.", product_id)\n+            return False\n+        self.ps.upgradeProfile(profile["id"])\n+        return True\n+\n+    def install_product(self, product_id, allow_hidden=False):\n+        """Install a product by name.\n+\n+        From CMFQuickInstallerTool/QuickInstallerTool.py installProduct\n+\n+        :param product_id: id of product/package\n+        :type product_id: string\n+        :param allow_hidden: Allow installing otherwise hidden products.\n+            In the UI this will be False, but you can set it to True in\n+            for example a call from plone.app.upgrade where you want to\n+            install a new core product, even though it is hidden for users.\n+        :type allow_hidden: boolean\n+        :returns: True on success, False otherwise.\n+        :rtype: boolean\n+        """\n+        profile = self.get_install_profile(product_id, allow_hidden=allow_hidden)\n+        if not profile:\n+            logger.error("Could not install %s: no profile found.", product_id)\n+            # TODO Possibly raise an error.\n+            return False\n+\n+        if self.is_product_installed(product_id):\n+            logger.error("Could not install %s: profile already installed.", product_id)\n+            return False\n+\n+        # Okay, actually install the profile.\n+        profile_id = profile["id"]\n+        self.ps.runAllImportStepsFromProfile("profile-%s" % profile_id)\n+\n+        if not self.is_profile_installed(profile_id):\n+            version = self.get_product_version(product_id)\n+            logger.warn(\n+                "Profile %s has no metadata.xml version. Falling back "\n+                "to package version %s",\n+                profile_id,\n+                version,\n+            )\n+            self.ps.setLastVersionForProfile(profile_id, version)\n+\n+        # No problems encountered.\n+        return True\n+\n+    def uninstall_product(self, product_id):\n+        """Uninstall a product by name.\n+\n+        Returns True on success, False otherwise.\n+        """\n+        profile = self.get_uninstall_profile(product_id)\n+        if not profile:\n+            logger.error(\n+                "Could not uninstall %s: no uninstall profile " "found.", product_id\n+            )\n+            return False\n+\n+        self.ps.runAllImportStepsFromProfile("profile-%s" % profile["id"])\n+\n+        # Unmark the install profile.\n+        install_profile = self.get_install_profile(product_id, allow_hidden=True)\n+        if install_profile:\n+            self.ps.unsetLastVersionForProfile(install_profile["id"])\n+        return True\n+\n+    @view.memoize\n+    def marshall_addons(self):\n+        addons = {}\n+\n+        ignore_profiles = []\n+        ignore_products = []\n+        utils = getAllUtilitiesRegisteredFor(INonInstallable)\n+        for util in utils:\n+            ni_profiles = getattr(util, "getNonInstallableProfiles", None)\n+            if ni_profiles is not None:\n+                ignore_profiles.extend(ni_profiles())\n+            ni_products = getattr(util, "getNonInstallableProducts", None)\n+            if ni_products is not None:\n+                ignore_products.extend(ni_products())\n+\n+        # Known profiles:\n+        profiles = self.ps.listProfileInfo()\n+        # Profiles that have upgrade steps (which may or may not have been\n+        # applied already).\n+        # profiles_with_upgrades = self.ps.listProfilesWithUpgrades()\n+        for profile in profiles:\n+            if profile["type"] != EXTENSION:\n+                continue\n+\n+            pid = profile["id"]\n+            if pid in ignore_profiles:\n+                continue\n+            pid_parts = pid.split(":")\n+            if len(pid_parts) != 2:\n+                logger.error("Profile with id \'%s\' is invalid." % pid)\n+            # Which package (product) is this from?\n+            product_id = profile["product"]\n+            if product_id in ignore_products:\n+                continue\n+            profile_type = pid_parts[-1]\n+            if product_id not in addons:\n+                # get some basic information on the product\n+                installed = self.is_product_installed(product_id)\n+                upgrade_info = {}\n+                if installed:\n+                    upgrade_info = self.upgrade_info(product_id)\n+                elif not self.is_product_installable(product_id):\n+                    continue\n+                addons[product_id] = {\n+                    "id": product_id,\n+                    "version": self.get_product_version(product_id),\n+                    "title": product_id,\n+                    "description": "",\n+                    "upgrade_profiles": {},\n+                    "other_profiles": [],\n+                    "install_profile": None,\n+                    "install_profile_id": "",\n+                    "uninstall_profile": None,\n+                    "uninstall_profile_id": "",\n+                    "is_installed": installed,\n+                    "upgrade_info": upgrade_info,\n+                    "profile_type": profile_type,\n+                }\n+                # Add info on install and uninstall profile.\n+                product = addons[product_id]\n+                install_profile = self.get_install_profile(product_id)\n+                if install_profile is not None:\n+                    product["title"] = install_profile["title"]\n+                    product["description"] = install_profile["description"]\n+                    product["install_profile"] = install_profile\n+                    product["install_profile_id"] = install_profile["id"]\n+                    product["profile_type"] = "default"\n+                uninstall_profile = self.get_uninstall_profile(product_id)\n+                if uninstall_profile is not None:\n+                    product["uninstall_profile"] = uninstall_profile\n+                    product["uninstall_profile_id"] = uninstall_profile["id"]\n+                    # Do not override profile_type.\n+                    if not product["profile_type"]:\n+                        product["profile_type"] = "uninstall"\n+            if profile["id"] in (\n+                product["install_profile_id"],\n+                product["uninstall_profile_id"],\n+            ):\n+                # Everything has been done.\n+                continue\n+            elif "version" in profile:\n+                product["upgrade_profiles"][profile["version"]] = profile\n+            else:\n+                product["other_profiles"].append(profile)\n+        return addons\n+\n+    def get_addons(self, apply_filter=None, product_name=None):\n+        """\n+        100% based on generic setup profiles now. Kinda.\n+        For products magic, use the zope quickinstaller I guess.\n+\n+        @filter:= \'installed\': only products that are installed and not hidden\n+                  \'upgrades\': only products with upgrades\n+                  \'available\': products that are not installed bit\n+                               could be\n+                  \'broken\': uninstallable products with broken\n+                            dependencies\n+\n+        @product_name:= a specific product id that you want info on. Do\n+                   not pass in the profile type, just the name\n+\n+        XXX: I am pretty sure we don\'t want base profiles ...\n+        """\n+        addons = self.marshall_addons()\n+        filtered = {}\n+        if apply_filter == "broken":\n+            all_broken = self.errors.values()\n+            for broken in all_broken:\n+                filtered[broken["product_id"]] = broken\n+        else:\n+            for product_id, addon in addons.items():\n+                if product_name and addon["id"] != product_name:\n+                    continue\n+\n+                installed = addon["is_installed"]\n+                if apply_filter in ["installed", "upgrades"] and not installed:\n+                    continue\n+                elif apply_filter == "available":\n+                    if installed:\n+                        continue\n+                    # filter out upgrade profiles\n+                    if addon["profile_type"] != "default":\n+                        continue\n+                elif apply_filter == "upgrades":\n+                    upgrade_info = addon["upgrade_info"]\n+                    if not upgrade_info.get("available"):\n+                        continue\n+\n+                filtered[product_id] = addon\n+\n+        return filtered\ndiff --git a/src/plone/restapi/services/addons/configure.zcml b/src/plone/restapi/services/addons/configure.zcml\nnew file mode 100644\nindex 00000000..99a1c6be\n--- /dev/null\n+++ b/src/plone/restapi/services/addons/configure.zcml\n@@ -0,0 +1,21 @@\n+<configure\n+    xmlns="http://namespaces.zope.org/zope"\n+    xmlns:plone="http://namespaces.plone.org/plone">\n+\n+  <plone:service\n+    method="GET"\n+    for="zope.interface.Interface"\n+    factory=".get.AddonsGet"\n+    name="@addons"\n+    permission="cmf.ManagePortal"\n+    />\n+\n+  <plone:service\n+    method="POST"\n+    for="Products.CMFPlone.interfaces.IPloneSiteRoot"\n+    factory=".post.AddonsPost"\n+    name="@addons"\n+    permission="cmf.ManagePortal"\n+    />\n+\n+</configure>\ndiff --git a/src/plone/restapi/services/addons/get.py b/src/plone/restapi/services/addons/get.py\nnew file mode 100644\nindex 00000000..87d2f605\n--- /dev/null\n+++ b/src/plone/restapi/services/addons/get.py\n@@ -0,0 +1,37 @@\n+# -*- coding: utf-8 -*-\n+from plone.restapi.services import Service\n+from plone.restapi.services.addons.addons import Addons\n+from zope.interface import implementer\n+from zope.publisher.interfaces import IPublishTraverse\n+\n+\n+@implementer(IPublishTraverse)\n+class AddonsGet(Service):\n+    def __init__(self, context, request):\n+        super(AddonsGet, self).__init__(context, request)\n+        self.params = []\n+        self.addons = Addons(context, request)\n+\n+    def publishTraverse(self, request, name):\n+        # Consume any path segments after /@addons as parameters\n+        self.params.append(name)\n+        return self\n+\n+    def reply(self):\n+        all_addons = self.addons.get_addons()\n+\n+        if self.params:\n+            if self.params[0] in all_addons:\n+                return self.addons.serializeAddon(all_addons[self.params[0]])\n+            else:\n+                return []\n+\n+        result = {\n+            "items": {"@id": "{}/@addons".format(self.context.absolute_url())},\n+        }\n+        addons_data = []\n+        for addon in all_addons.values():\n+            addons_data.append(self.addons.serializeAddon(addon))\n+        result["items"] = addons_data\n+        self.request.response.setStatus(200)\n+        return result\ndiff --git a/src/plone/restapi/services/addons/post.py b/src/plone/restapi/services/addons/post.py\nnew file mode 100644\nindex 00000000..b8f2ed1b\n--- /dev/null\n+++ b/src/plone/restapi/services/addons/post.py\n@@ -0,0 +1,67 @@\n+# -*- coding: utf-8 -*-\n+\n+from plone.restapi.services import Service\n+from plone.restapi.services.addons.addons import Addons\n+from zope.component import getMultiAdapter\n+from zope.interface import alsoProvides\n+from zope.interface import implementer\n+from zope.publisher.interfaces import IPublishTraverse\n+\n+import logging\n+import plone\n+\n+\n+logger = logging.getLogger("Plone")\n+\n+\n+@implementer(IPublishTraverse)\n+class AddonsPost(Service):\n+    """Performs install/upgrade/uninstall functions on an addon."""\n+\n+    def __init__(self, context, request):\n+        super(AddonsPost, self).__init__(context, request)\n+        self.params = []\n+        self.errors = {}\n+        self.addons = Addons(context, request)\n+\n+    def publishTraverse(self, request, name):\n+        # Consume any path segments after /@addons as parameters\n+        self.params.append(name)\n+        return self\n+\n+    def reply(self):\n+        addon, action = self.params\n+\n+        # Disable CSRF protection\n+        if "IDisableCSRFProtection" in dir(plone.protect.interfaces):\n+            alsoProvides(self.request, plone.protect.interfaces.IDisableCSRFProtection)\n+\n+        if action == "install":\n+            result = self.addons.install_product(addon)\n+        elif action == "uninstall":\n+            result = self.addons.uninstall_product(addon)\n+        elif action == "upgrade":\n+            result = self.addons.upgrade_product(addon)\n+        else:\n+            raise Exception("Unknown action {}".format(action))\n+\n+        prefer = self.request.getHeader("Prefer")\n+        if prefer == "return=representation":\n+            control_panel = getMultiAdapter(\n+                (self.context, self.request), name="prefs_install_products_form"\n+            )\n+            all_addons = control_panel.get_addons()\n+\n+            result = {\n+                "items": {"@id": "{}/@addons".format(self.context.absolute_url())}\n+            }\n+            addons_data = []\n+            for a in all_addons.values():\n+                addons_data.append(self.addons.serializeAddon(a))\n+            result["items"] = addons_data\n+\n+            self.request.response.setStatus(200)\n+            return result\n+        else:\n+            self.request.response.setStatus(204)\n+            return None\ndiff --git a/src/plone/restapi/services/configure.zcml b/src/plone/restapi/services/configure.zcml\nindex 5ba9cc26..42339ff1 100644\n--- a/src/plone/restapi/services/configure.zcml\n+++ b/src/plone/restapi/services/configure.zcml\n@@ -7,6 +7,8 @@\n \n   <include package=".auth" />\n   <include package=".actions" />\n+  <include package=".addons"\n+      zcml:condition="have plone-5"/>\n   <include package=".breadcrumbs"/>\n   <include package=".content"/>\n   <configure zcml:condition="have plone-5">\ndiff --git a/src/plone/restapi/tests/http-examples/addons_get.req b/src/plone/restapi/tests/http-examples/addons_get.req\nnew file mode 100644\nindex 00000000..d0d5b155\n--- /dev/null\n+++ b/src/plone/restapi/tests/http-examples/addons_get.req\n@@ -0,0 +1,3 @@\n+GET /plone/@addons/plone.session HTTP/1.1\n+Accept: application/json\n+Authorization: Basic YWRtaW46c2VjcmV0\ndiff --git a/src/plone/restapi/tests/http-examples/addons_get.resp b/src/plone/restapi/tests/http-examples/addons_get.resp\nnew file mode 100644\nindex 00000000..1e3be5ff\n--- /dev/null\n+++ b/src/plone/restapi/tests/http-examples/addons_get.resp\n@@ -0,0 +1,38 @@\n+HTTP/1.1 200 OK\n+Content-Type: application/json\n+\n+{\n+  "@id": "http://localhost:55001/plone/@addon/plone.session",\n+  "description": "Optional plone.session refresh support.",\n+  "profile_type": "default",\n+  "upgrade_profiles": {},\n+  "uninstall_profile_id": "plone.session:uninstall",\n+  "other_profiles": [],\n+  "is_installed": false,\n+  "id": "plone.session",\n+  "install_profile": {\n+    "product": "plone.session",\n+    "description": "Optional plone.session refresh support.",\n+    "for": null,\n+    "title": "Session refresh support",\n+    "pre_handler": null,\n+    "version": "1001",\n+    "type": 2,\n+    "id": "plone.session:default",\n+    "post_handler": null\n+  },\n+  "title": "Session refresh support",\n+  "uninstall_profile": {\n+    "product": "plone.session",\n+    "description": "Optional plone.session refresh support. [uninstall]",\n+    "for": null,\n+    "title": "Session refresh support [uninstall]",\n+    "pre_handler": null,\n+    "type": 2,\n+    "id": "plone.session:uninstall",\n+    "post_handler": null\n+  },\n+  "install_profile_id": "plone.session:default",\n+  "version": "3.7.0",\n+  "upgrade_info": {}\n+}\n\\ No newline at end of file\ndiff --git a/src/plone/restapi/tests/http-examples/addons_get_list.req b/src/plone/restapi/tests/http-examples/addons_get_list.req\nnew file mode 100644\nindex 00000000..86280d95\n--- /dev/null\n+++ b/src/plone/restapi/tests/http-examples/addons_get_list.req\n@@ -0,0 +1,3 @@\n+GET /plone/@addons HTTP/1.1\n+Accept: application/json\n+Authorization: Basic YWRtaW46c2VjcmV0\ndiff --git a/src/plone/restapi/tests/http-examples/addons_get_list.resp b/src/plone/restapi/tests/http-examples/addons_get_list.resp\nnew file mode 100644\nindex 00000000..ee55f71c\n--- /dev/null\n+++ b/src/plone/restapi/tests/http-examples/addons_get_list.resp\n@@ -0,0 +1,43 @@\n+HTTP/1.1 200 OK\n+Content-Type: application/json\n+\n+{\n+  "@id": "http://localhost:55001/plone/@addons",\n+  "items": [\n+    {\n+      "description": "Optional plone.session refresh support.",\n+      "profile_type": "default",\n+      "upgrade_profiles": {},\n+      "uninstall_profile_id": "plone.session:uninstall",\n+      "other_profiles": [],\n+      "is_installed": "FALSE",\n+      "id": "plone.session",\n+      "install_profile": {\n+        "product": "plone.session",\n+        "description": "Optional plone.session refresh support.",\n+        "for": "NULL",\n+        "title": "Session refresh support",\n+        "pre_handler": "NULL",\n+        "version": "1001",\n+        "type": 2,\n+        "id": "plone.session:default",\n+        "post_handler": "NULL"\n+      },\n+      "title": "Session refresh support",\n+      "uninstall_profile": {\n+        "product": "plone.session",\n+        "description": "Optional plone.session refresh support. [uninstall]",\n+        "for": "NULL",\n+        "title": "Session refresh support [uninstall]",\n+        "pre_handler": "NULL",\n+        "type": 2,\n+        "id": "plone.session:uninstall",\n+        "post_handler": "NULL"\n+      },\n+      "install_profile_id": "plone.session:default",\n+      "version": "3.7.0",\n+      "upgrade_info": {}\n+    }\n+  ],\n+  "items_total": 16\n+}\n\\ No newline at end of file\ndiff --git a/src/plone/restapi/tests/http-examples/addons_install.req b/src/plone/restapi/tests/http-examples/addons_install.req\nnew file mode 100644\nindex 00000000..5bf21a3e\n--- /dev/null\n+++ b/src/plone/restapi/tests/http-examples/addons_install.req\n@@ -0,0 +1,3 @@\n+POST /plone/@addons/plone.session/install HTTP/1.1\n+Accept: application/json\n+Authorization: Basic YWRtaW46c2VjcmV0\ndiff --git a/src/plone/restapi/tests/http-examples/addons_install.resp b/src/plone/restapi/tests/http-examples/addons_install.resp\nnew file mode 100644\nindex 00000000..79ba4d3f\n--- /dev/null\n+++ b/src/plone/restapi/tests/http-examples/addons_install.resp\n@@ -0,0 +1 @@\n+HTTP/1.1 204 No Content\n\\ No newline at end of file\ndiff --git a/src/plone/restapi/tests/http-examples/addons_uninstall.req b/src/plone/restapi/tests/http-examples/addons_uninstall.req\nnew file mode 100644\nindex 00000000..d26ba7cb\n--- /dev/null\n+++ b/src/plone/restapi/tests/http-examples/addons_uninstall.req\n@@ -0,0 +1,3 @@\n+POST /plone/@addons/plone.session/uninstall HTTP/1.1\n+Accept: application/json\n+Authorization: Basic YWRtaW46c2VjcmV0\ndiff --git a/src/plone/restapi/tests/http-examples/addons_uninstall.resp b/src/plone/restapi/tests/http-examples/addons_uninstall.resp\nnew file mode 100644\nindex 00000000..79ba4d3f\n--- /dev/null\n+++ b/src/plone/restapi/tests/http-examples/addons_uninstall.resp\n@@ -0,0 +1 @@\n+HTTP/1.1 204 No Content\n\\ No newline at end of file\ndiff --git a/src/plone/restapi/tests/http-examples/addons_upgrade.req b/src/plone/restapi/tests/http-examples/addons_upgrade.req\nnew file mode 100644\nindex 00000000..712cdba6\n--- /dev/null\n+++ b/src/plone/restapi/tests/http-examples/addons_upgrade.req\n@@ -0,0 +1,3 @@\n+POST /plone/@addons/plone.session/upgrade HTTP/1.1\n+Accept: application/json\n+Authorization: Basic YWRtaW46c2VjcmV0\ndiff --git a/src/plone/restapi/tests/http-examples/addons_upgrade.resp b/src/plone/restapi/tests/http-examples/addons_upgrade.resp\nnew file mode 100644\nindex 00000000..79ba4d3f\n--- /dev/null\n+++ b/src/plone/restapi/tests/http-examples/addons_upgrade.resp\n@@ -0,0 +1 @@\n+HTTP/1.1 204 No Content\n\\ No newline at end of file\ndiff --git a/src/plone/restapi/tests/test_addons.py b/src/plone/restapi/tests/test_addons.py\nnew file mode 100644\nindex 00000000..fa622a10\n--- /dev/null\n+++ b/src/plone/restapi/tests/test_addons.py\n@@ -0,0 +1,191 @@\n+# -*- coding: utf-8 -*-\n+from pkg_resources import parse_version\n+from plone import api\n+from plone.app.testing import setRoles\n+from plone.app.testing import SITE_OWNER_NAME\n+from plone.app.testing import SITE_OWNER_PASSWORD\n+from plone.app.testing import TEST_USER_ID\n+from plone.restapi.testing import PLONE_RESTAPI_DX_FUNCTIONAL_TESTING\n+from plone.restapi.testing import RelativeSession\n+from Products.CMFCore.utils import getToolByName\n+from Products.CMFPlone.utils import safe_unicode\n+\n+import transaction\n+import unittest\n+\n+\n+PLONE_VERSION = parse_version(api.env.plone_version())\n+\n+try:\n+    from Products.CMFPlone.factory import _IMREALLYPLONE5  # noqa\n+except ImportError:\n+    PLONE5 = False\n+else:\n+    PLONE5 = True\n+\n+\n+@unittest.skipIf(not PLONE5, "Just Plone 5 currently.")\n+class TestAddons(unittest.TestCase):\n+\n+    layer = PLONE_RESTAPI_DX_FUNCTIONAL_TESTING\n+\n+    def setUp(self):\n+        self.app = self.layer["app"]\n+        self.portal = self.layer["portal"]\n+        self.ps = getToolByName(self.portal, "portal_setup")\n+        self.portal_url = self.portal.absolute_url()\n+        setRoles(self.portal, TEST_USER_ID, ["Manager"])\n+\n+        self.api_session = RelativeSession(self.portal_url)\n+        self.api_session.headers.update({"Accept": "application/json"})\n+        self.api_session.auth = (SITE_OWNER_NAME, SITE_OWNER_PASSWORD)\n+\n+    def test_get_addon_record(self):\n+        response = self.api_session.get("/@addons/plone.session")\n+\n+        self.assertEqual(response.status_code, 200)\n+        result = response.json()\n+\n+        self.assertEqual(result["@id"], self.portal_url + u"/@addons/plone.session")\n+        self.assertEqual(result["id"], u"plone.session")\n+        # self.assertEqual(result[\'is_installed\'], False)\n+        self.assertEqual(result["title"], u"Session refresh support")\n+        self.assertEqual(\n+            result["description"], u"Optional plone.session refresh support."\n+        )\n+        self.assertEqual(result["profile_type"], u"default")\n+        self.assertEqual(result["upgrade_info"], {})\n+        self.assertEqual(result["install_profile_id"], u"plone.session:default")\n+\n+    def test_get_addon_listing(self):\n+        response = self.api_session.get("/@addons")\n+\n+        self.assertEqual(response.status_code, 200)\n+        response = response.json()\n+        self.assertIn("items", response)\n+\n+    def test_install_uninstall_addon(self):\n+        def _get_install_status(self):\n+            response = self.api_session.get("/@addons/plone.session")\n+            result = response.json()\n+            return result["is_installed"]\n+\n+        # Check to make sure the addon is currently shown as not installed\n+        self.assertEqual(_get_install_status(self), False)\n+\n+        response = self.api_session.post("/@addons/plone.session/install")\n+        self.assertEqual(response.status_code, 204)\n+        self.assertEqual(safe_unicode(response.content), "")\n+\n+        # Check to make sure the addon is currently shown as installed\n+        self.assertEqual(_get_install_status(self), True)\n+\n+        # Now uninstall the addon\n+        response = self.api_session.post("/@addons/plone.session/uninstall")\n+        self.assertEqual(response.status_code, 204)\n+        self.assertEqual(safe_unicode(response.content), "")\n+\n+        # Check to make sure the addon is currently shown as not installed\n+        self.assertEqual(_get_install_status(self), False)\n+\n+    def test_install_uninstall_addon_with_representation(self):\n+\n+        # Check to make sure the addon is currently shown as not installed\n+        response = self.api_session.get("/@addons/plone.session")\n+        result = response.json()\n+        self.assertEqual(result["is_installed"], False)\n+\n+        # Install the addon\n+        response = self.api_session.post(\n+            "/@addons/plone.session/install",\n+            headers={"Prefer": "return=representation"},\n+        )\n+        self.assertEqual(response.status_code, 200)\n+        result = response.json()\n+\n+        # Check to make sure the addon is currently shown as installed\n+        session = [a for a in result["items"] if a["id"] == u"plone.session"]\n+        self.assertEqual(len(session), 1)\n+        self.assertTrue(session[0]["is_installed"])\n+\n+        # Now uninstall the addon\n+        response = self.api_session.post(\n+            "/@addons/plone.session/uninstall",\n+            headers={"Prefer": "return=representation"},\n+        )\n+        self.assertEqual(response.status_code, 200)\n+        result = response.json()\n+\n+        # Check to make sure the addon is currently shown as not installed\n+        session = [a for a in result["items"] if a["id"] == u"plone.session"]\n+        self.assertEqual(len(session), 1)\n+        self.assertFalse(session[0]["is_installed"])\n+\n+    def test_upgrade_addon(self):\n+        def _get_upgrade_info(self):\n+            response = self.api_session.get("/@addons/plone.restapi")\n+            result = response.json()\n+            return result["upgrade_info"]\n+\n+        # Set need upgrade state\n+        self.ps.setLastVersionForProfile("plone.restapi:default", "0002")\n+        transaction.commit()\n+        self.assertEqual(\n+            {\n+                "available": True,\n+                "hasProfile": True,\n+                "installedVersion": "0002",\n+                "newVersion": "0006",\n+                "required": True,\n+            },\n+            _get_upgrade_info(self),\n+        )\n+\n+        # Now call the upgrade\n+        response = self.api_session.post("/@addons/plone.restapi/upgrade")\n+        self.assertEqual(response.status_code, 204)\n+        self.assertEqual(safe_unicode(response.content), "")\n+        self.assertEqual(\n+            {\n+                "available": False,\n+                "hasProfile": True,\n+                "installedVersion": "0006",\n+                "newVersion": "0006",\n+                "required": False,\n+            },\n+            _get_upgrade_info(self),\n+        )\n+\n+    def test_upgrade_addon_with_representation(self):\n+        response = self.api_session.get("/@addons/plone.restapi")\n+        result = response.json()\n+        last_version = result["upgrade_info"]\n+\n+        # Set need upgrade state\n+        self.ps.setLastVersionForProfile("plone.restapi:default", "0002")\n+        transaction.commit()\n+        response = self.api_session.get("/@addons/plone.restapi")\n+        result = response.json()\n+        self.assertEqual(\n+            {\n+                "available": True,\n+                "hasProfile": True,\n+                "installedVersion": "0002",\n+                "newVersion": last_version["newVersion"],\n+                "required": True,\n+            },\n+            result["upgrade_info"],\n+        )\n+\n+        # Now call the upgrade\n+        response = self.api_session.post(\n+            "/@addons/plone.restapi/upgrade",\n+            headers={"Prefer": "return=representation"},\n+        )\n+        self.assertEqual(response.status_code, 200)\n+        result = response.json()\n+\n+        # Check to make sure the addon is at last version\n+        session = [a for a in result["items"] if a["id"] == u"plone.restapi"]\n+        self.assertEqual(len(session), 1)\n+        self.assertEqual(last_version, session[0]["upgrade_info"])\n'

