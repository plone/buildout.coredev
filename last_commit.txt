Repository: plone.app.contentrules


Branch: refs/heads/4.0.x
Date: 2020-06-30T11:48:07+07:00
Author: Dylan Jay (djay) <software@pretaweb.com>
Commit: https://github.com/plone/plone.app.contentrules/commit/10511d1c95fae32ae3cbff492c3ff29154b9fa23

fix genericsetup export of properties of rules that have more complex fields such as IDict.

Files changed:
A news/50.bugfix
M plone/app/contentrules/exportimport/rules.py
M plone/app/contentrules/tests/test_configuration.py

b'diff --git a/news/50.bugfix b/news/50.bugfix\nnew file mode 100644\nindex 0000000..8ccab66\n--- /dev/null\n+++ b/news/50.bugfix\n@@ -0,0 +1 @@\n+fix genericsetup export of properties of rules that have more complex fields such as IDict.\n\\ No newline at end of file\ndiff --git a/plone/app/contentrules/exportimport/rules.py b/plone/app/contentrules/exportimport/rules.py\nindex 881ee94..6a06397 100644\n--- a/plone/app/contentrules/exportimport/rules.py\n+++ b/plone/app/contentrules/exportimport/rules.py\n@@ -26,6 +26,9 @@\n from zope.schema.interfaces import ICollection\n from zope.schema.interfaces import IField\n from zope.schema.interfaces import IFromUnicode\n+from plone.supermodel.utils import elementToValue, valueToElement\n+from lxml import etree\n+from xml.dom import minidom\n \n \n import six\n@@ -81,25 +84,9 @@ def import_node(self, interface, child):\n             return\n \n         field = field.bind(self.element)\n-        value = None\n-\n-        # If we have a collection, we need to look at the value_type.\n-        # We look for <element>value</element> child nodes and get the\n-        # value from there\n-        if ICollection.providedBy(field):\n-            value_type = field.value_type\n-            value = []\n-            for element in child.childNodes:\n-                if element.nodeName != \'element\':\n-                    continue\n-                element_value = self.extract_text(element)\n-                value.append(self.from_unicode(value_type, element_value))\n-            value = self.field_typecast(field, value)\n+        child = etree.fromstring(child.toxml())\n \n-        # Otherwise, just get the value of the <property /> node\n-        else:\n-            value = self.extract_text(child)\n-            value = self.from_unicode(field, value)\n+        value = elementToValue(field, child)\n \n         field.validate(value)\n         field.set(self.element, value)\n@@ -113,54 +100,16 @@ def export_field(self, doc, field):\n \n         child = doc.createElement(\'property\')\n         child.setAttribute(\'name\', field.__name__)\n-\n-        if value is not None:\n-            if ICollection.providedBy(field):\n-                for e in value:\n-                    list_element = doc.createElement(\'element\')\n-                    list_element.appendChild(doc.createTextNode(str(e)))\n-                    child.appendChild(list_element)\n-            else:\n-                child.appendChild(doc.createTextNode(six.text_type(value)))\n-\n+        \n+        node = valueToElement(field, value)\n+        if node.text:\n+            child.appendChild(doc.createTextNode(six.text_type(node.text)))\n+        # Assumes there are not other text nodes and we can throw away the parent node    \n+        for node in node.iterchildren():\n+            xml = etree.tostring(node).decode()\n+            child.appendChild(minidom.parseString(xml).firstChild)\n         return child\n \n-    def extract_text(self, node):\n-        node.normalize()\n-        text = u\'\'\n-        for child in node.childNodes:\n-            if child.nodeType == node.TEXT_NODE:\n-                text += child.nodeValue\n-        return text\n-\n-    def from_unicode(self, field, value):\n-\n-        # XXX: Bool incorrectly omits to declare that it implements\n-        # IFromUnicode, even though it does.\n-        import zope.schema\n-        if (\n-            IFromUnicode.providedBy(field) or\n-            isinstance(field, zope.schema.Bool)\n-        ):\n-            return field.fromUnicode(value)\n-        else:\n-            return self.field_typecast(field, value)\n-\n-    def field_typecast(self, field, value):\n-        # A slight hack to force sequence types to the right type\n-        typecast = getattr(field, \'_type\', None)\n-        if typecast is not None:\n-            if not isinstance(typecast, (list, tuple)):\n-                typecast = (typecast, )\n-            for tc in reversed(typecast):\n-                if callable(tc):\n-                    try:\n-                        value = tc(value)\n-                        break\n-                    except Exception:\n-                        pass\n-        return value\n-\n \n @adapter(ISiteRoot, ISetupEnviron)\n @implementer(IBody)\ndiff --git a/plone/app/contentrules/tests/test_configuration.py b/plone/app/contentrules/tests/test_configuration.py\nindex 456a244..7d55984 100644\n--- a/plone/app/contentrules/tests/test_configuration.py\n+++ b/plone/app/contentrules/tests/test_configuration.py\n@@ -128,8 +128,8 @@ def testExport(self):\n   <conditions>\n    <condition type="plone.conditions.PortalType">\n     <property name="check_types">\n-     <element>Document</element>\n      <element>News Item</element>\n+     <element>Document</element>\n     </property>\n    </condition>\n    <condition type="plone.conditions.Role">\n'

Repository: plone.app.contentrules


Branch: refs/heads/4.0.x
Date: 2020-06-30T11:50:20+07:00
Author: Dylan Jay (djay) <software@pretaweb.com>
Commit: https://github.com/plone/plone.app.contentrules/commit/b95b517742fcebc46222c56858c6ce5353022747

remove random failures

Files changed:
M plone/app/contentrules/exportimport/rules.py
M plone/app/contentrules/tests/test_configuration.py

b'diff --git a/plone/app/contentrules/exportimport/rules.py b/plone/app/contentrules/exportimport/rules.py\nindex 6a06397..d5f2d17 100644\n--- a/plone/app/contentrules/exportimport/rules.py\n+++ b/plone/app/contentrules/exportimport/rules.py\n@@ -106,7 +106,7 @@ def export_field(self, doc, field):\n             child.appendChild(doc.createTextNode(six.text_type(node.text)))\n         # Assumes there are not other text nodes and we can throw away the parent node    \n         for node in node.iterchildren():\n-            xml = etree.tostring(node).decode()\n+            xml = etree.tostring(node, encoding="utf8")\n             child.appendChild(minidom.parseString(xml).firstChild)\n         return child\n \ndiff --git a/plone/app/contentrules/tests/test_configuration.py b/plone/app/contentrules/tests/test_configuration.py\nindex 7d55984..8752254 100644\n--- a/plone/app/contentrules/tests/test_configuration.py\n+++ b/plone/app/contentrules/tests/test_configuration.py\n@@ -119,7 +119,19 @@ def testExport(self):\n         exporter = getMultiAdapter(\n             (site, context), IBody, name=u\'plone.contentrules\')\n \n-        expected = """<?xml version="1.0"?>\n+        body = exporter.body.decode(\'utf8\')\n+\n+        # There is a bug in supermodel such that Set fields can be exported in a random order\n+        body = body.replace("""\n+     <element>News Item</element>\n+     <element>Document</element>\n+""","""\n+     <element>Document</element>\n+     <element>News Item</element>\n+"""\n+        )\n+\n+        expected = u"""<?xml version="1.0" encoding="utf-8"?>\n <contentrules>\n  <rule name="test1" title="Test rule 1" cascading="False"\n     description="A test rule" enabled="True"\n@@ -128,8 +140,8 @@ def testExport(self):\n   <conditions>\n    <condition type="plone.conditions.PortalType">\n     <property name="check_types">\n-     <element>News Item</element>\n      <element>Document</element>\n+     <element>News Item</element>\n     </property>\n    </condition>\n    <condition type="plone.conditions.Role">\n@@ -216,5 +228,4 @@ def testExport(self):\n </contentrules>\n """\n \n-        body = exporter.body\n-        self.assertEqual(expected.strip(), body.strip(), body)\n+        self.assertEqual(expected.strip(), body.strip())\n'

Repository: plone.app.contentrules


Branch: refs/heads/4.0.x
Date: 2020-06-30T11:51:19+07:00
Author: Dylan Jay (djay) <software@pretaweb.com>
Commit: https://github.com/plone/plone.app.contentrules/commit/4bc7ea78bbeb2b0262b9dfcd79bf24a23f5f2fdd

Put in comments about conversion minidom&lt;&gt;lxml

Files changed:
M plone/app/contentrules/exportimport/rules.py
M plone/app/contentrules/tests/profiles/testing/contentrules.xml
M plone/app/contentrules/tests/test_configuration.py

b'diff --git a/plone/app/contentrules/exportimport/rules.py b/plone/app/contentrules/exportimport/rules.py\nindex d5f2d17..e142e05 100644\n--- a/plone/app/contentrules/exportimport/rules.py\n+++ b/plone/app/contentrules/exportimport/rules.py\n@@ -84,6 +84,7 @@ def import_node(self, interface, child):\n             return\n \n         field = field.bind(self.element)\n+        # child is minidom but supermodel needs an etree node so we need to convert it\n         child = etree.fromstring(child.toxml())\n \n         value = elementToValue(field, child)\n@@ -100,7 +101,8 @@ def export_field(self, doc, field):\n \n         child = doc.createElement(\'property\')\n         child.setAttribute(\'name\', field.__name__)\n-        \n+\n+        # supermodel gives us an etree node but GS uses minidom so we need to convert it\n         node = valueToElement(field, value)\n         if node.text:\n             child.appendChild(doc.createTextNode(six.text_type(node.text)))\ndiff --git a/plone/app/contentrules/tests/profiles/testing/contentrules.xml b/plone/app/contentrules/tests/profiles/testing/contentrules.xml\nindex af08103..9446c81 100644\n--- a/plone/app/contentrules/tests/profiles/testing/contentrules.xml\n+++ b/plone/app/contentrules/tests/profiles/testing/contentrules.xml\n@@ -1,4 +1,4 @@\n-<?xml version="1.0"?>\n+<?xml version="1.0" encoding="utf-8"?>\n <contentrules>\n \n     <rule\ndiff --git a/plone/app/contentrules/tests/test_configuration.py b/plone/app/contentrules/tests/test_configuration.py\nindex 8752254..0f2db07 100644\n--- a/plone/app/contentrules/tests/test_configuration.py\n+++ b/plone/app/contentrules/tests/test_configuration.py\n@@ -227,5 +227,4 @@ def testExport(self):\n  <assignment name="test5" bubbles="False" enabled="False" location=""/>\n </contentrules>\n """\n-\n         self.assertEqual(expected.strip(), body.strip())\n'

Repository: plone.app.contentrules


Branch: refs/heads/4.0.x
Date: 2020-06-30T11:54:23+07:00
Author: Dylan Jay (djay) <software@pretaweb.com>
Commit: https://github.com/plone/plone.app.contentrules/commit/57a3fe5248ff08abfa516e0628774d02a3ce57ec

add in code to ensure utf8 encoding

Files changed:
M plone/app/contentrules/exportimport/rules.py

b"diff --git a/plone/app/contentrules/exportimport/rules.py b/plone/app/contentrules/exportimport/rules.py\nindex e142e05..1a37d9a 100644\n--- a/plone/app/contentrules/exportimport/rules.py\n+++ b/plone/app/contentrules/exportimport/rules.py\n@@ -365,5 +365,9 @@ def exportRules(context):\n     if exporter is not None:\n         filename = '{0}{1}'.format(exporter.name, exporter.suffix)\n         body = exporter.body\n+        # make sure it's encoded as earlier version of GS didn't do this\n+        if isinstance(body, six.text_type):\n+            encoding = context.getEncoding() or 'utf-8'\n+            body = body.encode(encoding)\n         if body is not None:\n             context.writeDataFile(filename, body, exporter.mime_type)\n"

Repository: plone.app.contentrules


Branch: refs/heads/4.0.x
Date: 2020-09-23T10:13:09+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.app.contentrules/commit/fd088d305a430e70fe97193cce86bceff7c8ad19

Merge pull request #57 from plone/djay/backport_fix_complex_export

Backport "fix genericsetup export with complex properties" to 4.0

Files changed:
A news/50.bugfix
M plone/app/contentrules/exportimport/rules.py
M plone/app/contentrules/tests/profiles/testing/contentrules.xml
M plone/app/contentrules/tests/test_configuration.py

b'diff --git a/news/50.bugfix b/news/50.bugfix\nnew file mode 100644\nindex 0000000..8ccab66\n--- /dev/null\n+++ b/news/50.bugfix\n@@ -0,0 +1 @@\n+fix genericsetup export of properties of rules that have more complex fields such as IDict.\n\\ No newline at end of file\ndiff --git a/plone/app/contentrules/exportimport/rules.py b/plone/app/contentrules/exportimport/rules.py\nindex 881ee94..1a37d9a 100644\n--- a/plone/app/contentrules/exportimport/rules.py\n+++ b/plone/app/contentrules/exportimport/rules.py\n@@ -26,6 +26,9 @@\n from zope.schema.interfaces import ICollection\n from zope.schema.interfaces import IField\n from zope.schema.interfaces import IFromUnicode\n+from plone.supermodel.utils import elementToValue, valueToElement\n+from lxml import etree\n+from xml.dom import minidom\n \n \n import six\n@@ -81,25 +84,10 @@ def import_node(self, interface, child):\n             return\n \n         field = field.bind(self.element)\n-        value = None\n-\n-        # If we have a collection, we need to look at the value_type.\n-        # We look for <element>value</element> child nodes and get the\n-        # value from there\n-        if ICollection.providedBy(field):\n-            value_type = field.value_type\n-            value = []\n-            for element in child.childNodes:\n-                if element.nodeName != \'element\':\n-                    continue\n-                element_value = self.extract_text(element)\n-                value.append(self.from_unicode(value_type, element_value))\n-            value = self.field_typecast(field, value)\n+        # child is minidom but supermodel needs an etree node so we need to convert it\n+        child = etree.fromstring(child.toxml())\n \n-        # Otherwise, just get the value of the <property /> node\n-        else:\n-            value = self.extract_text(child)\n-            value = self.from_unicode(field, value)\n+        value = elementToValue(field, child)\n \n         field.validate(value)\n         field.set(self.element, value)\n@@ -114,53 +102,16 @@ def export_field(self, doc, field):\n         child = doc.createElement(\'property\')\n         child.setAttribute(\'name\', field.__name__)\n \n-        if value is not None:\n-            if ICollection.providedBy(field):\n-                for e in value:\n-                    list_element = doc.createElement(\'element\')\n-                    list_element.appendChild(doc.createTextNode(str(e)))\n-                    child.appendChild(list_element)\n-            else:\n-                child.appendChild(doc.createTextNode(six.text_type(value)))\n-\n+        # supermodel gives us an etree node but GS uses minidom so we need to convert it\n+        node = valueToElement(field, value)\n+        if node.text:\n+            child.appendChild(doc.createTextNode(six.text_type(node.text)))\n+        # Assumes there are not other text nodes and we can throw away the parent node    \n+        for node in node.iterchildren():\n+            xml = etree.tostring(node, encoding="utf8")\n+            child.appendChild(minidom.parseString(xml).firstChild)\n         return child\n \n-    def extract_text(self, node):\n-        node.normalize()\n-        text = u\'\'\n-        for child in node.childNodes:\n-            if child.nodeType == node.TEXT_NODE:\n-                text += child.nodeValue\n-        return text\n-\n-    def from_unicode(self, field, value):\n-\n-        # XXX: Bool incorrectly omits to declare that it implements\n-        # IFromUnicode, even though it does.\n-        import zope.schema\n-        if (\n-            IFromUnicode.providedBy(field) or\n-            isinstance(field, zope.schema.Bool)\n-        ):\n-            return field.fromUnicode(value)\n-        else:\n-            return self.field_typecast(field, value)\n-\n-    def field_typecast(self, field, value):\n-        # A slight hack to force sequence types to the right type\n-        typecast = getattr(field, \'_type\', None)\n-        if typecast is not None:\n-            if not isinstance(typecast, (list, tuple)):\n-                typecast = (typecast, )\n-            for tc in reversed(typecast):\n-                if callable(tc):\n-                    try:\n-                        value = tc(value)\n-                        break\n-                    except Exception:\n-                        pass\n-        return value\n-\n \n @adapter(ISiteRoot, ISetupEnviron)\n @implementer(IBody)\n@@ -414,5 +365,9 @@ def exportRules(context):\n     if exporter is not None:\n         filename = \'{0}{1}\'.format(exporter.name, exporter.suffix)\n         body = exporter.body\n+        # make sure it\'s encoded as earlier version of GS didn\'t do this\n+        if isinstance(body, six.text_type):\n+            encoding = context.getEncoding() or \'utf-8\'\n+            body = body.encode(encoding)\n         if body is not None:\n             context.writeDataFile(filename, body, exporter.mime_type)\ndiff --git a/plone/app/contentrules/tests/profiles/testing/contentrules.xml b/plone/app/contentrules/tests/profiles/testing/contentrules.xml\nindex af08103..9446c81 100644\n--- a/plone/app/contentrules/tests/profiles/testing/contentrules.xml\n+++ b/plone/app/contentrules/tests/profiles/testing/contentrules.xml\n@@ -1,4 +1,4 @@\n-<?xml version="1.0"?>\n+<?xml version="1.0" encoding="utf-8"?>\n <contentrules>\n \n     <rule\ndiff --git a/plone/app/contentrules/tests/test_configuration.py b/plone/app/contentrules/tests/test_configuration.py\nindex 456a244..0f2db07 100644\n--- a/plone/app/contentrules/tests/test_configuration.py\n+++ b/plone/app/contentrules/tests/test_configuration.py\n@@ -119,7 +119,19 @@ def testExport(self):\n         exporter = getMultiAdapter(\n             (site, context), IBody, name=u\'plone.contentrules\')\n \n-        expected = """<?xml version="1.0"?>\n+        body = exporter.body.decode(\'utf8\')\n+\n+        # There is a bug in supermodel such that Set fields can be exported in a random order\n+        body = body.replace("""\n+     <element>News Item</element>\n+     <element>Document</element>\n+""","""\n+     <element>Document</element>\n+     <element>News Item</element>\n+"""\n+        )\n+\n+        expected = u"""<?xml version="1.0" encoding="utf-8"?>\n <contentrules>\n  <rule name="test1" title="Test rule 1" cascading="False"\n     description="A test rule" enabled="True"\n@@ -215,6 +227,4 @@ def testExport(self):\n  <assignment name="test5" bubbles="False" enabled="False" location=""/>\n </contentrules>\n """\n-\n-        body = exporter.body\n-        self.assertEqual(expected.strip(), body.strip(), body)\n+        self.assertEqual(expected.strip(), body.strip())\n'

