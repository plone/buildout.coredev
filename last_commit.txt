Repository: plone.memoize


Branch: refs/heads/master
Date: 2020-04-10T16:36:39+02:00
Author: ale-rt (ale-rt) <alessandro.pisa@gmail.com>
Commit: https://github.com/plone/plone.memoize/commit/06607af611a876d3e8e4419436ef9642dc6d1d22

Make code black

Preparation for #17

Files changed:
A news/17.bugfix
M bootstrap-buildout.py
M plone/__init__.py
M plone/memoize/compress.py
M plone/memoize/forever.py
M plone/memoize/instance.py
M plone/memoize/interfaces.py
M plone/memoize/ram.py
M plone/memoize/request.py
M plone/memoize/tests.py
M plone/memoize/view.py
M plone/memoize/volatile.py
M setup.py

b'diff --git a/bootstrap-buildout.py b/bootstrap-buildout.py\nindex a459921..a8bc0c9 100644\n--- a/bootstrap-buildout.py\n+++ b/bootstrap-buildout.py\n@@ -25,12 +25,12 @@\n \n from optparse import OptionParser\n \n-__version__ = \'2015-07-01\'\n+__version__ = "2015-07-01"\n # See zc.buildout\'s changelog if this version is up to date.\n \n-tmpeggs = tempfile.mkdtemp(prefix=\'bootstrap-\')\n+tmpeggs = tempfile.mkdtemp(prefix="bootstrap-")\n \n-usage = \'\'\'\\\n+usage = """\\\n [DESIRED PYTHON FOR BUILDOUT] bootstrap.py [options]\n \n Bootstraps a buildout-based project.\n@@ -40,36 +40,50 @@\n \n Note that by using --find-links to point to local resources, you can keep\n this script from going over the network.\n-\'\'\'\n+"""\n \n parser = OptionParser(usage=usage)\n-parser.add_option("--version",\n-                  action="store_true", default=False,\n-                  help=("Return bootstrap.py version."))\n-parser.add_option("-t", "--accept-buildout-test-releases",\n-                  dest=\'accept_buildout_test_releases\',\n-                  action="store_true", default=False,\n-                  help=("Normally, if you do not specify a --version, the "\n-                        "bootstrap script and buildout gets the newest "\n-                        "*final* versions of zc.buildout and its recipes and "\n-                        "extensions for you.  If you use this flag, "\n-                        "bootstrap and buildout will get the newest releases "\n-                        "even if they are alphas or betas."))\n-parser.add_option("-c", "--config-file",\n-                  help=("Specify the path to the buildout configuration "\n-                        "file to be used."))\n-parser.add_option("-f", "--find-links",\n-                  help=("Specify a URL to search for buildout releases"))\n-parser.add_option("--allow-site-packages",\n-                  action="store_true", default=False,\n-                  help=("Let bootstrap.py use existing site packages"))\n-parser.add_option("--buildout-version",\n-                  help="Use a specific zc.buildout version")\n-parser.add_option("--setuptools-version",\n-                  help="Use a specific setuptools version")\n-parser.add_option("--setuptools-to-dir",\n-                  help=("Allow for re-use of existing directory of "\n-                        "setuptools versions"))\n+parser.add_option(\n+    "--version",\n+    action="store_true",\n+    default=False,\n+    help=("Return bootstrap.py version."),\n+)\n+parser.add_option(\n+    "-t",\n+    "--accept-buildout-test-releases",\n+    dest="accept_buildout_test_releases",\n+    action="store_true",\n+    default=False,\n+    help=(\n+        "Normally, if you do not specify a --version, the "\n+        "bootstrap script and buildout gets the newest "\n+        "*final* versions of zc.buildout and its recipes and "\n+        "extensions for you.  If you use this flag, "\n+        "bootstrap and buildout will get the newest releases "\n+        "even if they are alphas or betas."\n+    ),\n+)\n+parser.add_option(\n+    "-c",\n+    "--config-file",\n+    help=("Specify the path to the buildout configuration " "file to be used."),\n+)\n+parser.add_option(\n+    "-f", "--find-links", help=("Specify a URL to search for buildout releases")\n+)\n+parser.add_option(\n+    "--allow-site-packages",\n+    action="store_true",\n+    default=False,\n+    help=("Let bootstrap.py use existing site packages"),\n+)\n+parser.add_option("--buildout-version", help="Use a specific zc.buildout version")\n+parser.add_option("--setuptools-version", help="Use a specific setuptools version")\n+parser.add_option(\n+    "--setuptools-to-dir",\n+    help=("Allow for re-use of existing directory of " "setuptools versions"),\n+)\n \n options, args = parser.parse_args()\n if options.version:\n@@ -86,35 +100,35 @@\n     from urllib2 import urlopen\n \n ez = {}\n-if os.path.exists(\'ez_setup.py\'):\n-    exec(open(\'ez_setup.py\').read(), ez)\n+if os.path.exists("ez_setup.py"):\n+    exec(open("ez_setup.py").read(), ez)\n else:\n-    exec(urlopen(\'https://bootstrap.pypa.io/ez_setup.py\').read(), ez)\n+    exec(urlopen("https://bootstrap.pypa.io/ez_setup.py").read(), ez)\n \n if not options.allow_site_packages:\n     # ez_setup imports site, which adds site packages\n     # this will remove them from the path to ensure that incompatible versions\n     # of setuptools are not in the path\n     import site\n+\n     # inside a virtualenv, there is no \'getsitepackages\'.\n     # We can\'t remove these reliably\n-    if hasattr(site, \'getsitepackages\'):\n+    if hasattr(site, "getsitepackages"):\n         for sitepackage_path in site.getsitepackages():\n             # Strip all site-packages directories from sys.path that\n             # are not sys.prefix; this is because on Windows\n             # sys.prefix is a site-package directory.\n             if sitepackage_path != sys.prefix:\n-                sys.path[:] = [x for x in sys.path\n-                               if sitepackage_path not in x]\n+                sys.path[:] = [x for x in sys.path if sitepackage_path not in x]\n \n setup_args = dict(to_dir=tmpeggs, download_delay=0)\n \n if options.setuptools_version is not None:\n-    setup_args[\'version\'] = options.setuptools_version\n+    setup_args["version"] = options.setuptools_version\n if options.setuptools_to_dir is not None:\n-    setup_args[\'to_dir\'] = options.setuptools_to_dir\n+    setup_args["to_dir"] = options.setuptools_to_dir\n \n-ez[\'use_setuptools\'](**setup_args)\n+ez["use_setuptools"](**setup_args)\n import setuptools\n import pkg_resources\n \n@@ -129,30 +143,37 @@\n \n ws = pkg_resources.working_set\n \n-setuptools_path = ws.find(\n-    pkg_resources.Requirement.parse(\'setuptools\')).location\n+setuptools_path = ws.find(pkg_resources.Requirement.parse("setuptools")).location\n \n # Fix sys.path here as easy_install.pth added before PYTHONPATH\n-cmd = [sys.executable, \'-c\',\n-       \'import sys; sys.path[0:0] = [%r]; \' % setuptools_path +\n-       \'from setuptools.command.easy_install import main; main()\',\n-       \'-mZqNxd\', tmpeggs]\n+cmd = [\n+    sys.executable,\n+    "-c",\n+    "import sys; sys.path[0:0] = [%r]; " % setuptools_path\n+    + "from setuptools.command.easy_install import main; main()",\n+    "-mZqNxd",\n+    tmpeggs,\n+]\n \n find_links = os.environ.get(\n-    \'bootstrap-testing-find-links\',\n-    options.find_links or\n-    (\'http://downloads.buildout.org/\'\n-     if options.accept_buildout_test_releases else None)\n-    )\n+    "bootstrap-testing-find-links",\n+    options.find_links\n+    or (\n+        "http://downloads.buildout.org/"\n+        if options.accept_buildout_test_releases\n+        else None\n+    ),\n+)\n if find_links:\n-    cmd.extend([\'-f\', find_links])\n+    cmd.extend(["-f", find_links])\n \n-requirement = \'zc.buildout\'\n+requirement = "zc.buildout"\n version = options.buildout_version\n if version is None and not options.accept_buildout_test_releases:\n     # Figure out the most recent final version of zc.buildout.\n     import setuptools.package_index\n-    _final_parts = \'*final-\', \'*final\'\n+\n+    _final_parts = "*final-", "*final"\n \n     def _final_version(parsed_version):\n         try:\n@@ -160,12 +181,11 @@ def _final_version(parsed_version):\n         except AttributeError:\n             # Older setuptools\n             for part in parsed_version:\n-                if (part[:1] == \'*\') and (part not in _final_parts):\n+                if (part[:1] == "*") and (part not in _final_parts):\n                     return False\n             return True\n \n-    index = setuptools.package_index.PackageIndex(\n-        search_path=[setuptools_path])\n+    index = setuptools.package_index.PackageIndex(search_path=[setuptools_path])\n     if find_links:\n         index.add_find_links((find_links,))\n     req = pkg_resources.Requirement.parse(requirement)\n@@ -184,13 +204,13 @@ def _final_version(parsed_version):\n             best.sort()\n             version = best[-1].version\n if version:\n-    requirement = \'==\'.join((requirement, version))\n+    requirement = "==".join((requirement, version))\n cmd.append(requirement)\n \n import subprocess\n+\n if subprocess.call(cmd) != 0:\n-    raise Exception(\n-        "Failed to execute command:\\n%s" % repr(cmd)[1:-1])\n+    raise Exception("Failed to execute command:\\n%s" % repr(cmd)[1:-1])\n \n ######################################################################\n # Import and run buildout\n@@ -199,12 +219,12 @@ def _final_version(parsed_version):\n ws.require(requirement)\n import zc.buildout.buildout\n \n-if not [a for a in args if \'=\' not in a]:\n-    args.append(\'bootstrap\')\n+if not [a for a in args if "=" not in a]:\n+    args.append("bootstrap")\n \n # if -c was provided, we push it back into args for buildout\' main function\n if options.config_file is not None:\n-    args[0:0] = [\'-c\', options.config_file]\n+    args[0:0] = ["-c", options.config_file]\n \n zc.buildout.buildout.main(args)\n shutil.rmtree(tmpeggs)\ndiff --git a/news/17.bugfix b/news/17.bugfix\nnew file mode 100644\nindex 0000000..8056098\n--- /dev/null\n+++ b/news/17.bugfix\n@@ -0,0 +1 @@\n+Make code black [ale-rt]\ndiff --git a/plone/__init__.py b/plone/__init__.py\nindex 68c04af..03d08ff 100644\n--- a/plone/__init__.py\n+++ b/plone/__init__.py\n@@ -1,2 +1,2 @@\n # -*- coding: utf-8 -*-\n-__import__(\'pkg_resources\').declare_namespace(__name__)\n+__import__("pkg_resources").declare_namespace(__name__)\ndiff --git a/plone/memoize/compress.py b/plone/memoize/compress.py\nindex bea7a21..6ef4bf8 100644\n--- a/plone/memoize/compress.py\n+++ b/plone/memoize/compress.py\n@@ -22,10 +22,10 @@ def xhtml_compress(string):\n \n @implementer(IXHTMLCompressor)\n class XHTMLSlimmer(object):\n-\n     def compress(self, string):\n         if SLIMMER:\n             return xhtml_slimmer(string)\n         return string\n \n+\n xhtmlslimmer = XHTMLSlimmer()\ndiff --git a/plone/memoize/forever.py b/plone/memoize/forever.py\nindex 5e020e6..11ba9ef 100644\n--- a/plone/memoize/forever.py\n+++ b/plone/memoize/forever.py\n@@ -13,13 +13,16 @@\n \n \n def memoize(fun):\n-\n     def get_key(fun, *args, **kwargs):\n-        return (args, frozenset(kwargs.items()), )\n+        return (\n+            args,\n+            frozenset(kwargs.items()),\n+        )\n \n     def get_cache(fun, *args, **kwargs):\n         return _memos\n \n     return volatile.cache(get_key, get_cache)(fun)\n \n-__all__ = (memoize, )\n+\n+__all__ = (memoize,)\ndiff --git a/plone/memoize/instance.py b/plone/memoize/instance.py\nindex 42c2961..f1b0671 100644\n--- a/plone/memoize/instance.py\n+++ b/plone/memoize/instance.py\n@@ -11,31 +11,30 @@\n \n \n class Memojito(object):\n-    propname = \'_memojito_\'\n+    propname = "_memojito_"\n \n     def clear(self, inst):\n         if hasattr(inst, self.propname):\n             delattr(inst, self.propname)\n \n     def clearbefore(self, func):\n-\n         def clear(*args, **kwargs):\n             inst = args[0]\n             self.clear(inst)\n             return func(*args, **kwargs)\n+\n         return clear\n \n     def clearafter(self, func):\n-\n         def clear(*args, **kwargs):\n             inst = args[0]\n             val = func(*args, **kwargs)\n             self.clear(inst)\n             return val\n+\n         return clear\n \n     def memoize(self, func):\n-\n         @wraps(func)\n         def memogetter(*args, **kwargs):\n             inst = args[0]\n@@ -54,6 +53,7 @@ def memogetter(*args, **kwargs):\n                 cache[key] = val\n                 setattr(inst, self.propname, cache)\n             return val\n+\n         return memogetter\n \n \n@@ -66,4 +66,5 @@ def memogetter(*args, **kwargs):\n def memoizedproperty(func):\n     return property(_m.memoize(func))\n \n+\n __all__ = (memoize, memoizedproperty, clearbefore, clearafter)\ndiff --git a/plone/memoize/interfaces.py b/plone/memoize/interfaces.py\nindex 3bae4df..8c83bf2 100644\n--- a/plone/memoize/interfaces.py\n+++ b/plone/memoize/interfaces.py\n@@ -3,7 +3,6 @@\n \n \n class ICacheChooser(Interface):\n-\n     def __call__(fun_name):\n         """Return a cache with a dict interface based on a dotted\n         function name `fun_name`.\n@@ -13,7 +12,6 @@ def __call__(fun_name):\n \n \n class IXHTMLCompressor(Interface):\n-\n     def compress(string):\n         """Expects a valid XHTML Unicode string as input and returns a valid\n         XHTML Unicode string.\ndiff --git a/plone/memoize/ram.py b/plone/memoize/ram.py\nindex 1db6e38..8876302 100644\n--- a/plone/memoize/ram.py\n+++ b/plone/memoize/ram.py\n@@ -30,7 +30,6 @@\n \n \n class AbstractDict:\n-\n     def get(self, key, default=None):\n         try:\n             return self.__getitem__(key)\n@@ -39,14 +38,13 @@ def get(self, key, default=None):\n \n \n class MemcacheAdapter(AbstractDict):\n-\n-    def __init__(self, client, globalkey=\'\'):\n+    def __init__(self, client, globalkey=""):\n         self.client = client\n-        self.globalkey = globalkey and \'%s:\' % globalkey\n+        self.globalkey = globalkey and "%s:" % globalkey\n \n     def _make_key(self, source):\n         if issubclass(type(source), six.text_type):\n-            source = source.encode(\'utf-8\')\n+            source = source.encode("utf-8")\n         return md5(source).hexdigest()\n \n     def __getitem__(self, key):\n@@ -62,39 +60,37 @@ def __setitem__(self, key, value):\n \n \n class RAMCacheAdapter(AbstractDict):\n-\n-    def __init__(self, ramcache, globalkey=\'\'):\n+    def __init__(self, ramcache, globalkey=""):\n         self.ramcache = ramcache\n         self.globalkey = globalkey\n \n     def _make_key(self, source):\n         if issubclass(type(source), six.text_type):\n-            source = source.encode(\'utf-8\')\n+            source = source.encode("utf-8")\n         return md5(source).digest()\n \n     def __getitem__(self, key):\n-        value = self.ramcache.query(self.globalkey,\n-                                    dict(key=self._make_key(key)),\n-                                    MARKER)\n+        value = self.ramcache.query(\n+            self.globalkey, dict(key=self._make_key(key)), MARKER\n+        )\n         if value is MARKER:\n             raise KeyError(key)\n         else:\n             return value\n \n     def __setitem__(self, key, value):\n-        self.ramcache.set(value,\n-                          self.globalkey,\n-                          dict(key=self._make_key(key)))\n+        self.ramcache.set(value, self.globalkey, dict(key=self._make_key(key)))\n \n \n def choose_cache(fun_name):\n-    return RAMCacheAdapter(component.queryUtility(IRAMCache),\n-                           globalkey=fun_name)\n+    return RAMCacheAdapter(component.queryUtility(IRAMCache), globalkey=fun_name)\n+\n+\n interface.directlyProvides(choose_cache, ICacheChooser)\n \n \n def store_in_cache(fun, *args, **kwargs):\n-    key = \'%s.%s\' % (fun.__module__, fun.__name__)\n+    key = "%s.%s" % (fun.__module__, fun.__name__)\n     cache_chooser = component.queryUtility(ICacheChooser)\n     if cache_chooser is not None:\n         return cache_chooser(key)\ndiff --git a/plone/memoize/request.py b/plone/memoize/request.py\nindex 8de98ff..acdc553 100644\n--- a/plone/memoize/request.py\n+++ b/plone/memoize/request.py\n@@ -13,13 +13,12 @@\n \n class RequestMemo(object):\n \n-    key = \'plone.memoize_request\'\n+    key = "plone.memoize_request"\n \n     def __init__(self, arg=0):\n         self.arg = arg\n \n     def __call__(self, func):\n-\n         @wraps(func)\n         def memogetter(*args, **kwargs):\n             request = None\n@@ -34,17 +33,21 @@ def memogetter(*args, **kwargs):\n             if cache is _marker:\n                 cache = annotations[self.key] = dict()\n \n-            key = (func.__module__, func.__name__,\n-                   args, frozenset(list(kwargs.items())))\n+            key = (\n+                func.__module__,\n+                func.__name__,\n+                args,\n+                frozenset(list(kwargs.items())),\n+            )\n             value = cache.get(key, _marker)\n             if value is _marker:\n                 value = cache[key] = func(*args, **kwargs)\n             return value\n+\n         return memogetter\n \n \n def store_in_annotation_of(expr):\n-\n     def _store_in_annotation(fun, *args, **kwargs):\n         # Use expr to find out the name of the request variable\n         vars = {}\n@@ -59,8 +62,10 @@ def _store_in_annotation(fun, *args, **kwargs):\n         if spec[3] is not None:\n             expected_num_args = len(spec[0]) - len(spec[3])\n         if num_args != expected_num_args:\n-            raise TypeError("%s() takes exactly %s arguments (%s given)"\n-                            % (fun.__name__, expected_num_args, num_args))\n+            raise TypeError(\n+                "%s() takes exactly %s arguments (%s given)"\n+                % (fun.__name__, expected_num_args, num_args)\n+            )\n \n         for index, name in enumerate(spec[0]):\n             if index < num_args:\n@@ -69,13 +74,14 @@ def _store_in_annotation(fun, *args, **kwargs):\n                 vars[name] = kwargs.get(name, spec[3][index - num_args])\n         request = eval(expr, {}, vars)\n         return IAnnotations(request)\n+\n     return _store_in_annotation\n \n \n-def cache(get_key, get_request=\'request\'):\n+def cache(get_key, get_request="request"):\n+\n+    return volatile.cache(get_key, get_cache=store_in_annotation_of(get_request))\n \n-    return volatile.cache(get_key,\n-                          get_cache=store_in_annotation_of(get_request))\n \n memoize_diy_request = RequestMemo\n \ndiff --git a/plone/memoize/tests.py b/plone/memoize/tests.py\nindex 63da7c5..ffbe9b3 100644\n--- a/plone/memoize/tests.py\n+++ b/plone/memoize/tests.py\n@@ -11,53 +11,71 @@\n def configurationSetUp(test):\n     setUp()\n     import zope.component\n-    XMLConfig(\'meta.zcml\', zope.component)()\n+\n+    XMLConfig("meta.zcml", zope.component)()\n     import plone.memoize\n-    XMLConfig(\'configure.zcml\', plone.memoize)()\n+\n+    XMLConfig("configure.zcml", plone.memoize)()\n \n \n def test_suite():\n     tests = (\n-        doctest.DocFileSuite(\'README.rst\',\n-                             package="plone.memoize",\n-                             setUp=configurationSetUp,\n-                             tearDown=tearDown,\n-                             optionflags=optionflags),\n-        doctest.DocFileSuite(\'compress.rst\',\n-                             package="plone.memoize",\n-                             setUp=configurationSetUp,\n-                             tearDown=tearDown,\n-                             optionflags=optionflags),\n-        doctest.DocFileSuite(\'forever.rst\',\n-                             package="plone.memoize",\n-                             setUp=configurationSetUp,\n-                             tearDown=tearDown,\n-                             optionflags=optionflags),\n-        doctest.DocFileSuite(\'instance.rst\',\n-                             package="plone.memoize",\n-                             setUp=configurationSetUp,\n-                             tearDown=tearDown,\n-                             optionflags=optionflags),\n-        doctest.DocFileSuite(\'ram.rst\',\n-                             package="plone.memoize",\n-                             setUp=configurationSetUp,\n-                             tearDown=tearDown,\n-                             optionflags=optionflags),\n-        doctest.DocFileSuite(\'request.rst\',\n-                             package="plone.memoize",\n-                             setUp=configurationSetUp,\n-                             tearDown=tearDown,\n-                             optionflags=optionflags),\n-        doctest.DocFileSuite(\'view.rst\',\n-                             package="plone.memoize",\n-                             setUp=configurationSetUp,\n-                             tearDown=tearDown,\n-                             optionflags=optionflags),\n-        doctest.DocFileSuite(\'volatile.rst\',\n-                             package="plone.memoize",\n-                             setUp=configurationSetUp,\n-                             tearDown=tearDown,\n-                             optionflags=optionflags),\n+        doctest.DocFileSuite(\n+            "README.rst",\n+            package="plone.memoize",\n+            setUp=configurationSetUp,\n+            tearDown=tearDown,\n+            optionflags=optionflags,\n+        ),\n+        doctest.DocFileSuite(\n+            "compress.rst",\n+            package="plone.memoize",\n+            setUp=configurationSetUp,\n+            tearDown=tearDown,\n+            optionflags=optionflags,\n+        ),\n+        doctest.DocFileSuite(\n+            "forever.rst",\n+            package="plone.memoize",\n+            setUp=configurationSetUp,\n+            tearDown=tearDown,\n+            optionflags=optionflags,\n+        ),\n+        doctest.DocFileSuite(\n+            "instance.rst",\n+            package="plone.memoize",\n+            setUp=configurationSetUp,\n+            tearDown=tearDown,\n+            optionflags=optionflags,\n+        ),\n+        doctest.DocFileSuite(\n+            "ram.rst",\n+            package="plone.memoize",\n+            setUp=configurationSetUp,\n+            tearDown=tearDown,\n+            optionflags=optionflags,\n+        ),\n+        doctest.DocFileSuite(\n+            "request.rst",\n+            package="plone.memoize",\n+            setUp=configurationSetUp,\n+            tearDown=tearDown,\n+            optionflags=optionflags,\n+        ),\n+        doctest.DocFileSuite(\n+            "view.rst",\n+            package="plone.memoize",\n+            setUp=configurationSetUp,\n+            tearDown=tearDown,\n+            optionflags=optionflags,\n+        ),\n+        doctest.DocFileSuite(\n+            "volatile.rst",\n+            package="plone.memoize",\n+            setUp=configurationSetUp,\n+            tearDown=tearDown,\n+            optionflags=optionflags,\n+        ),\n     )\n \n     return unittest.TestSuite(tests)\ndiff --git a/plone/memoize/view.py b/plone/memoize/view.py\nindex 3586ce1..dc57f7f 100644\n--- a/plone/memoize/view.py\n+++ b/plone/memoize/view.py\n@@ -11,16 +11,15 @@\n \n class ViewMemo(object):\n \n-    key = \'plone.memoize\'\n+    key = "plone.memoize"\n \n     def memoize(self, func):\n-\n         @wraps(func)\n         def memogetter(*args, **kwargs):\n             instance = args[0]\n \n-            context = getattr(instance, \'context\', None)\n-            request = getattr(instance, \'request\', None)\n+            context = getattr(instance, "context", None)\n+            request = getattr(instance, "request", None)\n \n             annotations = IAnnotations(request)\n             cache = annotations.get(self.key, _marker)\n@@ -41,19 +40,24 @@ def memogetter(*args, **kwargs):\n             # instance and the whole point is that we can cache different\n             # requests\n \n-            key = (context_id, instance.__class__.__name__, func.__name__,\n-                   args[1:], frozenset(kwargs.items()))\n+            key = (\n+                context_id,\n+                instance.__class__.__name__,\n+                func.__name__,\n+                args[1:],\n+                frozenset(kwargs.items()),\n+            )\n             value = cache.get(key, _marker)\n             if value is _marker:\n                 value = cache[key] = func(*args, **kwargs)\n             return value\n+\n         return memogetter\n \n     def memoize_contextless(self, func):\n-\n         def memogetter(*args, **kwargs):\n             instance = args[0]\n-            request = getattr(instance, \'request\', None)\n+            request = getattr(instance, "request", None)\n \n             annotations = IAnnotations(request)\n             cache = annotations.get(self.key, _marker)\n@@ -61,14 +65,20 @@ def memogetter(*args, **kwargs):\n             if cache is _marker:\n                 cache = annotations[self.key] = dict()\n \n-            key = (instance.__class__.__name__, func.__name__,\n-                   args[1:], frozenset(kwargs.items()))\n+            key = (\n+                instance.__class__.__name__,\n+                func.__name__,\n+                args[1:],\n+                frozenset(kwargs.items()),\n+            )\n             value = cache.get(key, _marker)\n             if value is _marker:\n                 value = cache[key] = func(*args, **kwargs)\n             return value\n+\n         return memogetter\n \n+\n _m = ViewMemo()\n memoize = _m.memoize\n memoize_contextless = _m.memoize_contextless\ndiff --git a/plone/memoize/volatile.py b/plone/memoize/volatile.py\nindex f921ded..37502a2 100644\n--- a/plone/memoize/volatile.py\n+++ b/plone/memoize/volatile.py\n@@ -13,6 +13,7 @@ class CleanupDict(dict):\n     """A dict that automatically cleans up items that haven\'t been\n     accessed in a given timespan on *set*.\n     """\n+\n     cleanup_period = 60 * 60 * 24 * 3  # 3 days\n \n     def __init__(self, cleanup_period=None):\n@@ -39,7 +40,8 @@ def _cleanup(self):\n                 del self._last_access[key]\n                 super(CleanupDict, self).__delitem__(key)\n \n-ATTR = \'_v_memoize_cache\'\n+\n+ATTR = "_v_memoize_cache"\n CONTAINER_FACTORY = CleanupDict\n _marker = object()\n \n@@ -57,20 +59,20 @@ def store_on_context(method, obj, *args, **kwargs):\n \n \n def cache(get_key, get_cache=store_on_self):\n-\n     def decorator(fun):\n-\n         @wraps(fun)\n         def replacement(*args, **kwargs):\n             try:\n                 key = get_key(fun, *args, **kwargs)\n             except DontCache:\n                 return fun(*args, **kwargs)\n-            key = \'%s.%s:%s\' % (fun.__module__, fun.__name__, key)\n+            key = "%s.%s:%s" % (fun.__module__, fun.__name__, key)\n             cache = get_cache(fun, *args, **kwargs)\n             cached_value = cache.get(key, _marker)\n             if cached_value is _marker:\n                 cached_value = cache[key] = fun(*args, **kwargs)\n             return cached_value\n+\n         return replacement\n+\n     return decorator\ndiff --git a/setup.py b/setup.py\nindex 21bcfa9..be8e128 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -7,17 +7,15 @@ def read(*rnames):\n     return open(os.path.join(os.path.dirname(__file__), *rnames)).read()\n \n \n-version = \'2.0.2.dev0\'\n+version = "2.0.2.dev0"\n \n-long_description = u"\\n".join([\n-    read(\'README.rst\'),\n-    read(\'plone\', \'memoize\', \'README.rst\'),\n-    read(\'CHANGES.rst\'),\n-])\n+long_description = u"\\n".join(\n+    [read("README.rst"), read("plone", "memoize", "README.rst"), read("CHANGES.rst"),]\n+)\n \n \n setup(\n-    name=\'plone.memoize\',\n+    name="plone.memoize",\n     version=version,\n     description="Decorators for caching the values of functions and methods",\n     long_description=long_description,\n@@ -42,28 +40,23 @@ def read(*rnames):\n         "Programming Language :: Python :: Implementation :: CPython",\n         "Programming Language :: Python :: Implementation :: PyPy",\n     ],\n-    keywords=\'plone memoize decorator cache\',\n-    author=\'Plone Foundation\',\n-    author_email=\'plone-developers@lists.sourceforge.net\',\n-    url=\'https://pypi.org/project/plone.memoize\',\n-    license=\'BSD\',\n+    keywords="plone memoize decorator cache",\n+    author="Plone Foundation",\n+    author_email="plone-developers@lists.sourceforge.net",\n+    url="https://pypi.org/project/plone.memoize",\n+    license="BSD",\n     packages=find_packages(),\n-    namespace_packages=[\'plone\'],\n+    namespace_packages=["plone"],\n     include_package_data=True,\n     zip_safe=False,\n-    test_suite=\'plone.memoize.tests.test_suite\',\n-    extras_require=dict(\n-        test=[\n-            \'zope.configuration\',\n-            \'zope.publisher\',\n-        ]\n-    ),\n+    test_suite="plone.memoize.tests.test_suite",\n+    extras_require=dict(test=["zope.configuration", "zope.publisher",]),\n     install_requires=[\n-        \'setuptools\',\n-        \'six\',\n-        \'zope.annotation\',\n-        \'zope.component\',\n-        \'zope.interface\',\n-        \'zope.ramcache\',\n+        "setuptools",\n+        "six",\n+        "zope.annotation",\n+        "zope.component",\n+        "zope.interface",\n+        "zope.ramcache",\n     ],\n )\n'

Repository: plone.memoize


Branch: refs/heads/master
Date: 2020-04-11T10:46:53+02:00
Author: Alessandro Pisa (ale-rt) <alessandro.pisa@gmail.com>
Commit: https://github.com/plone/plone.memoize/commit/0e94832c64f0bf061f0520e2ee462bd161468c3c

Merge pull request #18 from plone/17-black

Make code black

Files changed:
A news/17.bugfix
M bootstrap-buildout.py
M plone/__init__.py
M plone/memoize/compress.py
M plone/memoize/forever.py
M plone/memoize/instance.py
M plone/memoize/interfaces.py
M plone/memoize/ram.py
M plone/memoize/request.py
M plone/memoize/tests.py
M plone/memoize/view.py
M plone/memoize/volatile.py
M setup.py

b'diff --git a/bootstrap-buildout.py b/bootstrap-buildout.py\nindex a459921..a8bc0c9 100644\n--- a/bootstrap-buildout.py\n+++ b/bootstrap-buildout.py\n@@ -25,12 +25,12 @@\n \n from optparse import OptionParser\n \n-__version__ = \'2015-07-01\'\n+__version__ = "2015-07-01"\n # See zc.buildout\'s changelog if this version is up to date.\n \n-tmpeggs = tempfile.mkdtemp(prefix=\'bootstrap-\')\n+tmpeggs = tempfile.mkdtemp(prefix="bootstrap-")\n \n-usage = \'\'\'\\\n+usage = """\\\n [DESIRED PYTHON FOR BUILDOUT] bootstrap.py [options]\n \n Bootstraps a buildout-based project.\n@@ -40,36 +40,50 @@\n \n Note that by using --find-links to point to local resources, you can keep\n this script from going over the network.\n-\'\'\'\n+"""\n \n parser = OptionParser(usage=usage)\n-parser.add_option("--version",\n-                  action="store_true", default=False,\n-                  help=("Return bootstrap.py version."))\n-parser.add_option("-t", "--accept-buildout-test-releases",\n-                  dest=\'accept_buildout_test_releases\',\n-                  action="store_true", default=False,\n-                  help=("Normally, if you do not specify a --version, the "\n-                        "bootstrap script and buildout gets the newest "\n-                        "*final* versions of zc.buildout and its recipes and "\n-                        "extensions for you.  If you use this flag, "\n-                        "bootstrap and buildout will get the newest releases "\n-                        "even if they are alphas or betas."))\n-parser.add_option("-c", "--config-file",\n-                  help=("Specify the path to the buildout configuration "\n-                        "file to be used."))\n-parser.add_option("-f", "--find-links",\n-                  help=("Specify a URL to search for buildout releases"))\n-parser.add_option("--allow-site-packages",\n-                  action="store_true", default=False,\n-                  help=("Let bootstrap.py use existing site packages"))\n-parser.add_option("--buildout-version",\n-                  help="Use a specific zc.buildout version")\n-parser.add_option("--setuptools-version",\n-                  help="Use a specific setuptools version")\n-parser.add_option("--setuptools-to-dir",\n-                  help=("Allow for re-use of existing directory of "\n-                        "setuptools versions"))\n+parser.add_option(\n+    "--version",\n+    action="store_true",\n+    default=False,\n+    help=("Return bootstrap.py version."),\n+)\n+parser.add_option(\n+    "-t",\n+    "--accept-buildout-test-releases",\n+    dest="accept_buildout_test_releases",\n+    action="store_true",\n+    default=False,\n+    help=(\n+        "Normally, if you do not specify a --version, the "\n+        "bootstrap script and buildout gets the newest "\n+        "*final* versions of zc.buildout and its recipes and "\n+        "extensions for you.  If you use this flag, "\n+        "bootstrap and buildout will get the newest releases "\n+        "even if they are alphas or betas."\n+    ),\n+)\n+parser.add_option(\n+    "-c",\n+    "--config-file",\n+    help=("Specify the path to the buildout configuration " "file to be used."),\n+)\n+parser.add_option(\n+    "-f", "--find-links", help=("Specify a URL to search for buildout releases")\n+)\n+parser.add_option(\n+    "--allow-site-packages",\n+    action="store_true",\n+    default=False,\n+    help=("Let bootstrap.py use existing site packages"),\n+)\n+parser.add_option("--buildout-version", help="Use a specific zc.buildout version")\n+parser.add_option("--setuptools-version", help="Use a specific setuptools version")\n+parser.add_option(\n+    "--setuptools-to-dir",\n+    help=("Allow for re-use of existing directory of " "setuptools versions"),\n+)\n \n options, args = parser.parse_args()\n if options.version:\n@@ -86,35 +100,35 @@\n     from urllib2 import urlopen\n \n ez = {}\n-if os.path.exists(\'ez_setup.py\'):\n-    exec(open(\'ez_setup.py\').read(), ez)\n+if os.path.exists("ez_setup.py"):\n+    exec(open("ez_setup.py").read(), ez)\n else:\n-    exec(urlopen(\'https://bootstrap.pypa.io/ez_setup.py\').read(), ez)\n+    exec(urlopen("https://bootstrap.pypa.io/ez_setup.py").read(), ez)\n \n if not options.allow_site_packages:\n     # ez_setup imports site, which adds site packages\n     # this will remove them from the path to ensure that incompatible versions\n     # of setuptools are not in the path\n     import site\n+\n     # inside a virtualenv, there is no \'getsitepackages\'.\n     # We can\'t remove these reliably\n-    if hasattr(site, \'getsitepackages\'):\n+    if hasattr(site, "getsitepackages"):\n         for sitepackage_path in site.getsitepackages():\n             # Strip all site-packages directories from sys.path that\n             # are not sys.prefix; this is because on Windows\n             # sys.prefix is a site-package directory.\n             if sitepackage_path != sys.prefix:\n-                sys.path[:] = [x for x in sys.path\n-                               if sitepackage_path not in x]\n+                sys.path[:] = [x for x in sys.path if sitepackage_path not in x]\n \n setup_args = dict(to_dir=tmpeggs, download_delay=0)\n \n if options.setuptools_version is not None:\n-    setup_args[\'version\'] = options.setuptools_version\n+    setup_args["version"] = options.setuptools_version\n if options.setuptools_to_dir is not None:\n-    setup_args[\'to_dir\'] = options.setuptools_to_dir\n+    setup_args["to_dir"] = options.setuptools_to_dir\n \n-ez[\'use_setuptools\'](**setup_args)\n+ez["use_setuptools"](**setup_args)\n import setuptools\n import pkg_resources\n \n@@ -129,30 +143,37 @@\n \n ws = pkg_resources.working_set\n \n-setuptools_path = ws.find(\n-    pkg_resources.Requirement.parse(\'setuptools\')).location\n+setuptools_path = ws.find(pkg_resources.Requirement.parse("setuptools")).location\n \n # Fix sys.path here as easy_install.pth added before PYTHONPATH\n-cmd = [sys.executable, \'-c\',\n-       \'import sys; sys.path[0:0] = [%r]; \' % setuptools_path +\n-       \'from setuptools.command.easy_install import main; main()\',\n-       \'-mZqNxd\', tmpeggs]\n+cmd = [\n+    sys.executable,\n+    "-c",\n+    "import sys; sys.path[0:0] = [%r]; " % setuptools_path\n+    + "from setuptools.command.easy_install import main; main()",\n+    "-mZqNxd",\n+    tmpeggs,\n+]\n \n find_links = os.environ.get(\n-    \'bootstrap-testing-find-links\',\n-    options.find_links or\n-    (\'http://downloads.buildout.org/\'\n-     if options.accept_buildout_test_releases else None)\n-    )\n+    "bootstrap-testing-find-links",\n+    options.find_links\n+    or (\n+        "http://downloads.buildout.org/"\n+        if options.accept_buildout_test_releases\n+        else None\n+    ),\n+)\n if find_links:\n-    cmd.extend([\'-f\', find_links])\n+    cmd.extend(["-f", find_links])\n \n-requirement = \'zc.buildout\'\n+requirement = "zc.buildout"\n version = options.buildout_version\n if version is None and not options.accept_buildout_test_releases:\n     # Figure out the most recent final version of zc.buildout.\n     import setuptools.package_index\n-    _final_parts = \'*final-\', \'*final\'\n+\n+    _final_parts = "*final-", "*final"\n \n     def _final_version(parsed_version):\n         try:\n@@ -160,12 +181,11 @@ def _final_version(parsed_version):\n         except AttributeError:\n             # Older setuptools\n             for part in parsed_version:\n-                if (part[:1] == \'*\') and (part not in _final_parts):\n+                if (part[:1] == "*") and (part not in _final_parts):\n                     return False\n             return True\n \n-    index = setuptools.package_index.PackageIndex(\n-        search_path=[setuptools_path])\n+    index = setuptools.package_index.PackageIndex(search_path=[setuptools_path])\n     if find_links:\n         index.add_find_links((find_links,))\n     req = pkg_resources.Requirement.parse(requirement)\n@@ -184,13 +204,13 @@ def _final_version(parsed_version):\n             best.sort()\n             version = best[-1].version\n if version:\n-    requirement = \'==\'.join((requirement, version))\n+    requirement = "==".join((requirement, version))\n cmd.append(requirement)\n \n import subprocess\n+\n if subprocess.call(cmd) != 0:\n-    raise Exception(\n-        "Failed to execute command:\\n%s" % repr(cmd)[1:-1])\n+    raise Exception("Failed to execute command:\\n%s" % repr(cmd)[1:-1])\n \n ######################################################################\n # Import and run buildout\n@@ -199,12 +219,12 @@ def _final_version(parsed_version):\n ws.require(requirement)\n import zc.buildout.buildout\n \n-if not [a for a in args if \'=\' not in a]:\n-    args.append(\'bootstrap\')\n+if not [a for a in args if "=" not in a]:\n+    args.append("bootstrap")\n \n # if -c was provided, we push it back into args for buildout\' main function\n if options.config_file is not None:\n-    args[0:0] = [\'-c\', options.config_file]\n+    args[0:0] = ["-c", options.config_file]\n \n zc.buildout.buildout.main(args)\n shutil.rmtree(tmpeggs)\ndiff --git a/news/17.bugfix b/news/17.bugfix\nnew file mode 100644\nindex 0000000..8056098\n--- /dev/null\n+++ b/news/17.bugfix\n@@ -0,0 +1 @@\n+Make code black [ale-rt]\ndiff --git a/plone/__init__.py b/plone/__init__.py\nindex 68c04af..03d08ff 100644\n--- a/plone/__init__.py\n+++ b/plone/__init__.py\n@@ -1,2 +1,2 @@\n # -*- coding: utf-8 -*-\n-__import__(\'pkg_resources\').declare_namespace(__name__)\n+__import__("pkg_resources").declare_namespace(__name__)\ndiff --git a/plone/memoize/compress.py b/plone/memoize/compress.py\nindex bea7a21..6ef4bf8 100644\n--- a/plone/memoize/compress.py\n+++ b/plone/memoize/compress.py\n@@ -22,10 +22,10 @@ def xhtml_compress(string):\n \n @implementer(IXHTMLCompressor)\n class XHTMLSlimmer(object):\n-\n     def compress(self, string):\n         if SLIMMER:\n             return xhtml_slimmer(string)\n         return string\n \n+\n xhtmlslimmer = XHTMLSlimmer()\ndiff --git a/plone/memoize/forever.py b/plone/memoize/forever.py\nindex 5e020e6..11ba9ef 100644\n--- a/plone/memoize/forever.py\n+++ b/plone/memoize/forever.py\n@@ -13,13 +13,16 @@\n \n \n def memoize(fun):\n-\n     def get_key(fun, *args, **kwargs):\n-        return (args, frozenset(kwargs.items()), )\n+        return (\n+            args,\n+            frozenset(kwargs.items()),\n+        )\n \n     def get_cache(fun, *args, **kwargs):\n         return _memos\n \n     return volatile.cache(get_key, get_cache)(fun)\n \n-__all__ = (memoize, )\n+\n+__all__ = (memoize,)\ndiff --git a/plone/memoize/instance.py b/plone/memoize/instance.py\nindex 42c2961..f1b0671 100644\n--- a/plone/memoize/instance.py\n+++ b/plone/memoize/instance.py\n@@ -11,31 +11,30 @@\n \n \n class Memojito(object):\n-    propname = \'_memojito_\'\n+    propname = "_memojito_"\n \n     def clear(self, inst):\n         if hasattr(inst, self.propname):\n             delattr(inst, self.propname)\n \n     def clearbefore(self, func):\n-\n         def clear(*args, **kwargs):\n             inst = args[0]\n             self.clear(inst)\n             return func(*args, **kwargs)\n+\n         return clear\n \n     def clearafter(self, func):\n-\n         def clear(*args, **kwargs):\n             inst = args[0]\n             val = func(*args, **kwargs)\n             self.clear(inst)\n             return val\n+\n         return clear\n \n     def memoize(self, func):\n-\n         @wraps(func)\n         def memogetter(*args, **kwargs):\n             inst = args[0]\n@@ -54,6 +53,7 @@ def memogetter(*args, **kwargs):\n                 cache[key] = val\n                 setattr(inst, self.propname, cache)\n             return val\n+\n         return memogetter\n \n \n@@ -66,4 +66,5 @@ def memogetter(*args, **kwargs):\n def memoizedproperty(func):\n     return property(_m.memoize(func))\n \n+\n __all__ = (memoize, memoizedproperty, clearbefore, clearafter)\ndiff --git a/plone/memoize/interfaces.py b/plone/memoize/interfaces.py\nindex 3bae4df..8c83bf2 100644\n--- a/plone/memoize/interfaces.py\n+++ b/plone/memoize/interfaces.py\n@@ -3,7 +3,6 @@\n \n \n class ICacheChooser(Interface):\n-\n     def __call__(fun_name):\n         """Return a cache with a dict interface based on a dotted\n         function name `fun_name`.\n@@ -13,7 +12,6 @@ def __call__(fun_name):\n \n \n class IXHTMLCompressor(Interface):\n-\n     def compress(string):\n         """Expects a valid XHTML Unicode string as input and returns a valid\n         XHTML Unicode string.\ndiff --git a/plone/memoize/ram.py b/plone/memoize/ram.py\nindex 1db6e38..8876302 100644\n--- a/plone/memoize/ram.py\n+++ b/plone/memoize/ram.py\n@@ -30,7 +30,6 @@\n \n \n class AbstractDict:\n-\n     def get(self, key, default=None):\n         try:\n             return self.__getitem__(key)\n@@ -39,14 +38,13 @@ def get(self, key, default=None):\n \n \n class MemcacheAdapter(AbstractDict):\n-\n-    def __init__(self, client, globalkey=\'\'):\n+    def __init__(self, client, globalkey=""):\n         self.client = client\n-        self.globalkey = globalkey and \'%s:\' % globalkey\n+        self.globalkey = globalkey and "%s:" % globalkey\n \n     def _make_key(self, source):\n         if issubclass(type(source), six.text_type):\n-            source = source.encode(\'utf-8\')\n+            source = source.encode("utf-8")\n         return md5(source).hexdigest()\n \n     def __getitem__(self, key):\n@@ -62,39 +60,37 @@ def __setitem__(self, key, value):\n \n \n class RAMCacheAdapter(AbstractDict):\n-\n-    def __init__(self, ramcache, globalkey=\'\'):\n+    def __init__(self, ramcache, globalkey=""):\n         self.ramcache = ramcache\n         self.globalkey = globalkey\n \n     def _make_key(self, source):\n         if issubclass(type(source), six.text_type):\n-            source = source.encode(\'utf-8\')\n+            source = source.encode("utf-8")\n         return md5(source).digest()\n \n     def __getitem__(self, key):\n-        value = self.ramcache.query(self.globalkey,\n-                                    dict(key=self._make_key(key)),\n-                                    MARKER)\n+        value = self.ramcache.query(\n+            self.globalkey, dict(key=self._make_key(key)), MARKER\n+        )\n         if value is MARKER:\n             raise KeyError(key)\n         else:\n             return value\n \n     def __setitem__(self, key, value):\n-        self.ramcache.set(value,\n-                          self.globalkey,\n-                          dict(key=self._make_key(key)))\n+        self.ramcache.set(value, self.globalkey, dict(key=self._make_key(key)))\n \n \n def choose_cache(fun_name):\n-    return RAMCacheAdapter(component.queryUtility(IRAMCache),\n-                           globalkey=fun_name)\n+    return RAMCacheAdapter(component.queryUtility(IRAMCache), globalkey=fun_name)\n+\n+\n interface.directlyProvides(choose_cache, ICacheChooser)\n \n \n def store_in_cache(fun, *args, **kwargs):\n-    key = \'%s.%s\' % (fun.__module__, fun.__name__)\n+    key = "%s.%s" % (fun.__module__, fun.__name__)\n     cache_chooser = component.queryUtility(ICacheChooser)\n     if cache_chooser is not None:\n         return cache_chooser(key)\ndiff --git a/plone/memoize/request.py b/plone/memoize/request.py\nindex 8de98ff..acdc553 100644\n--- a/plone/memoize/request.py\n+++ b/plone/memoize/request.py\n@@ -13,13 +13,12 @@\n \n class RequestMemo(object):\n \n-    key = \'plone.memoize_request\'\n+    key = "plone.memoize_request"\n \n     def __init__(self, arg=0):\n         self.arg = arg\n \n     def __call__(self, func):\n-\n         @wraps(func)\n         def memogetter(*args, **kwargs):\n             request = None\n@@ -34,17 +33,21 @@ def memogetter(*args, **kwargs):\n             if cache is _marker:\n                 cache = annotations[self.key] = dict()\n \n-            key = (func.__module__, func.__name__,\n-                   args, frozenset(list(kwargs.items())))\n+            key = (\n+                func.__module__,\n+                func.__name__,\n+                args,\n+                frozenset(list(kwargs.items())),\n+            )\n             value = cache.get(key, _marker)\n             if value is _marker:\n                 value = cache[key] = func(*args, **kwargs)\n             return value\n+\n         return memogetter\n \n \n def store_in_annotation_of(expr):\n-\n     def _store_in_annotation(fun, *args, **kwargs):\n         # Use expr to find out the name of the request variable\n         vars = {}\n@@ -59,8 +62,10 @@ def _store_in_annotation(fun, *args, **kwargs):\n         if spec[3] is not None:\n             expected_num_args = len(spec[0]) - len(spec[3])\n         if num_args != expected_num_args:\n-            raise TypeError("%s() takes exactly %s arguments (%s given)"\n-                            % (fun.__name__, expected_num_args, num_args))\n+            raise TypeError(\n+                "%s() takes exactly %s arguments (%s given)"\n+                % (fun.__name__, expected_num_args, num_args)\n+            )\n \n         for index, name in enumerate(spec[0]):\n             if index < num_args:\n@@ -69,13 +74,14 @@ def _store_in_annotation(fun, *args, **kwargs):\n                 vars[name] = kwargs.get(name, spec[3][index - num_args])\n         request = eval(expr, {}, vars)\n         return IAnnotations(request)\n+\n     return _store_in_annotation\n \n \n-def cache(get_key, get_request=\'request\'):\n+def cache(get_key, get_request="request"):\n+\n+    return volatile.cache(get_key, get_cache=store_in_annotation_of(get_request))\n \n-    return volatile.cache(get_key,\n-                          get_cache=store_in_annotation_of(get_request))\n \n memoize_diy_request = RequestMemo\n \ndiff --git a/plone/memoize/tests.py b/plone/memoize/tests.py\nindex 63da7c5..ffbe9b3 100644\n--- a/plone/memoize/tests.py\n+++ b/plone/memoize/tests.py\n@@ -11,53 +11,71 @@\n def configurationSetUp(test):\n     setUp()\n     import zope.component\n-    XMLConfig(\'meta.zcml\', zope.component)()\n+\n+    XMLConfig("meta.zcml", zope.component)()\n     import plone.memoize\n-    XMLConfig(\'configure.zcml\', plone.memoize)()\n+\n+    XMLConfig("configure.zcml", plone.memoize)()\n \n \n def test_suite():\n     tests = (\n-        doctest.DocFileSuite(\'README.rst\',\n-                             package="plone.memoize",\n-                             setUp=configurationSetUp,\n-                             tearDown=tearDown,\n-                             optionflags=optionflags),\n-        doctest.DocFileSuite(\'compress.rst\',\n-                             package="plone.memoize",\n-                             setUp=configurationSetUp,\n-                             tearDown=tearDown,\n-                             optionflags=optionflags),\n-        doctest.DocFileSuite(\'forever.rst\',\n-                             package="plone.memoize",\n-                             setUp=configurationSetUp,\n-                             tearDown=tearDown,\n-                             optionflags=optionflags),\n-        doctest.DocFileSuite(\'instance.rst\',\n-                             package="plone.memoize",\n-                             setUp=configurationSetUp,\n-                             tearDown=tearDown,\n-                             optionflags=optionflags),\n-        doctest.DocFileSuite(\'ram.rst\',\n-                             package="plone.memoize",\n-                             setUp=configurationSetUp,\n-                             tearDown=tearDown,\n-                             optionflags=optionflags),\n-        doctest.DocFileSuite(\'request.rst\',\n-                             package="plone.memoize",\n-                             setUp=configurationSetUp,\n-                             tearDown=tearDown,\n-                             optionflags=optionflags),\n-        doctest.DocFileSuite(\'view.rst\',\n-                             package="plone.memoize",\n-                             setUp=configurationSetUp,\n-                             tearDown=tearDown,\n-                             optionflags=optionflags),\n-        doctest.DocFileSuite(\'volatile.rst\',\n-                             package="plone.memoize",\n-                             setUp=configurationSetUp,\n-                             tearDown=tearDown,\n-                             optionflags=optionflags),\n+        doctest.DocFileSuite(\n+            "README.rst",\n+            package="plone.memoize",\n+            setUp=configurationSetUp,\n+            tearDown=tearDown,\n+            optionflags=optionflags,\n+        ),\n+        doctest.DocFileSuite(\n+            "compress.rst",\n+            package="plone.memoize",\n+            setUp=configurationSetUp,\n+            tearDown=tearDown,\n+            optionflags=optionflags,\n+        ),\n+        doctest.DocFileSuite(\n+            "forever.rst",\n+            package="plone.memoize",\n+            setUp=configurationSetUp,\n+            tearDown=tearDown,\n+            optionflags=optionflags,\n+        ),\n+        doctest.DocFileSuite(\n+            "instance.rst",\n+            package="plone.memoize",\n+            setUp=configurationSetUp,\n+            tearDown=tearDown,\n+            optionflags=optionflags,\n+        ),\n+        doctest.DocFileSuite(\n+            "ram.rst",\n+            package="plone.memoize",\n+            setUp=configurationSetUp,\n+            tearDown=tearDown,\n+            optionflags=optionflags,\n+        ),\n+        doctest.DocFileSuite(\n+            "request.rst",\n+            package="plone.memoize",\n+            setUp=configurationSetUp,\n+            tearDown=tearDown,\n+            optionflags=optionflags,\n+        ),\n+        doctest.DocFileSuite(\n+            "view.rst",\n+            package="plone.memoize",\n+            setUp=configurationSetUp,\n+            tearDown=tearDown,\n+            optionflags=optionflags,\n+        ),\n+        doctest.DocFileSuite(\n+            "volatile.rst",\n+            package="plone.memoize",\n+            setUp=configurationSetUp,\n+            tearDown=tearDown,\n+            optionflags=optionflags,\n+        ),\n     )\n \n     return unittest.TestSuite(tests)\ndiff --git a/plone/memoize/view.py b/plone/memoize/view.py\nindex 3586ce1..dc57f7f 100644\n--- a/plone/memoize/view.py\n+++ b/plone/memoize/view.py\n@@ -11,16 +11,15 @@\n \n class ViewMemo(object):\n \n-    key = \'plone.memoize\'\n+    key = "plone.memoize"\n \n     def memoize(self, func):\n-\n         @wraps(func)\n         def memogetter(*args, **kwargs):\n             instance = args[0]\n \n-            context = getattr(instance, \'context\', None)\n-            request = getattr(instance, \'request\', None)\n+            context = getattr(instance, "context", None)\n+            request = getattr(instance, "request", None)\n \n             annotations = IAnnotations(request)\n             cache = annotations.get(self.key, _marker)\n@@ -41,19 +40,24 @@ def memogetter(*args, **kwargs):\n             # instance and the whole point is that we can cache different\n             # requests\n \n-            key = (context_id, instance.__class__.__name__, func.__name__,\n-                   args[1:], frozenset(kwargs.items()))\n+            key = (\n+                context_id,\n+                instance.__class__.__name__,\n+                func.__name__,\n+                args[1:],\n+                frozenset(kwargs.items()),\n+            )\n             value = cache.get(key, _marker)\n             if value is _marker:\n                 value = cache[key] = func(*args, **kwargs)\n             return value\n+\n         return memogetter\n \n     def memoize_contextless(self, func):\n-\n         def memogetter(*args, **kwargs):\n             instance = args[0]\n-            request = getattr(instance, \'request\', None)\n+            request = getattr(instance, "request", None)\n \n             annotations = IAnnotations(request)\n             cache = annotations.get(self.key, _marker)\n@@ -61,14 +65,20 @@ def memogetter(*args, **kwargs):\n             if cache is _marker:\n                 cache = annotations[self.key] = dict()\n \n-            key = (instance.__class__.__name__, func.__name__,\n-                   args[1:], frozenset(kwargs.items()))\n+            key = (\n+                instance.__class__.__name__,\n+                func.__name__,\n+                args[1:],\n+                frozenset(kwargs.items()),\n+            )\n             value = cache.get(key, _marker)\n             if value is _marker:\n                 value = cache[key] = func(*args, **kwargs)\n             return value\n+\n         return memogetter\n \n+\n _m = ViewMemo()\n memoize = _m.memoize\n memoize_contextless = _m.memoize_contextless\ndiff --git a/plone/memoize/volatile.py b/plone/memoize/volatile.py\nindex f921ded..37502a2 100644\n--- a/plone/memoize/volatile.py\n+++ b/plone/memoize/volatile.py\n@@ -13,6 +13,7 @@ class CleanupDict(dict):\n     """A dict that automatically cleans up items that haven\'t been\n     accessed in a given timespan on *set*.\n     """\n+\n     cleanup_period = 60 * 60 * 24 * 3  # 3 days\n \n     def __init__(self, cleanup_period=None):\n@@ -39,7 +40,8 @@ def _cleanup(self):\n                 del self._last_access[key]\n                 super(CleanupDict, self).__delitem__(key)\n \n-ATTR = \'_v_memoize_cache\'\n+\n+ATTR = "_v_memoize_cache"\n CONTAINER_FACTORY = CleanupDict\n _marker = object()\n \n@@ -57,20 +59,20 @@ def store_on_context(method, obj, *args, **kwargs):\n \n \n def cache(get_key, get_cache=store_on_self):\n-\n     def decorator(fun):\n-\n         @wraps(fun)\n         def replacement(*args, **kwargs):\n             try:\n                 key = get_key(fun, *args, **kwargs)\n             except DontCache:\n                 return fun(*args, **kwargs)\n-            key = \'%s.%s:%s\' % (fun.__module__, fun.__name__, key)\n+            key = "%s.%s:%s" % (fun.__module__, fun.__name__, key)\n             cache = get_cache(fun, *args, **kwargs)\n             cached_value = cache.get(key, _marker)\n             if cached_value is _marker:\n                 cached_value = cache[key] = fun(*args, **kwargs)\n             return cached_value\n+\n         return replacement\n+\n     return decorator\ndiff --git a/setup.py b/setup.py\nindex 21bcfa9..be8e128 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -7,17 +7,15 @@ def read(*rnames):\n     return open(os.path.join(os.path.dirname(__file__), *rnames)).read()\n \n \n-version = \'2.0.2.dev0\'\n+version = "2.0.2.dev0"\n \n-long_description = u"\\n".join([\n-    read(\'README.rst\'),\n-    read(\'plone\', \'memoize\', \'README.rst\'),\n-    read(\'CHANGES.rst\'),\n-])\n+long_description = u"\\n".join(\n+    [read("README.rst"), read("plone", "memoize", "README.rst"), read("CHANGES.rst"),]\n+)\n \n \n setup(\n-    name=\'plone.memoize\',\n+    name="plone.memoize",\n     version=version,\n     description="Decorators for caching the values of functions and methods",\n     long_description=long_description,\n@@ -42,28 +40,23 @@ def read(*rnames):\n         "Programming Language :: Python :: Implementation :: CPython",\n         "Programming Language :: Python :: Implementation :: PyPy",\n     ],\n-    keywords=\'plone memoize decorator cache\',\n-    author=\'Plone Foundation\',\n-    author_email=\'plone-developers@lists.sourceforge.net\',\n-    url=\'https://pypi.org/project/plone.memoize\',\n-    license=\'BSD\',\n+    keywords="plone memoize decorator cache",\n+    author="Plone Foundation",\n+    author_email="plone-developers@lists.sourceforge.net",\n+    url="https://pypi.org/project/plone.memoize",\n+    license="BSD",\n     packages=find_packages(),\n-    namespace_packages=[\'plone\'],\n+    namespace_packages=["plone"],\n     include_package_data=True,\n     zip_safe=False,\n-    test_suite=\'plone.memoize.tests.test_suite\',\n-    extras_require=dict(\n-        test=[\n-            \'zope.configuration\',\n-            \'zope.publisher\',\n-        ]\n-    ),\n+    test_suite="plone.memoize.tests.test_suite",\n+    extras_require=dict(test=["zope.configuration", "zope.publisher",]),\n     install_requires=[\n-        \'setuptools\',\n-        \'six\',\n-        \'zope.annotation\',\n-        \'zope.component\',\n-        \'zope.interface\',\n-        \'zope.ramcache\',\n+        "setuptools",\n+        "six",\n+        "zope.annotation",\n+        "zope.component",\n+        "zope.interface",\n+        "zope.ramcache",\n     ],\n )\n'

