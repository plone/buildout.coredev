Repository: plone.dexterity


Branch: refs/heads/master
Date: 2021-09-21T12:05:36+02:00
Author: Peter Mathis (petschki) <peter.mathis@kombinat.at>
Commit: https://github.com/plone/plone.dexterity/commit/9cabb702fd4073de11e9e27e1e776c28cfc4ed62

Fix recursion in FTI lookup

Files changed:
A news/155.bugfix
M plone/dexterity/content.py

b'diff --git a/news/155.bugfix b/news/155.bugfix\nnew file mode 100644\nindex 0000000..5478aed\n--- /dev/null\n+++ b/news/155.bugfix\n@@ -0,0 +1,2 @@\n+Fix recursion error when lookup IDexterityFTI for `Plone Site`\n+[petschki]\ndiff --git a/plone/dexterity/content.py b/plone/dexterity/content.py\nindex e397505..ccef458 100644\n--- a/plone/dexterity/content.py\n+++ b/plone/dexterity/content.py\n@@ -16,6 +16,7 @@\n from plone.dexterity.filerepresentation import DAVResourceMixin\n from plone.dexterity.interfaces import IDexterityContainer\n from plone.dexterity.interfaces import IDexterityContent\n+from plone.dexterity.interfaces import IDexterityFTI\n from plone.dexterity.interfaces import IDexterityItem\n from plone.dexterity.schema import SCHEMA_CACHE\n from plone.dexterity.utils import all_merged_tagged_values_dict\n@@ -50,7 +51,6 @@\n from zope.security.interfaces import IPermission\n \n import six\n-import warnings\n import threading\n \n \n@@ -62,6 +62,7 @@\n \n # see comment in DexterityContent.__getattr__ method\n ATTRIBUTE_NAMES_TO_IGNORE = (\n+    "_v__cached_fti",\n     "_dav_writelocks",\n     "aq_inner",\n     "getCurrentSkinName",\n@@ -149,6 +150,14 @@ def __get__(self, inst, cls=None):\n         if portal_type is None:\n             return spec\n \n+        fti = getattr(inst, "_v__cached_fti", None)\n+        if fti is None:\n+            fti = queryUtility(IDexterityFTI, name=portal_type)\n+            if fti is None:\n+                print(f"No FTI found for {portal_type}")\n+                return spec\n+            setattr(inst, "_v__cached_fti", fti)\n+\n         # Find the cached value. This calculation is expensive and called\n         # hundreds of times during each request, so we require a fast cache\n         cache = getattr(inst, "_v__providedBy__", None)\n@@ -160,7 +169,7 @@ def __get__(self, inst, cls=None):\n         #  - The instance has a different direct specification.\n         updated = (\n             inst._p_mtime,\n-            SCHEMA_CACHE.modified(portal_type),\n+            SCHEMA_CACHE.modified(fti),\n             SCHEMA_CACHE.invalidations,\n             hash(spec),\n         )\n@@ -169,7 +178,7 @@ def __get__(self, inst, cls=None):\n                 return cache[-1]\n             return spec\n \n-        main_schema = SCHEMA_CACHE.get(portal_type)\n+        main_schema = SCHEMA_CACHE.get(fti)\n         if main_schema:\n             dynamically_provided = [main_schema]\n         else:\n'

Repository: plone.dexterity


Branch: refs/heads/master
Date: 2021-09-21T12:06:10+02:00
Author: Peter Mathis (petschki) <peter.mathis@kombinat.at>
Commit: https://github.com/plone/plone.dexterity/commit/4caa6a9bacb3117b2e4561532410360be4ea8c0e

fix tests

and enable FTI lookup caching in tests by providing a global TestRequest

Files changed:
M plone/dexterity/content.py
M plone/dexterity/tests/case.py
M plone/dexterity/tests/test_content.py
M plone/dexterity/tests/test_schema_cache.py
M plone/dexterity/tests/test_security.py

b'diff --git a/plone/dexterity/content.py b/plone/dexterity/content.py\nindex ccef458..9fba265 100644\n--- a/plone/dexterity/content.py\n+++ b/plone/dexterity/content.py\n@@ -154,7 +154,6 @@ def __get__(self, inst, cls=None):\n         if fti is None:\n             fti = queryUtility(IDexterityFTI, name=portal_type)\n             if fti is None:\n-                print(f"No FTI found for {portal_type}")\n                 return spec\n             setattr(inst, "_v__cached_fti", fti)\n \ndiff --git a/plone/dexterity/tests/case.py b/plone/dexterity/tests/case.py\nindex 9b6b879..b98db41 100644\n--- a/plone/dexterity/tests/case.py\n+++ b/plone/dexterity/tests/case.py\n@@ -6,7 +6,7 @@\n import unittest\n import zope.component\n import zope.component.testing\n-\n+import zope.globalrequest\n \n try:\n     from unittest.mock import Mock\n@@ -24,6 +24,8 @@ class MockTestCase(unittest.TestCase):\n \n     def tearDown(self):\n         zope.component.testing.tearDown(self)\n+        zope.globalrequest.setRequest(None)\n+\n         if self._replaced_globals is not None:\n             for mock, orig in self._replaced_globals.items():\n                 _global_replace(mock, orig)\ndiff --git a/plone/dexterity/tests/test_content.py b/plone/dexterity/tests/test_content.py\nindex 2844138..205c6ac 100644\n--- a/plone/dexterity/tests/test_content.py\n+++ b/plone/dexterity/tests/test_content.py\n@@ -24,6 +24,8 @@\n from zope.component import provideAdapter\n from zope.interface import alsoProvides\n from zope.interface import Interface\n+from zope.globalrequest import setRequest\n+from zope.publisher.browser import TestRequest\n \n import six\n import zope.schema\n@@ -42,6 +44,7 @@\n \n class TestContent(MockTestCase):\n     def setUp(self):\n+        setRequest(TestRequest())\n         SCHEMA_CACHE.clear()\n         provideAdapter(DefaultOrdering)\n         provideAdapter(AttributeAnnotations)\n@@ -74,6 +77,7 @@ class IMarker(Interface):\n         fti_mock = Mock(wraps=DexterityFTI("testtype"))\n         fti_mock.lookupSchema = Mock(return_value=ISchema)\n         self.mock_utility(fti_mock, IDexterityFTI, name=u"testtype")\n+        alsoProvides(fti_mock, IDexterityFTI)\n \n         self.assertFalse(ISchema.implementedBy(Item))\n \n@@ -129,6 +133,7 @@ class IMarker(Interface):\n         fti_mock = Mock(wraps=DexterityFTI(u"testtype"))\n         fti_mock.lookupSchema = Mock(return_value=ISchema)\n         self.mock_utility(fti_mock, IDexterityFTI, name=u"testtype")\n+        alsoProvides(fti_mock, IDexterityFTI)\n \n         self.assertFalse(ISchema.implementedBy(MyItem))\n \n@@ -175,6 +180,7 @@ class IMarker(Interface):\n         fti_mock = Mock(wraps=DexterityFTI(u"testtype"))\n         fti_mock.lookupSchema = Mock(return_value=ISchema)\n         self.mock_utility(fti_mock, IDexterityFTI, name=u"testtype")\n+        alsoProvides(fti_mock, IDexterityFTI)\n \n         self.assertFalse(ISchema.implementedBy(MyItem))\n \n@@ -358,6 +364,7 @@ class IMarker3(Interface):\n         fti_mock = Mock(wraps=DexterityFTI(u"testtype"))\n         fti_mock.lookupSchema = Mock(return_value=ISchema)\n         self.mock_utility(fti_mock, IDexterityFTI, name=u"testtype")\n+        alsoProvides(fti_mock, IDexterityFTI)\n \n         # start clean\n         SCHEMA_CACHE.invalidate("testtype")\n@@ -411,6 +418,7 @@ class ISchema(Interface):\n         fti_mock = Mock(wraps=DexterityFTI(u"testtype"))\n         fti_mock.lookupSchema = Mock(return_value=ISchema)\n         self.mock_utility(fti_mock, IDexterityFTI, name=u"testtype")\n+        alsoProvides(fti_mock, IDexterityFTI)\n \n         SCHEMA_CACHE.invalidate("testtype")\n \n@@ -433,6 +441,7 @@ class ISchema(Interface):\n         fti_mock = Mock(wraps=DexterityFTI(u"testtype"))\n         fti_mock.lookupSchema = Mock(return_value=ISchema)\n         self.mock_utility(fti_mock, IDexterityFTI, name=u"testtype")\n+        alsoProvides(fti_mock, IDexterityFTI)\n \n         SCHEMA_CACHE.invalidate("testtype")\n \n@@ -462,6 +471,7 @@ class ISchema(Interface):\n         fti_mock = Mock(wraps=DexterityFTI(u"testtype"))\n         fti_mock.lookupSchema = Mock(return_value=ISchema)\n         self.mock_utility(fti_mock, IDexterityFTI, name=u"testtype")\n+        alsoProvides(fti_mock, IDexterityFTI)\n \n         SCHEMA_CACHE.invalidate("testtype")\n \n@@ -487,6 +497,7 @@ class ISchema(Interface):\n         fti_mock = Mock(wraps=DexterityFTI(u"testtype"))\n         fti_mock.lookupSchema = Mock(return_value=ISchema)\n         self.mock_utility(fti_mock, IDexterityFTI, name=u"testtype")\n+        alsoProvides(fti_mock, IDexterityFTI)\n \n         SCHEMA_CACHE.invalidate("testtype")\n \ndiff --git a/plone/dexterity/tests/test_schema_cache.py b/plone/dexterity/tests/test_schema_cache.py\nindex 8940b7f..9f05432 100644\n--- a/plone/dexterity/tests/test_schema_cache.py\n+++ b/plone/dexterity/tests/test_schema_cache.py\n@@ -4,7 +4,8 @@\n from plone.dexterity.interfaces import IDexterityFTI\n from plone.dexterity.schema import SCHEMA_CACHE\n from zope.interface import Interface\n-\n+from zope.globalrequest import setRequest\n+from zope.publisher.browser import TestRequest\n \n try:\n     from unittest.mock import Mock\n@@ -19,6 +20,7 @@\n \n class TestSchemaCache(MockTestCase):\n     def setUp(self):\n+        setRequest(TestRequest())\n         SCHEMA_CACHE.clear()\n \n     def test_repeated_get_lookup(self):\ndiff --git a/plone/dexterity/tests/test_security.py b/plone/dexterity/tests/test_security.py\nindex af4ccd6..acca24a 100644\n--- a/plone/dexterity/tests/test_security.py\n+++ b/plone/dexterity/tests/test_security.py\n@@ -10,6 +10,8 @@\n from zope.interface import provider\n from zope.security.interfaces import IPermission\n from zope.security.permission import Permission\n+from zope.globalrequest import setRequest\n+from zope.publisher.browser import TestRequest\n \n import zope.schema\n \n@@ -22,6 +24,7 @@\n \n class TestAttributeProtection(MockTestCase):\n     def setUp(self):\n+        setRequest(TestRequest())\n         SCHEMA_CACHE.clear()\n \n     def test_item(self):\n'

Repository: plone.dexterity


Branch: refs/heads/master
Date: 2021-09-21T12:13:12+02:00
Author: Peter Mathis (petschki) <peter.mathis@kombinat.at>
Commit: https://github.com/plone/plone.dexterity/commit/a679a8e7731dc1145842eca623d5ea70c9d40493

rethink recursion fix -&gt; catch earlier instead of caching FTI lookup

Files changed:
M news/155.bugfix
M plone/dexterity/content.py

b'diff --git a/news/155.bugfix b/news/155.bugfix\nindex 5478aed..a209590 100644\n--- a/news/155.bugfix\n+++ b/news/155.bugfix\n@@ -1,2 +1,2 @@\n-Fix recursion error when lookup IDexterityFTI for `Plone Site`\n+Catch maximum recursion error when lookup FTI\n [petschki]\ndiff --git a/plone/dexterity/content.py b/plone/dexterity/content.py\nindex 9fba265..1757415 100644\n--- a/plone/dexterity/content.py\n+++ b/plone/dexterity/content.py\n@@ -16,7 +16,6 @@\n from plone.dexterity.filerepresentation import DAVResourceMixin\n from plone.dexterity.interfaces import IDexterityContainer\n from plone.dexterity.interfaces import IDexterityContent\n-from plone.dexterity.interfaces import IDexterityFTI\n from plone.dexterity.interfaces import IDexterityItem\n from plone.dexterity.schema import SCHEMA_CACHE\n from plone.dexterity.utils import all_merged_tagged_values_dict\n@@ -62,7 +61,6 @@\n \n # see comment in DexterityContent.__getattr__ method\n ATTRIBUTE_NAMES_TO_IGNORE = (\n-    "_v__cached_fti",\n     "_dav_writelocks",\n     "aq_inner",\n     "getCurrentSkinName",\n@@ -150,42 +148,38 @@ def __get__(self, inst, cls=None):\n         if portal_type is None:\n             return spec\n \n-        fti = getattr(inst, "_v__cached_fti", None)\n-        if fti is None:\n-            fti = queryUtility(IDexterityFTI, name=portal_type)\n-            if fti is None:\n-                return spec\n-            setattr(inst, "_v__cached_fti", fti)\n-\n         # Find the cached value. This calculation is expensive and called\n         # hundreds of times during each request, so we require a fast cache\n         cache = getattr(inst, "_v__providedBy__", None)\n-\n-        # See if we have a current cache. Reasons to do this include:\n-        #\n-        #  - The FTI was modified.\n-        #  - The instance was modified and persisted since the cache was built.\n-        #  - The instance has a different direct specification.\n-        updated = (\n-            inst._p_mtime,\n-            SCHEMA_CACHE.modified(fti),\n-            SCHEMA_CACHE.invalidations,\n-            hash(spec),\n-        )\n-        if cache is not None and cache[:-1] == updated:\n-            if cache[-1] is not None:\n-                return cache[-1]\n-            return spec\n-\n-        main_schema = SCHEMA_CACHE.get(fti)\n-        if main_schema:\n-            dynamically_provided = [main_schema]\n-        else:\n-            dynamically_provided = []\n+        updated = ()\n+        dynamically_provided = []\n \n         # block recursion\n         setattr(_recursion_detection, "blocked", True)\n         try:\n+            # See if we have a current cache. Reasons to do this include:\n+            #\n+            #  - The FTI was modified.\n+            #  - The instance was modified and persisted since the cache was built.\n+            #  - The instance has a different direct specification.\n+            updated = (\n+                inst._p_mtime,\n+                SCHEMA_CACHE.modified(portal_type),\n+                SCHEMA_CACHE.invalidations,\n+                hash(spec),\n+            )\n+            if cache is not None and cache[:-1] == updated:\n+                setattr(_recursion_detection, "blocked", False)\n+                if cache[-1] is not None:\n+                    return cache[-1]\n+                return spec\n+\n+            main_schema = SCHEMA_CACHE.get(portal_type)\n+            if main_schema:\n+                dynamically_provided = [main_schema]\n+            else:\n+                dynamically_provided = []\n+\n             assignable = get_assignable(inst)\n             if assignable is not None:\n                 for behavior_registration in assignable.enumerateBehaviors():\n'

Repository: plone.dexterity


Branch: refs/heads/master
Date: 2021-09-27T10:36:23+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.dexterity/commit/b004e2f230a048c8cd81766dbac48a4bafe98969

Merge pull request #155 from plone/fix-plone-dx-siteroot-recursion

Fix recursion in FTI lookup

Files changed:
A news/155.bugfix
M plone/dexterity/content.py
M plone/dexterity/tests/case.py
M plone/dexterity/tests/test_content.py
M plone/dexterity/tests/test_schema_cache.py
M plone/dexterity/tests/test_security.py

b'diff --git a/news/155.bugfix b/news/155.bugfix\nnew file mode 100644\nindex 0000000..a209590\n--- /dev/null\n+++ b/news/155.bugfix\n@@ -0,0 +1,2 @@\n+Catch maximum recursion error when lookup FTI\n+[petschki]\ndiff --git a/plone/dexterity/content.py b/plone/dexterity/content.py\nindex e397505..1757415 100644\n--- a/plone/dexterity/content.py\n+++ b/plone/dexterity/content.py\n@@ -50,7 +50,6 @@\n from zope.security.interfaces import IPermission\n \n import six\n-import warnings\n import threading\n \n \n@@ -152,32 +151,35 @@ def __get__(self, inst, cls=None):\n         # Find the cached value. This calculation is expensive and called\n         # hundreds of times during each request, so we require a fast cache\n         cache = getattr(inst, "_v__providedBy__", None)\n-\n-        # See if we have a current cache. Reasons to do this include:\n-        #\n-        #  - The FTI was modified.\n-        #  - The instance was modified and persisted since the cache was built.\n-        #  - The instance has a different direct specification.\n-        updated = (\n-            inst._p_mtime,\n-            SCHEMA_CACHE.modified(portal_type),\n-            SCHEMA_CACHE.invalidations,\n-            hash(spec),\n-        )\n-        if cache is not None and cache[:-1] == updated:\n-            if cache[-1] is not None:\n-                return cache[-1]\n-            return spec\n-\n-        main_schema = SCHEMA_CACHE.get(portal_type)\n-        if main_schema:\n-            dynamically_provided = [main_schema]\n-        else:\n-            dynamically_provided = []\n+        updated = ()\n+        dynamically_provided = []\n \n         # block recursion\n         setattr(_recursion_detection, "blocked", True)\n         try:\n+            # See if we have a current cache. Reasons to do this include:\n+            #\n+            #  - The FTI was modified.\n+            #  - The instance was modified and persisted since the cache was built.\n+            #  - The instance has a different direct specification.\n+            updated = (\n+                inst._p_mtime,\n+                SCHEMA_CACHE.modified(portal_type),\n+                SCHEMA_CACHE.invalidations,\n+                hash(spec),\n+            )\n+            if cache is not None and cache[:-1] == updated:\n+                setattr(_recursion_detection, "blocked", False)\n+                if cache[-1] is not None:\n+                    return cache[-1]\n+                return spec\n+\n+            main_schema = SCHEMA_CACHE.get(portal_type)\n+            if main_schema:\n+                dynamically_provided = [main_schema]\n+            else:\n+                dynamically_provided = []\n+\n             assignable = get_assignable(inst)\n             if assignable is not None:\n                 for behavior_registration in assignable.enumerateBehaviors():\ndiff --git a/plone/dexterity/tests/case.py b/plone/dexterity/tests/case.py\nindex 9b6b879..b98db41 100644\n--- a/plone/dexterity/tests/case.py\n+++ b/plone/dexterity/tests/case.py\n@@ -6,7 +6,7 @@\n import unittest\n import zope.component\n import zope.component.testing\n-\n+import zope.globalrequest\n \n try:\n     from unittest.mock import Mock\n@@ -24,6 +24,8 @@ class MockTestCase(unittest.TestCase):\n \n     def tearDown(self):\n         zope.component.testing.tearDown(self)\n+        zope.globalrequest.setRequest(None)\n+\n         if self._replaced_globals is not None:\n             for mock, orig in self._replaced_globals.items():\n                 _global_replace(mock, orig)\ndiff --git a/plone/dexterity/tests/test_content.py b/plone/dexterity/tests/test_content.py\nindex 2844138..205c6ac 100644\n--- a/plone/dexterity/tests/test_content.py\n+++ b/plone/dexterity/tests/test_content.py\n@@ -24,6 +24,8 @@\n from zope.component import provideAdapter\n from zope.interface import alsoProvides\n from zope.interface import Interface\n+from zope.globalrequest import setRequest\n+from zope.publisher.browser import TestRequest\n \n import six\n import zope.schema\n@@ -42,6 +44,7 @@\n \n class TestContent(MockTestCase):\n     def setUp(self):\n+        setRequest(TestRequest())\n         SCHEMA_CACHE.clear()\n         provideAdapter(DefaultOrdering)\n         provideAdapter(AttributeAnnotations)\n@@ -74,6 +77,7 @@ class IMarker(Interface):\n         fti_mock = Mock(wraps=DexterityFTI("testtype"))\n         fti_mock.lookupSchema = Mock(return_value=ISchema)\n         self.mock_utility(fti_mock, IDexterityFTI, name=u"testtype")\n+        alsoProvides(fti_mock, IDexterityFTI)\n \n         self.assertFalse(ISchema.implementedBy(Item))\n \n@@ -129,6 +133,7 @@ class IMarker(Interface):\n         fti_mock = Mock(wraps=DexterityFTI(u"testtype"))\n         fti_mock.lookupSchema = Mock(return_value=ISchema)\n         self.mock_utility(fti_mock, IDexterityFTI, name=u"testtype")\n+        alsoProvides(fti_mock, IDexterityFTI)\n \n         self.assertFalse(ISchema.implementedBy(MyItem))\n \n@@ -175,6 +180,7 @@ class IMarker(Interface):\n         fti_mock = Mock(wraps=DexterityFTI(u"testtype"))\n         fti_mock.lookupSchema = Mock(return_value=ISchema)\n         self.mock_utility(fti_mock, IDexterityFTI, name=u"testtype")\n+        alsoProvides(fti_mock, IDexterityFTI)\n \n         self.assertFalse(ISchema.implementedBy(MyItem))\n \n@@ -358,6 +364,7 @@ class IMarker3(Interface):\n         fti_mock = Mock(wraps=DexterityFTI(u"testtype"))\n         fti_mock.lookupSchema = Mock(return_value=ISchema)\n         self.mock_utility(fti_mock, IDexterityFTI, name=u"testtype")\n+        alsoProvides(fti_mock, IDexterityFTI)\n \n         # start clean\n         SCHEMA_CACHE.invalidate("testtype")\n@@ -411,6 +418,7 @@ class ISchema(Interface):\n         fti_mock = Mock(wraps=DexterityFTI(u"testtype"))\n         fti_mock.lookupSchema = Mock(return_value=ISchema)\n         self.mock_utility(fti_mock, IDexterityFTI, name=u"testtype")\n+        alsoProvides(fti_mock, IDexterityFTI)\n \n         SCHEMA_CACHE.invalidate("testtype")\n \n@@ -433,6 +441,7 @@ class ISchema(Interface):\n         fti_mock = Mock(wraps=DexterityFTI(u"testtype"))\n         fti_mock.lookupSchema = Mock(return_value=ISchema)\n         self.mock_utility(fti_mock, IDexterityFTI, name=u"testtype")\n+        alsoProvides(fti_mock, IDexterityFTI)\n \n         SCHEMA_CACHE.invalidate("testtype")\n \n@@ -462,6 +471,7 @@ class ISchema(Interface):\n         fti_mock = Mock(wraps=DexterityFTI(u"testtype"))\n         fti_mock.lookupSchema = Mock(return_value=ISchema)\n         self.mock_utility(fti_mock, IDexterityFTI, name=u"testtype")\n+        alsoProvides(fti_mock, IDexterityFTI)\n \n         SCHEMA_CACHE.invalidate("testtype")\n \n@@ -487,6 +497,7 @@ class ISchema(Interface):\n         fti_mock = Mock(wraps=DexterityFTI(u"testtype"))\n         fti_mock.lookupSchema = Mock(return_value=ISchema)\n         self.mock_utility(fti_mock, IDexterityFTI, name=u"testtype")\n+        alsoProvides(fti_mock, IDexterityFTI)\n \n         SCHEMA_CACHE.invalidate("testtype")\n \ndiff --git a/plone/dexterity/tests/test_schema_cache.py b/plone/dexterity/tests/test_schema_cache.py\nindex 8940b7f..9f05432 100644\n--- a/plone/dexterity/tests/test_schema_cache.py\n+++ b/plone/dexterity/tests/test_schema_cache.py\n@@ -4,7 +4,8 @@\n from plone.dexterity.interfaces import IDexterityFTI\n from plone.dexterity.schema import SCHEMA_CACHE\n from zope.interface import Interface\n-\n+from zope.globalrequest import setRequest\n+from zope.publisher.browser import TestRequest\n \n try:\n     from unittest.mock import Mock\n@@ -19,6 +20,7 @@\n \n class TestSchemaCache(MockTestCase):\n     def setUp(self):\n+        setRequest(TestRequest())\n         SCHEMA_CACHE.clear()\n \n     def test_repeated_get_lookup(self):\ndiff --git a/plone/dexterity/tests/test_security.py b/plone/dexterity/tests/test_security.py\nindex af4ccd6..acca24a 100644\n--- a/plone/dexterity/tests/test_security.py\n+++ b/plone/dexterity/tests/test_security.py\n@@ -10,6 +10,8 @@\n from zope.interface import provider\n from zope.security.interfaces import IPermission\n from zope.security.permission import Permission\n+from zope.globalrequest import setRequest\n+from zope.publisher.browser import TestRequest\n \n import zope.schema\n \n@@ -22,6 +24,7 @@\n \n class TestAttributeProtection(MockTestCase):\n     def setUp(self):\n+        setRequest(TestRequest())\n         SCHEMA_CACHE.clear()\n \n     def test_item(self):\n'

