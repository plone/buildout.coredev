Repository: plone.app.querystring


Branch: refs/heads/1.x
Date: 2022-07-07T16:34:56+02:00
Author: Mikel Larreategi (erral) <mlarreategi@codesyntax.com>
Commit: https://github.com/plone/plone.app.querystring/commit/d1a1d54532899e21442ef2642ce740d9b8d58cba

add failing tests to use SearchableText

Files changed:
M plone/app/querystring/tests/testQueryBuilder.py

b'diff --git a/plone/app/querystring/tests/testQueryBuilder.py b/plone/app/querystring/tests/testQueryBuilder.py\nindex a112304..6b579d0 100644\n--- a/plone/app/querystring/tests/testQueryBuilder.py\n+++ b/plone/app/querystring/tests/testQueryBuilder.py\n@@ -209,6 +209,48 @@ def testMakeQueryWithUnicodeSubjectWithMultipleSubjects(self):\n             results[0].getObject().Subject(),\n             (\'\xc3\x84\xc3\xbc\xc3\xb6\',))\n \n+    def testMakeQueryWithSearchableText(self):\n+        query = [{\n+            \'i\': \'SearchableText\',\n+            \'o\': \'plone.app.querystring.operation.string.contains\',\n+            \'v\': u\'Test\',\n+        }]\n+        results = self.querybuilder._makequery(query=query)\n+        self.assertEqual(len(results), 1)\n+        self.assertEqual(\n+            results[0].getURL(),\n+            \'http://nohost/plone/testfolder\')\n+\n+    def testMakeQueryWithSearchableTextSpecialWordsAnd(self):\n+        self.testpage.description = \'This and that is the description\'\n+        self.testpage.reindexObject()\n+        query = [{\n+            \'i\': \'SearchableText\',\n+            \'o\': \'plone.app.querystring.operation.string.contains\',\n+            \'v\': u\'This and that\',\n+        }]\n+        results = self.querybuilder._makequery(query=query)\n+        self.assertEqual(len(results), 1)\n+        self.assertEqual(\n+            results[0].getURL(),\n+            \'http://nohost/plone/collectionstestpage\')\n+\n+    def testMakeQueryWithSearchableTextSpecialWordsOr(self):\n+        self.testpage.description = \'This or that is the description\'\n+        self.testpage.reindexObject()\n+        query = [{\n+            \'i\': \'SearchableText\',\n+            \'o\': \'plone.app.querystring.operation.string.contains\',\n+            \'v\': u\'This or that\',\n+        }]\n+        results = self.querybuilder._makequery(query=query)\n+        self.assertEqual(len(results), 1)\n+        self.assertEqual(\n+            results[0].getURL(),\n+            \'http://nohost/plone/collectionstestpage\')\n+\n+\n+\n     def testQueryBuilderCustomQuery(self):\n         """Test, if custom queries are respected when getting the results.\n         """\n'

Repository: plone.app.querystring


Branch: refs/heads/1.x
Date: 2022-07-08T18:12:21+02:00
Author: Mikel Larreategi (erral) <mlarreategi@codesyntax.com>
Commit: https://github.com/plone/plone.app.querystring/commit/4a6bfdb56e615e4dd9d6e8fdbcb585d9310fb741

rework the munge_search_term function

Files changed:
M plone/app/querystring/querybuilder.py

b'diff --git a/plone/app/querystring/querybuilder.py b/plone/app/querystring/querybuilder.py\nindex 8cd3c39..0b44e73 100644\n--- a/plone/app/querystring/querybuilder.py\n+++ b/plone/app/querystring/querybuilder.py\n@@ -15,22 +15,35 @@\n \n import json\n import logging\n+import re\n \n \n-logger = logging.getLogger(\'plone.app.querystring\')\n-_ = MessageFactory(\'plone\')\n+logger = logging.getLogger("plone.app.querystring")\n+_ = MessageFactory("plone")\n \n-BAD_CHARS = (\'?\', \'-\', \'+\', \'*\')\n+MULTISPACE = "\\u3000"\n+BAD_CHARS = ("?", "-", "+", "*", MULTISPACE)\n \n \n def quote_chars(s):\n     # We need to quote parentheses when searching text indices\n-    if \'(\' in s:\n-        s = s.replace(\'(\', \'"("\')\n-    if \')\' in s:\n-        s = s.replace(\')\', \'")"\')\n+    if "(" in s:\n+        s = s.replace("(", \'"("\')\n+    if ")" in s:\n+        s = s.replace(")", \'")"\')\n+    if MULTISPACE in s:\n+        s = s.replace(MULTISPACE, " ")\n     return s\n \n+\n+def quote(term):\n+    # The terms and, or and not must be wrapped in quotes to avoid\n+    # being parsed as logical query atoms.\n+    if term.lower() in ("and", "or", "not"):\n+        term = \'"%s"\' % term\n+    return term\n+\n+\n class ContentListingView(BrowserView):\n     """BrowserView for displaying query results"""\n \n@@ -39,16 +52,25 @@ def __call__(self, **kw):\n \n \n class QueryBuilder(BrowserView):\n-    """ This view is used by the javascripts,\n-        fetching configuration or results"""\n+    """This view is used by the javascripts,\n+    fetching configuration or results"""\n \n     def __init__(self, context, request):\n         super(QueryBuilder, self).__init__(context, request)\n         self._results = None\n \n-    def __call__(self, query, batch=False, b_start=0, b_size=30,\n-                 sort_on=None, sort_order=None, limit=0, brains=False,\n-                 custom_query=None):\n+    def __call__(\n+        self,\n+        query,\n+        batch=False,\n+        b_start=0,\n+        b_size=30,\n+        sort_on=None,\n+        sort_order=None,\n+        limit=0,\n+        brains=False,\n+        custom_query=None,\n+    ):\n         """Create a zope catalog query and return results.\n \n         :param query: The querystring to be parsed into a zope catalog query.\n@@ -95,32 +117,45 @@ def __call__(self, query, batch=False, b_start=0, b_size=30,\n                 sort_order=sort_order,\n                 limit=limit,\n                 brains=brains,\n-                custom_query=custom_query)\n+                custom_query=custom_query,\n+            )\n         return self._results\n \n     def html_results(self, query):\n         """html results, used for in the edit screen of a collection,\n-           used in the live update results"""\n+        used in the live update results"""\n         options = dict(original_context=self.context)\n-        results = self(query, sort_on=self.request.get(\'sort_on\', None),\n-                       sort_order=self.request.get(\'sort_order\', None),\n-                       limit=10)\n+        results = self(\n+            query,\n+            sort_on=self.request.get("sort_on", None),\n+            sort_order=self.request.get("sort_order", None),\n+            limit=10,\n+        )\n \n         return getMultiAdapter(\n-            (results, self.request),\n-            name=\'display_query_results\'\n+            (results, self.request), name="display_query_results"\n         )(**options)\n \n-    def _makequery(self, query=None, batch=False, b_start=0, b_size=30,\n-                   sort_on=None, sort_order=None, limit=0, brains=False,\n-                   custom_query=None):\n+    def _makequery(\n+        self,\n+        query=None,\n+        batch=False,\n+        b_start=0,\n+        b_size=30,\n+        sort_on=None,\n+        sort_order=None,\n+        limit=0,\n+        brains=False,\n+        custom_query=None,\n+    ):\n         """Parse the (form)query and return using multi-adapter"""\n         query_modifiers = getUtilitiesFor(IQueryModifier)\n         for name, modifier in sorted(query_modifiers, key=itemgetter(0)):\n             query = modifier(query)\n \n         parsedquery = queryparser.parseFormquery(\n-            self.context, query, sort_on, sort_order)\n+            self.context, query, sort_on, sort_order\n+        )\n \n         index_modifiers = getUtilitiesFor(IParsedQueryIndexModifier)\n         for name, modifier in index_modifiers:\n@@ -134,36 +169,37 @@ def _makequery(self, query=None, batch=False, b_start=0, b_size=30,\n                     parsedquery[new_name] = query\n \n         # Check for valid indexes\n-        catalog = getToolByName(self.context, \'portal_catalog\')\n-        valid_indexes = [index for index in parsedquery\n-                         if index in catalog.indexes()]\n+        catalog = getToolByName(self.context, "portal_catalog")\n+        valid_indexes = [\n+            index for index in parsedquery if index in catalog.indexes()\n+        ]\n \n         # We\'ll ignore any invalid index, but will return an empty set if none\n         # of the indexes are valid.\n         if not valid_indexes:\n             logger.warning(\n-                "Using empty query because there are no valid indexes used.")\n+                "Using empty query because there are no valid indexes used."\n+            )\n             parsedquery = {}\n \n         empty_query = not parsedquery  # store emptiness\n \n         if batch:\n-            parsedquery[\'b_start\'] = b_start\n-            parsedquery[\'b_size\'] = b_size\n+            parsedquery["b_start"] = b_start\n+            parsedquery["b_size"] = b_size\n         elif limit:\n-            parsedquery[\'sort_limit\'] = limit\n+            parsedquery["sort_limit"] = limit\n \n-        if \'path\' not in parsedquery:\n-            parsedquery[\'path\'] = {\'query\': \'\'}\n+        if "path" not in parsedquery:\n+            parsedquery["path"] = {"query": ""}\n \n         if isinstance(custom_query, dict) and custom_query:\n             # Update the parsed query with an extra query dictionary. This may\n             # override the parsed query. The custom_query is a dictonary of\n             # index names and their associated query values.\n             for key in custom_query:\n-                if (\n-                    isinstance(parsedquery.get(key), dict)\n-                    and isinstance(custom_query.get(key), dict)\n+                if isinstance(parsedquery.get(key), dict) and isinstance(\n+                    custom_query.get(key), dict\n                 ):\n                     parsedquery[key].update(custom_query[key])\n                     continue\n@@ -175,8 +211,11 @@ def _makequery(self, query=None, batch=False, b_start=0, b_size=30,\n         results = []\n         if not empty_query:\n             results = catalog(**parsedquery)\n-            if getattr(results, \'actual_result_count\', False) and limit\\\n-                    and results.actual_result_count > limit:\n+            if (\n+                getattr(results, "actual_result_count", False)\n+                and limit\n+                and results.actual_result_count > limit\n+            ):\n                 results.actual_result_count = limit\n \n         if not brains:\n@@ -189,26 +228,42 @@ def number_of_results(self, query):\n         """Get the number of results"""\n         results = self(query, sort_on=None, sort_order=None, limit=1)\n         return translate(\n-            _(u"batch_x_items_matching_your_criteria",\n-              default=u"${number} items matching your search terms.",\n-              mapping={\'number\': results.actual_result_count}),\n-            context=self.request\n+            _(\n+                u"batch_x_items_matching_your_criteria",\n+                default=u"${number} items matching your search terms.",\n+                mapping={"number": results.actual_result_count},\n+            ),\n+            context=self.request,\n         )\n \n     def filter_query(self, query):\n-        text = query.get(\'SearchableText\', None)\n+        text = query.get("SearchableText", None)\n         if isinstance(text, dict):\n-            text = text.get(\'query\', \'\')\n+            text = text.get("query", "")\n         if text:\n-            query[\'SearchableText\'] = self.munge_search_term(text)\n+            query["SearchableText"] = self.munge_search_term(text)\n         return query\n \n-    def munge_search_term(self, q):\n+    def munge_search_term(query):\n         for char in BAD_CHARS:\n-            q = q.replace(char, \' \')\n-        r = q.split()\n+            query = query.replace(char, " ")\n+\n+        # extract quoted phrases first\n+        quoted_phrases = re.findall(r\'"([^"]*)"\', query)\n+        r = []\n+        for qp in quoted_phrases:\n+            # remove from original query\n+            query = query.replace(\'"{qp}"\'.format(qp=qp), "")\n+            # replace with cleaned leading/trailing whitespaces\n+            # and skip empty phrases\n+            clean_qp = qp.strip()\n+            if not clean_qp:\n+                continue\n+            r.append(\'"{clean_qp}"\'.format(clean_qp=clean_qp))\n+\n+        r += map(quote, query.strip().split())\n         r = " AND ".join(r)\n-        r = quote_chars(r) + \'*\'\n+        r = quote_chars(r) + ("*" if r and not r.endswith(\'"\') else "")\n         return r\n \n \n@@ -216,6 +271,7 @@ class RegistryConfiguration(BrowserView):\n     def __call__(self):\n         registry = getUtility(IRegistry)\n         reader = getMultiAdapter(\n-            (registry, self.request), IQuerystringRegistryReader)\n+            (registry, self.request), IQuerystringRegistryReader\n+        )\n         data = reader()\n         return json.dumps(data)\n'

Repository: plone.app.querystring


Branch: refs/heads/1.x
Date: 2022-07-08T18:12:26+02:00
Author: Mikel Larreategi (erral) <mlarreategi@codesyntax.com>
Commit: https://github.com/plone/plone.app.querystring/commit/f72bfb2c468b35c4d92dd1b6dcc7541687c887d8

changelog

Files changed:
A news/111.bugfix

b"diff --git a/news/111.bugfix b/news/111.bugfix\nnew file mode 100644\nindex 0000000..214546b\n--- /dev/null\n+++ b/news/111.bugfix\n@@ -0,0 +1,2 @@\n+Make SearchableText work when using 'and' and 'or' as search items\n+[erral]\n"

Repository: plone.app.querystring


Branch: refs/heads/1.x
Date: 2022-07-09T11:16:17+02:00
Author: Peter Mathis (petschki) <petschki@users.noreply.github.com>
Commit: https://github.com/plone/plone.app.querystring/commit/7452027c9e31a21fafe253f3e2a2f481285dc869

fix positional arguments in class method

Files changed:
M plone/app/querystring/querybuilder.py

b'diff --git a/plone/app/querystring/querybuilder.py b/plone/app/querystring/querybuilder.py\nindex 0b44e73..02b2104 100644\n--- a/plone/app/querystring/querybuilder.py\n+++ b/plone/app/querystring/querybuilder.py\n@@ -13,7 +13,7 @@\n from zope.i18nmessageid import MessageFactory\n from zope.publisher.browser import BrowserView\n \n-import json\n+import jso\n import logging\n import re\n \n@@ -244,7 +244,7 @@ def filter_query(self, query):\n             query["SearchableText"] = self.munge_search_term(text)\n         return query\n \n-    def munge_search_term(query):\n+    def munge_search_term(self, query):\n         for char in BAD_CHARS:\n             query = query.replace(char, " ")\n \n'

Repository: plone.app.querystring


Branch: refs/heads/1.x
Date: 2022-07-09T11:17:40+02:00
Author: Peter Mathis (petschki) <petschki@users.noreply.github.com>
Commit: https://github.com/plone/plone.app.querystring/commit/2b54538a79b628f6846dbf074a851a95c3814c17

typo

Files changed:
M plone/app/querystring/querybuilder.py

b'diff --git a/plone/app/querystring/querybuilder.py b/plone/app/querystring/querybuilder.py\nindex 02b2104..dcf0194 100644\n--- a/plone/app/querystring/querybuilder.py\n+++ b/plone/app/querystring/querybuilder.py\n@@ -13,7 +13,7 @@\n from zope.i18nmessageid import MessageFactory\n from zope.publisher.browser import BrowserView\n \n-import jso\n+import json\n import logging\n import re\n \n'

Repository: plone.app.querystring


Branch: refs/heads/1.x
Date: 2022-07-11T08:07:05+02:00
Author: Peter Mathis (petschki) <petschki@users.noreply.github.com>
Commit: https://github.com/plone/plone.app.querystring/commit/252854f7d96e15b231ca7eee7d5beacbcaa09e0d

Merge pull request #112 from plone/erral-issue-111

Fixes #111 for branch 1.x

Files changed:
A news/111.bugfix
M plone/app/querystring/querybuilder.py
M plone/app/querystring/tests/testQueryBuilder.py

b'diff --git a/news/111.bugfix b/news/111.bugfix\nnew file mode 100644\nindex 0000000..214546b\n--- /dev/null\n+++ b/news/111.bugfix\n@@ -0,0 +1,2 @@\n+Make SearchableText work when using \'and\' and \'or\' as search items\n+[erral]\ndiff --git a/plone/app/querystring/querybuilder.py b/plone/app/querystring/querybuilder.py\nindex 8cd3c39..dcf0194 100644\n--- a/plone/app/querystring/querybuilder.py\n+++ b/plone/app/querystring/querybuilder.py\n@@ -15,22 +15,35 @@\n \n import json\n import logging\n+import re\n \n \n-logger = logging.getLogger(\'plone.app.querystring\')\n-_ = MessageFactory(\'plone\')\n+logger = logging.getLogger("plone.app.querystring")\n+_ = MessageFactory("plone")\n \n-BAD_CHARS = (\'?\', \'-\', \'+\', \'*\')\n+MULTISPACE = "\\u3000"\n+BAD_CHARS = ("?", "-", "+", "*", MULTISPACE)\n \n \n def quote_chars(s):\n     # We need to quote parentheses when searching text indices\n-    if \'(\' in s:\n-        s = s.replace(\'(\', \'"("\')\n-    if \')\' in s:\n-        s = s.replace(\')\', \'")"\')\n+    if "(" in s:\n+        s = s.replace("(", \'"("\')\n+    if ")" in s:\n+        s = s.replace(")", \'")"\')\n+    if MULTISPACE in s:\n+        s = s.replace(MULTISPACE, " ")\n     return s\n \n+\n+def quote(term):\n+    # The terms and, or and not must be wrapped in quotes to avoid\n+    # being parsed as logical query atoms.\n+    if term.lower() in ("and", "or", "not"):\n+        term = \'"%s"\' % term\n+    return term\n+\n+\n class ContentListingView(BrowserView):\n     """BrowserView for displaying query results"""\n \n@@ -39,16 +52,25 @@ def __call__(self, **kw):\n \n \n class QueryBuilder(BrowserView):\n-    """ This view is used by the javascripts,\n-        fetching configuration or results"""\n+    """This view is used by the javascripts,\n+    fetching configuration or results"""\n \n     def __init__(self, context, request):\n         super(QueryBuilder, self).__init__(context, request)\n         self._results = None\n \n-    def __call__(self, query, batch=False, b_start=0, b_size=30,\n-                 sort_on=None, sort_order=None, limit=0, brains=False,\n-                 custom_query=None):\n+    def __call__(\n+        self,\n+        query,\n+        batch=False,\n+        b_start=0,\n+        b_size=30,\n+        sort_on=None,\n+        sort_order=None,\n+        limit=0,\n+        brains=False,\n+        custom_query=None,\n+    ):\n         """Create a zope catalog query and return results.\n \n         :param query: The querystring to be parsed into a zope catalog query.\n@@ -95,32 +117,45 @@ def __call__(self, query, batch=False, b_start=0, b_size=30,\n                 sort_order=sort_order,\n                 limit=limit,\n                 brains=brains,\n-                custom_query=custom_query)\n+                custom_query=custom_query,\n+            )\n         return self._results\n \n     def html_results(self, query):\n         """html results, used for in the edit screen of a collection,\n-           used in the live update results"""\n+        used in the live update results"""\n         options = dict(original_context=self.context)\n-        results = self(query, sort_on=self.request.get(\'sort_on\', None),\n-                       sort_order=self.request.get(\'sort_order\', None),\n-                       limit=10)\n+        results = self(\n+            query,\n+            sort_on=self.request.get("sort_on", None),\n+            sort_order=self.request.get("sort_order", None),\n+            limit=10,\n+        )\n \n         return getMultiAdapter(\n-            (results, self.request),\n-            name=\'display_query_results\'\n+            (results, self.request), name="display_query_results"\n         )(**options)\n \n-    def _makequery(self, query=None, batch=False, b_start=0, b_size=30,\n-                   sort_on=None, sort_order=None, limit=0, brains=False,\n-                   custom_query=None):\n+    def _makequery(\n+        self,\n+        query=None,\n+        batch=False,\n+        b_start=0,\n+        b_size=30,\n+        sort_on=None,\n+        sort_order=None,\n+        limit=0,\n+        brains=False,\n+        custom_query=None,\n+    ):\n         """Parse the (form)query and return using multi-adapter"""\n         query_modifiers = getUtilitiesFor(IQueryModifier)\n         for name, modifier in sorted(query_modifiers, key=itemgetter(0)):\n             query = modifier(query)\n \n         parsedquery = queryparser.parseFormquery(\n-            self.context, query, sort_on, sort_order)\n+            self.context, query, sort_on, sort_order\n+        )\n \n         index_modifiers = getUtilitiesFor(IParsedQueryIndexModifier)\n         for name, modifier in index_modifiers:\n@@ -134,36 +169,37 @@ def _makequery(self, query=None, batch=False, b_start=0, b_size=30,\n                     parsedquery[new_name] = query\n \n         # Check for valid indexes\n-        catalog = getToolByName(self.context, \'portal_catalog\')\n-        valid_indexes = [index for index in parsedquery\n-                         if index in catalog.indexes()]\n+        catalog = getToolByName(self.context, "portal_catalog")\n+        valid_indexes = [\n+            index for index in parsedquery if index in catalog.indexes()\n+        ]\n \n         # We\'ll ignore any invalid index, but will return an empty set if none\n         # of the indexes are valid.\n         if not valid_indexes:\n             logger.warning(\n-                "Using empty query because there are no valid indexes used.")\n+                "Using empty query because there are no valid indexes used."\n+            )\n             parsedquery = {}\n \n         empty_query = not parsedquery  # store emptiness\n \n         if batch:\n-            parsedquery[\'b_start\'] = b_start\n-            parsedquery[\'b_size\'] = b_size\n+            parsedquery["b_start"] = b_start\n+            parsedquery["b_size"] = b_size\n         elif limit:\n-            parsedquery[\'sort_limit\'] = limit\n+            parsedquery["sort_limit"] = limit\n \n-        if \'path\' not in parsedquery:\n-            parsedquery[\'path\'] = {\'query\': \'\'}\n+        if "path" not in parsedquery:\n+            parsedquery["path"] = {"query": ""}\n \n         if isinstance(custom_query, dict) and custom_query:\n             # Update the parsed query with an extra query dictionary. This may\n             # override the parsed query. The custom_query is a dictonary of\n             # index names and their associated query values.\n             for key in custom_query:\n-                if (\n-                    isinstance(parsedquery.get(key), dict)\n-                    and isinstance(custom_query.get(key), dict)\n+                if isinstance(parsedquery.get(key), dict) and isinstance(\n+                    custom_query.get(key), dict\n                 ):\n                     parsedquery[key].update(custom_query[key])\n                     continue\n@@ -175,8 +211,11 @@ def _makequery(self, query=None, batch=False, b_start=0, b_size=30,\n         results = []\n         if not empty_query:\n             results = catalog(**parsedquery)\n-            if getattr(results, \'actual_result_count\', False) and limit\\\n-                    and results.actual_result_count > limit:\n+            if (\n+                getattr(results, "actual_result_count", False)\n+                and limit\n+                and results.actual_result_count > limit\n+            ):\n                 results.actual_result_count = limit\n \n         if not brains:\n@@ -189,26 +228,42 @@ def number_of_results(self, query):\n         """Get the number of results"""\n         results = self(query, sort_on=None, sort_order=None, limit=1)\n         return translate(\n-            _(u"batch_x_items_matching_your_criteria",\n-              default=u"${number} items matching your search terms.",\n-              mapping={\'number\': results.actual_result_count}),\n-            context=self.request\n+            _(\n+                u"batch_x_items_matching_your_criteria",\n+                default=u"${number} items matching your search terms.",\n+                mapping={"number": results.actual_result_count},\n+            ),\n+            context=self.request,\n         )\n \n     def filter_query(self, query):\n-        text = query.get(\'SearchableText\', None)\n+        text = query.get("SearchableText", None)\n         if isinstance(text, dict):\n-            text = text.get(\'query\', \'\')\n+            text = text.get("query", "")\n         if text:\n-            query[\'SearchableText\'] = self.munge_search_term(text)\n+            query["SearchableText"] = self.munge_search_term(text)\n         return query\n \n-    def munge_search_term(self, q):\n+    def munge_search_term(self, query):\n         for char in BAD_CHARS:\n-            q = q.replace(char, \' \')\n-        r = q.split()\n+            query = query.replace(char, " ")\n+\n+        # extract quoted phrases first\n+        quoted_phrases = re.findall(r\'"([^"]*)"\', query)\n+        r = []\n+        for qp in quoted_phrases:\n+            # remove from original query\n+            query = query.replace(\'"{qp}"\'.format(qp=qp), "")\n+            # replace with cleaned leading/trailing whitespaces\n+            # and skip empty phrases\n+            clean_qp = qp.strip()\n+            if not clean_qp:\n+                continue\n+            r.append(\'"{clean_qp}"\'.format(clean_qp=clean_qp))\n+\n+        r += map(quote, query.strip().split())\n         r = " AND ".join(r)\n-        r = quote_chars(r) + \'*\'\n+        r = quote_chars(r) + ("*" if r and not r.endswith(\'"\') else "")\n         return r\n \n \n@@ -216,6 +271,7 @@ class RegistryConfiguration(BrowserView):\n     def __call__(self):\n         registry = getUtility(IRegistry)\n         reader = getMultiAdapter(\n-            (registry, self.request), IQuerystringRegistryReader)\n+            (registry, self.request), IQuerystringRegistryReader\n+        )\n         data = reader()\n         return json.dumps(data)\ndiff --git a/plone/app/querystring/tests/testQueryBuilder.py b/plone/app/querystring/tests/testQueryBuilder.py\nindex a112304..6b579d0 100644\n--- a/plone/app/querystring/tests/testQueryBuilder.py\n+++ b/plone/app/querystring/tests/testQueryBuilder.py\n@@ -209,6 +209,48 @@ def testMakeQueryWithUnicodeSubjectWithMultipleSubjects(self):\n             results[0].getObject().Subject(),\n             (\'\xc3\x84\xc3\xbc\xc3\xb6\',))\n \n+    def testMakeQueryWithSearchableText(self):\n+        query = [{\n+            \'i\': \'SearchableText\',\n+            \'o\': \'plone.app.querystring.operation.string.contains\',\n+            \'v\': u\'Test\',\n+        }]\n+        results = self.querybuilder._makequery(query=query)\n+        self.assertEqual(len(results), 1)\n+        self.assertEqual(\n+            results[0].getURL(),\n+            \'http://nohost/plone/testfolder\')\n+\n+    def testMakeQueryWithSearchableTextSpecialWordsAnd(self):\n+        self.testpage.description = \'This and that is the description\'\n+        self.testpage.reindexObject()\n+        query = [{\n+            \'i\': \'SearchableText\',\n+            \'o\': \'plone.app.querystring.operation.string.contains\',\n+            \'v\': u\'This and that\',\n+        }]\n+        results = self.querybuilder._makequery(query=query)\n+        self.assertEqual(len(results), 1)\n+        self.assertEqual(\n+            results[0].getURL(),\n+            \'http://nohost/plone/collectionstestpage\')\n+\n+    def testMakeQueryWithSearchableTextSpecialWordsOr(self):\n+        self.testpage.description = \'This or that is the description\'\n+        self.testpage.reindexObject()\n+        query = [{\n+            \'i\': \'SearchableText\',\n+            \'o\': \'plone.app.querystring.operation.string.contains\',\n+            \'v\': u\'This or that\',\n+        }]\n+        results = self.querybuilder._makequery(query=query)\n+        self.assertEqual(len(results), 1)\n+        self.assertEqual(\n+            results[0].getURL(),\n+            \'http://nohost/plone/collectionstestpage\')\n+\n+\n+\n     def testQueryBuilderCustomQuery(self):\n         """Test, if custom queries are respected when getting the results.\n         """\n'

