Repository: plone.namedfile


Branch: refs/heads/master
Date: 2021-06-19T01:50:25+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.namedfile/commit/37b9b7f29b0f804df622db9502abae28f3eccf38

Prevent stored XSS from file upload (svg, html).
Do this by implementing an allowlist of trusted mimetypes.
You can turn this around by using a denylist of just svg, html and javascript.
Do this by setting OS environment variable ``NAMEDFILE_USE_DENYLIST=1``.
From [Products.PloneHotfix20210518](https://plone.org/security/hotfix/20210518/reflected-xss-in-various-spots).

Files changed:
A news/3274.feature
A plone/namedfile/tests/file.pdf
A plone/namedfile/tests/test_display_file.py
M plone/namedfile/browser.py
M plone/namedfile/usage.rst
M setup.py

b'diff --git a/news/3274.feature b/news/3274.feature\nnew file mode 100644\nindex 0000000..b931022\n--- /dev/null\n+++ b/news/3274.feature\n@@ -0,0 +1,6 @@\n+Prevent stored XSS from file upload (svg, html).\n+Do this by implementing an allowlist of trusted mimetypes.\n+You can turn this around by using a denylist of just svg, html and javascript.\n+Do this by setting OS environment variable ``NAMEDFILE_USE_DENYLIST=1``.\n+From `Products.PloneHotfix20210518 <https://plone.org/security/hotfix/20210518/reflected-xss-in-various-spots>`_.\n+[maurits]\ndiff --git a/plone/namedfile/browser.py b/plone/namedfile/browser.py\nindex 012797f..0792545 100644\n--- a/plone/namedfile/browser.py\n+++ b/plone/namedfile/browser.py\n@@ -11,6 +11,56 @@\n from ZPublisher.HTTPRangeSupport import expandRanges\n from ZPublisher.HTTPRangeSupport import parseRange\n \n+import os\n+\n+\n+# List of mimetypes that we allow to display inline.\n+# This is mostly to avoid XSS (Cross Site Scripting).\n+# We especially do not want image/svg+xml, text/html, application/javascript.\n+# If a Manager has a use case for displaying those inline, there are other ways to create them,\n+# for example in the ZMI as standard OFS File or maybe via the Resource Registries or Theming control panel.\n+# ATContentTypes allows PDF and a few old MS Office formats to display inline.\n+# But I think most browsers always ask what you want to do for each mimetype,\n+# and you can let it remember your answer.\n+# So: a few image mimetypes are likely enough here.\n+# Note: a tag like `<img src="example.svg" />` loading an image/svg+xml mimetype will show up fine.\n+# But when you visit example.svg as url, you will get a download.\n+ALLOWED_INLINE_MIMETYPES = [\n+    "image/gif",\n+    # The mimetypes registry lists several for jpeg 2000:\n+    "image/jp2",\n+    "image/jpeg",\n+    "image/jpeg2000-image",\n+    "image/jpeg2000",\n+    "image/jpx",\n+    "image/png",\n+    "image/webp",\n+    "image/x-icon",\n+    "image/x-jpeg2000-image",\n+    "text/plain",\n+    # By popular request we allow PDF:\n+    "application/pdf",\n+]\n+\n+# Perhaps a denylist is better.\n+DISALLOWED_INLINE_MIMETYPES = [\n+    "application/javascript",\n+    "application/x-javascript",\n+    "text/javascript",\n+    "text/html",\n+    "image/svg+xml",\n+    "image/svg+xml-compressed",\n+]\n+\n+# By default we use the allowlist.  We might change this when merging back to plone.namedfile.\n+# We give integrators the option to choose the denylist via an environment variable.\n+try:\n+    # Look for sane name, and fall back to very specific name of hotfix.\n+    USE_DENYLIST = os.environ.get("NAMEDFILE_USE_DENYLIST", os.environ.get("PLONEHOTFIX20210518_NAMEDFILE_USE_DENYLIST", 0))\n+    USE_DENYLIST = bool(int(USE_DENYLIST))\n+except (ValueError, TypeError, AttributeError):\n+    USE_DENYLIST = False\n+\n \n @implementer(IPublishTraverse)\n class Download(BrowserView):\n@@ -75,8 +125,13 @@ def handle_request_range(self, file):\n         return {}\n \n     def set_headers(self, file):\n+        # With filename None, set_headers will not add the download headers.\n         if not self.filename:\n-            self.filename = getattr(file, \'filename\', self.fieldname)\n+            self.filename = getattr(file, "filename", None)\n+            if self.filename is None:\n+                self.filename = self.fieldname\n+                if self.filename is None:\n+                    self.filename = "file.ext"\n         set_headers(file, self.request.response, filename=self.filename)\n \n     def _getFile(self):\n@@ -108,5 +163,23 @@ class DisplayFile(Download):\n     Same as Download, however in this case we don\'t set the filename so the\n     browser can decide to display the file instead.\n     """\n+\n+    # Make the configuration available on the class.\n+    # Then subclasses can override this.\n+    allowed_inline_mimetypes = ALLOWED_INLINE_MIMETYPES\n+    disallowed_inline_mimetypes = DISALLOWED_INLINE_MIMETYPES\n+    use_denylist = USE_DENYLIST\n+\n     def set_headers(self, file):\n+        if hasattr(file, "contentType"):\n+            mimetype = file.contentType\n+            if self.use_denylist:\n+                if mimetype in self.disallowed_inline_mimetypes:\n+                    # Let the Download view handle this.\n+                    return super(DisplayFile, self).set_headers(file)\n+            else:\n+                # Use the allowlist\n+                if mimetype not in self.allowed_inline_mimetypes:\n+                    # Let the Download view handle this.\n+                    return super(DisplayFile, self).set_headers(file)\n         set_headers(file, self.request.response)\ndiff --git a/plone/namedfile/tests/file.pdf b/plone/namedfile/tests/file.pdf\nnew file mode 100644\nindex 0000000..2cc4348\nBinary files /dev/null and b/plone/namedfile/tests/file.pdf differ\ndiff --git a/plone/namedfile/tests/test_display_file.py b/plone/namedfile/tests/test_display_file.py\nnew file mode 100644\nindex 0000000..fe537e8\n--- /dev/null\n+++ b/plone/namedfile/tests/test_display_file.py\n@@ -0,0 +1,167 @@\n+# -*- coding: utf-8 -*-\n+from OFS.SimpleItem import SimpleItem\n+from plone.app.testing import SITE_OWNER_NAME\n+from plone.app.testing import SITE_OWNER_PASSWORD\n+from plone.namedfile import field\n+from plone.namedfile import file\n+from plone.namedfile.interfaces import IImageScaleTraversable\n+from plone.namedfile.testing import PLONE_NAMEDFILE_FUNCTIONAL_TESTING\n+from plone.namedfile.tests import getFile\n+from plone.testing.zope import Browser\n+from Products.CMFPlone.utils import safe_unicode\n+from zope.annotation import IAttributeAnnotatable\n+from zope.interface import implementer\n+\n+import os\n+import transaction\n+import unittest\n+\n+\n+class ISchema(IImageScaleTraversable):\n+    image = field.NamedImage()\n+    blob_image = field.NamedBlobImage()\n+    file = field.NamedFile()\n+    blob_file = field.NamedBlobFile()\n+\n+\n+@implementer(IAttributeAnnotatable, ISchema)\n+class DummyContent(SimpleItem):\n+    # Adapted from test_scaling_functional.py\n+    image = None\n+    blob_image = None\n+    file = None\n+    blob_file = None\n+    # modified = DateTime\n+    id = __name__ = "item"\n+    title = "foo"\n+\n+    def Title(self):\n+        return self.title\n+\n+\n+def get_disposition_header(browser):\n+    # Could be CamelCase or all lowercase.\n+    name = "Content-Disposition"\n+    if name in browser.headers.keys():\n+        return browser.headers.get(name)\n+    name = name.lower()\n+    return browser.headers.get(name, None)\n+\n+\n+class TestAttackVectorNamedImage(unittest.TestCase):\n+    layer = PLONE_NAMEDFILE_FUNCTIONAL_TESTING\n+    field_class = file.NamedImage\n+    field_name = "image"\n+\n+    def setUp(self):\n+        self.portal = self.layer["app"]\n+        item = DummyContent()\n+        self.layer["app"]._setOb("item", item)\n+        self.item = self.layer["app"].item\n+\n+    def get_admin_browser(self):\n+        browser = Browser(self.layer["app"])\n+        browser.handleErrors = False\n+        browser.addHeader(\n+            "Authorization",\n+            "Basic {0}:{1}".format(SITE_OWNER_NAME, SITE_OWNER_PASSWORD),\n+        )\n+        return browser\n+\n+    def get_anon_browser(self):\n+        browser = Browser(self.layer["app"])\n+        browser.handleErrors = False\n+        return browser\n+\n+    def _named_file(self, name):\n+        data = getFile(name)\n+        return self.field_class(data, filename=safe_unicode(name))\n+\n+    def assert_download_works(self, base_url):\n+        browser = self.get_anon_browser()\n+        browser.open(base_url + "/@@download/{0}".format(self.field_name))\n+        header = get_disposition_header(browser)\n+        self.assertIsNotNone(header)\n+        self.assertIn("attachment", header)\n+        self.assertIn("filename", header)\n+\n+    def assert_display_inline_works(self, base_url):\n+        # Test that displaying this file inline works.\n+        browser = self.get_anon_browser()\n+        browser.open(base_url + "/@@display-file/{0}".format(self.field_name))\n+        self.assertIsNone(get_disposition_header(browser))\n+\n+    def assert_display_inline_is_download(self, base_url):\n+        # Test that displaying this file inline turns into a download.\n+        browser = self.get_anon_browser()\n+        browser.open(base_url + "/@@display-file/{0}".format(self.field_name))\n+        header = get_disposition_header(browser)\n+        self.assertIsNotNone(header)\n+        self.assertIn("attachment", header)\n+        self.assertIn("filename", header)\n+\n+    def test_png_image(self):\n+        setattr(self.item, self.field_name, self._named_file("image.png"))\n+        transaction.commit()\n+        base_url = self.item.absolute_url()\n+        self.assert_download_works(base_url)\n+        self.assert_display_inline_works(base_url)\n+\n+    def test_svg_image(self):\n+        setattr(self.item, self.field_name, self._named_file("image.svg"))\n+        transaction.commit()\n+        base_url = self.item.absolute_url()\n+        self.assert_download_works(base_url)\n+        self.assert_display_inline_is_download(base_url)\n+\n+    def test_filename_none(self):\n+        # A \'None\' filename None probably does not happen during normal upload,\n+        # but if an attacker manages this, even @@download will show inline.\n+        data = self._named_file("image.svg")\n+        data.filename = None\n+        setattr(self.item, self.field_name, data)\n+        transaction.commit()\n+        base_url = self.item.absolute_url()\n+        self.assert_download_works(base_url)\n+        self.assert_display_inline_is_download(base_url)\n+\n+    def test_filename_empty(self):\n+        # An empty filename is probably no problem, but let\'s check.\n+        data = self._named_file("image.svg")\n+        data.filename = u""\n+        setattr(self.item, self.field_name, self._named_file("image.svg"))\n+        transaction.commit()\n+        base_url = self.item.absolute_url()\n+        self.assert_download_works(base_url)\n+        self.assert_display_inline_is_download(base_url)\n+\n+\n+class TestAttackVectorNamedBlobImage(TestAttackVectorNamedImage):\n+    field_class = file.NamedBlobImage\n+\n+\n+class TestAttackVectorNamedFile(TestAttackVectorNamedImage):\n+    field_class = file.NamedFile\n+    field_name = "file"\n+\n+    def test_html_file(self):\n+        data = self.field_class(\n+            "<h1>Attacker</h1>", filename=safe_unicode("attacker.html")\n+        )\n+        setattr(self.item, self.field_name, data)\n+        transaction.commit()\n+        base_url = self.item.absolute_url()\n+        self.assert_download_works(base_url)\n+        self.assert_display_inline_is_download(base_url)\n+\n+    def test_pdf(self):\n+        # By popular request we allow PDF.\n+        setattr(self.item, self.field_name, self._named_file("file.pdf"))\n+        transaction.commit()\n+        base_url = self.item.absolute_url()\n+        self.assert_download_works(base_url)\n+        self.assert_display_inline_works(base_url)\n+\n+\n+class TestAttackVectorNamedBlobFile(TestAttackVectorNamedFile):\n+    field_class = file.NamedBlobFile\ndiff --git a/plone/namedfile/usage.rst b/plone/namedfile/usage.rst\nindex 6f6ce31..77030c2 100644\n--- a/plone/namedfile/usage.rst\n+++ b/plone/namedfile/usage.rst\n@@ -289,7 +289,12 @@ We will test this with a dummy request, faking traversal::\n     \'341\'\n     >>> request.response.getHeader(\'Content-Type\')\n     \'image/foo\'\n+\n+Since the Content-Type is unknown, we do not trust it, and refuse to display inline.\n+We download instead.\n+\n     >>> request.response.getHeader(\'Content-Disposition\')\n+    "attachment; filename*=UTF-8\'\'zpt.gif"\n \n     >>> request = TestRequest()\n     >>> display_file = DisplayFile(container, request).publishTraverse(request, \'blobimage\')\n@@ -301,6 +306,7 @@ We will test this with a dummy request, faking traversal::\n     >>> request.response.getHeader(\'Content-Type\')\n     \'image/foo\'\n     >>> request.response.getHeader(\'Content-Disposition\')\n+    "attachment; filename*=UTF-8\'\'zpt.gif"\n \n \n Specifying the primary field\ndiff --git a/setup.py b/setup.py\nindex e316291..72e10ee 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -5,7 +5,7 @@\n import os\n \n \n-version = \'5.4.1.dev0\'\n+version = \'5.5.0.dev0\'\n \n description = \'File types and fields for images, files and blob files with \' \\\n               \'filenames\'\n'

Repository: plone.namedfile


Branch: refs/heads/master
Date: 2021-06-30T12:10:56+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.namedfile/commit/2ae8ad9b6434d7b900cb257d7a018fe704092c06

Merge pull request #99 from plone/hotfix-20210518

Prevent stored XSS from file upload (svg, html).

Files changed:
A news/3274.feature
A plone/namedfile/tests/file.pdf
A plone/namedfile/tests/test_display_file.py
M plone/namedfile/browser.py
M plone/namedfile/usage.rst
M setup.py

b'diff --git a/news/3274.feature b/news/3274.feature\nnew file mode 100644\nindex 0000000..b931022\n--- /dev/null\n+++ b/news/3274.feature\n@@ -0,0 +1,6 @@\n+Prevent stored XSS from file upload (svg, html).\n+Do this by implementing an allowlist of trusted mimetypes.\n+You can turn this around by using a denylist of just svg, html and javascript.\n+Do this by setting OS environment variable ``NAMEDFILE_USE_DENYLIST=1``.\n+From `Products.PloneHotfix20210518 <https://plone.org/security/hotfix/20210518/reflected-xss-in-various-spots>`_.\n+[maurits]\ndiff --git a/plone/namedfile/browser.py b/plone/namedfile/browser.py\nindex 012797f..0792545 100644\n--- a/plone/namedfile/browser.py\n+++ b/plone/namedfile/browser.py\n@@ -11,6 +11,56 @@\n from ZPublisher.HTTPRangeSupport import expandRanges\n from ZPublisher.HTTPRangeSupport import parseRange\n \n+import os\n+\n+\n+# List of mimetypes that we allow to display inline.\n+# This is mostly to avoid XSS (Cross Site Scripting).\n+# We especially do not want image/svg+xml, text/html, application/javascript.\n+# If a Manager has a use case for displaying those inline, there are other ways to create them,\n+# for example in the ZMI as standard OFS File or maybe via the Resource Registries or Theming control panel.\n+# ATContentTypes allows PDF and a few old MS Office formats to display inline.\n+# But I think most browsers always ask what you want to do for each mimetype,\n+# and you can let it remember your answer.\n+# So: a few image mimetypes are likely enough here.\n+# Note: a tag like `<img src="example.svg" />` loading an image/svg+xml mimetype will show up fine.\n+# But when you visit example.svg as url, you will get a download.\n+ALLOWED_INLINE_MIMETYPES = [\n+    "image/gif",\n+    # The mimetypes registry lists several for jpeg 2000:\n+    "image/jp2",\n+    "image/jpeg",\n+    "image/jpeg2000-image",\n+    "image/jpeg2000",\n+    "image/jpx",\n+    "image/png",\n+    "image/webp",\n+    "image/x-icon",\n+    "image/x-jpeg2000-image",\n+    "text/plain",\n+    # By popular request we allow PDF:\n+    "application/pdf",\n+]\n+\n+# Perhaps a denylist is better.\n+DISALLOWED_INLINE_MIMETYPES = [\n+    "application/javascript",\n+    "application/x-javascript",\n+    "text/javascript",\n+    "text/html",\n+    "image/svg+xml",\n+    "image/svg+xml-compressed",\n+]\n+\n+# By default we use the allowlist.  We might change this when merging back to plone.namedfile.\n+# We give integrators the option to choose the denylist via an environment variable.\n+try:\n+    # Look for sane name, and fall back to very specific name of hotfix.\n+    USE_DENYLIST = os.environ.get("NAMEDFILE_USE_DENYLIST", os.environ.get("PLONEHOTFIX20210518_NAMEDFILE_USE_DENYLIST", 0))\n+    USE_DENYLIST = bool(int(USE_DENYLIST))\n+except (ValueError, TypeError, AttributeError):\n+    USE_DENYLIST = False\n+\n \n @implementer(IPublishTraverse)\n class Download(BrowserView):\n@@ -75,8 +125,13 @@ def handle_request_range(self, file):\n         return {}\n \n     def set_headers(self, file):\n+        # With filename None, set_headers will not add the download headers.\n         if not self.filename:\n-            self.filename = getattr(file, \'filename\', self.fieldname)\n+            self.filename = getattr(file, "filename", None)\n+            if self.filename is None:\n+                self.filename = self.fieldname\n+                if self.filename is None:\n+                    self.filename = "file.ext"\n         set_headers(file, self.request.response, filename=self.filename)\n \n     def _getFile(self):\n@@ -108,5 +163,23 @@ class DisplayFile(Download):\n     Same as Download, however in this case we don\'t set the filename so the\n     browser can decide to display the file instead.\n     """\n+\n+    # Make the configuration available on the class.\n+    # Then subclasses can override this.\n+    allowed_inline_mimetypes = ALLOWED_INLINE_MIMETYPES\n+    disallowed_inline_mimetypes = DISALLOWED_INLINE_MIMETYPES\n+    use_denylist = USE_DENYLIST\n+\n     def set_headers(self, file):\n+        if hasattr(file, "contentType"):\n+            mimetype = file.contentType\n+            if self.use_denylist:\n+                if mimetype in self.disallowed_inline_mimetypes:\n+                    # Let the Download view handle this.\n+                    return super(DisplayFile, self).set_headers(file)\n+            else:\n+                # Use the allowlist\n+                if mimetype not in self.allowed_inline_mimetypes:\n+                    # Let the Download view handle this.\n+                    return super(DisplayFile, self).set_headers(file)\n         set_headers(file, self.request.response)\ndiff --git a/plone/namedfile/tests/file.pdf b/plone/namedfile/tests/file.pdf\nnew file mode 100644\nindex 0000000..2cc4348\nBinary files /dev/null and b/plone/namedfile/tests/file.pdf differ\ndiff --git a/plone/namedfile/tests/test_display_file.py b/plone/namedfile/tests/test_display_file.py\nnew file mode 100644\nindex 0000000..fe537e8\n--- /dev/null\n+++ b/plone/namedfile/tests/test_display_file.py\n@@ -0,0 +1,167 @@\n+# -*- coding: utf-8 -*-\n+from OFS.SimpleItem import SimpleItem\n+from plone.app.testing import SITE_OWNER_NAME\n+from plone.app.testing import SITE_OWNER_PASSWORD\n+from plone.namedfile import field\n+from plone.namedfile import file\n+from plone.namedfile.interfaces import IImageScaleTraversable\n+from plone.namedfile.testing import PLONE_NAMEDFILE_FUNCTIONAL_TESTING\n+from plone.namedfile.tests import getFile\n+from plone.testing.zope import Browser\n+from Products.CMFPlone.utils import safe_unicode\n+from zope.annotation import IAttributeAnnotatable\n+from zope.interface import implementer\n+\n+import os\n+import transaction\n+import unittest\n+\n+\n+class ISchema(IImageScaleTraversable):\n+    image = field.NamedImage()\n+    blob_image = field.NamedBlobImage()\n+    file = field.NamedFile()\n+    blob_file = field.NamedBlobFile()\n+\n+\n+@implementer(IAttributeAnnotatable, ISchema)\n+class DummyContent(SimpleItem):\n+    # Adapted from test_scaling_functional.py\n+    image = None\n+    blob_image = None\n+    file = None\n+    blob_file = None\n+    # modified = DateTime\n+    id = __name__ = "item"\n+    title = "foo"\n+\n+    def Title(self):\n+        return self.title\n+\n+\n+def get_disposition_header(browser):\n+    # Could be CamelCase or all lowercase.\n+    name = "Content-Disposition"\n+    if name in browser.headers.keys():\n+        return browser.headers.get(name)\n+    name = name.lower()\n+    return browser.headers.get(name, None)\n+\n+\n+class TestAttackVectorNamedImage(unittest.TestCase):\n+    layer = PLONE_NAMEDFILE_FUNCTIONAL_TESTING\n+    field_class = file.NamedImage\n+    field_name = "image"\n+\n+    def setUp(self):\n+        self.portal = self.layer["app"]\n+        item = DummyContent()\n+        self.layer["app"]._setOb("item", item)\n+        self.item = self.layer["app"].item\n+\n+    def get_admin_browser(self):\n+        browser = Browser(self.layer["app"])\n+        browser.handleErrors = False\n+        browser.addHeader(\n+            "Authorization",\n+            "Basic {0}:{1}".format(SITE_OWNER_NAME, SITE_OWNER_PASSWORD),\n+        )\n+        return browser\n+\n+    def get_anon_browser(self):\n+        browser = Browser(self.layer["app"])\n+        browser.handleErrors = False\n+        return browser\n+\n+    def _named_file(self, name):\n+        data = getFile(name)\n+        return self.field_class(data, filename=safe_unicode(name))\n+\n+    def assert_download_works(self, base_url):\n+        browser = self.get_anon_browser()\n+        browser.open(base_url + "/@@download/{0}".format(self.field_name))\n+        header = get_disposition_header(browser)\n+        self.assertIsNotNone(header)\n+        self.assertIn("attachment", header)\n+        self.assertIn("filename", header)\n+\n+    def assert_display_inline_works(self, base_url):\n+        # Test that displaying this file inline works.\n+        browser = self.get_anon_browser()\n+        browser.open(base_url + "/@@display-file/{0}".format(self.field_name))\n+        self.assertIsNone(get_disposition_header(browser))\n+\n+    def assert_display_inline_is_download(self, base_url):\n+        # Test that displaying this file inline turns into a download.\n+        browser = self.get_anon_browser()\n+        browser.open(base_url + "/@@display-file/{0}".format(self.field_name))\n+        header = get_disposition_header(browser)\n+        self.assertIsNotNone(header)\n+        self.assertIn("attachment", header)\n+        self.assertIn("filename", header)\n+\n+    def test_png_image(self):\n+        setattr(self.item, self.field_name, self._named_file("image.png"))\n+        transaction.commit()\n+        base_url = self.item.absolute_url()\n+        self.assert_download_works(base_url)\n+        self.assert_display_inline_works(base_url)\n+\n+    def test_svg_image(self):\n+        setattr(self.item, self.field_name, self._named_file("image.svg"))\n+        transaction.commit()\n+        base_url = self.item.absolute_url()\n+        self.assert_download_works(base_url)\n+        self.assert_display_inline_is_download(base_url)\n+\n+    def test_filename_none(self):\n+        # A \'None\' filename None probably does not happen during normal upload,\n+        # but if an attacker manages this, even @@download will show inline.\n+        data = self._named_file("image.svg")\n+        data.filename = None\n+        setattr(self.item, self.field_name, data)\n+        transaction.commit()\n+        base_url = self.item.absolute_url()\n+        self.assert_download_works(base_url)\n+        self.assert_display_inline_is_download(base_url)\n+\n+    def test_filename_empty(self):\n+        # An empty filename is probably no problem, but let\'s check.\n+        data = self._named_file("image.svg")\n+        data.filename = u""\n+        setattr(self.item, self.field_name, self._named_file("image.svg"))\n+        transaction.commit()\n+        base_url = self.item.absolute_url()\n+        self.assert_download_works(base_url)\n+        self.assert_display_inline_is_download(base_url)\n+\n+\n+class TestAttackVectorNamedBlobImage(TestAttackVectorNamedImage):\n+    field_class = file.NamedBlobImage\n+\n+\n+class TestAttackVectorNamedFile(TestAttackVectorNamedImage):\n+    field_class = file.NamedFile\n+    field_name = "file"\n+\n+    def test_html_file(self):\n+        data = self.field_class(\n+            "<h1>Attacker</h1>", filename=safe_unicode("attacker.html")\n+        )\n+        setattr(self.item, self.field_name, data)\n+        transaction.commit()\n+        base_url = self.item.absolute_url()\n+        self.assert_download_works(base_url)\n+        self.assert_display_inline_is_download(base_url)\n+\n+    def test_pdf(self):\n+        # By popular request we allow PDF.\n+        setattr(self.item, self.field_name, self._named_file("file.pdf"))\n+        transaction.commit()\n+        base_url = self.item.absolute_url()\n+        self.assert_download_works(base_url)\n+        self.assert_display_inline_works(base_url)\n+\n+\n+class TestAttackVectorNamedBlobFile(TestAttackVectorNamedFile):\n+    field_class = file.NamedBlobFile\ndiff --git a/plone/namedfile/usage.rst b/plone/namedfile/usage.rst\nindex 6f6ce31..77030c2 100644\n--- a/plone/namedfile/usage.rst\n+++ b/plone/namedfile/usage.rst\n@@ -289,7 +289,12 @@ We will test this with a dummy request, faking traversal::\n     \'341\'\n     >>> request.response.getHeader(\'Content-Type\')\n     \'image/foo\'\n+\n+Since the Content-Type is unknown, we do not trust it, and refuse to display inline.\n+We download instead.\n+\n     >>> request.response.getHeader(\'Content-Disposition\')\n+    "attachment; filename*=UTF-8\'\'zpt.gif"\n \n     >>> request = TestRequest()\n     >>> display_file = DisplayFile(container, request).publishTraverse(request, \'blobimage\')\n@@ -301,6 +306,7 @@ We will test this with a dummy request, faking traversal::\n     >>> request.response.getHeader(\'Content-Type\')\n     \'image/foo\'\n     >>> request.response.getHeader(\'Content-Disposition\')\n+    "attachment; filename*=UTF-8\'\'zpt.gif"\n \n \n Specifying the primary field\ndiff --git a/setup.py b/setup.py\nindex e316291..72e10ee 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -5,7 +5,7 @@\n import os\n \n \n-version = \'5.4.1.dev0\'\n+version = \'5.5.0.dev0\'\n \n description = \'File types and fields for images, files and blob files with \' \\\n               \'filenames\'\n'

