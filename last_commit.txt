Repository: plone.restapi


Branch: refs/heads/master
Date: 2021-03-17T06:46:56+01:00
Author: Tiberiu Ichim (tiberiuichim) <tiberiuichim@users.noreply.github.com>
Commit: https://github.com/plone/plone.restapi/commit/d2941fa8617c1222bd65623a2ab9cf2de2a186df

Add subblocks transformer support (#1085)

* Add subblocks transformer support

* Add news entry and a line in documentation

Files changed:
A news/1085.feature
M docs/source/blocks.rst
M src/plone/restapi/deserializer/blocks.py
M src/plone/restapi/serializer/blocks.py
M src/plone/restapi/tests/test_blocks_deserializer.py
M src/plone/restapi/tests/test_blocks_serializer.py

b'diff --git a/docs/source/blocks.rst b/docs/source/blocks.rst\nindex 0c46a5947..2e4a9c117 100644\n--- a/docs/source/blocks.rst\n+++ b/docs/source/blocks.rst\n@@ -149,17 +149,21 @@ Then register as a subscription adapter::\n Generic block transformers and smart fields\n ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n-You can create a block transformer that applies to all blocks, by using `None`\n-as the value for `block_type`. The `order` field still applies, though. Using\n+You can create a block transformer that applies to all blocks, by using ``None``\n+as the value for ``block_type``. The ``order`` field still applies, though. Using\n the generic block transfomers enables us to create **smart block fields**,\n-which are handled differently. For example, any internal link stored as `url`\n-or `href` in a block value is converted (and stored) as a resolveuid-based URL,\n+which are handled differently. For example, any internal link stored as ``url``\n+or ``href`` in a block value is converted (and stored) as a resolveuid-based URL,\n then resolved back to a full URL on block serialization.\n \n-Another **smart field** is the `searchableText` field in a block value. It\n-needs to be a plain text value and it will be used in the `SearchableText`\n+Another **smart field** is the ``searchableText`` field in a block value. It\n+needs to be a plain text value and it will be used in the ``SearchableText``\n value for the context item.\n \n+If you need to store "subblocks" in a block value, you should use the\n+``blocks`` smart field (or ``data.blocks``), doing so integrates those blocks\n+with the transfomers.\n+\n SearchableText indexing for blocks\n ----------------------------------\n \ndiff --git a/news/1085.feature b/news/1085.feature\nnew file mode 100644\nindex 000000000..ce6b646c4\n--- /dev/null\n+++ b/news/1085.feature\n@@ -0,0 +1 @@\n+Allow block transforms to run in "subblocks", discovered as the ``blocks`` field (or alternatively, ``data.blocks``) in a block value.\ndiff --git a/src/plone/restapi/deserializer/blocks.py b/src/plone/restapi/deserializer/blocks.py\nindex b5724766e..bc4f7c1e7 100644\n--- a/src/plone/restapi/deserializer/blocks.py\n+++ b/src/plone/restapi/deserializer/blocks.py\n@@ -57,11 +57,42 @@ def path2uid(context, link):\n @implementer(IFieldDeserializer)\n @adapter(IJSONField, IBlocks, IBrowserRequest)\n class BlocksJSONFieldDeserializer(DefaultFieldDeserializer):\n+    def _transform(self, blocks):\n+        for id, block_value in blocks.items():\n+            self.handle_subblocks(block_value)\n+            block_type = block_value.get("@type", "")\n+            handlers = []\n+            for h in subscribers(\n+                (self.context, self.request), IBlockFieldDeserializationTransformer\n+            ):\n+                if h.block_type == block_type or h.block_type is None:\n+                    h.blockid = id\n+                    handlers.append(h)\n+\n+            for handler in sorted(handlers, key=lambda h: h.order):\n+                block_value = handler(block_value)\n+\n+            blocks[id] = block_value\n+\n+        return blocks\n+\n+    def handle_subblocks(self, block_value):\n+        if "data" in block_value:\n+            if isinstance(block_value["data"], dict):\n+                if "blocks" in block_value["data"]:\n+                    block_value["data"]["blocks"] = self._transform(\n+                        block_value["data"]["blocks"]\n+                    )\n+\n+        if "blocks" in block_value:\n+            block_value["blocks"] = self._transform(block_value["blocks"])\n+\n     def __call__(self, value):\n         value = super(BlocksJSONFieldDeserializer, self).__call__(value)\n \n         if self.field.getName() == "blocks":\n             for id, block_value in value.items():\n+                self.handle_subblocks(block_value)\n                 block_type = block_value.get("@type", "")\n \n                 handlers = []\n@@ -70,6 +101,7 @@ def __call__(self, value):\n                     IBlockFieldDeserializationTransformer,\n                 ):\n                     if h.block_type == block_type or h.block_type is None:\n+                        h.blockid = id\n                         handlers.append(h)\n \n                 for handler in sorted(handlers, key=lambda h: h.order):\ndiff --git a/src/plone/restapi/serializer/blocks.py b/src/plone/restapi/serializer/blocks.py\nindex 128ac046f..e1bd49e63 100644\n--- a/src/plone/restapi/serializer/blocks.py\n+++ b/src/plone/restapi/serializer/blocks.py\n@@ -53,17 +53,49 @@ def uid_to_url(path):\n @adapter(IJSONField, IBlocks, Interface)\n @implementer(IFieldSerializer)\n class BlocksJSONFieldSerializer(DefaultFieldSerializer):\n+    def _transform(self, blocks):\n+        for id, block_value in blocks.items():\n+            self.handle_subblocks(block_value)\n+            block_type = block_value.get("@type", "")\n+            handlers = []\n+            for h in subscribers(\n+                (self.context, self.request), IBlockFieldSerializationTransformer\n+            ):\n+                if h.block_type == block_type or h.block_type is None:\n+                    h.blockid = id\n+                    handlers.append(h)\n+\n+            for handler in sorted(handlers, key=lambda h: h.order):\n+                block_value = handler(block_value)\n+\n+            blocks[id] = block_value\n+\n+        return blocks\n+\n+    def handle_subblocks(self, block_value):\n+        if "data" in block_value:\n+            if isinstance(block_value["data"], dict):\n+                if "blocks" in block_value["data"]:\n+                    block_value["data"]["blocks"] = self._transform(\n+                        block_value["data"]["blocks"]\n+                    )\n+\n+        if "blocks" in block_value:\n+            block_value["blocks"] = self._transform(block_value["blocks"])\n+\n     def __call__(self):\n         value = copy.deepcopy(self.get_value())\n \n         if self.field.getName() == "blocks":\n             for id, block_value in value.items():\n+                self.handle_subblocks(block_value)\n                 block_type = block_value.get("@type", "")\n                 handlers = []\n                 for h in subscribers(\n                     (self.context, self.request), IBlockFieldSerializationTransformer\n                 ):\n                     if h.block_type == block_type or h.block_type is None:\n+                        h.blockid = id\n                         handlers.append(h)\n \n                 for handler in sorted(handlers, key=lambda h: h.order):\ndiff --git a/src/plone/restapi/tests/test_blocks_deserializer.py b/src/plone/restapi/tests/test_blocks_deserializer.py\nindex 9aae50e08..be350e875 100644\n--- a/src/plone/restapi/tests/test_blocks_deserializer.py\n+++ b/src/plone/restapi/tests/test_blocks_deserializer.py\n@@ -286,3 +286,25 @@ def test_deserialize_blocks_smart_href_array(self):\n             self.portal.doc1.blocks["123"]["href"][0],\n             "../resolveuid/{}".format(doc_uid),\n         )\n+\n+    def test_deserialize_subblocks_transformers(self):\n+        # use the html transformer to test subblocks transformers\n+        subblock = {\n+            "@type": "html",\n+            "html": u"<script>nasty</script><div>This stays</div>",\n+        }\n+        self.deserialize(\n+            blocks={\n+                "1": {\n+                    "@type": "columns_block",\n+                    "data": {\n+                        "blocks": {"2": {"@type": "tabs", "blocks": {"3": subblock}}}\n+                    },\n+                }\n+            }\n+        )\n+\n+        block = self.portal.doc1.blocks["1"]["data"]["blocks"]["2"]["blocks"]["3"][\n+            "html"\n+        ]\n+        self.assertEqual(block, u"<div>This stays</div>")\ndiff --git a/src/plone/restapi/tests/test_blocks_serializer.py b/src/plone/restapi/tests/test_blocks_serializer.py\nindex 38222b98a..af923a047 100644\n--- a/src/plone/restapi/tests/test_blocks_serializer.py\n+++ b/src/plone/restapi/tests/test_blocks_serializer.py\n@@ -169,3 +169,23 @@ def test_serialize_blocks_smart_href_array(self):\n         )\n \n         self.assertEqual(value["123"]["href"][0], self.portal.doc1.absolute_url())\n+\n+    def test_serialize_subblocks_transformers(self):\n+        # use the href smart field transformer for testing subblocks transformers\n+        doc_uid = IUUID(self.portal.doc1)\n+        subblock = {"@type": "foo", "href": ["../resolveuid/{}".format(doc_uid)]}\n+        value = self.serialize(\n+            context=self.portal.doc1,\n+            blocks={\n+                "1": {\n+                    "@type": "columns_block",\n+                    "data": {\n+                        "blocks": {"2": {"@type": "tabs", "blocks": {"3": subblock}}}\n+                    },\n+                }\n+            },\n+        )\n+\n+        href = value["1"]["data"]["blocks"]["2"]["blocks"]["3"]["href"]\n+\n+        self.assertEqual(href[0], self.portal.doc1.absolute_url())\n'

