Repository: plone.app.event


Branch: refs/heads/master
Date: 2023-07-17T19:24:14+02:00
Author: Franco Pellegrini (frapell) <frapell@gmail.com>
Commit: https://github.com/plone/plone.app.event/commit/e590d5012a45d2c1d02bc0b093570b6ad9b6929f

Cache the events from the 'Upcoming Events' portlet. refs gh-351

Files changed:
A news/351.feature
M plone/app/event/portlets/portlet_events.py

b'diff --git a/news/351.feature b/news/351.feature\nnew file mode 100644\nindex 00000000..95fe102e\n--- /dev/null\n+++ b/news/351.feature\n@@ -0,0 +1,2 @@\n+Cache the events from the \'Upcoming Events\' portlet\n+[frapell]\ndiff --git a/plone/app/event/portlets/portlet_events.py b/plone/app/event/portlets/portlet_events.py\nindex db67a036..737c1404 100644\n--- a/plone/app/event/portlets/portlet_events.py\n+++ b/plone/app/event/portlets/portlet_events.py\n@@ -14,6 +14,7 @@\n from plone.app.querystring import queryparser\n from plone.app.uuid.utils import uuidToObject\n from plone.base.interfaces.controlpanel import ISiteSchema\n+from plone.memoize import ram\n from plone.memoize.compress import xhtml_compress\n from plone.portlets.interfaces import IPortletDataProvider\n from plone.registry.interfaces import IRegistry\n@@ -27,6 +28,46 @@\n from zope.interface import implementer\n \n \n+def _render_events_cachekey(method, self):\n+    # XXX: Since the events portlet shows the upcoming events, I will simply get\n+    # the most recently modified event using the same logic, and return its uuid\n+    # and last modified date as key. If there is a change, then the most expensive\n+    # computation can be performed\n+\n+    site = getSite()\n+    pc = site.portal_catalog\n+\n+    query = {}\n+    data = self.data\n+    if data.state:\n+        query[\'review_state\'] = data.state\n+\n+    query.update(self.request.get(\'contentFilter\', {}))\n+    if ICollection and ICollection.providedBy(self.search_base):\n+        # Whatever sorting is defined, we\'re overriding it.\n+        query = queryparser.parseFormquery(\n+            self.search_base, self.search_base.query,\n+            sort_on=\'start\', sort_order=None\n+        )\n+    else:\n+        if self.search_base_path:\n+            query[\'path\'] = {\'query\': self.search_base_path}\n+\n+    query[\'portal_type\'] = \'Event\'\n+    query[\'sort_on\'] = \'start\'\n+    query[\'sort_order\'] = \'asc\'\n+    query[\'sort_limit\'] = data.count\n+\n+    events = pc(**query)\n+    uuid = ""\n+    modified = 0\n+    for event in events:\n+        uuid += event.UID\n+        modified += event.modified.asdatetime().timestamp()\n+\n+    return (uuid, modified)\n+\n+\n class IEventsPortlet(IPortletDataProvider):\n     count = schema.Int(\n         title=_("Number of items to display"),\n@@ -145,6 +186,7 @@ def available(self):\n         return self.data.count > 0 and len(self.events)\n \n     @property\n+    @ram.cache(_render_events_cachekey)\n     def events(self):\n         context = aq_inner(self.context)\n         data = self.data\n'

Repository: plone.app.event


Branch: refs/heads/master
Date: 2023-07-17T19:24:16+02:00
Author: Franco Pellegrini (frapell) <frapell@gmail.com>
Commit: https://github.com/plone/plone.app.event/commit/669b51d5a17a69341d4284794f0ad5c3010e230e

Update plone/app/event/portlets/portlet_events.py

Co-authored-by: Peter Mathis &lt;petschki@users.noreply.github.com&gt;

Files changed:
M plone/app/event/portlets/portlet_events.py

b"diff --git a/plone/app/event/portlets/portlet_events.py b/plone/app/event/portlets/portlet_events.py\nindex 737c1404..7554403d 100644\n--- a/plone/app/event/portlets/portlet_events.py\n+++ b/plone/app/event/portlets/portlet_events.py\n@@ -43,7 +43,7 @@ def _render_events_cachekey(method, self):\n         query['review_state'] = data.state\n \n     query.update(self.request.get('contentFilter', {}))\n-    if ICollection and ICollection.providedBy(self.search_base):\n+    if ISyndicatableCollection and ISyndicatableCollection.providedBy(self.search_base):\n         # Whatever sorting is defined, we're overriding it.\n         query = queryparser.parseFormquery(\n             self.search_base, self.search_base.query,\n"

Repository: plone.app.event


Branch: refs/heads/master
Date: 2023-07-17T22:34:15+02:00
Author: Johannes Raggam (thet) <thetetet@gmail.com>
Commit: https://github.com/plone/plone.app.event/commit/aa7a743ca20dfcfb9da33d067a23260bdeb225fc

Possible improvement for cachkey, getting the most recently modified event directly from the catalog.

Files changed:
M plone/app/event/portlets/portlet_events.py

b'diff --git a/plone/app/event/portlets/portlet_events.py b/plone/app/event/portlets/portlet_events.py\nindex 7554403d..783a0902 100644\n--- a/plone/app/event/portlets/portlet_events.py\n+++ b/plone/app/event/portlets/portlet_events.py\n@@ -14,10 +14,12 @@\n from plone.app.querystring import queryparser\n from plone.app.uuid.utils import uuidToObject\n from plone.base.interfaces.controlpanel import ISiteSchema\n+from plone.event.interfaces import IEvent\n from plone.memoize import ram\n from plone.memoize.compress import xhtml_compress\n from plone.portlets.interfaces import IPortletDataProvider\n from plone.registry.interfaces import IRegistry\n+from Products.CMFCore.utils import getToolByName\n from Products.Five.browser.pagetemplatefile import ViewPageTemplateFile\n from zExceptions import NotFound\n from zope import schema\n@@ -29,41 +31,44 @@\n \n \n def _render_events_cachekey(method, self):\n-    # XXX: Since the events portlet shows the upcoming events, I will simply get\n-    # the most recently modified event using the same logic, and return its uuid\n-    # and last modified date as key. If there is a change, then the most expensive\n-    # computation can be performed\n+    # Since the events portlet shows the upcoming events, we simply get the\n+    # most recently modified event and return its uuid and last modified date\n+    # as key. If there is a change, then the most expensive computation can be\n+    # performed.\n \n-    site = getSite()\n-    pc = site.portal_catalog\n+    cat = getToolByName(getSite(), "portal_catalog")\n \n     query = {}\n     data = self.data\n     if data.state:\n-        query[\'review_state\'] = data.state\n+        query["review_state"] = data.state\n \n-    query.update(self.request.get(\'contentFilter\', {}))\n+    query.update(self.request.get("contentFilter", {}))\n     if ISyndicatableCollection and ISyndicatableCollection.providedBy(self.search_base):\n         # Whatever sorting is defined, we\'re overriding it.\n         query = queryparser.parseFormquery(\n-            self.search_base, self.search_base.query,\n-            sort_on=\'start\', sort_order=None\n+            self.search_base, self.search_base.query, sort_on="start", sort_order=None\n         )\n     else:\n         if self.search_base_path:\n-            query[\'path\'] = {\'query\': self.search_base_path}\n-\n-    query[\'portal_type\'] = \'Event\'\n-    query[\'sort_on\'] = \'start\'\n-    query[\'sort_order\'] = \'asc\'\n-    query[\'sort_limit\'] = data.count\n-\n-    events = pc(**query)\n+            query["path"] = {"query": self.search_base_path}\n+\n+    # Any object with an IEvent interface.\n+    query["object_provides"] = IEvent.__identifier__\n+    # Only upcoming events.\n+    query.update(start_end_query(start=localized_now(), end=None))\n+    # Sort on last modified.\n+    query["sort_on"] = "modified"\n+    # We only need the most recent modified event.\n+    query["sort_order"] = "reverse"\n+    query["sort_limit"] = 1\n+\n+    events = cat(**query)\n     uuid = ""\n     modified = 0\n-    for event in events:\n-        uuid += event.UID\n-        modified += event.modified.asdatetime().timestamp()\n+    if events:\n+        uuid += events[0].UID\n+        modified += events[0].modified.asdatetime().timestamp()\n \n     return (uuid, modified)\n \n'

Repository: plone.app.event


Branch: refs/heads/master
Date: 2023-07-18T09:36:03+02:00
Author: Johannes Raggam (thet) <thetetet@gmail.com>
Commit: https://github.com/plone/plone.app.event/commit/6d197ce805da916c2b2993213f45f80738025d1b

Reverting to previous cachekey logic except for:‌ 1)‌ limiting to only upcoming events, 2) querying for any IEvent based object.

Files changed:
M plone/app/event/portlets/portlet_events.py

b'diff --git a/plone/app/event/portlets/portlet_events.py b/plone/app/event/portlets/portlet_events.py\nindex 783a0902..df70e21d 100644\n--- a/plone/app/event/portlets/portlet_events.py\n+++ b/plone/app/event/portlets/portlet_events.py\n@@ -36,39 +36,42 @@ def _render_events_cachekey(method, self):\n     # as key. If there is a change, then the most expensive computation can be\n     # performed.\n \n-    cat = getToolByName(getSite(), "portal_catalog")\n+    site = getSite()\n+    cat = getToolByName(site, "portal_catalog")\n \n     query = {}\n     data = self.data\n     if data.state:\n         query["review_state"] = data.state\n \n+    start = localized_now(site)\n+\n     query.update(self.request.get("contentFilter", {}))\n     if ISyndicatableCollection and ISyndicatableCollection.providedBy(self.search_base):\n         # Whatever sorting is defined, we\'re overriding it.\n         query = queryparser.parseFormquery(\n             self.search_base, self.search_base.query, sort_on="start", sort_order=None\n         )\n-    else:\n-        if self.search_base_path:\n-            query["path"] = {"query": self.search_base_path}\n+        if "start" in query:\n+            start = query["start"]\n+    elif self.search_base_path:\n+        query["path"] = {"query": self.search_base_path}\n \n     # Any object with an IEvent interface.\n     query["object_provides"] = IEvent.__identifier__\n     # Only upcoming events.\n-    query.update(start_end_query(start=localized_now(), end=None))\n-    # Sort on last modified.\n-    query["sort_on"] = "modified"\n-    # We only need the most recent modified event.\n-    query["sort_order"] = "reverse"\n-    query["sort_limit"] = 1\n+    query.update(start_end_query(start=start, end=None))\n+    # We want to get the next data.count events, just as the portlet would.\n+    query["sort_on"] = "start"\n+    query["sort_order"] = "asc"\n+    query["sort_limit"] = data.count\n \n     events = cat(**query)\n     uuid = ""\n     modified = 0\n-    if events:\n-        uuid += events[0].UID\n-        modified += events[0].modified.asdatetime().timestamp()\n+    for event in events:\n+        uuid += event.UID\n+        modified += event.modified.asdatetime().timestamp()\n \n     return (uuid, modified)\n \n'

Repository: plone.app.event


Branch: refs/heads/master
Date: 2023-07-18T11:04:14+02:00
Author: Johannes Raggam (thet) <thetetet@gmail.com>
Commit: https://github.com/plone/plone.app.event/commit/d8f1bcb5d27b0aa559299865d14ee3de63b761d1

Merge pull request #352 from plone/portlet-cache-events

Cache the events from the 'Upcoming Events' portlet.

Files changed:
A news/351.feature
M plone/app/event/portlets/portlet_events.py

b'diff --git a/news/351.feature b/news/351.feature\nnew file mode 100644\nindex 00000000..95fe102e\n--- /dev/null\n+++ b/news/351.feature\n@@ -0,0 +1,2 @@\n+Cache the events from the \'Upcoming Events\' portlet\n+[frapell]\ndiff --git a/plone/app/event/portlets/portlet_events.py b/plone/app/event/portlets/portlet_events.py\nindex db67a036..df70e21d 100644\n--- a/plone/app/event/portlets/portlet_events.py\n+++ b/plone/app/event/portlets/portlet_events.py\n@@ -14,9 +14,12 @@\n from plone.app.querystring import queryparser\n from plone.app.uuid.utils import uuidToObject\n from plone.base.interfaces.controlpanel import ISiteSchema\n+from plone.event.interfaces import IEvent\n+from plone.memoize import ram\n from plone.memoize.compress import xhtml_compress\n from plone.portlets.interfaces import IPortletDataProvider\n from plone.registry.interfaces import IRegistry\n+from Products.CMFCore.utils import getToolByName\n from Products.Five.browser.pagetemplatefile import ViewPageTemplateFile\n from zExceptions import NotFound\n from zope import schema\n@@ -27,6 +30,52 @@\n from zope.interface import implementer\n \n \n+def _render_events_cachekey(method, self):\n+    # Since the events portlet shows the upcoming events, we simply get the\n+    # most recently modified event and return its uuid and last modified date\n+    # as key. If there is a change, then the most expensive computation can be\n+    # performed.\n+\n+    site = getSite()\n+    cat = getToolByName(site, "portal_catalog")\n+\n+    query = {}\n+    data = self.data\n+    if data.state:\n+        query["review_state"] = data.state\n+\n+    start = localized_now(site)\n+\n+    query.update(self.request.get("contentFilter", {}))\n+    if ISyndicatableCollection and ISyndicatableCollection.providedBy(self.search_base):\n+        # Whatever sorting is defined, we\'re overriding it.\n+        query = queryparser.parseFormquery(\n+            self.search_base, self.search_base.query, sort_on="start", sort_order=None\n+        )\n+        if "start" in query:\n+            start = query["start"]\n+    elif self.search_base_path:\n+        query["path"] = {"query": self.search_base_path}\n+\n+    # Any object with an IEvent interface.\n+    query["object_provides"] = IEvent.__identifier__\n+    # Only upcoming events.\n+    query.update(start_end_query(start=start, end=None))\n+    # We want to get the next data.count events, just as the portlet would.\n+    query["sort_on"] = "start"\n+    query["sort_order"] = "asc"\n+    query["sort_limit"] = data.count\n+\n+    events = cat(**query)\n+    uuid = ""\n+    modified = 0\n+    for event in events:\n+        uuid += event.UID\n+        modified += event.modified.asdatetime().timestamp()\n+\n+    return (uuid, modified)\n+\n+\n class IEventsPortlet(IPortletDataProvider):\n     count = schema.Int(\n         title=_("Number of items to display"),\n@@ -145,6 +194,7 @@ def available(self):\n         return self.data.count > 0 and len(self.events)\n \n     @property\n+    @ram.cache(_render_events_cachekey)\n     def events(self):\n         context = aq_inner(self.context)\n         data = self.data\n'

