Repository: plone.app.iterate


Branch: refs/heads/master
Date: 2021-04-19T18:20:07+02:00
Author: Victor Fernandez de Alba (sneridagh) <sneridagh@gmail.com>
Commit: https://github.com/plone/plone.app.iterate/commit/8f3e31b6a689bc5ed8f154d0aa50a499412a266d

Add specific adapter for Folderish content types

Files changed:
M plone/app/iterate/dexterity/configure.zcml
M plone/app/iterate/dexterity/copier.py

b'diff --git a/plone/app/iterate/dexterity/configure.zcml b/plone/app/iterate/dexterity/configure.zcml\nindex 7351a01..42ddbe0 100644\n--- a/plone/app/iterate/dexterity/configure.zcml\n+++ b/plone/app/iterate/dexterity/configure.zcml\n@@ -14,6 +14,11 @@\n        factory=".copier.ContentCopier"\n        />\n \n+    <adapter\n+       for="plone.dexterity.interfaces.IDexterityContainer"\n+       factory=".copier.FolderishContentCopier"\n+       />\n+\n     <adapter\n        for=".interfaces.IDexterityIterateAware"\n        factory=".policy.CheckinCheckoutPolicyAdapter"\ndiff --git a/plone/app/iterate/dexterity/copier.py b/plone/app/iterate/dexterity/copier.py\nindex ca01d55..ed2ea84 100644\n--- a/plone/app/iterate/dexterity/copier.py\n+++ b/plone/app/iterate/dexterity/copier.py\n@@ -17,10 +17,10 @@\n from zope.event import notify\n from zope.intid.interfaces import IIntIds\n from zope.schema import getFieldsInOrder\n+from plone.dexterity.utils import createContentInContainer\n \n \n class ContentCopier(BaseContentCopier):\n-\n     def copyTo(self, container):\n         context = aq_inner(self.context)\n         wc = self._copyBaseline(container)\n@@ -57,7 +57,7 @@ def _replaceBaseline(self, baseline):\n                 # Skip read-only fields\n                 if field.readonly:\n                     continue\n-                if field.__name__ == \'id\':\n+                if field.__name__ == "id":\n                     continue\n                 try:\n                     value = field.get(schema(self.context))\n@@ -66,11 +66,11 @@ def _replaceBaseline(self, baseline):\n \n                 # TODO: We need a way to identify the DCFieldProperty\n                 # fields and use the appropriate set_name/get_name\n-                if name == \'effective\':\n+                if name == "effective":\n                     baseline.effective_date = self.context.effective()\n-                elif name == \'expires\':\n+                elif name == "expires":\n                     baseline.expiration_date = self.context.expires()\n-                elif name == \'subjects\':\n+                elif name == "subjects":\n                     baseline.setSubject(self.context.Subject())\n                 else:\n                     field.set(baseline, value)\n@@ -78,11 +78,12 @@ def _replaceBaseline(self, baseline):\n         baseline.reindexObject()\n \n         # copy annotations\n-        wc_annotations = IAnnotations(self.context)\n-        baseline_annotations = IAnnotations(baseline)\n+        # wc_annotations = IAnnotations(self.context)\n+        # baseline_annotations = IAnnotations(baseline)\n \n-        baseline_annotations.clear()\n-        baseline_annotations.update(wc_annotations)\n+        # The next one is wrong\n+        # baseline_annotations.clear()\n+        # baseline_annotations.update(wc_annotations)\n \n         # delete the working copy\n         wc_container._delObject(wc_id)\n@@ -93,13 +94,14 @@ def _reassembleWorkingCopy(self, new_baseline, baseline):\n         # reattach the source\'s workflow history, try avoid a dangling ref\n         try:\n             new_baseline.workflow_history = PersistentMapping(\n-                baseline.workflow_history.items())\n+                baseline.workflow_history.items()\n+            )\n         except AttributeError:\n             # No workflow apparently.  Oh well.\n             pass\n \n         # reset wf state security directly\n-        workflow_tool = getToolByName(self.context, \'portal_workflow\')\n+        workflow_tool = getToolByName(self.context, "portal_workflow")\n         wfs = workflow_tool.getWorkflowsFor(self.context)\n         for wf in wfs:\n             if not isinstance(wf, DCWorkflowDefinition):\n@@ -124,15 +126,14 @@ def _get_relation_to_baseline(self):\n         id = intids.getId(context)\n         # ask catalog\n         catalog = component.getUtility(ICatalog)\n-        relations = catalog.findRelations({\'to_id\': id})\n-        relations = [i for i in relations\n-                     if i.from_attribute == ITERATE_RELATION_NAME]\n+        relations = catalog.findRelations({"to_id": id})\n+        relations = [i for i in relations if i.from_attribute == ITERATE_RELATION_NAME]\n         # do we have a baseline in our relations?\n         if relations and not len(relations) == 1:\n-            raise interfaces.CheckinException(\'Baseline count mismatch\')\n+            raise interfaces.CheckinException("Baseline count mismatch")\n \n         if not relations or not relations[0]:\n-            raise interfaces.CheckinException(\'Baseline has disappeared\')\n+            raise interfaces.CheckinException("Baseline has disappeared")\n         return relations[0]\n \n     def _getBaseline(self):\n@@ -142,7 +143,7 @@ def _getBaseline(self):\n             baseline = intids.getObject(relation.from_id)\n \n         if not baseline:\n-            raise interfaces.CheckinException(\'Baseline has disappeared\')\n+            raise interfaces.CheckinException("Baseline has disappeared")\n         return baseline\n \n     def checkin(self, checkin_message):\n@@ -152,15 +153,59 @@ def checkin(self, checkin_message):\n         relation = self._get_relation_to_baseline()\n         # publish the event for subscribers, early because contexts are about\n         # to be manipulated\n-        notify(event.CheckinEvent(self.context,\n-                                  baseline,\n-                                  relation,\n-                                  checkin_message\n-                                  ))\n+        notify(event.CheckinEvent(self.context, baseline, relation, checkin_message))\n         # merge the object back to the baseline with a copier\n-        copier = component.queryAdapter(self.context,\n-                                        interfaces.IObjectCopier)\n+        copier = component.queryAdapter(self.context, interfaces.IObjectCopier)\n         new_baseline = copier.merge()\n         # don\'t need to unlock the lock disappears with old baseline deletion\n         notify(AfterCheckinEvent(new_baseline, checkin_message))\n         return new_baseline\n+\n+\n+class FolderishContentCopier(ContentCopier):\n+    """ """\n+\n+    def _copyBaseline(self, container):\n+        source_container = aq_parent(aq_inner(self.context))\n+        obj = createContentInContainer(\n+            source_container,\n+            self.context.portal_type,\n+            id="working_copy_of_{}".format(self.context.id),\n+        )\n+\n+        # copy all field values from the baseline to the working copy\n+        for schema in iterSchemata(self.context):\n+            for name, field in getFieldsInOrder(schema):\n+                # Skip read-only fields\n+                if field.readonly:\n+                    continue\n+                if field.__name__ == "id":\n+                    continue\n+                try:\n+                    value = field.get(schema(self.context))\n+                except Exception:\n+                    value = None\n+\n+                # TODO: We need a way to identify the DCFieldProperty\n+                # fields and use the appropriate set_name/get_name\n+                if name == "effective":\n+                    obj.effective_date = self.context.effective()\n+                elif name == "expires":\n+                    obj.expiration_date = self.context.expires()\n+                elif name == "subjects":\n+                    obj.setSubject(self.context.Subject())\n+                else:\n+                    field.set(obj, value)\n+\n+        obj.reindexObject()\n+\n+        # clone workflow history, try avoid a dangling ref\n+        try:\n+            obj.workflow_history = PersistentMapping(\n+                self.context.workflow_history.items()\n+            )\n+        except AttributeError:\n+            # No workflow apparently.  Oh well.\n+            pass\n+\n+        return obj\n'

Repository: plone.app.iterate


Branch: refs/heads/master
Date: 2021-04-19T18:46:05+02:00
Author: Victor Fernandez de Alba (sneridagh) <sneridagh@gmail.com>
Commit: https://github.com/plone/plone.app.iterate/commit/bd1c3447c01a75effce0d7854cca2389a89e0bfc

Deal with annotations

Files changed:
M plone/app/iterate/dexterity/copier.py

b'diff --git a/plone/app/iterate/dexterity/copier.py b/plone/app/iterate/dexterity/copier.py\nindex ed2ea84..e9df313 100644\n--- a/plone/app/iterate/dexterity/copier.py\n+++ b/plone/app/iterate/dexterity/copier.py\n@@ -78,12 +78,17 @@ def _replaceBaseline(self, baseline):\n         baseline.reindexObject()\n \n         # copy annotations\n-        # wc_annotations = IAnnotations(self.context)\n-        # baseline_annotations = IAnnotations(baseline)\n+        wc_annotations = IAnnotations(self.context)\n+        baseline_annotations = IAnnotations(baseline)\n \n-        # The next one is wrong\n+        # The next one is just wrong\n         # baseline_annotations.clear()\n-        # baseline_annotations.update(wc_annotations)\n+\n+        # Remove plone.folder.ordered.order from it to not mess with the original\n+        if "plone.folder.ordered.order" in wc_annotations:\n+            wc_annotations.pop("plone.folder.ordered.order")\n+\n+        baseline_annotations.update(wc_annotations)\n \n         # delete the working copy\n         wc_container._delObject(wc_id)\n@@ -199,6 +204,15 @@ def _copyBaseline(self, container):\n \n         obj.reindexObject()\n \n+        # copy annotations\n+        wc_annotations = IAnnotations(self.context)\n+        baseline_annotations = IAnnotations(self.context)\n+\n+        wc_annotations.update(baseline_annotations)\n+        # Remove plone.folder.order from it to not spoil the wc\n+        if "plone.folder.ordered.order" in wc_annotations:\n+            wc_annotations.pop("plone.folder.ordered.order")\n+\n         # clone workflow history, try avoid a dangling ref\n         try:\n             obj.workflow_history = PersistentMapping(\n'

Repository: plone.app.iterate


Branch: refs/heads/master
Date: 2021-05-11T10:35:54+02:00
Author: Victor Fernandez de Alba (sneridagh) <sneridagh@gmail.com>
Commit: https://github.com/plone/plone.app.iterate/commit/f4cb9790cf63d01139564c59381aae34db7847fe

Merge branch 'master' into plone6

* master:
  Changelog
  Black and flake8
  Do not break if some custom code provides an alias for Products.Archetypes

Files changed:
A news/85.bugfix
A news/88.bugfix
M plone/__init__.py
M plone/app/__init__.py
M plone/app/iterate/__init__.py
M plone/app/iterate/archiver.py
M plone/app/iterate/base.py
M plone/app/iterate/browser/cancel.py
M plone/app/iterate/browser/checkin.py
M plone/app/iterate/browser/checkout.py
M plone/app/iterate/browser/control.py
M plone/app/iterate/browser/diff.py
M plone/app/iterate/browser/info.py
M plone/app/iterate/configure.zcml
M plone/app/iterate/containers.py
M plone/app/iterate/copier.py
M plone/app/iterate/dexterity/__init__.py
M plone/app/iterate/dexterity/policy.py
M plone/app/iterate/dexterity/relation.py
M plone/app/iterate/dexterity/utils.py
M plone/app/iterate/event.py
M plone/app/iterate/interfaces.py
M plone/app/iterate/lock.py
M plone/app/iterate/permissions.py
M plone/app/iterate/policy.py
M plone/app/iterate/relation.py
M plone/app/iterate/setuphandlers.py
M plone/app/iterate/subscribers/locking.py
M plone/app/iterate/subscribers/versioning.py
M plone/app/iterate/subscribers/workflow.py
M plone/app/iterate/testing.py
M plone/app/iterate/tests/content.py
M plone/app/iterate/tests/test_annotations.py
M plone/app/iterate/tests/test_doctests.py
M plone/app/iterate/tests/test_interfaces.py
M plone/app/iterate/tests/test_iterate.py
M plone/app/iterate/tests/test_iterate_at.py
M plone/app/iterate/util.py
M setup.py

b'diff --git a/news/85.bugfix b/news/85.bugfix\nnew file mode 100644\nindex 0000000..1a2b9db\n--- /dev/null\n+++ b/news/85.bugfix\n@@ -0,0 +1 @@\n+Do not break if some custom code provides an alias for Products.Archetypes\ndiff --git a/news/88.bugfix b/news/88.bugfix\nnew file mode 100644\nindex 0000000..e3a7e0f\n--- /dev/null\n+++ b/news/88.bugfix\n@@ -0,0 +1,2 @@\n+Black and pep8 compliance\n+[sneridagh]\ndiff --git a/plone/__init__.py b/plone/__init__.py\nindex 85880ef..ca12a73 100644\n--- a/plone/__init__.py\n+++ b/plone/__init__.py\n@@ -1,7 +1,8 @@\n # -*- coding: utf-8 -*-\n # See http://peak.telecommunity.com/DevCenter/setuptools#namespace-packages\n try:\n-    __import__(\'pkg_resources\').declare_namespace(__name__)\n+    __import__("pkg_resources").declare_namespace(__name__)\n except ImportError:\n     from pkgutil import extend_path\n+\n     __path__ = extend_path(__path__, __name__)\ndiff --git a/plone/app/__init__.py b/plone/app/__init__.py\nindex 85880ef..ca12a73 100644\n--- a/plone/app/__init__.py\n+++ b/plone/app/__init__.py\n@@ -1,7 +1,8 @@\n # -*- coding: utf-8 -*-\n # See http://peak.telecommunity.com/DevCenter/setuptools#namespace-packages\n try:\n-    __import__(\'pkg_resources\').declare_namespace(__name__)\n+    __import__("pkg_resources").declare_namespace(__name__)\n except ImportError:\n     from pkgutil import extend_path\n+\n     __path__ = extend_path(__path__, __name__)\ndiff --git a/plone/app/iterate/__init__.py b/plone/app/iterate/__init__.py\nindex 8d1a70e..68c569b 100644\n--- a/plone/app/iterate/__init__.py\n+++ b/plone/app/iterate/__init__.py\n@@ -29,23 +29,26 @@\n import logging\n \n \n-PloneMessageFactory = MessageFactory(\'plone\')\n-logger = logging.getLogger(\'plone.app.iterate\')\n+PloneMessageFactory = MessageFactory("plone")\n+logger = logging.getLogger("plone.app.iterate")\n \n \n try:\n     import plone.app.relationfield  # noqa\n except ImportError:\n-    logger.warn(\'Dexterity support for iterate is not available. \'\n-                \'You must install plone.app.relationfield\')\n+    logger.warn(\n+        "Dexterity support for iterate is not available. "\n+        "You must install plone.app.relationfield"\n+    )\n \n \n try:\n     import plone.app.stagingbehavior  # noqa\n+\n     logger.error(\n-        \'plone.app.stagingbehavior should NOT be installed with this version \'\n-        \'of plone.app.iterate. You may experience problems running this \'\n-        \'configuration. plone.app.iterate now has dexterity suport built-in.\'\n+        "plone.app.stagingbehavior should NOT be installed with this version "\n+        "of plone.app.iterate. You may experience problems running this "\n+        "configuration. plone.app.iterate now has dexterity suport built-in."\n     )\n except ImportError:\n     pass\ndiff --git a/plone/app/iterate/archiver.py b/plone/app/iterate/archiver.py\nindex f962003..6293477 100644\n--- a/plone/app/iterate/archiver.py\n+++ b/plone/app/iterate/archiver.py\n@@ -30,10 +30,9 @@\n @implementer(interfaces.IObjectArchiver)\n @adapter(interfaces.IIterateAware)\n class ContentArchiver(object):\n-\n     def __init__(self, context):\n         self.context = context\n-        self.repository = getToolByName(context, \'portal_repository\')\n+        self.repository = getToolByName(context, "portal_repository")\n \n     def save(self, checkin_message):\n         self.repository.save(self.context, checkin_message)\n@@ -44,7 +43,7 @@ def isVersionable(self):\n         return True\n \n     def isVersioned(self):\n-        archivist = getToolByName(self.context, \'portal_archivist\')\n+        archivist = getToolByName(self.context, "portal_archivist")\n         version_count = len(archivist.queryHistory(self.context))\n         return bool(version_count)\n \ndiff --git a/plone/app/iterate/base.py b/plone/app/iterate/base.py\nindex b35a7fc..3b6339b 100644\n--- a/plone/app/iterate/base.py\n+++ b/plone/app/iterate/base.py\n@@ -54,13 +54,13 @@ class CheckinCheckoutBasePolicyAdapter(object):\n     """\n \n     # used when creating baseline version for first time\n-    default_base_message = \'Created Baseline\'\n+    default_base_message = "Created Baseline"\n \n     def __init__(self, context):\n         self.context = context\n \n     def checkin(self, checkin_message):\n-        raise NotImplemented()\n+        raise NotImplementedError()\n \n     def checkout(self, container):\n         # see interface\n@@ -100,10 +100,10 @@ def cancelCheckout(self):\n     #  Checkin Support Methods\n \n     def getBaseline(self):\n-        raise NotImplemented()\n+        raise NotImplementedError()\n \n     def getWorkingCopy(self):\n-        raise NotImplemented()\n+        raise NotImplementedError()\n \n     def getProperties(self, obj, default=None):\n         return get_storage(obj, default=default)\n@@ -112,7 +112,6 @@ def getProperties(self, obj, default=None):\n @implementer(interfaces.IObjectCopier)\n @component.adapter(interfaces.IIterateAware)\n class BaseContentCopier(object):\n-\n     def __init__(self, context):\n         self.context = context\n \n@@ -131,12 +130,11 @@ def _recursivelyReattachUIDs(self, baseline, new_baseline):\n             new_ids = new_baseline.contentIds()\n             for child in baseline.contentValues():\n                 if child.getId() in new_ids:\n-                    self._recursivelyReattachUIDs(\n-                        child, new_baseline[child.getId()])\n+                    self._recursivelyReattachUIDs(child, new_baseline[child.getId()])\n \n     def _removeDuplicateReferences(self, item, backrefs=False):\n         # Remove duplicate (back) references from this item.\n-        reference_tool = getToolByName(self.context, \'reference_catalog\')\n+        reference_tool = getToolByName(self.context, "reference_catalog")\n         if backrefs:\n             ref_func = reference_tool.getBackReferences\n         else:\n@@ -161,6 +159,6 @@ def _copyBaseline(self, container):\n         result = container.manage_pasteObjects(clipboard)\n \n         # get a reference to the working copy\n-        target_id = result[0][\'new_id\']\n+        target_id = result[0]["new_id"]\n         target = container._getOb(target_id)\n         return target\ndiff --git a/plone/app/iterate/browser/cancel.py b/plone/app/iterate/browser/cancel.py\nindex 95582fe..eb75d77 100644\n--- a/plone/app/iterate/browser/cancel.py\n+++ b/plone/app/iterate/browser/cancel.py\n@@ -33,29 +33,27 @@\n \n class Cancel(BrowserView):\n \n-    index = ViewPageTemplateFile(\'cancel.pt\')\n+    index = ViewPageTemplateFile("cancel.pt")\n \n     def __call__(self):\n         context = aq_inner(self.context)\n \n-        if \'form.button.Cancel\' in self.request.form:\n-            control = getMultiAdapter(\n-                (context, self.request), name=u\'iterate_control\')\n+        if "form.button.Cancel" in self.request.form:\n+            control = getMultiAdapter((context, self.request), name=u"iterate_control")\n             if not control.cancel_allowed():\n-                raise CheckoutException(u\'Not a checkout\')\n+                raise CheckoutException(u"Not a checkout")\n \n             policy = ICheckinCheckoutPolicy(context)\n             baseline = policy.cancelCheckout()\n             baseline.reindexObject()\n \n             IStatusMessage(self.request).addStatusMessage(\n-                _(u\'Checkout cancelled\'), type=\'info\')\n-            view_url = baseline.restrictedTraverse(\n-                \'@@plone_context_state\').view_url()\n+                _(u"Checkout cancelled"), type="info"\n+            )\n+            view_url = baseline.restrictedTraverse("@@plone_context_state").view_url()\n             self.request.response.redirect(view_url)\n-        elif \'form.button.Keep\' in self.request.form:\n-            view_url = context.restrictedTraverse(\n-                \'@@plone_context_state\').view_url()\n+        elif "form.button.Keep" in self.request.form:\n+            view_url = context.restrictedTraverse("@@plone_context_state").view_url()\n             self.request.response.redirect(view_url)\n         else:\n             return self.index()\ndiff --git a/plone/app/iterate/browser/checkin.py b/plone/app/iterate/browser/checkin.py\nindex 28f56ea..3717ad0 100644\n--- a/plone/app/iterate/browser/checkin.py\n+++ b/plone/app/iterate/browser/checkin.py\n@@ -33,30 +33,26 @@\n \n class Checkin(BrowserView):\n \n-    index = ViewPageTemplateFile(\'checkin.pt\')\n+    index = ViewPageTemplateFile("checkin.pt")\n \n     def __call__(self):\n         context = aq_inner(self.context)\n \n-        if \'form.button.Checkin\' in self.request.form:\n-            control = getMultiAdapter(\n-                (context, self.request), name=u\'iterate_control\')\n+        if "form.button.Checkin" in self.request.form:\n+            control = getMultiAdapter((context, self.request), name=u"iterate_control")\n             if not control.checkin_allowed():\n-                raise CheckinException(u\'Not a checkout\')\n+                raise CheckinException(u"Not a checkout")\n \n-            message = self.request.form.get(\'checkin_message\', \'\')\n+            message = self.request.form.get("checkin_message", "")\n \n             policy = ICheckinCheckoutPolicy(context)\n             baseline = policy.checkin(message)\n \n-            IStatusMessage(self.request).addStatusMessage(\n-                _(\'Checked in\'), type=\'info\')\n-            view_url = baseline.restrictedTraverse(\n-                \'@@plone_context_state\').view_url()\n+            IStatusMessage(self.request).addStatusMessage(_("Checked in"), type="info")\n+            view_url = baseline.restrictedTraverse("@@plone_context_state").view_url()\n             self.request.response.redirect(view_url)\n-        elif \'form.button.Cancel\'in self.request.form:\n-            view_url = context.restrictedTraverse(\n-                \'@@plone_context_state\').view_url()\n+        elif "form.button.Cancel" in self.request.form:\n+            view_url = context.restrictedTraverse("@@plone_context_state").view_url()\n             self.request.response.redirect(view_url)\n         else:\n             return self.index()\ndiff --git a/plone/app/iterate/browser/checkout.py b/plone/app/iterate/browser/checkout.py\nindex 4fb9577..b38912a 100644\n--- a/plone/app/iterate/browser/checkout.py\n+++ b/plone/app/iterate/browser/checkout.py\n@@ -35,11 +35,10 @@\n \n class Checkout(BrowserView):\n \n-    index = ViewPageTemplateFile(\'checkout.pt\')\n+    index = ViewPageTemplateFile("checkout.pt")\n \n     def containers(self):\n-        """Get a list of potential containers\n-        """\n+        """Get a list of potential containers"""\n         context = aq_inner(self.context)\n         for name, locator in getAdapters((context,), IWCContainerLocator):\n             if locator.available:\n@@ -50,27 +49,24 @@ def __call__(self):\n \n         # We want to redirect to a specific template, else we might\n         # end up downloading a file\n-        if \'form.button.Checkout\' in self.request.form:\n-            control = getMultiAdapter(\n-                (context, self.request), name=u\'iterate_control\')\n+        if "form.button.Checkout" in self.request.form:\n+            control = getMultiAdapter((context, self.request), name=u"iterate_control")\n             if not control.checkout_allowed():\n-                raise CheckoutException(u\'Not allowed\')\n+                raise CheckoutException(u"Not allowed")\n \n-            location = self.request.form.get(\'checkout_location\', None)\n+            location = self.request.form.get("checkout_location", None)\n             locator = None\n             try:\n                 locator = [\n-                    c[\'locator\']\n-                    for c in self.containers()\n-                    if c[\'name\'] == location\n+                    c["locator"] for c in self.containers() if c["name"] == location\n                 ][0]\n             except IndexError:\n                 IStatusMessage(self.request).addStatusMessage(\n-                    _(\'Cannot find checkout location\'),\n-                    type=\'error\'\n+                    _("Cannot find checkout location"), type="error"\n                 )\n                 view_url = context.restrictedTraverse(\n-                    \'@@plone_context_state\').view_url()\n+                    "@@plone_context_state"\n+                ).view_url()\n                 self.request.response.redirect(view_url)\n                 return\n \n@@ -79,16 +75,15 @@ def __call__(self):\n \n             # we do this for metadata update side affects which will update\n             # lock info\n-            context.reindexObject(\'review_state\')\n+            context.reindexObject("review_state")\n \n             IStatusMessage(self.request).addStatusMessage(\n-                _(\'Check-out created\'), type=\'info\')\n-            view_url = wc.restrictedTraverse(\n-                \'@@plone_context_state\').view_url()\n+                _("Check-out created"), type="info"\n+            )\n+            view_url = wc.restrictedTraverse("@@plone_context_state").view_url()\n             self.request.response.redirect(view_url)\n-        elif \'form.button.Cancel\' in self.request.form:\n-            view_url = context.restrictedTraverse(\n-                \'@@plone_context_state\').view_url()\n+        elif "form.button.Cancel" in self.request.form:\n+            view_url = context.restrictedTraverse("@@plone_context_state").view_url()\n             self.request.response.redirect(view_url)\n         else:\n             return self.index()\ndiff --git a/plone/app/iterate/browser/control.py b/plone/app/iterate/browser/control.py\nindex 56762bb..46651e2 100644\n--- a/plone/app/iterate/browser/control.py\n+++ b/plone/app/iterate/browser/control.py\n@@ -39,8 +39,7 @@ class Control(BrowserView):\n     """\n \n     def checkin_allowed(self):\n-        """Check if a checkin is allowed\n-        """\n+        """Check if a checkin is allowed"""\n         context = aq_inner(self.context)\n         checkPermission = getSecurityManager().checkPermission\n \n@@ -72,8 +71,7 @@ def checkin_allowed(self):\n         return True\n \n     def checkout_allowed(self):\n-        """Check if a checkout is allowed.\n-        """\n+        """Check if a checkout is allowed."""\n         context = aq_inner(self.context)\n \n         if not interfaces.IIterateAware.providedBy(context):\ndiff --git a/plone/app/iterate/browser/diff.py b/plone/app/iterate/browser/diff.py\nindex f63e19e..baa5de3 100644\n--- a/plone/app/iterate/browser/diff.py\n+++ b/plone/app/iterate/browser/diff.py\n@@ -11,7 +11,6 @@\n \n \n class DiffView(BrowserView):\n-\n     def __call__(self):\n         policy = ICheckinCheckoutPolicy(self.context)\n         if IBaseline.providedBy(self.context):\n@@ -21,12 +20,11 @@ def __call__(self):\n             self.working_copy = self.context\n             self.baseline = policy.getBaseline()\n         else:\n-            raise AttributeError(\'Invalid Context\')\n+            raise AttributeError("Invalid Context")\n         return self.index()\n \n     def diffs(self):\n-        diff = getToolByName(self.context, \'portal_diff\')\n-        return diff.createChangeSet(self.baseline,\n-                                    self.working_copy,\n-                                    id1=\'Baseline\',\n-                                    id2=\'Working Copy\')\n+        diff = getToolByName(self.context, "portal_diff")\n+        return diff.createChangeSet(\n+            self.baseline, self.working_copy, id1="Baseline", id2="Working Copy"\n+        )\ndiff --git a/plone/app/iterate/browser/info.py b/plone/app/iterate/browser/info.py\nindex 8a6316e..300acf4 100644\n--- a/plone/app/iterate/browser/info.py\n+++ b/plone/app/iterate/browser/info.py\n@@ -21,7 +21,6 @@\n \n @implementer(IViewlet)\n class BaseInfoViewlet(BrowserView):\n-\n     def __init__(self, context, request, view, manager):\n         super(BaseInfoViewlet, self).__init__(context, request)\n         self.__parent__ = view\n@@ -42,17 +41,17 @@ def policy(self):\n     @memoize\n     def created(self):\n         time = self.properties.get(keys.checkout_time, DateTime())\n-        util = getToolByName(self.context, \'translation_service\')\n+        util = getToolByName(self.context, "translation_service")\n         return util.ulocalized_time(\n             time,\n             context=self.context,\n-            domain=\'plonelocales\',\n+            domain="plonelocales",\n         )\n \n     @memoize\n     def creator(self):\n         user_id = self.properties.get(keys.checkout_user)\n-        membership = getToolByName(self.context, \'portal_membership\')\n+        membership = getToolByName(self.context, "portal_membership")\n         if not user_id:\n             return membership.getAuthenticatedMember()\n         return membership.getMemberById(user_id)\n@@ -61,24 +60,28 @@ def creator(self):\n     def creator_url(self):\n         creator = self.creator()\n         if creator is not None:\n-            portal_url = getToolByName(self.context, \'portal_url\')\n-            return \'{0}/author/{1}\'.format(portal_url(), creator.getId())\n+            portal_url = getToolByName(self.context, "portal_url")\n+            return "{0}/author/{1}".format(portal_url(), creator.getId())\n \n     @memoize\n     def creator_name(self):\n         creator = self.creator()\n         if creator is not None:\n-            return creator.getProperty(\'fullname\') or creator.getId()\n+            return creator.getProperty("fullname") or creator.getId()\n         # User is not known by PAS. This may be due to LDAP issues, so we keep\n         # the user and log this.\n         name = self.properties.get(keys.checkout_user)\n         if IBaseline.providedBy(self.context):\n-            warning_tpl = \'%s is a baseline of a plone.app.iterate checkout \' \\\n-                          \'by an unknown user id "%s"\'\n+            warning_tpl = (\n+                "%s is a baseline of a plone.app.iterate checkout "\n+                \'by an unknown user id "%s"\'\n+            )\n         else:\n             # IWorkingCopy.providedBy(self.context)\n-            warning_tpl = \'%s is a working copy of a plone.app.iterate \' \\\n-                          \'checkout by an unknown user id "%s"\'\n+            warning_tpl = (\n+                "%s is a working copy of a plone.app.iterate "\n+                \'checkout by an unknown user id "%s"\'\n+            )\n         logger.warning(warning_tpl, self.context, name)\n         return name\n \n@@ -92,23 +95,24 @@ def properties(self):\n             return {}\n \n     def _getReference(self):\n-        raise NotImplemented\n+        raise NotImplementedError\n \n \n class BaselineInfoViewlet(BaseInfoViewlet):\n \n-    index = ViewPageTemplateFile(\'info_baseline.pt\')\n+    index = ViewPageTemplateFile("info_baseline.pt")\n \n     def render(self):\n         sm = getSecurityManager()\n         working_copy = self.working_copy()\n         if working_copy is not None and (\n-                sm.checkPermission(ModifyPortalContent, self.context) or\n-                sm.checkPermission(CheckoutPermission, self.context) or\n-                sm.checkPermission(ModifyPortalContent, working_copy)):\n+            sm.checkPermission(ModifyPortalContent, self.context)\n+            or sm.checkPermission(CheckoutPermission, self.context)\n+            or sm.checkPermission(ModifyPortalContent, working_copy)\n+        ):\n             return self.index()\n         else:\n-            return \'\'\n+            return ""\n \n     @memoize\n     def working_copy(self):\n@@ -120,17 +124,18 @@ def _getReference(self):\n \n class CheckoutInfoViewlet(BaseInfoViewlet):\n \n-    index = ViewPageTemplateFile(\'info_checkout.pt\')\n+    index = ViewPageTemplateFile("info_checkout.pt")\n \n     def render(self):\n         sm = getSecurityManager()\n         baseline = self.baseline()\n         if baseline is not None and (\n-                sm.checkPermission(ModifyPortalContent, self.context) or\n-                sm.checkPermission(CheckoutPermission, baseline)):\n+            sm.checkPermission(ModifyPortalContent, self.context)\n+            or sm.checkPermission(CheckoutPermission, baseline)\n+        ):\n             return self.index()\n         else:\n-            return \'\'\n+            return ""\n \n     @memoize\n     def baseline(self):\ndiff --git a/plone/app/iterate/configure.zcml b/plone/app/iterate/configure.zcml\nindex 9f63dfa..4dde056 100644\n--- a/plone/app/iterate/configure.zcml\n+++ b/plone/app/iterate/configure.zcml\n@@ -108,6 +108,6 @@\n     />\n \n   <include package=".dexterity" zcml:condition="installed plone.app.relationfield" />\n-  <include file="at.zcml" zcml:condition="installed Products.Archetypes" />\n+  <include file="at.zcml" zcml:condition="installed Products.Archetypes.BaseObject" />\n \n </configure>\ndiff --git a/plone/app/iterate/containers.py b/plone/app/iterate/containers.py\nindex 063ecdb..9a0c933 100644\n--- a/plone/app/iterate/containers.py\n+++ b/plone/app/iterate/containers.py\n@@ -36,20 +36,19 @@\n @implementer(IWCContainerLocator)\n @adapter(IDynamicType)\n class HomeFolderLocator(object):\n-    """Locate the current user\'s home folder, if possible.\n-    """\n+    """Locate the current user\'s home folder, if possible."""\n \n     def __init__(self, context):\n         self.context = context\n \n-    title = _(u\'Home folder\')\n+    title = _(u"Home folder")\n \n     @property\n     def available(self):\n         return self() is not None\n \n     def __call__(self):\n-        return getToolByName(self.context, \'portal_membership\').getHomeFolder()\n+        return getToolByName(self.context, "portal_membership").getHomeFolder()\n \n \n @implementer(IWCContainerLocator)\n@@ -62,14 +61,13 @@ class ParentFolderLocator(object):\n     def __init__(self, context):\n         self.context = context\n \n-    title = _(u\'Parent folder\')\n+    title = _(u"Parent folder")\n \n     @property\n     def available(self):\n         return bool(\n             getSecurityManager().checkPermission(\n-                AddPortalContent,\n-                aq_parent(aq_inner(self.context))\n+                AddPortalContent, aq_parent(aq_inner(self.context))\n             )\n         )\n \ndiff --git a/plone/app/iterate/copier.py b/plone/app/iterate/copier.py\nindex 32b77ed..3fec074 100644\n--- a/plone/app/iterate/copier.py\n+++ b/plone/app/iterate/copier.py\n@@ -53,8 +53,9 @@ def copyTo(self, container):\n         wc_ref = wc.addReference(\n             self.context,\n             relationship=WorkingCopyRelation.relationship,\n-            referenceClass=WorkingCopyRelation)\n-        self._handleReferences(self.context, wc, \'checkout\', wc_ref)\n+            referenceClass=WorkingCopyRelation,\n+        )\n+        self._handleReferences(self.context, wc, "checkout", wc_ref)\n         return wc, wc_ref\n \n     def merge(self):\n@@ -64,7 +65,7 @@ def merge(self):\n         wc_ref = self._deleteWorkingCopyRelation()\n \n         # reassemble references on the new baseline\n-        self._handleReferences(baseline, self.context, \'checkin\', wc_ref)\n+        self._handleReferences(baseline, self.context, "checkin", wc_ref)\n \n         # move the working copy to the baseline container, deleting\n         # the baseline\n@@ -81,10 +82,10 @@ def _getBaseline(self):\n         refs = self.context.getRefs(WorkingCopyRelation.relationship)\n \n         if not len(refs) == 1:\n-            raise CheckinException(\'Baseline count mismatch\')\n+            raise CheckinException("Baseline count mismatch")\n \n         if not refs or refs[0] is None:\n-            raise CheckinException(\'Baseline has disappeared\')\n+            raise CheckinException("Baseline has disappeared")\n \n         baseline = refs[0]\n         return baseline\n@@ -100,12 +101,13 @@ def _replaceBaseline(self, baseline):\n         # Check if we are a default_page, because this property of the\n         # container might get lost.\n         is_default_page = (\n-            baseline_container.getProperty(\'default_page\', \'\') == baseline_id)\n+            baseline_container.getProperty("default_page", "") == baseline_id\n+        )\n         baseline_pos = baseline_container.getObjectPosition(baseline_id)\n         baseline_container._delOb(baseline_id)\n \n         # uninedxing the deleted baseline object from portal_catalog\n-        portal_catalog = getToolByName(self.context, \'portal_catalog\')\n+        portal_catalog = getToolByName(self.context, "portal_catalog")\n         portal_catalog.unindexObject(baseline)\n \n         # delete the working copy from the its container\n@@ -128,17 +130,19 @@ def _replaceBaseline(self, baseline):\n         if is_default_page:\n             # Restore default_page to container.  Note that the property might\n             # have been removed by an event handler in the mean time.\n-            if baseline_container.hasProperty(\'default_page\'):\n-                baseline_container._updateProperty(\'default_page\', baseline_id)\n+            if baseline_container.hasProperty("default_page"):\n+                baseline_container._updateProperty("default_page", baseline_id)\n             else:\n-                baseline_container._setProperty(\'default_page\', baseline_id)\n+                baseline_container._setProperty("default_page", baseline_id)\n \n         # reregister our references with the reference machinery after moving\n-        Referenceable.manage_afterAdd(new_baseline, new_baseline,\n-                                      baseline_container)\n+        Referenceable.manage_afterAdd(new_baseline, new_baseline, baseline_container)\n \n-        notify(ObjectMovedEvent(new_baseline, wc_container,\n-                                wc_id, baseline_container, baseline_id))\n+        notify(\n+            ObjectMovedEvent(\n+                new_baseline, wc_container, wc_id, baseline_container, baseline_id\n+            )\n+        )\n \n         return new_baseline\n \n@@ -146,13 +150,14 @@ def _reassembleWorkingCopy(self, new_baseline, baseline):\n         # reattach the source\'s workflow history, try avoid a dangling ref\n         try:\n             new_baseline.workflow_history = PersistentMapping(\n-                baseline.workflow_history.items())\n+                baseline.workflow_history.items()\n+            )\n         except AttributeError:\n             # No workflow apparently.  Oh well.\n             pass\n \n         # reset wf state security directly\n-        workflow_tool = getToolByName(self.context, \'portal_workflow\')\n+        workflow_tool = getToolByName(self.context, "portal_workflow")\n         wfs = workflow_tool.getWorkflowsFor(self.context)\n         for wf in wfs:\n             if not isinstance(wf, DCWorkflowDefinition):\n@@ -166,7 +171,7 @@ def _reassembleWorkingCopy(self, new_baseline, baseline):\n \n         # reattach the source\'s history id, to get the previous\n         # version ancestry\n-        histid_handler = getToolByName(self.context, \'portal_historyidhandler\')\n+        histid_handler = getToolByName(self.context, "portal_historyidhandler")\n         huid = histid_handler.getUid(baseline)\n         histid_handler.setUid(new_baseline, huid, check_uniqueness=False)\n \n@@ -195,9 +200,8 @@ def _handleReferences(self, baseline, wc, mode, wc_ref):\n             else:\n                 # look for a named relation adapter first\n                 adapter = component.queryAdapter(\n-                    baseline,\n-                    interfaces.ICheckinCheckoutReference,\n-                    relationship)\n+                    baseline, interfaces.ICheckinCheckoutReference, relationship\n+                )\n \n             if adapter is None:  # default\n                 adapter = baseline_adapter\n@@ -207,7 +211,7 @@ def _handleReferences(self, baseline, wc, mode, wc_ref):\n             mode_method = getattr(adapter, mode)\n             mode_method(baseline, wc, references, annotations)\n \n-        mode = mode + \'BackReferences\'\n+        mode = mode + "BackReferences"\n \n         # handle backward references\n         for relationship in baseline.getBRelationships():\n@@ -216,9 +220,8 @@ def _handleReferences(self, baseline, wc, mode, wc_ref):\n             else:\n                 # look for a named relation adapter first\n                 adapter = component.queryAdapter(\n-                    baseline,\n-                    interfaces.ICheckinCheckoutReference,\n-                    relationship)\n+                    baseline, interfaces.ICheckinCheckoutReference, relationship\n+                )\n \n             if adapter is None:\n                 adapter = baseline_adapter\ndiff --git a/plone/app/iterate/dexterity/__init__.py b/plone/app/iterate/dexterity/__init__.py\nindex afd34c6..22ba3f6 100644\n--- a/plone/app/iterate/dexterity/__init__.py\n+++ b/plone/app/iterate/dexterity/__init__.py\n@@ -1,3 +1,3 @@\n # -*- coding: utf-8 -*-\n \n-ITERATE_RELATION_NAME = \'iterate-working-copy\'\n+ITERATE_RELATION_NAME = "iterate-working-copy"\ndiff --git a/plone/app/iterate/dexterity/policy.py b/plone/app/iterate/dexterity/policy.py\nindex 14d1ea4..f88c69c 100644\n--- a/plone/app/iterate/dexterity/policy.py\n+++ b/plone/app/iterate/dexterity/policy.py\n@@ -40,16 +40,16 @@ def _get_relation_to_baseline(self):\n         # do we have a baseline in our relations?\n         relations = get_relations(self.context)\n         if relations and not len(relations) == 1:\n-            raise CheckinException(\'Baseline count mismatch\')\n+            raise CheckinException("Baseline count mismatch")\n         if not relations or not relations[0]:\n-            raise CheckinException(\'Baseline has disappeared\')\n+            raise CheckinException("Baseline has disappeared")\n \n         return relations[0]\n \n     def _getBaseline(self):\n         baseline = get_baseline(self.context)\n         if not baseline:\n-            raise CheckinException(\'Baseline has disappeared\')\n+            raise CheckinException("Baseline has disappeared")\n         return baseline\n \n     def getBaseline(self):\ndiff --git a/plone/app/iterate/dexterity/relation.py b/plone/app/iterate/dexterity/relation.py\nindex 8c2eca1..3180f92 100644\n--- a/plone/app/iterate/dexterity/relation.py\n+++ b/plone/app/iterate/dexterity/relation.py\n@@ -10,16 +10,14 @@\n \n @implementer(IStagingRelationValue, IAttributeAnnotatable)\n class StagingRelationValue(relation.RelationValue):\n-\n     @classmethod\n     def get_relations_of(cls, obj, from_attribute=None):\n-        """ a list of relations to or from the passed object\n-        """\n+        """a list of relations to or from the passed object"""\n         catalog = getUtility(ICatalog)\n         intids = getUtility(IIntIds)\n         obj_id = intids.getId(obj)\n-        items = list(catalog.findRelations({\'from_id\': obj_id}))\n-        items += list(catalog.findRelations({\'to_id\': obj_id}))\n+        items = list(catalog.findRelations({"from_id": obj_id}))\n+        items += list(catalog.findRelations({"to_id": obj_id}))\n         if from_attribute:\n \n             def condition(r):\ndiff --git a/plone/app/iterate/dexterity/utils.py b/plone/app/iterate/dexterity/utils.py\nindex e1dd41b..6f142bb 100644\n--- a/plone/app/iterate/dexterity/utils.py\n+++ b/plone/app/iterate/dexterity/utils.py\n@@ -18,12 +18,9 @@ def get_relations(context):\n         return []\n     # ask catalog\n     catalog = component.getUtility(ICatalog)\n-    relations = list(catalog.findRelations({\'to_id\': id}))\n-    relations += list(catalog.findRelations({\'from_id\': id}))\n-    relations = filter(\n-        lambda r: r.from_attribute == ITERATE_RELATION_NAME,\n-        relations\n-    )\n+    relations = list(catalog.findRelations({"to_id": id}))\n+    relations += list(catalog.findRelations({"from_id": id}))\n+    relations = filter(lambda r: r.from_attribute == ITERATE_RELATION_NAME, relations)\n     return list(relations)\n \n \ndiff --git a/plone/app/iterate/event.py b/plone/app/iterate/event.py\nindex 61cd53e..16d6041 100644\n--- a/plone/app/iterate/event.py\n+++ b/plone/app/iterate/event.py\n@@ -31,7 +31,6 @@\n \n @implementer(interfaces.ICheckoutEvent)\n class CheckoutEvent(ObjectEvent):\n-\n     def __init__(self, baseline, wc, relation):\n         ObjectEvent.__init__(self, baseline)\n         self.working_copy = wc\n@@ -40,7 +39,6 @@ def __init__(self, baseline, wc, relation):\n \n @implementer(interfaces.ICheckinEvent)\n class CheckinEvent(ObjectEvent):\n-\n     def __init__(self, wc, baseline, relation, message):\n         ObjectEvent.__init__(self, wc)\n         self.baseline = baseline\n@@ -50,7 +48,6 @@ def __init__(self, wc, baseline, relation, message):\n \n @implementer(interfaces.IAfterCheckinEvent)\n class AfterCheckinEvent(ObjectEvent):\n-\n     def __init__(self, new_baseline, checkin_message):\n         super(AfterCheckinEvent, self).__init__(new_baseline)\n         self.message = checkin_message\n@@ -58,7 +55,6 @@ def __init__(self, new_baseline, checkin_message):\n \n @implementer(interfaces.ICancelCheckoutEvent)\n class CancelCheckoutEvent(ObjectEvent):\n-\n     def __init__(self, wc, baseline):\n         ObjectEvent.__init__(self, wc)\n         self.baseline = baseline\n@@ -66,7 +62,6 @@ def __init__(self, wc, baseline):\n \n @implementer(interfaces.IWorkingCopyDeletedEvent)\n class WorkingCopyDeletedEvent(ObjectEvent):\n-\n     def __init__(self, wc, baseline, relation):\n         ObjectEvent.__init__(self, wc)\n         self.baseline = baseline\ndiff --git a/plone/app/iterate/interfaces.py b/plone/app/iterate/interfaces.py\nindex c12e27d..d63b42a 100644\n--- a/plone/app/iterate/interfaces.py\n+++ b/plone/app/iterate/interfaces.py\n@@ -36,11 +36,13 @@\n \n \n try:\n-    pkg_resources.get_distribution(\'Products.Archetypes\')\n+    pkg_resources.get_distribution("Products.Archetypes")\n except pkg_resources.DistributionNotFound:\n \n     class IReference(Interface):\n         pass\n+\n+\n else:\n     from Products.Archetypes.interfaces import IReference\n \n@@ -50,13 +52,15 @@ class IReference(Interface):\n \n \n class IIterateAware(Interface):\n-    """An object that can be used for check-in/check-out operations.\n-    """\n+    """An object that can be used for check-in/check-out operations."""\n+\n \n #################################\n #  Lock types\n \n-ITERATE_LOCK = LockType(u\'iterate.lock\', stealable=False, user_unlockable=False, timeout=MAX_TIMEOUT)  # noqa\n+ITERATE_LOCK = LockType(\n+    u"iterate.lock", stealable=False, user_unlockable=False, timeout=MAX_TIMEOUT\n+)  # noqa\n \n #################################\n #  Exceptions\n@@ -80,32 +84,33 @@ class ConflictError(CheckinException):\n \n #################################\n # Annotation Key\n-annotation_key = \'ore.iterate\'\n+annotation_key = "ore.iterate"\n \n \n class keys(object):\n     # various common keys\n-    checkout_user = \'checkout_user\'\n-    checkout_time = \'checkout_time\'\n+    checkout_user = "checkout_user"\n+    checkout_time = "checkout_time"\n \n \n #################################\n #  Event Interfaces\n \n+\n class ICheckinEvent(IObjectEvent):\n-    """ a working copy is being checked in, event.object is the working copy, this\n+    """a working copy is being checked in, event.object is the working copy, this\n     message is sent before any mutation/merge has been done on the objects\n     """\n \n-    baseline = Attribute(\'The Working Copy\\\'s baseline\')\n-    relation = Attribute(\'The Working Copy Archetypes Relation Object\')\n-    checkin_message = Attribute(\'checkin message\')\n+    baseline = Attribute("The Working Copy\'s baseline")\n+    relation = Attribute("The Working Copy Archetypes Relation Object")\n+    checkin_message = Attribute("checkin message")\n \n \n class IAfterCheckinEvent(IObjectEvent):\n     """ sent out after an object is checked in """\n \n-    checkin_message = Attribute(\'checkin message\')\n+    checkin_message = Attribute("checkin message")\n \n \n class IBeforeCheckoutEvent(IObjectEvent):\n@@ -115,26 +120,27 @@ class IBeforeCheckoutEvent(IObjectEvent):\n class ICheckoutEvent(IObjectEvent):\n     """ an object is being checked out, event.object is the baseline """\n \n-    working_copy = Attribute(\'The object\\\'s working copy\')\n-    relation = Attribute(\'The Working Copy Archetypes Relation Object\')\n+    working_copy = Attribute("The object\'s working copy")\n+    relation = Attribute("The Working Copy Archetypes Relation Object")\n \n \n class ICancelCheckoutEvent(IObjectEvent):\n     """ a working copy is being cancelled """\n \n-    baseline = Attribute(\'The working copy\\\'s baseline\')\n+    baseline = Attribute("The working copy\'s baseline")\n \n \n class IWorkingCopyDeletedEvent(IObjectEvent):\n-    """ a working copy is being deleted, this gets called multiple times at\n+    """a working copy is being deleted, this gets called multiple times at\n     different states.\n     So on cancel checkout and checkin operations, its mostly designed to\n     broadcast an event when the user deletes a working copy using the standard\n     container paradigms.\n     """\n \n-    baseline = Attribute(\'The working copy baseline\')\n-    relation = Attribute(\'The Working Copy Archetypes Relation Object\')\n+    baseline = Attribute("The working copy baseline")\n+    relation = Attribute("The Working Copy Archetypes Relation Object")\n+\n \n #################################\n # Content Marker Interfaces\n@@ -147,18 +153,16 @@ class IIterateManagedContent(Interface):\n \n \n class IWorkingCopy(IIterateManagedContent):\n-    """A working copy/check-out\n-    """\n+    """A working copy/check-out"""\n \n \n class IBaseline(IIterateManagedContent):\n-    """A baseline\n-    """\n+    """A baseline"""\n \n \n class IWorkingCopyRelation(IReference):\n-    """A relationship to a working copy\n-    """\n+    """A relationship to a working copy"""\n+\n \n #################################\n #  Working copy container locator\n@@ -170,21 +174,20 @@ class IWCContainerLocator(Interface):\n     """\n \n     available = schema.Bool(\n-        title=u\'Available\', description=u\'Whether location will be available.\')\n+        title=u"Available", description=u"Whether location will be available."\n+    )\n \n-    title = schema.TextLine(\n-        title=u\'Title\', description=u\'Title of this location\')\n+    title = schema.TextLine(title=u"Title", description=u"Title of this location")\n \n     def __call__():\n-        """Return a container object, or None if available() is False\n-        """\n+        """Return a container object, or None if available() is False"""\n+\n \n #################################\n #  Interfaces\n \n \n class ICheckinCheckoutTool(Interface):\n-\n     def allowCheckin(content):\n         """\n         denotes whether a checkin operation can be performed on the content.\n@@ -213,40 +216,33 @@ def cancelCheckout(content):\n \n \n class IObjectCopier(Interface):\n-    """ copies and merges the object state\n-    """\n+    """copies and merges the object state"""\n \n     def copyTo(container):\n-        """ copy the context to the given container, must also create an AT\n+        """copy the context to the given container, must also create an AT\n         relation using the WorkingCopyRelation.relation name between the\n         source and the copy.\n         returns the copy.\n         """\n \n     def merge():\n-        """ merge/replace the source with the copy, context is the copy.\n-        """\n+        """merge/replace the source with the copy, context is the copy."""\n \n \n class IObjectArchiver(Interface):\n-    """ iterate needs minimal versioning support\n-    """\n+    """iterate needs minimal versioning support"""\n \n     def save(checkin_message):\n-        """ save a new version of the object\n-        """\n+        """save a new version of the object"""\n \n     def isVersioned(self):\n-        """ is this content already versioned\n-        """\n+        """is this content already versioned"""\n \n     def isVersionable(self):\n-        """ is versionable check.\n-        """\n+        """is versionable check."""\n \n     def isModified(self):\n-        """ is the resource current state, different than its last saved state.\n-        """\n+        """is the resource current state, different than its last saved state."""\n \n \n class ICheckinCheckoutPolicy(Interface):\n@@ -254,10 +250,10 @@ class ICheckinCheckoutPolicy(Interface):\n \n     def checkin(checkin_message):\n         """checkin the context, if the target has been deleted then raises a\n-        checkin exception.\n+         checkin exception.\n \n-       if the object version has changed since the checkout begin (due to\n-       another checkin) raises a conflict error.\n+        if the object version has changed since the checkout begin (due to\n+        another checkin) raises a conflict error.\n         """\n \n     def checkout(container):\n@@ -289,6 +285,7 @@ def getWorkingCopy():\n \n #################################\n \n+\n class ICheckinCheckoutReference(Interface):\n     # a reference processor\n \n@@ -300,30 +297,27 @@ def checkout(baseline, wc, references, storage):\n         """\n \n     def checkoutBackReferences(baseline, wc, references, storage):\n-        """\n-        """\n+        """"""\n \n     def checkin(baseline, wc, references, storage):\n-        """\n-        """\n+        """"""\n \n     def checkinBackReferences(baseline, wc, references, storage):\n-        """\n-        """\n+        """"""\n \n \n class IIterateSettings(Interface):\n \n     enable_checkout_workflow = schema.Bool(\n-        title=_(u\'Enable checkout workflow\'),\n-        description=u\'\',\n+        title=_(u"Enable checkout workflow"),\n+        description=u"",\n         default=False,\n-        required=False\n+        required=False,\n     )\n \n     checkout_workflow_policy = schema.ASCIILine(\n-        title=_(u\'Checkout workflow policy\'),\n-        description=u\'\',\n-        default=\'checkout_workflow_policy\',\n-        required=True\n+        title=_(u"Checkout workflow policy"),\n+        description=u"",\n+        default="checkout_workflow_policy",\n+        required=True,\n     )\ndiff --git a/plone/app/iterate/lock.py b/plone/app/iterate/lock.py\nindex 138c24b..7851c81 100644\n--- a/plone/app/iterate/lock.py\n+++ b/plone/app/iterate/lock.py\n@@ -30,7 +30,7 @@\n from plone.locking.interfaces import ILockable\n \n \n-__all__ = [\'lockContext\', \'unlockContext\', \'isLocked\']\n+__all__ = ["lockContext", "unlockContext", "isLocked"]\n \n \n def lockContext(context):\ndiff --git a/plone/app/iterate/permissions.py b/plone/app/iterate/permissions.py\nindex 7978780..d829aef 100644\n--- a/plone/app/iterate/permissions.py\n+++ b/plone/app/iterate/permissions.py\n@@ -23,9 +23,9 @@\n \n from AccessControl.Permission import addPermission\n \n-CheckinPermission = \'iterate : Check in content\'\n-CheckoutPermission = \'iterate : Check out content\'\n+CheckinPermission = "iterate : Check in content"\n+CheckoutPermission = "iterate : Check out content"\n \n-DEFAULT_ROLES = (\'Manager\', \'Owner\', \'Site Administrator\', \'Editor\')\n+DEFAULT_ROLES = ("Manager", "Owner", "Site Administrator", "Editor")\n addPermission(CheckinPermission, default_roles=DEFAULT_ROLES)\n addPermission(CheckoutPermission, default_roles=DEFAULT_ROLES)\ndiff --git a/plone/app/iterate/policy.py b/plone/app/iterate/policy.py\nindex ac0fa4e..e2f536d 100644\n--- a/plone/app/iterate/policy.py\n+++ b/plone/app/iterate/policy.py\n@@ -53,9 +53,7 @@ def checkin(self, checkin_message):\n         baseline = self._getBaseline()\n \n         # get a hold of the relation object\n-        wc_ref = self.context.getReferenceImpl(\n-            WorkingCopyRelation.relationship\n-        )[0]\n+        wc_ref = self.context.getReferenceImpl(WorkingCopyRelation.relationship)[0]\n \n         # publish the event for subscribers, early because contexts are about\n         # to be manipulated\n@@ -81,10 +79,10 @@ def _getBaseline(self):\n         refs = self.context.getReferences(WorkingCopyRelation.relationship)\n \n         if not len(refs) == 1:\n-            raise CheckinException(\'Baseline count mismatch\')\n+            raise CheckinException("Baseline count mismatch")\n \n         if not refs or refs[0] is None:\n-            raise CheckinException(\'Baseline has disappeared\')\n+            raise CheckinException("Baseline has disappeared")\n \n         baseline = refs[0]\n         return baseline\ndiff --git a/plone/app/iterate/relation.py b/plone/app/iterate/relation.py\nindex 7332cf0..dd3ada7 100644\n--- a/plone/app/iterate/relation.py\n+++ b/plone/app/iterate/relation.py\n@@ -37,7 +37,7 @@\n import logging\n \n \n-logger = logging.getLogger(\'plone.app.iterate\')\n+logger = logging.getLogger("plone.app.iterate")\n \n \n @implementer(IWorkingCopyRelation, IAttributeAnnotatable)\n@@ -47,7 +47,8 @@ class WorkingCopyRelation(Reference):\n \n     Target Object is Baseline Version\n     """\n-    relationship = \'Working Copy Relation\'\n+\n+    relationship = "Working Copy Relation"\n \n \n @implementer(ICheckinCheckoutReference)\n@@ -71,7 +72,7 @@ class CheckinCheckoutReferenceAdapter(object):\n \n     """\n \n-    storage_key = \'coci.references\'\n+    storage_key = "coci.references"\n \n     def __init__(self, context):\n         self.context = context\n@@ -79,14 +80,17 @@ def __init__(self, context):\n     def checkout(self, baseline, wc, refs, storage):\n         for ref in refs:\n             try:\n-                wc.addReference(ref.targetUID, ref.relationship,\n-                                referenceClass=ref.__class__)\n+                wc.addReference(\n+                    ref.targetUID, ref.relationship, referenceClass=ref.__class__\n+                )\n             except ReferenceException:\n                 logger.warn(\n-                    \'Reference exception when adding relation %r \'\n-                    \'from new working copy %s to uid %s. Ignoring relation.\',\n-                    ref.relationship, \'/\'.join(wc.getPhysicalPath()),\n-                    ref.targetUID)\n+                    "Reference exception when adding relation %r "\n+                    "from new working copy %s to uid %s. Ignoring relation.",\n+                    ref.relationship,\n+                    "/".join(wc.getPhysicalPath()),\n+                    ref.targetUID,\n+                )\n \n     def checkin(self, *args):\n         pass\ndiff --git a/plone/app/iterate/setuphandlers.py b/plone/app/iterate/setuphandlers.py\nindex e397cb6..0f6a18b 100644\n--- a/plone/app/iterate/setuphandlers.py\n+++ b/plone/app/iterate/setuphandlers.py\n@@ -7,15 +7,14 @@\n \n @implementer(INonInstallable)\n class HiddenProfiles(object):\n-\n     def getNonInstallableProfiles(self):\n         """Prevents uninstall profile from showing up in the profile list\n         when creating a Plone site.\n \n         """\n         return [\n-            u\'plone.app.iterate:uninstall\',\n-            u\'plone.app.iterate:plone.app.iterate\',\n+            u"plone.app.iterate:uninstall",\n+            u"plone.app.iterate:plone.app.iterate",\n         ]\n \n \n@@ -26,5 +25,5 @@ def deprecate_profile(tool):\n     """\n     warnings.warn(\n         \'The profile with id "plone.app.iterate" was renamed to "default".\',\n-        DeprecationWarning\n+        DeprecationWarning,\n     )\ndiff --git a/plone/app/iterate/subscribers/locking.py b/plone/app/iterate/subscribers/locking.py\nindex 783e8cd..851b5a8 100644\n--- a/plone/app/iterate/subscribers/locking.py\n+++ b/plone/app/iterate/subscribers/locking.py\n@@ -32,12 +32,12 @@ def handleWCDeleted(event):\n     # may be called multiple times, must be reentrant\n     lock.unlockContext(event.baseline)\n     # we reindex to force a metadata update\n-    event.baseline.reindexObject(idxs=[\'review_state\'])\n+    event.baseline.reindexObject(idxs=["review_state"])\n \n \n def handleCheckout(event):\n     lock.lockContext(event.object)\n-    event.object.reindexObject(idxs=[\'review_state\'])\n+    event.object.reindexObject(idxs=["review_state"])\n \n \n def handleCheckin(event):\n@@ -53,4 +53,4 @@ def handleCancelCheckout(event):\n         # unlock working copy if it was auto-locked, or this will fail\n         lockable.clear_locks()\n     lock.unlockContext(event.baseline)\n-    event.baseline.reindexObject(idxs=[\'review_state\'])\n+    event.baseline.reindexObject(idxs=["review_state"])\ndiff --git a/plone/app/iterate/subscribers/versioning.py b/plone/app/iterate/subscribers/versioning.py\nindex f1daa5a..027f60e 100644\n--- a/plone/app/iterate/subscribers/versioning.py\n+++ b/plone/app/iterate/subscribers/versioning.py\n@@ -29,7 +29,7 @@\n def handleBeforeCheckout(event):\n     archiver = interfaces.IObjectArchiver(event.object)\n     if archiver.isModified() or not archiver.isVersioned():\n-        archiver.save(\'Baseline created\')\n+        archiver.save("Baseline created")\n \n \n def handleAfterCheckin(event):\ndiff --git a/plone/app/iterate/subscribers/workflow.py b/plone/app/iterate/subscribers/workflow.py\nindex 572245e..bce937a 100644\n--- a/plone/app/iterate/subscribers/workflow.py\n+++ b/plone/app/iterate/subscribers/workflow.py\n@@ -31,14 +31,18 @@\n from plone.app.iterate.interfaces import IIterateSettings\n from plone.app.iterate.util import get_storage\n from plone.registry.interfaces import IRegistry\n-from Products.CMFPlacefulWorkflow.PlacefulWorkflowTool import WorkflowPolicyConfig_id  # noqa\n-from Products.CMFPlacefulWorkflow.WorkflowPolicyConfig import WorkflowPolicyConfig  # noqa\n+from Products.CMFPlacefulWorkflow.PlacefulWorkflowTool import (\n+    WorkflowPolicyConfig_id,\n+)  # noqa\n+from Products.CMFPlacefulWorkflow.WorkflowPolicyConfig import (\n+    WorkflowPolicyConfig,\n+)  # noqa\n from zope.component import getUtility\n \n \n-USE_WORKFLOW = \'checkout_workflow_policy\'\n+USE_WORKFLOW = "checkout_workflow_policy"\n \n-policy_storage = \'previous_wf_policy\'\n+policy_storage = "previous_wf_policy"\n \n \n def handleCheckout(event):\n@@ -50,7 +54,8 @@ def handleCheckout(event):\n     policy_id = str(settings.checkout_workflow_policy)\n \n     existing_policy = getattr(\n-        aq_base(event.working_copy), WorkflowPolicyConfig_id, None)\n+        aq_base(event.working_copy), WorkflowPolicyConfig_id, None\n+    )\n     storage = get_storage(event.relation)\n \n     # set config for policy in and below\n@@ -72,7 +77,7 @@ def handleCheckin(event):\n     previous_policy = storage.get(policy_storage)\n     if previous_policy is None:\n         # only reset workflows we know.. could use are own storage\n-        if policy and not getattr(policy, \'coci_created\', False):\n+        if policy and not getattr(policy, "coci_created", False):\n             return\n         elif policy is None:\n             return\ndiff --git a/plone/app/iterate/testing.py b/plone/app/iterate/testing.py\nindex 6cb7c8b..0bb87e1 100644\n--- a/plone/app/iterate/testing.py\n+++ b/plone/app/iterate/testing.py\n@@ -12,7 +12,7 @@\n \n \n try:\n-    pkg_resources.get_distribution(\'Products.Archetypes\')\n+    pkg_resources.get_distribution("Products.Archetypes")\n except pkg_resources.DistributionNotFound:\n     HAS_AT = False\n else:\n@@ -20,19 +20,19 @@\n \n \n ADMIN = {\n-    \'id\': \'admin\',\n-    \'password\': \'secret\',\n-    \'roles\': [\'Manager\'],\n+    "id": "admin",\n+    "password": "secret",\n+    "roles": ["Manager"],\n }\n EDITOR = {\n-    \'id\': \'editor\',\n-    \'password\': \'secret\',\n-    \'roles\': [\'Editor\'],\n+    "id": "editor",\n+    "password": "secret",\n+    "roles": ["Editor"],\n }\n CONTRIBUTOR = {\n-    \'id\': \'contributor\',\n-    \'password\': \'secret\',\n-    \'roles\': [\'Contributor\'],\n+    "id": "contributor",\n+    "password": "secret",\n+    "roles": ["Contributor"],\n }\n USERS_TO_BE_ADDED = (\n     ADMIN,\n@@ -56,15 +56,17 @@ def setUpZope(self, app, configurationContext):\n             return\n \n         import Products.ATContentTypes\n+\n         self.loadZCML(package=Products.ATContentTypes)\n-        z2.installProduct(app, \'Products.ATContentTypes\')\n+        z2.installProduct(app, "Products.ATContentTypes")\n \n-        z2.installProduct(app, \'Products.Archetypes\')\n-        z2.installProduct(app, \'Products.ATContentTypes\')\n-        z2.installProduct(app, \'plone.app.blob\')\n-        z2.installProduct(app, \'plone.app.collection\')\n+        z2.installProduct(app, "Products.Archetypes")\n+        z2.installProduct(app, "Products.ATContentTypes")\n+        z2.installProduct(app, "plone.app.blob")\n+        z2.installProduct(app, "plone.app.collection")\n \n         import plone.app.iterate\n+\n         self.loadZCML(package=plone.app.iterate)\n \n     def setUpPloneSite(self, portal):\n@@ -73,18 +75,18 @@ def setUpPloneSite(self, portal):\n             return\n \n         # restore default workflow\n-        applyProfile(portal, \'Products.CMFPlone:testfixture\')\n+        applyProfile(portal, "Products.CMFPlone:testfixture")\n \n         # add default content\n-        applyProfile(portal, \'Products.ATContentTypes:content\')\n-        applyProfile(portal, \'plone.app.iterate:default\')\n-        applyProfile(portal, \'plone.app.iterate:test\')\n+        applyProfile(portal, "Products.ATContentTypes:content")\n+        applyProfile(portal, "plone.app.iterate:default")\n+        applyProfile(portal, "plone.app.iterate:test")\n \n         for user in USERS_TO_BE_ADDED:\n             portal.portal_membership.addMember(\n-                user[\'id\'],\n-                user[\'password\'],\n-                user[\'roles\'],\n+                user["id"],\n+                user["password"],\n+                user["roles"],\n                 [],\n             )\n \n@@ -92,40 +94,40 @@ def setUpPloneSite(self, portal):\n             mtool = portal.portal_membership\n             if not mtool.getMemberareaCreationFlag():\n                 mtool.setMemberareaCreationFlag()\n-                mtool.createMemberArea(user[\'id\'])\n+                mtool.createMemberArea(user["id"])\n \n             if mtool.getMemberareaCreationFlag():\n                 mtool.setMemberareaCreationFlag()\n \n         portal.portal_workflow.setChainForPortalTypes(\n-            (\'Document\',),\n-            \'plone_workflow\',\n+            ("Document",),\n+            "plone_workflow",\n         )\n \n         # Turn on versioning for folders\n         portal_repository = portal.portal_repository\n         portal_repository.addPolicyForContentType(\n-            \'Folder\',\n-            u\'at_edit_autoversion\',\n+            "Folder",\n+            u"at_edit_autoversion",\n         )\n         portal_repository.addPolicyForContentType(\n-            \'Folder\',\n-            u\'version_on_revert\',\n+            "Folder",\n+            u"version_on_revert",\n         )\n         versionable_types = portal_repository.getVersionableContentTypes()\n-        versionable_types.append(\'Folder\')\n+        versionable_types.append("Folder")\n         portal_repository.setVersionableContentTypes(versionable_types)\n \n \n PLONEAPPITERATE_FIXTURE = PloneAppIterateLayer()\n \n PLONEAPPITERATE_INTEGRATION_TESTING = IntegrationTesting(\n-    bases=(PLONEAPPITERATE_FIXTURE,),\n-    name=\'PloneAppIterateLayer:Integration\')\n+    bases=(PLONEAPPITERATE_FIXTURE,), name="PloneAppIterateLayer:Integration"\n+)\n \n PLONEAPPITERATE_FUNCTIONAL_TESTING = FunctionalTesting(\n-    bases=(PLONEAPPITERATE_FIXTURE,),\n-    name=\'PloneAppIterateLayer:Functional\')\n+    bases=(PLONEAPPITERATE_FIXTURE,), name="PloneAppIterateLayer:Functional"\n+)\n \n \n class DexPloneAppIterateLayer(PloneAppContenttypes):\n@@ -133,26 +135,26 @@ class DexPloneAppIterateLayer(PloneAppContenttypes):\n \n     def setUpZope(self, app, configurationContext):\n         """Setup Zope with Addons."""\n-        super(DexPloneAppIterateLayer,\n-              self).setUpZope(app, configurationContext)\n+        super(DexPloneAppIterateLayer, self).setUpZope(app, configurationContext)\n \n         import plone.app.iterate\n+\n         self.loadZCML(package=plone.app.iterate)\n \n     def setUpPloneSite(self, portal):\n         """Setup Plone Site with Addons."""\n         super(DexPloneAppIterateLayer, self).setUpPloneSite(portal)\n-        applyProfile(portal, \'plone.app.iterate:default\')\n+        applyProfile(portal, "plone.app.iterate:default")\n         # with named AND dotted behaviors we need to take care of both\n         versioning_behavior = set(\n             [\n-                \'plone.app.versioningbehavior.behaviors.IVersionable\',\n-                \'plone.versioning\',\n+                "plone.app.versioningbehavior.behaviors.IVersionable",\n+                "plone.versioning",\n             ],\n         )\n \n         # Disable automatic versioning of core content types\n-        for name in (\'Document\', \'Event\', \'Link\', \'News Item\'):\n+        for name in ("Document", "Event", "Link", "News Item"):\n             fti = portal.portal_types[name]\n             # write back the behaviors without the versioning behaviors\n             # using a Set to keep it simple\n@@ -166,9 +168,9 @@ def setUpPloneSite(self, portal):\n \n PLONEAPPITERATEDEX_FIXTURE = DexPloneAppIterateLayer()\n PLONEAPPITERATEDEX_INTEGRATION_TESTING = IntegrationTesting(\n-    bases=(PLONEAPPITERATEDEX_FIXTURE,),\n-    name=\'DexPloneAppIterateLayer:Integration\')\n+    bases=(PLONEAPPITERATEDEX_FIXTURE,), name="DexPloneAppIterateLayer:Integration"\n+)\n \n PLONEAPPITERATEDEX_FUNCTIONAL_TESTING = FunctionalTesting(\n-    bases=(PLONEAPPITERATEDEX_FIXTURE,),\n-    name=\'DexPloneAppIterateLayer:Functional\')\n+    bases=(PLONEAPPITERATEDEX_FIXTURE,), name="DexPloneAppIterateLayer:Functional"\n+)\ndiff --git a/plone/app/iterate/tests/content.py b/plone/app/iterate/tests/content.py\nindex 5023591..fcdeb44 100644\n--- a/plone/app/iterate/tests/content.py\n+++ b/plone/app/iterate/tests/content.py\n@@ -5,22 +5,25 @@\n from Products.ATContentTypes.content.base import registerATCT\n \n \n-RichFolderSchema = ATFolderSchema.copy() + atapi.Schema((\n-    atapi.TextField(\'text\',\n-                    default_output_type=\'text/x-html-safe\',\n-                    widget=atapi.RichWidget(),\n-                    ),\n-))\n+RichFolderSchema = ATFolderSchema.copy() + atapi.Schema(\n+    (\n+        atapi.TextField(\n+            "text",\n+            default_output_type="text/x-html-safe",\n+            widget=atapi.RichWidget(),\n+        ),\n+    )\n+)\n \n \n class RichFolder(ATFolder):\n     """ sample content type for testing purposes """\n \n     schema = RichFolderSchema\n-    portal_type = \'RichFolder\'\n+    portal_type = "RichFolder"\n \n \n-registerATCT(RichFolder, \'plone.app.iterate\')\n+registerATCT(RichFolder, "plone.app.iterate")\n \n \n def addRichFolder(container, id, **kwargs):\ndiff --git a/plone/app/iterate/tests/test_annotations.py b/plone/app/iterate/tests/test_annotations.py\nindex c19e5b4..e18cd45 100644\n--- a/plone/app/iterate/tests/test_annotations.py\n+++ b/plone/app/iterate/tests/test_annotations.py\n@@ -17,10 +17,10 @@ class AnnotationsTestCase(unittest.TestCase):\n     layer = PLONEAPPITERATEDEX_INTEGRATION_TESTING\n \n     def setUp(self):\n-        self.portal = self.layer[\'portal\']\n-        setRoles(self.portal, TEST_USER_ID, [\'Manager\'])\n-        self.portal.invokeFactory(\'Document\', \'s1\')\n-        self.s1 = self.portal[\'s1\']\n+        self.portal = self.layer["portal"]\n+        setRoles(self.portal, TEST_USER_ID, ["Manager"])\n+        self.portal.invokeFactory("Document", "s1")\n+        self.s1 = self.portal["s1"]\n \n     def test_object_annotatable(self):\n         self.assertTrue(IAnnotatable.providedBy(self.s1))\n@@ -30,13 +30,13 @@ def test_annotation_saved_on_checkin(self):\n         obj_annotations = IAnnotations(self.s1)\n         self.assertEqual(obj_annotations, {})\n \n-        obj_annotations[\'key1\'] = u\'value1\'\n+        obj_annotations["key1"] = u"value1"\n         obj_annotations = IAnnotations(self.s1)\n-        self.assertEqual(obj_annotations, {\'key1\': u\'value1\'})\n+        self.assertEqual(obj_annotations, {"key1": u"value1"})\n \n         # Now, let\'s get a working copy for it.\n         locators = getAdapters((self.s1,), IWCContainerLocator)\n-        location = u\'plone.app.iterate.parent\'\n+        location = u"plone.app.iterate.parent"\n         locator = [c[1] for c in locators if c[0] == location][0]\n \n         policy = ICheckinCheckoutPolicy(self.s1)\n@@ -45,31 +45,31 @@ def test_annotation_saved_on_checkin(self):\n \n         # Annotations should be the same\n         new_annotations = IAnnotations(wc)\n-        self.assertEqual(new_annotations[\'key1\'], u\'value1\')\n+        self.assertEqual(new_annotations["key1"], u"value1")\n \n         # Now, let\'s modify the existing one, and create a new one\n-        new_annotations[\'key1\'] = u\'value2\'\n-        new_annotations[\'key2\'] = u\'value1\'\n+        new_annotations["key1"] = u"value2"\n+        new_annotations["key2"] = u"value1"\n \n         # Check that annotations were stored correctly and original ones were\n         # not overriten\n         new_annotations = IAnnotations(wc)\n-        self.assertEqual(new_annotations[\'key1\'], u\'value2\')\n-        self.assertEqual(new_annotations[\'key2\'], u\'value1\')\n+        self.assertEqual(new_annotations["key1"], u"value2")\n+        self.assertEqual(new_annotations["key2"], u"value1")\n \n         obj_annotations = IAnnotations(self.s1)\n-        self.assertEqual(obj_annotations[\'key1\'],  u\'value1\')\n-        self.assertFalse(\'key2\' in obj_annotations)\n+        self.assertEqual(obj_annotations["key1"], u"value1")\n+        self.assertFalse("key2" in obj_annotations)\n \n         # Now, we do a checkin\n         policy = ICheckinCheckoutPolicy(wc)\n-        policy.checkin(u\'Commit message\')\n+        policy.checkin(u"Commit message")\n \n         # And finally check that the old object has the same annotations as\n         # its working copy\n \n         obj_annotations = IAnnotations(self.s1)\n-        self.assertTrue(\'key1\' in obj_annotations)\n-        self.assertTrue(\'key2\' in obj_annotations)\n-        self.assertEqual(obj_annotations[\'key1\'], u\'value2\')\n-        self.assertEqual(obj_annotations[\'key2\'], u\'value1\')\n+        self.assertTrue("key1" in obj_annotations)\n+        self.assertTrue("key2" in obj_annotations)\n+        self.assertEqual(obj_annotations["key1"], u"value2")\n+        self.assertEqual(obj_annotations["key2"], u"value1")\ndiff --git a/plone/app/iterate/tests/test_doctests.py b/plone/app/iterate/tests/test_doctests.py\nindex 506e933..cc6e435 100644\n--- a/plone/app/iterate/tests/test_doctests.py\n+++ b/plone/app/iterate/tests/test_doctests.py\n@@ -6,7 +6,7 @@\n import doctest\n \n try:\n-    import Products.ATContentTypes\n+    import Products.ATContentTypes  # noqa\n except ImportError:\n     HAS_AT = False\n else:\n@@ -15,22 +15,26 @@\n \n def test_suite():\n     suite = TestSuite()\n-    OPTIONFLAGS = (doctest.ELLIPSIS | doctest.NORMALIZE_WHITESPACE)\n+    OPTIONFLAGS = doctest.ELLIPSIS | doctest.NORMALIZE_WHITESPACE\n     if HAS_AT:\n-        suite.addTest(layered(\n+        suite.addTest(\n+            layered(\n+                doctest.DocFileSuite(\n+                    "browser.rst",\n+                    optionflags=OPTIONFLAGS,\n+                    package="plone.app.iterate.tests",\n+                ),\n+                layer=PLONEAPPITERATE_FUNCTIONAL_TESTING,\n+            )\n+        )\n+    suite.addTest(\n+        layered(\n             doctest.DocFileSuite(\n-                \'browser.rst\',\n+                "dexterity.rst",\n                 optionflags=OPTIONFLAGS,\n-                package=\'plone.app.iterate.tests\',\n+                package="plone.app.iterate.tests",\n             ),\n-            layer=PLONEAPPITERATE_FUNCTIONAL_TESTING)\n+            layer=PLONEAPPITERATEDEX_FUNCTIONAL_TESTING,\n         )\n-    suite.addTest(layered(\n-        doctest.DocFileSuite(\n-            \'dexterity.rst\',\n-            optionflags=OPTIONFLAGS,\n-            package=\'plone.app.iterate.tests\',\n-        ),\n-        layer=PLONEAPPITERATEDEX_FUNCTIONAL_TESTING)\n     )\n     return suite\ndiff --git a/plone/app/iterate/tests/test_interfaces.py b/plone/app/iterate/tests/test_interfaces.py\nindex 12b99ca..f921b18 100644\n--- a/plone/app/iterate/tests/test_interfaces.py\n+++ b/plone/app/iterate/tests/test_interfaces.py\n@@ -29,21 +29,22 @@ class TestObjectsProvideCorrectInterfaces(TestCase):\n     def setUp(self):\n         super(TestObjectsProvideCorrectInterfaces, self).setUp()\n \n-        self.portal = self.layer[\'portal\']\n-        setRoles(self.portal, TEST_USER_ID, [\'Manager\'])\n+        self.portal = self.layer["portal"]\n+        setRoles(self.portal, TEST_USER_ID, ["Manager"])\n         login(self.portal, TEST_USER_NAME)\n \n         # create a folder where everything of this test suite should happen\n-        self.assertNotIn(\'test-folder\', self.portal.objectIds())\n+        self.assertNotIn("test-folder", self.portal.objectIds())\n         self.folder = self.portal.get(\n-            self.portal.invokeFactory(\'Folder\', \'test-folder\'))\n+            self.portal.invokeFactory("Folder", "test-folder")\n+        )\n \n-        self.obj = createContentInContainer(self.folder, \'Document\')\n+        self.obj = createContentInContainer(self.folder, "Document")\n \n     def tearDown(self):\n         self.portal.manage_delObjects([self.folder.id])\n         logout()\n-        setRoles(self.portal, TEST_USER_ID, [\'Member\'])\n+        setRoles(self.portal, TEST_USER_ID, ["Member"])\n         super(TestObjectsProvideCorrectInterfaces, self).tearDown()\n \n     def do_checkout(self):\n@@ -57,7 +58,7 @@ def do_cancel(self, working_copy):\n \n     def do_checkin(self, working_copy):\n         policy = ICheckinCheckoutPolicy(working_copy)\n-        policy.checkin(\'\')\n+        policy.checkin("")\n \n     def test_before_checkout(self):\n         self.assertTrue(self.obj)\ndiff --git a/plone/app/iterate/tests/test_iterate.py b/plone/app/iterate/tests/test_iterate.py\nindex 70bb950..8fcf288 100644\n--- a/plone/app/iterate/tests/test_iterate.py\n+++ b/plone/app/iterate/tests/test_iterate.py\n@@ -42,24 +42,24 @@ class TestIterations(unittest.TestCase):\n     layer = PLONEAPPITERATEDEX_INTEGRATION_TESTING\n \n     def setUp(self):\n-        self.portal = self.layer[\'portal\']\n-        setRoles(self.portal, TEST_USER_ID, [\'Manager\'])\n+        self.portal = self.layer["portal"]\n+        setRoles(self.portal, TEST_USER_ID, ["Manager"])\n         login(self.portal, TEST_USER_NAME)\n \n         self.wf = self.portal.portal_workflow\n-        self.wf.setChainForPortalTypes((\'Document\',), \'plone_workflow\')\n+        self.wf.setChainForPortalTypes(("Document",), "plone_workflow")\n \n         # add a folder with two documents in it\n-        self.portal.invokeFactory(\'Folder\', \'docs\')\n-        self.portal.docs.invokeFactory(\'Document\', \'doc1\')\n-        self.portal.docs.invokeFactory(\'Document\', \'doc2\')\n+        self.portal.invokeFactory("Folder", "docs")\n+        self.portal.docs.invokeFactory("Document", "doc1")\n+        self.portal.docs.invokeFactory("Document", "doc2")\n \n         # add a working copy folder\n-        self.portal.invokeFactory(\'Folder\', \'workarea\')\n+        self.portal.invokeFactory("Folder", "workarea")\n \n         self.repo = self.portal.portal_repository\n \n-    @unittest.skip(\'This test needs to be fixed for Dexterity content.\')\n+    @unittest.skip("This test needs to be fixed for Dexterity content.")\n     def test_workflowState(self):\n         # ensure baseline workflow state is retained on checkin, including\n         # security\n@@ -67,24 +67,27 @@ def test_workflowState(self):\n         doc = self.portal.docs.doc1\n \n         # sanity check that owner can edit visible docs\n-        setRoles(self.portal, TEST_USER_ID, [\'Owner\'])\n-        self.assertTrue(getSecurityManager().checkPermission(\n-            \'Modify portal content\', self.portal.docs.doc1))\n+        setRoles(self.portal, TEST_USER_ID, ["Owner"])\n+        self.assertTrue(\n+            getSecurityManager().checkPermission(\n+                "Modify portal content", self.portal.docs.doc1\n+            )\n+        )\n \n-        setRoles(self.portal, TEST_USER_ID, [\'Manager\'])\n-        self.wf.doActionFor(doc, \'publish\')\n-        state = self.wf.getInfoFor(doc, \'review_state\')\n+        setRoles(self.portal, TEST_USER_ID, ["Manager"])\n+        self.wf.doActionFor(doc, "publish")\n+        state = self.wf.getInfoFor(doc, "review_state")\n \n         self.repo.save(doc)\n         wc = ICheckinCheckoutPolicy(doc).checkout(self.portal.workarea)\n-        wc_state = self.wf.getInfoFor(wc, \'review_state\')\n+        wc_state = self.wf.getInfoFor(wc, "review_state")\n \n         self.assertNotEqual(state, wc_state)\n \n-        ICheckinCheckoutPolicy(wc).checkin(\'modified\')\n-        bstate = self.wf.getInfoFor(wc, \'review_state\')\n+        ICheckinCheckoutPolicy(wc).checkin("modified")\n+        bstate = self.wf.getInfoFor(wc, "review_state")\n         self.assertEqual(state, bstate)\n-        setRoles(self.portal, TEST_USER_ID, [\'Owner\'])\n+        setRoles(self.portal, TEST_USER_ID, ["Owner"])\n \n     def test_baselineVersionCreated(self):\n         # if a baseline has no version ensure that one is created on checkout\n@@ -117,82 +120,86 @@ def test_folderOrder(self):\n \n         # check that there is another document which could interact with\n         # position of document the test work on\n-        doc2_position = container.getObjectPosition(\'doc2\')\n+        doc2_position = container.getObjectPosition("doc2")\n         self.assertTrue(doc2_position > original_position)\n \n         self.repo.save(doc)\n         wc = ICheckinCheckoutPolicy(doc).checkout(container)\n-        wc.text = \'new document text\'\n+        wc.text = "new document text"\n \n         # check that the copy is put after the second document\n         copy_position = container.getObjectPosition(wc.getId())\n         self.assertTrue(copy_position > doc2_position)\n \n-        new_doc = ICheckinCheckoutPolicy(wc).checkin(\'updated\')\n+        new_doc = ICheckinCheckoutPolicy(wc).checkin("updated")\n         new_position = container.getObjectPosition(new_doc.getId())\n         self.assertEqual(new_position, original_position)\n \n-    @unittest.skip(\'This test needs to be fixed for Dexterity content.\')\n+    @unittest.skip("This test needs to be fixed for Dexterity content.")\n     def test_folderContents(self):\n         """When an folder is checked out, and item is added, and then\n         the folder is checked back in, the added item is in the new\n         version of the folder.  UIDs of contained content are also\n         preserved."""\n         container = self.portal.docs\n-        folder = container[container.invokeFactory(\n-            type_name=\'Folder\', id=\'foo-folder\')]\n-        existing_doc = folder[folder.invokeFactory(\n-            type_name=\'Document\', id=\'existing-folder-item\')]\n+        folder = container[container.invokeFactory(type_name="Folder", id="foo-folder")]\n+        existing_doc = folder[\n+            folder.invokeFactory(type_name="Document", id="existing-folder-item")\n+        ]\n         existing_doc_uid = existing_doc.UID()\n \n         self.repo.save(folder)\n         wc = ICheckinCheckoutPolicy(folder).checkout(container)\n-        new_doc = wc[wc.invokeFactory(type_name=\'Document\',\n-                                      id=\'new-folder-item\',\n-                                      text=\'new folder item text\')]\n+        new_doc = wc[\n+            wc.invokeFactory(\n+                type_name="Document", id="new-folder-item", text="new folder item text"\n+            )\n+        ]\n         new_doc_uid = new_doc.UID()\n-        new_folder = ICheckinCheckoutPolicy(wc).checkin(\'updated\')\n+        new_folder = ICheckinCheckoutPolicy(wc).checkin("updated")\n \n-        catalog = getToolByName(self.portal, \'portal_catalog\')\n+        catalog = getToolByName(self.portal, "portal_catalog")\n \n-        self.assertTrue(\'existing-folder-item\' in new_folder)\n-        self.assertEqual(\n-            new_folder[\'existing-folder-item\'].UID(), existing_doc_uid)\n-        self.assertTrue(\'new-folder-item\' in new_folder)\n-        self.assertEqual(new_folder[\'new-folder-item\'].UID(), new_doc_uid)\n-        brains = catalog(path=\'/\'.join(\n-            new_folder[\'new-folder-item\'].getPhysicalPath()))\n+        self.assertTrue("existing-folder-item" in new_folder)\n+        self.assertEqual(new_folder["existing-folder-item"].UID(), existing_doc_uid)\n+        self.assertTrue("new-folder-item" in new_folder)\n+        self.assertEqual(new_folder["new-folder-item"].UID(), new_doc_uid)\n+        brains = catalog(path="/".join(new_folder["new-folder-item"].getPhysicalPath()))\n         self.assertTrue(brains)\n-        self.assertTrue(\'new folder item text\' in\n-                        new_folder[\'new-folder-item\'].getText())\n+        self.assertTrue(\n+            "new folder item text" in new_folder["new-folder-item"].getText()\n+        )\n \n     def test_default_page_is_kept_in_folder(self):\n         # Ensure that a default page that is checked out and back in is still\n         # the default page.\n         folder = self.portal.docs\n         doc = folder.doc1\n-        from Products.CMFDynamicViewFTI.interfaces import ISelectableBrowserDefault  # noqa: C901\n-        ISelectableBrowserDefault(folder).setDefaultPage(\'doc1\')\n-        self.assertEqual(folder.getProperty(\'default_page\', \'\'), \'doc1\')\n-        self.assertEqual(folder.getDefaultPage(), \'doc1\')\n+        from Products.CMFDynamicViewFTI.interfaces import (\n+            ISelectableBrowserDefault,\n+        )  # noqa: C901\n+\n+        ISelectableBrowserDefault(folder).setDefaultPage("doc1")\n+        self.assertEqual(folder.getProperty("default_page", ""), "doc1")\n+        self.assertEqual(folder.getDefaultPage(), "doc1")\n         # Note: when checking out to self.portal.workarea it surprisingly works\n         # without changes.  But the default behavior in Plone is to check a\n         # document out in its original folder, so that is what we check here.\n         wc = ICheckinCheckoutPolicy(doc).checkout(folder)\n-        doc = ICheckinCheckoutPolicy(wc).checkin(\'updated\')\n-        self.assertEqual(folder.getProperty(\'default_page\', \'\'), \'doc1\')\n-        self.assertEqual(folder.getDefaultPage(), \'doc1\')\n+        doc = ICheckinCheckoutPolicy(wc).checkin("updated")\n+        self.assertEqual(folder.getProperty("default_page", ""), "doc1")\n+        self.assertEqual(folder.getDefaultPage(), "doc1")\n \n     def test_control_checkin_allowed_with_no_policy(self):\n-        control = Control(self.portal, self.layer[\'request\'])\n+        control = Control(self.portal, self.layer["request"])\n         self.assertFalse(control.checkin_allowed())\n \n     def test_control_checkout_allowed_with_no_policy(self):\n-        control = Control(self.portal, self.layer[\'request\'])\n+        control = Control(self.portal, self.layer["request"])\n         self.assertFalse(control.checkout_allowed())\n \n     def test_control_cancel_allowed_with_no_policy(self):\n-        control = Control(self.portal, self.layer[\'request\'])\n+        control = Control(self.portal, self.layer["request"])\n         self.assertFalse(control.cancel_allowed())\n \n     def test_control_cancel_on_original_does_not_delete_original(self):\n@@ -203,11 +210,13 @@ def test_control_cancel_on_original_does_not_delete_original(self):\n \n         # get cancel browser view\n         from plone.app.iterate.browser.cancel import Cancel\n-        cancel = Cancel(doc, self.layer[\'request\'])\n-        self.layer[\'request\'].form[\'form.button.Cancel\'] = True\n+\n+        cancel = Cancel(doc, self.layer["request"])\n+        self.layer["request"].form["form.button.Cancel"] = True\n \n         # check if cancel on original raises the correct exception\n         from plone.app.iterate.interfaces import CheckoutException\n+\n         with self.assertRaises(CheckoutException):\n             cancel()\n \n@@ -220,25 +229,25 @@ def test_relationship_deleted_on_checkin(self):\n         intids = component.getUtility(IIntIds)\n         catalog = component.getUtility(ICatalog)\n         obj_id = intids.getId(doc)\n-        rels = list(catalog.findRelations({\'from_id\': obj_id}))\n+        rels = list(catalog.findRelations({"from_id": obj_id}))\n         self.assertEqual(len(rels), 0)\n \n         wc = ICheckinCheckoutPolicy(doc).checkout(folder)\n         wc_id = intids.getId(wc)\n \n-        rels = list(catalog.findRelations({\'from_id\': obj_id}))\n+        rels = list(catalog.findRelations({"from_id": obj_id}))\n         self.assertEqual(len(rels), 1)\n         from_rel = rels[0]\n \n-        rels = list(catalog.findRelations({\'to_id\': wc_id}))\n+        rels = list(catalog.findRelations({"to_id": wc_id}))\n         self.assertEqual(len(rels), 1)\n         to_rel = rels[0]\n \n         self.assertEqual(from_rel, to_rel)\n \n-        doc = ICheckinCheckoutPolicy(wc).checkin(\'updated\')\n+        doc = ICheckinCheckoutPolicy(wc).checkin("updated")\n \n-        rels = list(catalog.findRelations({\'from_id\': obj_id}))\n+        rels = list(catalog.findRelations({"from_id": obj_id}))\n \n         self.assertEqual(len(rels), 0)\n \n@@ -251,17 +260,17 @@ def test_relationship_deleted_on_cancel_checkout(self):\n         intids = component.getUtility(IIntIds)\n         catalog = component.getUtility(ICatalog)\n         obj_id = intids.getId(doc)\n-        rels = list(catalog.findRelations({\'from_id\': obj_id}))\n+        rels = list(catalog.findRelations({"from_id": obj_id}))\n         self.assertEqual(len(rels), 0)\n \n         wc = ICheckinCheckoutPolicy(doc).checkout(folder)\n         wc_id = intids.getId(wc)\n \n-        rels = list(catalog.findRelations({\'from_id\': obj_id}))\n+        rels = list(catalog.findRelations({"from_id": obj_id}))\n         self.assertEqual(len(rels), 1)\n         from_rel = rels[0]\n \n-        rels = list(catalog.findRelations({\'to_id\': wc_id}))\n+        rels = list(catalog.findRelations({"to_id": wc_id}))\n         self.assertEqual(len(rels), 1)\n         to_rel = rels[0]\n \n@@ -269,6 +278,6 @@ def test_relationship_deleted_on_cancel_checkout(self):\n \n         ICheckinCheckoutPolicy(wc).cancelCheckout()\n \n-        rels = list(catalog.findRelations({\'from_id\': obj_id}))\n+        rels = list(catalog.findRelations({"from_id": obj_id}))\n \n         self.assertEqual(len(rels), 0)\ndiff --git a/plone/app/iterate/tests/test_iterate_at.py b/plone/app/iterate/tests/test_iterate_at.py\nindex 1062264..f7cd5de 100644\n--- a/plone/app/iterate/tests/test_iterate_at.py\n+++ b/plone/app/iterate/tests/test_iterate_at.py\n@@ -39,6 +39,7 @@\n     HAS_AT = False\n else:\n     HAS_AT = True\n+\n     class CustomReference(Reference):\n         pass\n \n@@ -49,22 +50,22 @@ class TestIterations(unittest.TestCase):\n \n     def setUp(self):\n         if not HAS_AT:\n-            raise unittest.SkipTest(\'Testing Archetypes support requires Archetypes\')\n+            raise unittest.SkipTest("Testing Archetypes support requires Archetypes")\n \n-        self.portal = self.layer[\'portal\']\n-        setRoles(self.portal, TEST_USER_ID, [\'Manager\'])\n+        self.portal = self.layer["portal"]\n+        setRoles(self.portal, TEST_USER_ID, ["Manager"])\n         login(self.portal, TEST_USER_NAME)\n \n         self.wf = self.portal.portal_workflow\n-        self.wf.setChainForPortalTypes((\'Document\',), \'plone_workflow\')\n+        self.wf.setChainForPortalTypes(("Document",), "plone_workflow")\n \n         # add a folder with two documents in it\n-        self.portal.invokeFactory(\'Folder\', \'docs\')\n-        self.portal.docs.invokeFactory(\'Document\', \'doc1\')\n-        self.portal.docs.invokeFactory(\'Document\', \'doc2\')\n+        self.portal.invokeFactory("Folder", "docs")\n+        self.portal.docs.invokeFactory("Document", "doc1")\n+        self.portal.docs.invokeFactory("Document", "doc2")\n \n         # add a working copy folder\n-        self.portal.invokeFactory(\'Folder\', \'workarea\')\n+        self.portal.invokeFactory("Folder", "workarea")\n \n         self.repo = self.portal.portal_repository\n \n@@ -75,24 +76,27 @@ def test_workflowState(self):\n         doc = self.portal.docs.doc1\n \n         # sanity check that owner can edit visible docs\n-        setRoles(self.portal, TEST_USER_ID, [\'Owner\'])\n-        self.assertTrue(getSecurityManager().checkPermission(\n-            \'Modify portal content\', self.portal.docs.doc1))\n+        setRoles(self.portal, TEST_USER_ID, ["Owner"])\n+        self.assertTrue(\n+            getSecurityManager().checkPermission(\n+                "Modify portal content", self.portal.docs.doc1\n+            )\n+        )\n \n-        setRoles(self.portal, TEST_USER_ID, [\'Manager\'])\n-        self.wf.doActionFor(doc, \'publish\')\n-        state = self.wf.getInfoFor(doc, \'review_state\')\n+        setRoles(self.portal, TEST_USER_ID, ["Manager"])\n+        self.wf.doActionFor(doc, "publish")\n+        state = self.wf.getInfoFor(doc, "review_state")\n \n         self.repo.save(doc)\n         wc = ICheckinCheckoutPolicy(doc).checkout(self.portal.workarea)\n-        wc_state = self.wf.getInfoFor(wc, \'review_state\')\n+        wc_state = self.wf.getInfoFor(wc, "review_state")\n \n         self.assertNotEqual(state, wc_state)\n \n-        ICheckinCheckoutPolicy(wc).checkin(\'modified\')\n-        bstate = self.wf.getInfoFor(wc, \'review_state\')\n+        ICheckinCheckoutPolicy(wc).checkin("modified")\n+        bstate = self.wf.getInfoFor(wc, "review_state")\n         self.assertEqual(state, bstate)\n-        setRoles(self.portal, TEST_USER_ID, [\'Owner\'])\n+        setRoles(self.portal, TEST_USER_ID, ["Owner"])\n \n     def test_baselineVersionCreated(self):\n         # if a baseline has no version ensure that one is created on checkout\n@@ -121,35 +125,35 @@ def test_wcNewForwardReferencesCopied(self):\n         # checkin\n         doc = self.portal.docs.doc1\n         doc.addReference(self.portal.docs)\n-        self.assertEqual(len(doc.getReferences(\'zebra\')), 0)\n+        self.assertEqual(len(doc.getReferences("zebra")), 0)\n         wc = ICheckinCheckoutPolicy(doc).checkout(self.portal.workarea)\n-        wc.addReference(self.portal.docs.doc2, \'zebra\')\n-        doc = ICheckinCheckoutPolicy(wc).checkin(\'updated\')\n-        self.assertEqual(len(doc.getReferences(\'zebra\')), 1)\n+        wc.addReference(self.portal.docs.doc2, "zebra")\n+        doc = ICheckinCheckoutPolicy(wc).checkin("updated")\n+        self.assertEqual(len(doc.getReferences("zebra")), 1)\n \n     def test_wcNewBackwardReferencesCopied(self):\n         # ensure that new wc back references are copied back to the baseline on\n         # checkin\n \n         doc = self.portal.docs.doc1\n-        self.assertEqual(len(doc.getBackReferences(\'zebra\')), 0)\n+        self.assertEqual(len(doc.getBackReferences("zebra")), 0)\n         wc = ICheckinCheckoutPolicy(doc).checkout(self.portal.workarea)\n-        self.portal.docs.doc2.addReference(wc, \'zebra\')\n-        self.assertEqual(len(wc.getBackReferences(\'zebra\')), 1)\n-        doc = ICheckinCheckoutPolicy(wc).checkin(\'updated\')\n-        self.assertEqual(len(doc.getBackReferences(\'zebra\')), 1)\n+        self.portal.docs.doc2.addReference(wc, "zebra")\n+        self.assertEqual(len(wc.getBackReferences("zebra")), 1)\n+        doc = ICheckinCheckoutPolicy(wc).checkin("updated")\n+        self.assertEqual(len(doc.getBackReferences("zebra")), 1)\n \n     def test_baselineReferencesMaintained(self):\n         # ensure that baseline references are maintained when the object is\n         # checked in copies forward, bkw are not copied, but are maintained.\n \n         doc = self.portal.docs.doc1\n-        doc.addReference(self.portal.docs, \'elephant\')\n+        doc.addReference(self.portal.docs, "elephant")\n         self.portal.docs.doc2.addReference(doc)\n \n         wc = ICheckinCheckoutPolicy(doc).checkout(self.portal.workarea)\n \n-        doc = ICheckinCheckoutPolicy(wc).checkin(\'updated\')\n+        doc = ICheckinCheckoutPolicy(wc).checkin("updated")\n \n         # TODO: This fails in Plone 4.1. The new optimized catalog lookups\n         # in the reference catalog no longer filter out non-existing reference\n@@ -164,8 +168,8 @@ def test_baselineBrokenReferencesRemoved(self):\n         # checkout should not fail with a ReferenceException.\n \n         doc = self.portal.docs.doc1\n-        doc.addReference(self.portal.docs.doc2, \'pony\')\n-        self.portal.docs._delOb(\'doc2\')\n+        doc.addReference(self.portal.docs.doc2, "pony")\n+        self.portal.docs._delOb("doc2")\n         # _delOb is low level enough that the reference does not get cleaned\n         # up.\n         self.assertEqual(len(doc.getReferences()), 1)\n@@ -173,9 +177,9 @@ def test_baselineBrokenReferencesRemoved(self):\n         wc = ICheckinCheckoutPolicy(doc).checkout(self.portal.workarea)\n         # The working copy has one reference: its original.\n         self.assertEqual(len(wc.getReferences()), 1)\n-        self.assertEqual(wc.getReferences()[0].id, \'doc1\')\n+        self.assertEqual(wc.getReferences()[0].id, "doc1")\n \n-        doc = ICheckinCheckoutPolicy(wc).checkin(\'updated\')\n+        doc = ICheckinCheckoutPolicy(wc).checkin("updated")\n         # The checkin removes the broken reference.\n         self.assertEqual(len(doc.getReferences()), 0)\n \n@@ -191,25 +195,27 @@ def test_baselineNoCopyReferences(self):\n             adapts=(IBaseObject,),\n             provides=interfaces.ICheckinCheckoutReference,\n             factory=relation.NoCopyReferenceAdapter,\n-            name=\'zebra\')\n+            name="zebra",\n+        )\n \n         doc = self.portal.docs.doc1\n         ref = doc.addReference(\n-            self.portal.docs, \'zebra\', referenceClass=CustomReference)\n-        ref.custom_state = \'hello world\'\n+            self.portal.docs, "zebra", referenceClass=CustomReference\n+        )\n+        ref.custom_state = "hello world"\n \n         wc = ICheckinCheckoutPolicy(doc).checkout(self.portal.workarea)\n \n-        self.assertEqual(len(wc.getReferences(\'zebra\')), 0)\n+        self.assertEqual(len(wc.getReferences("zebra")), 0)\n \n-        doc = ICheckinCheckoutPolicy(wc).checkin(\'updated\')\n+        doc = ICheckinCheckoutPolicy(wc).checkin("updated")\n \n-        self.assertEqual(len(doc.getReferences(\'zebra\')), 1)\n+        self.assertEqual(len(doc.getReferences("zebra")), 1)\n \n-        ref = doc.getReferenceImpl(\'zebra\')[0]\n+        ref = doc.getReferenceImpl("zebra")[0]\n \n-        self.assertTrue(hasattr(ref, \'custom_state\'))\n-        self.assertEqual(ref.custom_state, \'hello world\')\n+        self.assertTrue(hasattr(ref, "custom_state"))\n+        self.assertEqual(ref.custom_state, "hello world")\n \n     def test_folderOrder(self):\n         """When an item is checked out and then back in, the original\n@@ -220,18 +226,18 @@ def test_folderOrder(self):\n \n         # check that there is another document which could interact with\n         # position of document the test work on\n-        doc2_position = container.getObjectPosition(\'doc2\')\n+        doc2_position = container.getObjectPosition("doc2")\n         self.assertTrue(doc2_position > original_position)\n \n         self.repo.save(doc)\n         wc = ICheckinCheckoutPolicy(doc).checkout(container)\n-        wc.update(text=\'new document text\')\n+        wc.update(text="new document text")\n \n         # check that the copy is put after the second document\n         copy_position = container.getObjectPosition(wc.getId())\n         self.assertTrue(copy_position > doc2_position)\n \n-        new_doc = ICheckinCheckoutPolicy(wc).checkin(\'updated\')\n+        new_doc = ICheckinCheckoutPolicy(wc).checkin("updated")\n         new_position = container.getObjectPosition(new_doc.getId())\n         self.assertEqual(new_position, original_position)\n \n@@ -241,32 +247,33 @@ def test_folderContents(self):\n         version of the folder.  UIDs of contained content are also\n         preserved."""\n         container = self.portal.docs\n-        folder = container[container.invokeFactory(\n-            type_name=\'Folder\', id=\'foo-folder\')]\n-        existing_doc = folder[folder.invokeFactory(\n-            type_name=\'Document\', id=\'existing-folder-item\')]\n+        folder = container[container.invokeFactory(type_name="Folder", id="foo-folder")]\n+        existing_doc = folder[\n+            folder.invokeFactory(type_name="Document", id="existing-folder-item")\n+        ]\n         existing_doc_uid = existing_doc.UID()\n \n         self.repo.save(folder)\n         wc = ICheckinCheckoutPolicy(folder).checkout(container)\n-        new_doc = wc[wc.invokeFactory(type_name=\'Document\',\n-                                      id=\'new-folder-item\',\n-                                      text=\'new folder item text\')]\n+        new_doc = wc[\n+            wc.invokeFactory(\n+                type_name="Document", id="new-folder-item", text="new folder item text"\n+            )\n+        ]\n         new_doc_uid = new_doc.UID()\n-        new_folder = ICheckinCheckoutPolicy(wc).checkin(\'updated\')\n+        new_folder = ICheckinCheckoutPolicy(wc).checkin("updated")\n \n-        catalog = getToolByName(self.portal, \'portal_catalog\')\n+        catalog = getToolByName(self.portal, "portal_catalog")\n \n-        self.assertTrue(\'existing-folder-item\' in new_folder)\n-        self.assertEqual(\n-            new_folder[\'existing-folder-item\'].UID(), existing_doc_uid)\n-        self.assertTrue(\'new-folder-item\' in new_folder)\n-        self.assertEqual(new_folder[\'new-folder-item\'].UID(), new_doc_uid)\n-        brains = catalog(path=\'/\'.join(\n-            new_folder[\'new-folder-item\'].getPhysicalPath()))\n+        self.assertTrue("existing-folder-item" in new_folder)\n+        self.assertEqual(new_folder["existing-folder-item"].UID(), existing_doc_uid)\n+        self.assertTrue("new-folder-item" in new_folder)\n+        self.assertEqual(new_folder["new-folder-item"].UID(), new_doc_uid)\n+        brains = catalog(path="/".join(new_folder["new-folder-item"].getPhysicalPath()))\n         self.assertTrue(brains)\n-        self.assertTrue(\'new folder item text\' in\n-                        new_folder[\'new-folder-item\'].getText())\n+        self.assertTrue(\n+            "new folder item text" in new_folder["new-folder-item"].getText()\n+        )\n \n     def test_checkinObjectLinkedInParentsRichTextField(self):\n         """Checnking-in an object that is linked in it\'s\n@@ -274,22 +281,24 @@ def test_checkinObjectLinkedInParentsRichTextField(self):\n         """\n         # create a folderish object with a rich text field\n         from content import addRichFolder\n-        addRichFolder(self.portal, \'rich_text_folder\')\n+\n+        addRichFolder(self.portal, "rich_text_folder")\n         rich_text_folder = self.portal.rich_text_folder\n \n         # create the subobject\n-        rich_text_folder.invokeFactory(\'Document\', \'subobject\')\n+        rich_text_folder.invokeFactory("Document", "subobject")\n         subobject = rich_text_folder.subobject\n         subobject_uid = subobject.UID()\n \n         # link (by uid) the subobject in it\'s parent\'s rich text field\n-        link_html = \'<a class="internal-link" href="resolveuid/{0}">\' \\\n-            \'Link to subobject</a>\'\n+        link_html = (\n+            \'<a class="internal-link" href="resolveuid/{0}">\' "Link to subobject</a>"\n+        )\n         rich_text_folder.setText(link_html.format(subobject_uid))\n \n         # try to checkout and checkin the subobject\n         wc = ICheckinCheckoutPolicy(subobject).checkout(rich_text_folder)\n-        ICheckinCheckoutPolicy(wc).checkin(\'updated\')\n+        ICheckinCheckoutPolicy(wc).checkin("updated")\n \n         # everything went right and the working copy is checked in\n         self.assertEqual(subobject_uid, wc.UID())\n@@ -299,28 +308,31 @@ def test_default_page_is_kept_in_folder(self):\n         # the default page.\n         folder = self.portal.docs\n         doc = folder.doc1\n-        from Products.CMFDynamicViewFTI.interfaces import ISelectableBrowserDefault  # noqa: C901\n-        ISelectableBrowserDefault(folder).setDefaultPage(\'doc1\')\n-        self.assertEqual(folder.getProperty(\'default_page\', \'\'), \'doc1\')\n-        self.assertEqual(folder.getDefaultPage(), \'doc1\')\n+        from Products.CMFDynamicViewFTI.interfaces import (\n+            ISelectableBrowserDefault,\n+        )  # noqa: C901\n+\n+        ISelectableBrowserDefault(folder).setDefaultPage("doc1")\n+        self.assertEqual(folder.getProperty("default_page", ""), "doc1")\n+        self.assertEqual(folder.getDefaultPage(), "doc1")\n         # Note: when checking out to self.portal.workarea it surprisingly works\n         # without changes.  But the default behavior in Plone is to check a\n         # document out in its original folder, so that is what we check here.\n         wc = ICheckinCheckoutPolicy(doc).checkout(folder)\n-        doc = ICheckinCheckoutPolicy(wc).checkin(\'updated\')\n-        self.assertEqual(folder.getProperty(\'default_page\', \'\'), \'doc1\')\n-        self.assertEqual(folder.getDefaultPage(), \'doc1\')\n+        doc = ICheckinCheckoutPolicy(wc).checkin("updated")\n+        self.assertEqual(folder.getProperty("default_page", ""), "doc1")\n+        self.assertEqual(folder.getDefaultPage(), "doc1")\n \n     def test_control_checkin_allowed_with_no_policy(self):\n-        control = Control(self.portal, self.layer[\'request\'])\n+        control = Control(self.portal, self.layer["request"])\n         self.assertFalse(control.checkin_allowed())\n \n     def test_control_checkout_allowed_with_no_policy(self):\n-        control = Control(self.portal, self.layer[\'request\'])\n+        control = Control(self.portal, self.layer["request"])\n         self.assertFalse(control.checkout_allowed())\n \n     def test_control_cancel_allowed_with_no_policy(self):\n-        control = Control(self.portal, self.layer[\'request\'])\n+        control = Control(self.portal, self.layer["request"])\n         self.assertFalse(control.cancel_allowed())\n \n     def test_control_cancel_on_original_does_not_delete_original(self):\n@@ -331,10 +343,12 @@ def test_control_cancel_on_original_does_not_delete_original(self):\n \n         # get cancel browser view\n         from plone.app.iterate.browser.cancel import Cancel\n-        cancel = Cancel(doc, self.layer[\'request\'])\n-        self.layer[\'request\'].form[\'form.button.Cancel\'] = True\n+\n+        cancel = Cancel(doc, self.layer["request"])\n+        self.layer["request"].form["form.button.Cancel"] = True\n \n         # check if cancel on original raises the correct exception\n         from plone.app.iterate.interfaces import CheckoutException\n+\n         with self.assertRaises(CheckoutException):\n             cancel()\ndiff --git a/plone/app/iterate/util.py b/plone/app/iterate/util.py\nindex 744b94a..6826071 100644\n--- a/plone/app/iterate/util.py\n+++ b/plone/app/iterate/util.py\n@@ -38,5 +38,5 @@ def get_storage(context, default=None):\n \n def upgrade_by_reinstall(context):\n     qi = get_installer(context)\n-    qi.uninstall_product(\'plone.app.iterate\')\n-    qi.install_product(\'plone.app.iterate\')\n+    qi.uninstall_product("plone.app.iterate")\n+    qi.install_product("plone.app.iterate")\ndiff --git a/setup.py b/setup.py\nindex c3453ba..c68835b 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -3,73 +3,69 @@\n from setuptools import setup\n \n \n-LONG_DESCRIPTION = (\n-    open(\'README.rst\').read() +\n-    \'\\n\' +\n-    open(\'CHANGES.rst\').read() +\n-    \'\\n\')\n+LONG_DESCRIPTION = open("README.rst").read() + "\\n" + open("CHANGES.rst").read() + "\\n"\n \n setup(\n-    name=\'plone.app.iterate\',\n-    version=\'3.3.16.dev0\',\n-    description=\'check-out/check-in staging for Plone\',\n+    name="plone.app.iterate",\n+    version="3.3.16.dev0",\n+    description="check-out/check-in staging for Plone",\n     long_description=LONG_DESCRIPTION,\n     classifiers=[\n-        \'Development Status :: 5 - Production/Stable\',\n-        \'Environment :: Web Environment\',\n-        \'Framework :: Plone\',\n-        \'Framework :: Plone :: 5.1\',\n-        \'Framework :: Plone :: 5.2\',\n-        \'Framework :: Plone :: Core\',\n-        \'Framework :: Zope2\',\n-        \'Framework :: Zope :: 4\',\n-        \'License :: OSI Approved :: GNU General Public License v2 (GPLv2)\',\n-        \'Operating System :: OS Independent\',\n-        \'Programming Language :: Python\',\n-        \'Programming Language :: Python :: 2.7\',\n-        \'Programming Language :: Python :: 3.6\',\n-        \'Programming Language :: Python :: 3.7\',\n-        \'Programming Language :: Python :: 3.8\',\n+        "Development Status :: 5 - Production/Stable",\n+        "Environment :: Web Environment",\n+        "Framework :: Plone",\n+        "Framework :: Plone :: 5.1",\n+        "Framework :: Plone :: 5.2",\n+        "Framework :: Plone :: Core",\n+        "Framework :: Zope2",\n+        "Framework :: Zope :: 4",\n+        "License :: OSI Approved :: GNU General Public License v2 (GPLv2)",\n+        "Operating System :: OS Independent",\n+        "Programming Language :: Python",\n+        "Programming Language :: Python :: 2.7",\n+        "Programming Language :: Python :: 3.6",\n+        "Programming Language :: Python :: 3.7",\n+        "Programming Language :: Python :: 3.8",\n     ],\n-    keywords=\'check-out check-in staging\',\n-    author=\'Plone Foundation\',\n-    author_email=\'plone-developers@lists.sourceforge.net\',\n-    url=\'https://pypi.org/project/plone.app.iterate\',\n-    license=\'GPL version 2\',\n+    keywords="check-out check-in staging",\n+    author="Plone Foundation",\n+    author_email="plone-developers@lists.sourceforge.net",\n+    url="https://pypi.org/project/plone.app.iterate",\n+    license="GPL version 2",\n     packages=find_packages(),\n-    namespace_packages=[\'plone\', \'plone.app\'],\n+    namespace_packages=["plone", "plone.app"],\n     include_package_data=True,\n     zip_safe=False,\n     install_requires=[\n-        \'Acquisition\',\n-        \'DateTime\',\n-        \'plone.locking\',\n-        \'plone.memoize\',\n-        \'Products.CMFCore\',\n-        \'Products.CMFEditions\',\n-        \'Products.CMFPlacefulWorkflow\',\n-        \'Products.DCWorkflow\',\n-        \'Products.GenericSetup>=1.8.2\',\n-        \'Products.statusmessages\',\n-        \'setuptools\',\n-        \'zope.annotation\',\n-        \'zope.component\',\n-        \'zope.event\',\n-        \'zope.i18nmessageid\',\n-        \'zope.interface\',\n-        \'zope.lifecycleevent\',\n-        \'zope.schema\',\n-        \'zope.viewlet\',\n+        "Acquisition",\n+        "DateTime",\n+        "plone.locking",\n+        "plone.memoize",\n+        "Products.CMFCore",\n+        "Products.CMFEditions",\n+        "Products.CMFPlacefulWorkflow",\n+        "Products.DCWorkflow",\n+        "Products.GenericSetup>=1.8.2",\n+        "Products.statusmessages",\n+        "setuptools",\n+        "zope.annotation",\n+        "zope.component",\n+        "zope.event",\n+        "zope.i18nmessageid",\n+        "zope.interface",\n+        "zope.lifecycleevent",\n+        "zope.schema",\n+        "zope.viewlet",\n     ],\n     extras_require={\n-        \'archetypes\': [\n-            \'Products.Archetypes\',\n+        "archetypes": [\n+            "Products.Archetypes",\n+        ],\n+        "test": [\n+            "plone.app.testing",\n+            "plone.app.contenttypes",\n+            "plone.app.robotframework",\n         ],\n-        \'test\': [\n-            \'plone.app.testing\',\n-            \'plone.app.contenttypes\',\n-            \'plone.app.robotframework\',\n-        ]\n     },\n     entry_points="""\n     [z3c.autoinclude.plugin]\n'

Repository: plone.app.iterate


Branch: refs/heads/master
Date: 2021-06-22T13:13:08+02:00
Author: Victor Fernandez de Alba (sneridagh) <sneridagh@gmail.com>
Commit: https://github.com/plone/plone.app.iterate/commit/656957d439f53d9d6f05668b964fe670a71cbaac

Finish tests, adjustments, fixes

Files changed:
A plone/app/iterate/profiles/testingdx/repositorytool.xml
A plone/app/iterate/profiles/testingdx/types.xml
A plone/app/iterate/profiles/testingdx/types/FolderishDocument.xml
A plone/app/iterate/tests/dxtypes.py
A plone/app/iterate/tests/test_containers.py
M plone/app/iterate/configure.zcml
M plone/app/iterate/dexterity/copier.py
M plone/app/iterate/testing.py

b'diff --git a/plone/app/iterate/configure.zcml b/plone/app/iterate/configure.zcml\nindex 4dde056..6b64a41 100644\n--- a/plone/app/iterate/configure.zcml\n+++ b/plone/app/iterate/configure.zcml\n@@ -56,6 +56,15 @@\n       provides="Products.GenericSetup.interfaces.EXTENSION"\n       />\n \n+  <genericsetup:registerProfile\n+      name="testingdx"\n+      title="plone.app.iterate: Test fixture for DX"\n+      directory="profiles/testingdx"\n+      description="Adds sample content types for testing"\n+      provides="Products.GenericSetup.interfaces.EXTENSION"\n+      for="Products.CMFPlone.interfaces.ITestCasePloneSiteRoot"\n+      />\n+\n   <genericsetup:registerProfile\n       name="uninstall"\n       title="Working Copy Support (Iterate) [uninstall]"\ndiff --git a/plone/app/iterate/dexterity/copier.py b/plone/app/iterate/dexterity/copier.py\nindex e9df313..472a8ff 100644\n--- a/plone/app/iterate/dexterity/copier.py\n+++ b/plone/app/iterate/dexterity/copier.py\n@@ -168,12 +168,9 @@ def checkin(self, checkin_message):\n \n \n class FolderishContentCopier(ContentCopier):\n-    """ """\n-\n     def _copyBaseline(self, container):\n-        source_container = aq_parent(aq_inner(self.context))\n         obj = createContentInContainer(\n-            source_container,\n+            container,\n             self.context.portal_type,\n             id="working_copy_of_{}".format(self.context.id),\n         )\n@@ -205,7 +202,7 @@ def _copyBaseline(self, container):\n         obj.reindexObject()\n \n         # copy annotations\n-        wc_annotations = IAnnotations(self.context)\n+        wc_annotations = IAnnotations(obj)\n         baseline_annotations = IAnnotations(self.context)\n \n         wc_annotations.update(baseline_annotations)\n@@ -213,13 +210,55 @@ def _copyBaseline(self, container):\n         if "plone.folder.ordered.order" in wc_annotations:\n             wc_annotations.pop("plone.folder.ordered.order")\n \n-        # clone workflow history, try avoid a dangling ref\n-        try:\n-            obj.workflow_history = PersistentMapping(\n-                self.context.workflow_history.items()\n-            )\n-        except AttributeError:\n-            # No workflow apparently.  Oh well.\n-            pass\n-\n         return obj\n+\n+    def _replaceBaseline(self, baseline):\n+        wc_id = self.context.getId()\n+        wc_container = aq_parent(self.context)\n+\n+        # copy all field values from the working copy to the baseline\n+        for schema in iterSchemata(baseline):\n+            for name, field in getFieldsInOrder(schema):\n+                # Skip read-only fields\n+                if field.readonly:\n+                    continue\n+                if field.__name__ == "id":\n+                    continue\n+                try:\n+                    value = field.get(schema(self.context))\n+                except Exception:\n+                    value = None\n+\n+                # TODO: We need a way to identify the DCFieldProperty\n+                # fields and use the appropriate set_name/get_name\n+                if name == "effective":\n+                    baseline.effective_date = self.context.effective()\n+                elif name == "expires":\n+                    baseline.expiration_date = self.context.expires()\n+                elif name == "subjects":\n+                    baseline.setSubject(self.context.Subject())\n+                else:\n+                    field.set(baseline, value)\n+\n+        baseline.reindexObject()\n+\n+        # Move working children (newly created objects)\n+        working_copy_children = [a for a in self.context.objectIds()]\n+\n+        clipboard = self.context.manage_cutObjects(working_copy_children)\n+        baseline.manage_pasteObjects(clipboard)\n+\n+        # copy back annotations\n+        wc_annotations = IAnnotations(self.context)\n+        baseline_annotations = IAnnotations(baseline)\n+\n+        # Remove plone.folder.ordered.order from it to not mess with the original\n+        if "plone.folder.ordered.order" in wc_annotations:\n+            wc_annotations.pop("plone.folder.ordered.order")\n+\n+        baseline_annotations.update(wc_annotations)\n+\n+        # delete the working copy\n+        wc_container._delObject(wc_id)\n+\n+        return baseline\ndiff --git a/plone/app/iterate/profiles/testingdx/repositorytool.xml b/plone/app/iterate/profiles/testingdx/repositorytool.xml\nnew file mode 100644\nindex 0000000..4da978c\n--- /dev/null\n+++ b/plone/app/iterate/profiles/testingdx/repositorytool.xml\n@@ -0,0 +1,9 @@\n+<?xml version="1.0"?>\n+<repositorytool>\n+    <policymap>\n+        <type name="FolderishDocument">\n+            <policy name="at_edit_autoversion"/>\n+            <policy name="version_on_revert"/>\n+        </type>\n+    </policymap>\n+</repositorytool>\ndiff --git a/plone/app/iterate/profiles/testingdx/types.xml b/plone/app/iterate/profiles/testingdx/types.xml\nnew file mode 100644\nindex 0000000..68faffd\n--- /dev/null\n+++ b/plone/app/iterate/profiles/testingdx/types.xml\n@@ -0,0 +1,6 @@\n+<?xml version="1.0"?>\n+<object name="portal_types" meta_type="Plone Types Tool">\n+\n+  <object name="FolderishDocument" meta_type="Dexterity FTI" />\n+\n+</object>\ndiff --git a/plone/app/iterate/profiles/testingdx/types/FolderishDocument.xml b/plone/app/iterate/profiles/testingdx/types/FolderishDocument.xml\nnew file mode 100644\nindex 0000000..17ed0f4\n--- /dev/null\n+++ b/plone/app/iterate/profiles/testingdx/types/FolderishDocument.xml\n@@ -0,0 +1,63 @@\n+<?xml version="1.0"?>\n+<object name="FolderishDocument"\n+   meta_type="Dexterity FTI"\n+   i18n:domain="plone" xmlns:i18n="http://xml.zope.org/namespaces/i18n">\n+\n+  <!-- Basic metadata -->\n+  <property name="title" i18n:translate="">DX Test Folderish Document</property>\n+  <property name="description"\n+    i18n:translate=""></property>\n+  <property name="icon_expr"></property>\n+  <property name="factory">FolderishDocument</property>\n+  <property name="add_view_expr">string:${folder_url}/++add++FolderishDocument</property>\n+  <property name="global_allow">True</property>\n+  <property name="filter_content_types">False</property>\n+  <property name="allowed_content_types"/>\n+  <property name="allow_discussion">False</property>\n+\n+  <!-- class used for content items -->\n+  <property name="klass">plone.app.iterate.tests.dxtypes.FolderishDocument</property>\n+  <property name="model_file">plone.app.contenttypes.schema:document.xml</property>\n+  <property name="model_source"></property>\n+  <property name="schema"></property>\n+\n+  <!-- Enabled behaviors -->\n+  <property name="behaviors" purge="false">\n+    <element value="plone.namefromtitle" />\n+    <element value="plone.allowdiscussion" />\n+    <element value="plone.excludefromnavigation" />\n+    <element value="plone.shortname" />\n+    <element value="plone.dublincore" />\n+    <element value="plone.richtext" />\n+    <element value="plone.relateditems" />\n+    <element value="plone.versioning" />\n+    <element value="plone.tableofcontents" />\n+    <element value="plone.locking" />\n+  </property>\n+\n+  <!-- View information -->\n+  <property name="link_target"></property>\n+  <property name="immediate_view">view</property>\n+  <property name="default_view">view</property>\n+  <property name="view_methods">\n+   <element value="view"/>\n+  </property>\n+  <property name="default_view_fallback">False</property>\n+  <property name="add_permission">cmf.AddPortalContent</property>\n+\n+  <!-- Method aliases -->\n+  <alias from="(Default)" to="(dynamic view)" />\n+  <alias from="view" to="(selected layout)" />\n+  <alias from="edit" to="@@edit" />\n+  <alias from="sharing" to="@@sharing" />\n+\n+  <!-- Actions -->\n+  <action title="View" action_id="view" category="object" condition_expr=""\n+    url_expr="string:${object_url}/" visible="True">\n+    <permission value="View" />\n+  </action>\n+  <action title="Edit" action_id="edit" category="object" condition_expr=""\n+    url_expr="string:${object_url}/edit" visible="True">\n+    <permission value="Modify portal content" />\n+  </action>\n+</object>\ndiff --git a/plone/app/iterate/testing.py b/plone/app/iterate/testing.py\nindex 0bb87e1..73c27fb 100644\n--- a/plone/app/iterate/testing.py\n+++ b/plone/app/iterate/testing.py\n@@ -145,6 +145,7 @@ def setUpPloneSite(self, portal):\n         """Setup Plone Site with Addons."""\n         super(DexPloneAppIterateLayer, self).setUpPloneSite(portal)\n         applyProfile(portal, "plone.app.iterate:default")\n+        applyProfile(portal, "plone.app.iterate:testingdx")\n         # with named AND dotted behaviors we need to take care of both\n         versioning_behavior = set(\n             [\ndiff --git a/plone/app/iterate/tests/dxtypes.py b/plone/app/iterate/tests/dxtypes.py\nnew file mode 100644\nindex 0000000..d354fa2\n--- /dev/null\n+++ b/plone/app/iterate/tests/dxtypes.py\n@@ -0,0 +1,16 @@\n+# -*- coding: utf-8 -*-\n+from plone.dexterity.content import Container\n+from plone.app.contenttypes.interfaces import IDocument\n+from zope.interface import Interface\n+from zope.interface import implementer\n+\n+\n+class IFolderishDocument(Interface):\n+    """Marker interface"""\n+\n+\n+@implementer(IDocument, IFolderishDocument)\n+class FolderishDocument(Container):\n+    """A Dexterity based test type containing a set of standard fields."""\n+\n+    pass\ndiff --git a/plone/app/iterate/tests/test_containers.py b/plone/app/iterate/tests/test_containers.py\nnew file mode 100644\nindex 0000000..107df77\n--- /dev/null\n+++ b/plone/app/iterate/tests/test_containers.py\n@@ -0,0 +1,311 @@\n+# -*- coding: utf-8 -*-\n+##################################################################\n+#\n+# (C) Copyright 2006 ObjectRealms, LLC\n+# All Rights Reserved\n+#\n+# This file is part of iterate.\n+#\n+# iterate is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 2 of the License, or\n+# (at your option) any later version.\n+#\n+# iterate is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with iterate; if not, write to the Free Software\n+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n+##################################################################\n+\n+from AccessControl import getSecurityManager\n+from plone.app.iterate.browser.control import Control\n+from plone.app.iterate.interfaces import ICheckinCheckoutPolicy\n+from plone.app.iterate.testing import PLONEAPPITERATEDEX_INTEGRATION_TESTING\n+from plone.app.testing import login\n+from plone.app.testing import setRoles\n+from plone.app.testing import TEST_USER_ID\n+from plone.app.testing import TEST_USER_NAME\n+from Products.CMFCore.utils import getToolByName\n+from zc.relation.interfaces import ICatalog\n+from zope.intid.interfaces import IIntIds\n+from zope import component\n+from plone.dexterity.utils import createContentInContainer\n+\n+import unittest\n+\n+\n+class TestIterations(unittest.TestCase):\n+\n+    layer = PLONEAPPITERATEDEX_INTEGRATION_TESTING\n+\n+    def setUp(self):\n+        self.portal = self.layer["portal"]\n+        setRoles(self.portal, TEST_USER_ID, ["Manager"])\n+        login(self.portal, TEST_USER_NAME)\n+\n+        self.wf = self.portal.portal_workflow\n+        self.wf.setChainForPortalTypes(\n+            ("FolderishDocument",), "simple_publication_workflow"\n+        )\n+\n+        # add a folder with two documents in it\n+        self.portal.invokeFactory("Folder", "docs")\n+        self.portal.docs.invokeFactory("FolderishDocument", "doc1")\n+        self.portal.docs.invokeFactory("FolderishDocument", "doc2")\n+\n+        # add a working copy folder\n+        self.portal.invokeFactory("Folder", "workarea")\n+\n+        self.repo = self.portal.portal_repository\n+\n+    def test_container_workflowState(self):\n+        # ensure baseline workflow state is retained on checkin, including\n+        # security\n+\n+        doc = self.portal.docs.doc1\n+\n+        # sanity check that owner can edit visible docs\n+        setRoles(self.portal, TEST_USER_ID, ["Owner"])\n+        self.assertTrue(\n+            getSecurityManager().checkPermission(\n+                "Modify portal content", self.portal.docs.doc1\n+            )\n+        )\n+\n+        setRoles(self.portal, TEST_USER_ID, ["Manager"])\n+        self.wf.doActionFor(doc, "publish")\n+        state = self.wf.getInfoFor(doc, "review_state")\n+\n+        self.repo.save(doc)\n+        wc = ICheckinCheckoutPolicy(doc).checkout(self.portal.workarea)\n+        wc_state = self.wf.getInfoFor(wc, "review_state")\n+\n+        self.assertNotEqual(state, wc_state)\n+\n+        baseline = ICheckinCheckoutPolicy(wc).checkin("modified")\n+        bstate = self.wf.getInfoFor(baseline, "review_state")\n+        self.assertEqual(bstate, "published")\n+\n+        self.assertEquals(len(self.portal.workarea.objectIds()), 0)\n+        setRoles(self.portal, TEST_USER_ID, ["Owner"])\n+\n+    def test_container_baselineCreated(self):\n+        # if a baseline has no version ensure that one is created on checkout\n+        doc = self.portal.docs.doc1\n+        self.assertTrue(self.repo.isVersionable(doc))\n+\n+        wc = ICheckinCheckoutPolicy(doc).checkout(self.portal.workarea)\n+\n+        self.assertEquals(wc.id, "working_copy_of_doc1")\n+        self.assertIn("working_copy_of_doc1", self.portal.workarea.objectIds())\n+\n+    def test_container_folderOrder(self):\n+        """When an item is checked out and then back in, the original\n+        folder order is preserved."""\n+        container = self.portal.docs\n+        doc = container.doc1\n+        original_position = container.getObjectPosition(doc.getId())\n+\n+        # check that there is another document which could interact with\n+        # position of document the test work on\n+        doc2_position = container.getObjectPosition("doc2")\n+        self.assertTrue(doc2_position > original_position)\n+\n+        self.repo.save(doc)\n+        wc = ICheckinCheckoutPolicy(doc).checkout(container)\n+        wc.text = "new document text"\n+\n+        # check that the copy is put after the second document\n+        copy_position = container.getObjectPosition(wc.getId())\n+        self.assertTrue(copy_position > doc2_position)\n+\n+        new_doc = ICheckinCheckoutPolicy(wc).checkin("updated")\n+        new_position = container.getObjectPosition(new_doc.getId())\n+        self.assertEqual(new_position, original_position)\n+\n+    def test_container_contents(self):\n+        """When an folderish content is checked out, and item is added, and then\n+        the content is checked back in, if resources (images or files) are added item is in the new\n+        version of the folder they are moved to the baseline container.  UIDs of contained content are also\n+        preserved."""\n+        container = self.portal.docs\n+        doc = container.doc1\n+\n+        wc = ICheckinCheckoutPolicy(doc).checkout(container)\n+        self.repo.save(wc)\n+        image = createContentInContainer(\n+            wc,\n+            "Image",\n+            id="an-image",\n+        )\n+        another_doc = createContentInContainer(\n+            wc,\n+            "FolderishDocument",\n+            id="document",\n+        )\n+        just_another_nested_doc = createContentInContainer(\n+            another_doc,\n+            "FolderishDocument",\n+            id="just_another_doc",\n+        )\n+        image_uid = image.UID()\n+        another_doc_uid = another_doc.UID()\n+        just_another_nested_doc_uid = just_another_nested_doc.UID()\n+\n+        baseline = ICheckinCheckoutPolicy(wc).checkin("updated")\n+\n+        self.assertTrue("an-image" in baseline)\n+        self.assertTrue("document" in baseline)\n+        self.assertTrue("just_another_doc" in baseline["document"])\n+        self.assertEqual(baseline["an-image"].UID(), image_uid)\n+        self.assertEqual(baseline["document"].UID(), another_doc_uid)\n+        self.assertEqual(\n+            baseline["document"]["just_another_doc"].UID(), just_another_nested_doc_uid\n+        )\n+\n+    def test_container_contents_with_collisions(self):\n+        """When an folderish content is checked out, and item is added, and then\n+        the content is checked back in, if resources (images or files) are added item is in the new\n+        version of the folder they are moved to the baseline container.  UIDs of contained content are also\n+        preserved and collisions handled by Zope cut/paste machinery."""\n+        container = self.portal.docs\n+        baseline = container.doc1\n+        baseline_image = createContentInContainer(\n+            baseline,\n+            "Image",\n+            id="an-image",\n+        )\n+        self.repo.save(baseline)\n+        baseline_image_uid = baseline_image.UID()\n+\n+        wc = ICheckinCheckoutPolicy(baseline).checkout(container)\n+        self.repo.save(wc)\n+        image = createContentInContainer(\n+            wc,\n+            "Image",\n+            id="an-image",\n+        )\n+        image_uid = image.UID()\n+\n+        baseline = ICheckinCheckoutPolicy(wc).checkin("updated")\n+\n+        self.assertTrue("copy_of_an-image" in baseline)\n+        self.assertTrue("an-image" in baseline)\n+        self.assertEqual(baseline["an-image"].UID(), baseline_image_uid)\n+        self.assertEqual(baseline["copy_of_an-image"].UID(), image_uid)\n+\n+    def test_container_default_page_is_kept_in_folder(self):\n+        # Ensure that a default page that is checked out and back in is still\n+        # the default page.\n+        folder = self.portal.docs\n+        doc = folder.doc1\n+        from Products.CMFDynamicViewFTI.interfaces import (\n+            ISelectableBrowserDefault,\n+        )  # noqa: C901\n+\n+        ISelectableBrowserDefault(folder).setDefaultPage("doc1")\n+        self.assertEqual(folder.getProperty("default_page", ""), "doc1")\n+        self.assertEqual(folder.getDefaultPage(), "doc1")\n+        # Note: when checking out to self.portal.workarea it surprisingly works\n+        # without changes.  But the default behavior in Plone is to check a\n+        # document out in its original folder, so that is what we check here.\n+        wc = ICheckinCheckoutPolicy(doc).checkout(folder)\n+        doc = ICheckinCheckoutPolicy(wc).checkin("updated")\n+        self.assertEqual(folder.getProperty("default_page", ""), "doc1")\n+        self.assertEqual(folder.getDefaultPage(), "doc1")\n+\n+    def test_container_control_checkin_allowed_with_no_policy(self):\n+        control = Control(self.portal, self.layer["request"])\n+        self.assertFalse(control.checkin_allowed())\n+\n+    def test_container_control_checkout_allowed_with_no_policy(self):\n+        control = Control(self.portal, self.layer["request"])\n+        self.assertFalse(control.checkout_allowed())\n+\n+    def test_container_control_cancel_allowed_with_no_policy(self):\n+        control = Control(self.portal, self.layer["request"])\n+        self.assertFalse(control.cancel_allowed())\n+\n+    def test_container_control_cancel_on_original_does_not_delete_original(self):\n+        # checkout document\n+        doc = self.portal.docs.doc1\n+        policy = ICheckinCheckoutPolicy(self.portal.docs.doc1, None)\n+        policy.checkout(self.portal.workarea)\n+\n+        # get cancel browser view\n+        from plone.app.iterate.browser.cancel import Cancel\n+\n+        cancel = Cancel(doc, self.layer["request"])\n+        self.layer["request"].form["form.button.Cancel"] = True\n+\n+        # check if cancel on original raises the correct exception\n+        from plone.app.iterate.interfaces import CheckoutException\n+\n+        with self.assertRaises(CheckoutException):\n+            cancel()\n+\n+    def test_container_relationship_deleted_on_checkin(self):\n+        # Ensure that the relationship between the baseline and the wc is\n+        # removed when the working copy is checked in\n+        folder = self.portal.docs\n+        doc = folder.doc1\n+\n+        intids = component.getUtility(IIntIds)\n+        catalog = component.getUtility(ICatalog)\n+        obj_id = intids.getId(doc)\n+        rels = list(catalog.findRelations({"from_id": obj_id}))\n+        self.assertEqual(len(rels), 0)\n+\n+        wc = ICheckinCheckoutPolicy(doc).checkout(folder)\n+        wc_id = intids.getId(wc)\n+\n+        rels = list(catalog.findRelations({"from_id": obj_id}))\n+        self.assertEqual(len(rels), 1)\n+        from_rel = rels[0]\n+\n+        rels = list(catalog.findRelations({"to_id": wc_id}))\n+        self.assertEqual(len(rels), 1)\n+        to_rel = rels[0]\n+\n+        self.assertEqual(from_rel, to_rel)\n+\n+        doc = ICheckinCheckoutPolicy(wc).checkin("updated")\n+\n+        rels = list(catalog.findRelations({"from_id": obj_id}))\n+\n+        self.assertEqual(len(rels), 0)\n+\n+    def test_relationship_deleted_on_cancel_checkout(self):\n+        # Ensure that the relationship between the baseline and the wc is\n+        # removed when the working copy is checked in\n+        folder = self.portal.docs\n+        doc = folder.doc1\n+\n+        intids = component.getUtility(IIntIds)\n+        catalog = component.getUtility(ICatalog)\n+        obj_id = intids.getId(doc)\n+        rels = list(catalog.findRelations({"from_id": obj_id}))\n+        self.assertEqual(len(rels), 0)\n+\n+        wc = ICheckinCheckoutPolicy(doc).checkout(folder)\n+        wc_id = intids.getId(wc)\n+\n+        rels = list(catalog.findRelations({"from_id": obj_id}))\n+        self.assertEqual(len(rels), 1)\n+        from_rel = rels[0]\n+\n+        rels = list(catalog.findRelations({"to_id": wc_id}))\n+        self.assertEqual(len(rels), 1)\n+        to_rel = rels[0]\n+\n+        self.assertEqual(from_rel, to_rel)\n+\n+        ICheckinCheckoutPolicy(wc).cancelCheckout()\n+\n+        rels = list(catalog.findRelations({"from_id": obj_id}))\n+\n+        self.assertEqual(len(rels), 0)\n'

Repository: plone.app.iterate


Branch: refs/heads/master
Date: 2021-06-22T13:16:32+02:00
Author: Victor Fernandez de Alba (sneridagh) <sneridagh@gmail.com>
Commit: https://github.com/plone/plone.app.iterate/commit/ba0a5bb373e4442a80e2cc724667972b17f00bf3

Merge branch 'master' into plone6

* master:
  Back to development: 3.3.17
  Preparing release 3.3.16
  chore: add changes message
  chore: black and flake8
  chore: remove debug comment
  fix: update relations on Check-In fix #89

Files changed:
A news/89.bugfix
M CHANGES.rst
M plone/app/iterate/dexterity/policy.py
M plone/app/iterate/tests/test_iterate.py
M setup.py

b'diff --git a/CHANGES.rst b/CHANGES.rst\nindex f6ff17b..edad449 100644\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -8,6 +8,20 @@ Changelog\n \n .. towncrier release notes start\n \n+3.3.16 (2021-06-14)\n+-------------------\n+\n+Bug fixes:\n+\n+\n+- Do not break if some custom code provides an alias for Products.Archetypes (#85)\n+- Black and pep8 compliance\n+  [sneridagh] (#88)\n+- Update relations on Check-In WorkingCopy, by trigger an ObjectModifiedEvent event\n+  black and flake8 formatting\n+  [2silver] (#89)\n+\n+\n 3.3.15 (2020-09-07)\n -------------------\n \ndiff --git a/news/89.bugfix b/news/89.bugfix\nnew file mode 100644\nindex 0000000..e3b60ea\n--- /dev/null\n+++ b/news/89.bugfix\n@@ -0,0 +1,3 @@\n+Update relations on Check-In WorkingCopy, by trigger an ObjectModifiedEvent event\n+black and flake8 formatting\n+[2silver]\ndiff --git a/plone/app/iterate/dexterity/policy.py b/plone/app/iterate/dexterity/policy.py\nindex f88c69c..e90911c 100644\n--- a/plone/app/iterate/dexterity/policy.py\n+++ b/plone/app/iterate/dexterity/policy.py\n@@ -13,6 +13,7 @@\n from zope.component import adapter\n from zope.component import queryAdapter\n from zope.event import notify\n+from zope.lifecycleevent import ObjectModifiedEvent\n \n \n @adapter(IDexterityIterateAware)\n@@ -34,6 +35,10 @@ def checkin(self, checkin_message):\n         new_baseline = copier.merge()\n         # don\'t need to unlock the lock disappears with old baseline deletion\n         notify(AfterCheckinEvent(new_baseline, checkin_message))\n+\n+        # update our new_baseline, ex. for all References ( and BackReferences)\n+        notify(ObjectModifiedEvent(new_baseline))\n+\n         return new_baseline\n \n     def _get_relation_to_baseline(self):\ndiff --git a/plone/app/iterate/tests/test_iterate.py b/plone/app/iterate/tests/test_iterate.py\nindex 8fcf288..9739f6a 100644\n--- a/plone/app/iterate/tests/test_iterate.py\n+++ b/plone/app/iterate/tests/test_iterate.py\n@@ -142,9 +142,13 @@ def test_folderContents(self):\n         version of the folder.  UIDs of contained content are also\n         preserved."""\n         container = self.portal.docs\n-        folder = container[container.invokeFactory(type_name="Folder", id="foo-folder")]\n+        folder = container[\n+            container.invokeFactory(type_name="Folder", id="foo-folder")\n+        ]\n         existing_doc = folder[\n-            folder.invokeFactory(type_name="Document", id="existing-folder-item")\n+            folder.invokeFactory(\n+                type_name="Document", id="existing-folder-item"\n+            )\n         ]\n         existing_doc_uid = existing_doc.UID()\n \n@@ -152,7 +156,9 @@ def test_folderContents(self):\n         wc = ICheckinCheckoutPolicy(folder).checkout(container)\n         new_doc = wc[\n             wc.invokeFactory(\n-                type_name="Document", id="new-folder-item", text="new folder item text"\n+                type_name="Document",\n+                id="new-folder-item",\n+                text="new folder item text",\n             )\n         ]\n         new_doc_uid = new_doc.UID()\n@@ -161,10 +167,14 @@ def test_folderContents(self):\n         catalog = getToolByName(self.portal, "portal_catalog")\n \n         self.assertTrue("existing-folder-item" in new_folder)\n-        self.assertEqual(new_folder["existing-folder-item"].UID(), existing_doc_uid)\n+        self.assertEqual(\n+            new_folder["existing-folder-item"].UID(), existing_doc_uid\n+        )\n         self.assertTrue("new-folder-item" in new_folder)\n         self.assertEqual(new_folder["new-folder-item"].UID(), new_doc_uid)\n-        brains = catalog(path="/".join(new_folder["new-folder-item"].getPhysicalPath()))\n+        brains = catalog(\n+            path="/".join(new_folder["new-folder-item"].getPhysicalPath())\n+        )\n         self.assertTrue(brains)\n         self.assertTrue(\n             "new folder item text" in new_folder["new-folder-item"].getText()\n@@ -281,3 +291,51 @@ def test_relationship_deleted_on_cancel_checkout(self):\n         rels = list(catalog.findRelations({"from_id": obj_id}))\n \n         self.assertEqual(len(rels), 0)\n+\n+    def test_baseline_relations_updated_on_checkin(self):\n+        # Ensure that relations between the baseline and\n+        # and other objects are up-to-date on checkin\n+        from zope.event import notify\n+        from zope.lifecycleevent import ObjectModifiedEvent\n+        from z3c.relationfield import RelationValue\n+\n+        folder = self.portal.docs\n+        baseline = folder.doc1\n+        target = folder.doc2\n+\n+        intids = component.getUtility(IIntIds)\n+        catalog = component.getUtility(ICatalog)\n+\n+        target_id = intids.getId(target)\n+        target_rel = [RelationValue(target_id)]\n+\n+        # Test, if nothing is present in the relation catalog\n+        rels = list(catalog.findRelations({"to_id": target_id}))\n+        self.assertEqual(len(rels), 0)\n+\n+        # set relatedItems on baseline\n+        baseline.relatedItems = target_rel\n+        notify(ObjectModifiedEvent(baseline))\n+\n+        # Test, if relation is present in the relation catalog\n+        rels = list(catalog.findRelations({"to_id": target_id}))\n+        self.assertEqual(len(rels), 1)\n+\n+        # make a workingcopy from baseline\n+        wc = ICheckinCheckoutPolicy(baseline).checkout(folder)\n+\n+        # remove relations on wc\n+        wc.relatedItems = []\n+        notify(ObjectModifiedEvent(wc))\n+\n+        # baseline -> target relation should be still there, we are on wc\n+        rels = list(catalog.findRelations({"to_id": target_id}))\n+        self.assertEqual(len(rels), 1)\n+\n+        # baseline -> target relation should be empty now\n+        # because we replaced our baseline with our wc (with empty relations)\n+        baseline = ICheckinCheckoutPolicy(wc).checkin("updated")\n+        rels = list(catalog.findRelations({"to_id": target_id}))\n+\n+        # new baseline\'s relatedItems should be empty\n+        self.assertEqual(len(rels), 0)\ndiff --git a/setup.py b/setup.py\nindex c68835b..cb5c848 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -7,7 +7,7 @@\n \n setup(\n     name="plone.app.iterate",\n-    version="3.3.16.dev0",\n+    version="3.3.17.dev0",\n     description="check-out/check-in staging for Plone",\n     long_description=LONG_DESCRIPTION,\n     classifiers=[\n'

Repository: plone.app.iterate


Branch: refs/heads/master
Date: 2021-06-22T13:19:39+02:00
Author: Victor Fernandez de Alba (sneridagh) <sneridagh@gmail.com>
Commit: https://github.com/plone/plone.app.iterate/commit/c5e0de5cd532e28a6eed1b911bbf36cf71e4d410

Changelog

Files changed:
A news/92.feature

b'diff --git a/news/92.feature b/news/92.feature\nnew file mode 100644\nindex 0000000..a7b7b4d\n--- /dev/null\n+++ b/news/92.feature\n@@ -0,0 +1,2 @@\n+Add proper support for DX folderish content\n+[sneridagh]\n'

Repository: plone.app.iterate


Branch: refs/heads/master
Date: 2021-06-22T13:39:04+02:00
Author: Victor Fernandez de Alba (sneridagh) <sneridagh@gmail.com>
Commit: https://github.com/plone/plone.app.iterate/commit/64ecdbbb01714ecf0745ca9af95b0029f2bb8cd3

Remove skipped tests (since they are already in the test_containers, fix flake8

Files changed:
M plone/app/iterate/tests/test_containers.py
M plone/app/iterate/tests/test_iterate.py

b'diff --git a/plone/app/iterate/tests/test_containers.py b/plone/app/iterate/tests/test_containers.py\nindex 107df77..12ad18c 100644\n--- a/plone/app/iterate/tests/test_containers.py\n+++ b/plone/app/iterate/tests/test_containers.py\n@@ -29,7 +29,6 @@\n from plone.app.testing import setRoles\n from plone.app.testing import TEST_USER_ID\n from plone.app.testing import TEST_USER_NAME\n-from Products.CMFCore.utils import getToolByName\n from zc.relation.interfaces import ICatalog\n from zope.intid.interfaces import IIntIds\n from zope import component\ndiff --git a/plone/app/iterate/tests/test_iterate.py b/plone/app/iterate/tests/test_iterate.py\nindex 9739f6a..f838f13 100644\n--- a/plone/app/iterate/tests/test_iterate.py\n+++ b/plone/app/iterate/tests/test_iterate.py\n@@ -21,7 +21,6 @@\n # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n ##################################################################\n \n-from AccessControl import getSecurityManager\n from plone.app.iterate.browser.control import Control\n from plone.app.iterate.interfaces import ICheckinCheckoutPolicy\n from plone.app.iterate.testing import PLONEAPPITERATEDEX_INTEGRATION_TESTING\n@@ -29,7 +28,6 @@\n from plone.app.testing import setRoles\n from plone.app.testing import TEST_USER_ID\n from plone.app.testing import TEST_USER_NAME\n-from Products.CMFCore.utils import getToolByName\n from zc.relation.interfaces import ICatalog\n from zope.intid.interfaces import IIntIds\n from zope import component\n@@ -59,36 +57,6 @@ def setUp(self):\n \n         self.repo = self.portal.portal_repository\n \n-    @unittest.skip("This test needs to be fixed for Dexterity content.")\n-    def test_workflowState(self):\n-        # ensure baseline workflow state is retained on checkin, including\n-        # security\n-\n-        doc = self.portal.docs.doc1\n-\n-        # sanity check that owner can edit visible docs\n-        setRoles(self.portal, TEST_USER_ID, ["Owner"])\n-        self.assertTrue(\n-            getSecurityManager().checkPermission(\n-                "Modify portal content", self.portal.docs.doc1\n-            )\n-        )\n-\n-        setRoles(self.portal, TEST_USER_ID, ["Manager"])\n-        self.wf.doActionFor(doc, "publish")\n-        state = self.wf.getInfoFor(doc, "review_state")\n-\n-        self.repo.save(doc)\n-        wc = ICheckinCheckoutPolicy(doc).checkout(self.portal.workarea)\n-        wc_state = self.wf.getInfoFor(wc, "review_state")\n-\n-        self.assertNotEqual(state, wc_state)\n-\n-        ICheckinCheckoutPolicy(wc).checkin("modified")\n-        bstate = self.wf.getInfoFor(wc, "review_state")\n-        self.assertEqual(state, bstate)\n-        setRoles(self.portal, TEST_USER_ID, ["Owner"])\n-\n     def test_baselineVersionCreated(self):\n         # if a baseline has no version ensure that one is created on checkout\n \n@@ -135,51 +103,6 @@ def test_folderOrder(self):\n         new_position = container.getObjectPosition(new_doc.getId())\n         self.assertEqual(new_position, original_position)\n \n-    @unittest.skip("This test needs to be fixed for Dexterity content.")\n-    def test_folderContents(self):\n-        """When an folder is checked out, and item is added, and then\n-        the folder is checked back in, the added item is in the new\n-        version of the folder.  UIDs of contained content are also\n-        preserved."""\n-        container = self.portal.docs\n-        folder = container[\n-            container.invokeFactory(type_name="Folder", id="foo-folder")\n-        ]\n-        existing_doc = folder[\n-            folder.invokeFactory(\n-                type_name="Document", id="existing-folder-item"\n-            )\n-        ]\n-        existing_doc_uid = existing_doc.UID()\n-\n-        self.repo.save(folder)\n-        wc = ICheckinCheckoutPolicy(folder).checkout(container)\n-        new_doc = wc[\n-            wc.invokeFactory(\n-                type_name="Document",\n-                id="new-folder-item",\n-                text="new folder item text",\n-            )\n-        ]\n-        new_doc_uid = new_doc.UID()\n-        new_folder = ICheckinCheckoutPolicy(wc).checkin("updated")\n-\n-        catalog = getToolByName(self.portal, "portal_catalog")\n-\n-        self.assertTrue("existing-folder-item" in new_folder)\n-        self.assertEqual(\n-            new_folder["existing-folder-item"].UID(), existing_doc_uid\n-        )\n-        self.assertTrue("new-folder-item" in new_folder)\n-        self.assertEqual(new_folder["new-folder-item"].UID(), new_doc_uid)\n-        brains = catalog(\n-            path="/".join(new_folder["new-folder-item"].getPhysicalPath())\n-        )\n-        self.assertTrue(brains)\n-        self.assertTrue(\n-            "new folder item text" in new_folder["new-folder-item"].getText()\n-        )\n-\n     def test_default_page_is_kept_in_folder(self):\n         # Ensure that a default page that is checked out and back in is still\n         # the default page.\n'

Repository: plone.app.iterate


Branch: refs/heads/master
Date: 2021-06-25T22:27:00+02:00
Author: Timo Stollenwerk (tisto) <tisto@users.noreply.github.com>
Commit: https://github.com/plone/plone.app.iterate/commit/5568b0d47770fa13a0969dfed434a23275bf9472

Merge pull request #84 from plone/plone6

Support for folderish objects

Files changed:
A news/92.feature
A plone/app/iterate/profiles/testingdx/repositorytool.xml
A plone/app/iterate/profiles/testingdx/types.xml
A plone/app/iterate/profiles/testingdx/types/FolderishDocument.xml
A plone/app/iterate/tests/dxtypes.py
A plone/app/iterate/tests/test_containers.py
M plone/app/iterate/configure.zcml
M plone/app/iterate/dexterity/configure.zcml
M plone/app/iterate/dexterity/copier.py
M plone/app/iterate/testing.py
M plone/app/iterate/tests/test_iterate.py

b'diff --git a/news/92.feature b/news/92.feature\nnew file mode 100644\nindex 0000000..a7b7b4d\n--- /dev/null\n+++ b/news/92.feature\n@@ -0,0 +1,2 @@\n+Add proper support for DX folderish content\n+[sneridagh]\ndiff --git a/plone/app/iterate/configure.zcml b/plone/app/iterate/configure.zcml\nindex 4dde056..6b64a41 100644\n--- a/plone/app/iterate/configure.zcml\n+++ b/plone/app/iterate/configure.zcml\n@@ -56,6 +56,15 @@\n       provides="Products.GenericSetup.interfaces.EXTENSION"\n       />\n \n+  <genericsetup:registerProfile\n+      name="testingdx"\n+      title="plone.app.iterate: Test fixture for DX"\n+      directory="profiles/testingdx"\n+      description="Adds sample content types for testing"\n+      provides="Products.GenericSetup.interfaces.EXTENSION"\n+      for="Products.CMFPlone.interfaces.ITestCasePloneSiteRoot"\n+      />\n+\n   <genericsetup:registerProfile\n       name="uninstall"\n       title="Working Copy Support (Iterate) [uninstall]"\ndiff --git a/plone/app/iterate/dexterity/configure.zcml b/plone/app/iterate/dexterity/configure.zcml\nindex 7351a01..42ddbe0 100644\n--- a/plone/app/iterate/dexterity/configure.zcml\n+++ b/plone/app/iterate/dexterity/configure.zcml\n@@ -14,6 +14,11 @@\n        factory=".copier.ContentCopier"\n        />\n \n+    <adapter\n+       for="plone.dexterity.interfaces.IDexterityContainer"\n+       factory=".copier.FolderishContentCopier"\n+       />\n+\n     <adapter\n        for=".interfaces.IDexterityIterateAware"\n        factory=".policy.CheckinCheckoutPolicyAdapter"\ndiff --git a/plone/app/iterate/dexterity/copier.py b/plone/app/iterate/dexterity/copier.py\nindex 622d250..472a8ff 100644\n--- a/plone/app/iterate/dexterity/copier.py\n+++ b/plone/app/iterate/dexterity/copier.py\n@@ -17,6 +17,7 @@\n from zope.event import notify\n from zope.intid.interfaces import IIntIds\n from zope.schema import getFieldsInOrder\n+from plone.dexterity.utils import createContentInContainer\n \n \n class ContentCopier(BaseContentCopier):\n@@ -80,7 +81,13 @@ def _replaceBaseline(self, baseline):\n         wc_annotations = IAnnotations(self.context)\n         baseline_annotations = IAnnotations(baseline)\n \n-        baseline_annotations.clear()\n+        # The next one is just wrong\n+        # baseline_annotations.clear()\n+\n+        # Remove plone.folder.ordered.order from it to not mess with the original\n+        if "plone.folder.ordered.order" in wc_annotations:\n+            wc_annotations.pop("plone.folder.ordered.order")\n+\n         baseline_annotations.update(wc_annotations)\n \n         # delete the working copy\n@@ -158,3 +165,100 @@ def checkin(self, checkin_message):\n         # don\'t need to unlock the lock disappears with old baseline deletion\n         notify(AfterCheckinEvent(new_baseline, checkin_message))\n         return new_baseline\n+\n+\n+class FolderishContentCopier(ContentCopier):\n+    def _copyBaseline(self, container):\n+        obj = createContentInContainer(\n+            container,\n+            self.context.portal_type,\n+            id="working_copy_of_{}".format(self.context.id),\n+        )\n+\n+        # copy all field values from the baseline to the working copy\n+        for schema in iterSchemata(self.context):\n+            for name, field in getFieldsInOrder(schema):\n+                # Skip read-only fields\n+                if field.readonly:\n+                    continue\n+                if field.__name__ == "id":\n+                    continue\n+                try:\n+                    value = field.get(schema(self.context))\n+                except Exception:\n+                    value = None\n+\n+                # TODO: We need a way to identify the DCFieldProperty\n+                # fields and use the appropriate set_name/get_name\n+                if name == "effective":\n+                    obj.effective_date = self.context.effective()\n+                elif name == "expires":\n+                    obj.expiration_date = self.context.expires()\n+                elif name == "subjects":\n+                    obj.setSubject(self.context.Subject())\n+                else:\n+                    field.set(obj, value)\n+\n+        obj.reindexObject()\n+\n+        # copy annotations\n+        wc_annotations = IAnnotations(obj)\n+        baseline_annotations = IAnnotations(self.context)\n+\n+        wc_annotations.update(baseline_annotations)\n+        # Remove plone.folder.order from it to not spoil the wc\n+        if "plone.folder.ordered.order" in wc_annotations:\n+            wc_annotations.pop("plone.folder.ordered.order")\n+\n+        return obj\n+\n+    def _replaceBaseline(self, baseline):\n+        wc_id = self.context.getId()\n+        wc_container = aq_parent(self.context)\n+\n+        # copy all field values from the working copy to the baseline\n+        for schema in iterSchemata(baseline):\n+            for name, field in getFieldsInOrder(schema):\n+                # Skip read-only fields\n+                if field.readonly:\n+                    continue\n+                if field.__name__ == "id":\n+                    continue\n+                try:\n+                    value = field.get(schema(self.context))\n+                except Exception:\n+                    value = None\n+\n+                # TODO: We need a way to identify the DCFieldProperty\n+                # fields and use the appropriate set_name/get_name\n+                if name == "effective":\n+                    baseline.effective_date = self.context.effective()\n+                elif name == "expires":\n+                    baseline.expiration_date = self.context.expires()\n+                elif name == "subjects":\n+                    baseline.setSubject(self.context.Subject())\n+                else:\n+                    field.set(baseline, value)\n+\n+        baseline.reindexObject()\n+\n+        # Move working children (newly created objects)\n+        working_copy_children = [a for a in self.context.objectIds()]\n+\n+        clipboard = self.context.manage_cutObjects(working_copy_children)\n+        baseline.manage_pasteObjects(clipboard)\n+\n+        # copy back annotations\n+        wc_annotations = IAnnotations(self.context)\n+        baseline_annotations = IAnnotations(baseline)\n+\n+        # Remove plone.folder.ordered.order from it to not mess with the original\n+        if "plone.folder.ordered.order" in wc_annotations:\n+            wc_annotations.pop("plone.folder.ordered.order")\n+\n+        baseline_annotations.update(wc_annotations)\n+\n+        # delete the working copy\n+        wc_container._delObject(wc_id)\n+\n+        return baseline\ndiff --git a/plone/app/iterate/profiles/testingdx/repositorytool.xml b/plone/app/iterate/profiles/testingdx/repositorytool.xml\nnew file mode 100644\nindex 0000000..4da978c\n--- /dev/null\n+++ b/plone/app/iterate/profiles/testingdx/repositorytool.xml\n@@ -0,0 +1,9 @@\n+<?xml version="1.0"?>\n+<repositorytool>\n+    <policymap>\n+        <type name="FolderishDocument">\n+            <policy name="at_edit_autoversion"/>\n+            <policy name="version_on_revert"/>\n+        </type>\n+    </policymap>\n+</repositorytool>\ndiff --git a/plone/app/iterate/profiles/testingdx/types.xml b/plone/app/iterate/profiles/testingdx/types.xml\nnew file mode 100644\nindex 0000000..68faffd\n--- /dev/null\n+++ b/plone/app/iterate/profiles/testingdx/types.xml\n@@ -0,0 +1,6 @@\n+<?xml version="1.0"?>\n+<object name="portal_types" meta_type="Plone Types Tool">\n+\n+  <object name="FolderishDocument" meta_type="Dexterity FTI" />\n+\n+</object>\ndiff --git a/plone/app/iterate/profiles/testingdx/types/FolderishDocument.xml b/plone/app/iterate/profiles/testingdx/types/FolderishDocument.xml\nnew file mode 100644\nindex 0000000..17ed0f4\n--- /dev/null\n+++ b/plone/app/iterate/profiles/testingdx/types/FolderishDocument.xml\n@@ -0,0 +1,63 @@\n+<?xml version="1.0"?>\n+<object name="FolderishDocument"\n+   meta_type="Dexterity FTI"\n+   i18n:domain="plone" xmlns:i18n="http://xml.zope.org/namespaces/i18n">\n+\n+  <!-- Basic metadata -->\n+  <property name="title" i18n:translate="">DX Test Folderish Document</property>\n+  <property name="description"\n+    i18n:translate=""></property>\n+  <property name="icon_expr"></property>\n+  <property name="factory">FolderishDocument</property>\n+  <property name="add_view_expr">string:${folder_url}/++add++FolderishDocument</property>\n+  <property name="global_allow">True</property>\n+  <property name="filter_content_types">False</property>\n+  <property name="allowed_content_types"/>\n+  <property name="allow_discussion">False</property>\n+\n+  <!-- class used for content items -->\n+  <property name="klass">plone.app.iterate.tests.dxtypes.FolderishDocument</property>\n+  <property name="model_file">plone.app.contenttypes.schema:document.xml</property>\n+  <property name="model_source"></property>\n+  <property name="schema"></property>\n+\n+  <!-- Enabled behaviors -->\n+  <property name="behaviors" purge="false">\n+    <element value="plone.namefromtitle" />\n+    <element value="plone.allowdiscussion" />\n+    <element value="plone.excludefromnavigation" />\n+    <element value="plone.shortname" />\n+    <element value="plone.dublincore" />\n+    <element value="plone.richtext" />\n+    <element value="plone.relateditems" />\n+    <element value="plone.versioning" />\n+    <element value="plone.tableofcontents" />\n+    <element value="plone.locking" />\n+  </property>\n+\n+  <!-- View information -->\n+  <property name="link_target"></property>\n+  <property name="immediate_view">view</property>\n+  <property name="default_view">view</property>\n+  <property name="view_methods">\n+   <element value="view"/>\n+  </property>\n+  <property name="default_view_fallback">False</property>\n+  <property name="add_permission">cmf.AddPortalContent</property>\n+\n+  <!-- Method aliases -->\n+  <alias from="(Default)" to="(dynamic view)" />\n+  <alias from="view" to="(selected layout)" />\n+  <alias from="edit" to="@@edit" />\n+  <alias from="sharing" to="@@sharing" />\n+\n+  <!-- Actions -->\n+  <action title="View" action_id="view" category="object" condition_expr=""\n+    url_expr="string:${object_url}/" visible="True">\n+    <permission value="View" />\n+  </action>\n+  <action title="Edit" action_id="edit" category="object" condition_expr=""\n+    url_expr="string:${object_url}/edit" visible="True">\n+    <permission value="Modify portal content" />\n+  </action>\n+</object>\ndiff --git a/plone/app/iterate/testing.py b/plone/app/iterate/testing.py\nindex 0bb87e1..73c27fb 100644\n--- a/plone/app/iterate/testing.py\n+++ b/plone/app/iterate/testing.py\n@@ -145,6 +145,7 @@ def setUpPloneSite(self, portal):\n         """Setup Plone Site with Addons."""\n         super(DexPloneAppIterateLayer, self).setUpPloneSite(portal)\n         applyProfile(portal, "plone.app.iterate:default")\n+        applyProfile(portal, "plone.app.iterate:testingdx")\n         # with named AND dotted behaviors we need to take care of both\n         versioning_behavior = set(\n             [\ndiff --git a/plone/app/iterate/tests/dxtypes.py b/plone/app/iterate/tests/dxtypes.py\nnew file mode 100644\nindex 0000000..d354fa2\n--- /dev/null\n+++ b/plone/app/iterate/tests/dxtypes.py\n@@ -0,0 +1,16 @@\n+# -*- coding: utf-8 -*-\n+from plone.dexterity.content import Container\n+from plone.app.contenttypes.interfaces import IDocument\n+from zope.interface import Interface\n+from zope.interface import implementer\n+\n+\n+class IFolderishDocument(Interface):\n+    """Marker interface"""\n+\n+\n+@implementer(IDocument, IFolderishDocument)\n+class FolderishDocument(Container):\n+    """A Dexterity based test type containing a set of standard fields."""\n+\n+    pass\ndiff --git a/plone/app/iterate/tests/test_containers.py b/plone/app/iterate/tests/test_containers.py\nnew file mode 100644\nindex 0000000..12ad18c\n--- /dev/null\n+++ b/plone/app/iterate/tests/test_containers.py\n@@ -0,0 +1,310 @@\n+# -*- coding: utf-8 -*-\n+##################################################################\n+#\n+# (C) Copyright 2006 ObjectRealms, LLC\n+# All Rights Reserved\n+#\n+# This file is part of iterate.\n+#\n+# iterate is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 2 of the License, or\n+# (at your option) any later version.\n+#\n+# iterate is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with iterate; if not, write to the Free Software\n+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n+##################################################################\n+\n+from AccessControl import getSecurityManager\n+from plone.app.iterate.browser.control import Control\n+from plone.app.iterate.interfaces import ICheckinCheckoutPolicy\n+from plone.app.iterate.testing import PLONEAPPITERATEDEX_INTEGRATION_TESTING\n+from plone.app.testing import login\n+from plone.app.testing import setRoles\n+from plone.app.testing import TEST_USER_ID\n+from plone.app.testing import TEST_USER_NAME\n+from zc.relation.interfaces import ICatalog\n+from zope.intid.interfaces import IIntIds\n+from zope import component\n+from plone.dexterity.utils import createContentInContainer\n+\n+import unittest\n+\n+\n+class TestIterations(unittest.TestCase):\n+\n+    layer = PLONEAPPITERATEDEX_INTEGRATION_TESTING\n+\n+    def setUp(self):\n+        self.portal = self.layer["portal"]\n+        setRoles(self.portal, TEST_USER_ID, ["Manager"])\n+        login(self.portal, TEST_USER_NAME)\n+\n+        self.wf = self.portal.portal_workflow\n+        self.wf.setChainForPortalTypes(\n+            ("FolderishDocument",), "simple_publication_workflow"\n+        )\n+\n+        # add a folder with two documents in it\n+        self.portal.invokeFactory("Folder", "docs")\n+        self.portal.docs.invokeFactory("FolderishDocument", "doc1")\n+        self.portal.docs.invokeFactory("FolderishDocument", "doc2")\n+\n+        # add a working copy folder\n+        self.portal.invokeFactory("Folder", "workarea")\n+\n+        self.repo = self.portal.portal_repository\n+\n+    def test_container_workflowState(self):\n+        # ensure baseline workflow state is retained on checkin, including\n+        # security\n+\n+        doc = self.portal.docs.doc1\n+\n+        # sanity check that owner can edit visible docs\n+        setRoles(self.portal, TEST_USER_ID, ["Owner"])\n+        self.assertTrue(\n+            getSecurityManager().checkPermission(\n+                "Modify portal content", self.portal.docs.doc1\n+            )\n+        )\n+\n+        setRoles(self.portal, TEST_USER_ID, ["Manager"])\n+        self.wf.doActionFor(doc, "publish")\n+        state = self.wf.getInfoFor(doc, "review_state")\n+\n+        self.repo.save(doc)\n+        wc = ICheckinCheckoutPolicy(doc).checkout(self.portal.workarea)\n+        wc_state = self.wf.getInfoFor(wc, "review_state")\n+\n+        self.assertNotEqual(state, wc_state)\n+\n+        baseline = ICheckinCheckoutPolicy(wc).checkin("modified")\n+        bstate = self.wf.getInfoFor(baseline, "review_state")\n+        self.assertEqual(bstate, "published")\n+\n+        self.assertEquals(len(self.portal.workarea.objectIds()), 0)\n+        setRoles(self.portal, TEST_USER_ID, ["Owner"])\n+\n+    def test_container_baselineCreated(self):\n+        # if a baseline has no version ensure that one is created on checkout\n+        doc = self.portal.docs.doc1\n+        self.assertTrue(self.repo.isVersionable(doc))\n+\n+        wc = ICheckinCheckoutPolicy(doc).checkout(self.portal.workarea)\n+\n+        self.assertEquals(wc.id, "working_copy_of_doc1")\n+        self.assertIn("working_copy_of_doc1", self.portal.workarea.objectIds())\n+\n+    def test_container_folderOrder(self):\n+        """When an item is checked out and then back in, the original\n+        folder order is preserved."""\n+        container = self.portal.docs\n+        doc = container.doc1\n+        original_position = container.getObjectPosition(doc.getId())\n+\n+        # check that there is another document which could interact with\n+        # position of document the test work on\n+        doc2_position = container.getObjectPosition("doc2")\n+        self.assertTrue(doc2_position > original_position)\n+\n+        self.repo.save(doc)\n+        wc = ICheckinCheckoutPolicy(doc).checkout(container)\n+        wc.text = "new document text"\n+\n+        # check that the copy is put after the second document\n+        copy_position = container.getObjectPosition(wc.getId())\n+        self.assertTrue(copy_position > doc2_position)\n+\n+        new_doc = ICheckinCheckoutPolicy(wc).checkin("updated")\n+        new_position = container.getObjectPosition(new_doc.getId())\n+        self.assertEqual(new_position, original_position)\n+\n+    def test_container_contents(self):\n+        """When an folderish content is checked out, and item is added, and then\n+        the content is checked back in, if resources (images or files) are added item is in the new\n+        version of the folder they are moved to the baseline container.  UIDs of contained content are also\n+        preserved."""\n+        container = self.portal.docs\n+        doc = container.doc1\n+\n+        wc = ICheckinCheckoutPolicy(doc).checkout(container)\n+        self.repo.save(wc)\n+        image = createContentInContainer(\n+            wc,\n+            "Image",\n+            id="an-image",\n+        )\n+        another_doc = createContentInContainer(\n+            wc,\n+            "FolderishDocument",\n+            id="document",\n+        )\n+        just_another_nested_doc = createContentInContainer(\n+            another_doc,\n+            "FolderishDocument",\n+            id="just_another_doc",\n+        )\n+        image_uid = image.UID()\n+        another_doc_uid = another_doc.UID()\n+        just_another_nested_doc_uid = just_another_nested_doc.UID()\n+\n+        baseline = ICheckinCheckoutPolicy(wc).checkin("updated")\n+\n+        self.assertTrue("an-image" in baseline)\n+        self.assertTrue("document" in baseline)\n+        self.assertTrue("just_another_doc" in baseline["document"])\n+        self.assertEqual(baseline["an-image"].UID(), image_uid)\n+        self.assertEqual(baseline["document"].UID(), another_doc_uid)\n+        self.assertEqual(\n+            baseline["document"]["just_another_doc"].UID(), just_another_nested_doc_uid\n+        )\n+\n+    def test_container_contents_with_collisions(self):\n+        """When an folderish content is checked out, and item is added, and then\n+        the content is checked back in, if resources (images or files) are added item is in the new\n+        version of the folder they are moved to the baseline container.  UIDs of contained content are also\n+        preserved and collisions handled by Zope cut/paste machinery."""\n+        container = self.portal.docs\n+        baseline = container.doc1\n+        baseline_image = createContentInContainer(\n+            baseline,\n+            "Image",\n+            id="an-image",\n+        )\n+        self.repo.save(baseline)\n+        baseline_image_uid = baseline_image.UID()\n+\n+        wc = ICheckinCheckoutPolicy(baseline).checkout(container)\n+        self.repo.save(wc)\n+        image = createContentInContainer(\n+            wc,\n+            "Image",\n+            id="an-image",\n+        )\n+        image_uid = image.UID()\n+\n+        baseline = ICheckinCheckoutPolicy(wc).checkin("updated")\n+\n+        self.assertTrue("copy_of_an-image" in baseline)\n+        self.assertTrue("an-image" in baseline)\n+        self.assertEqual(baseline["an-image"].UID(), baseline_image_uid)\n+        self.assertEqual(baseline["copy_of_an-image"].UID(), image_uid)\n+\n+    def test_container_default_page_is_kept_in_folder(self):\n+        # Ensure that a default page that is checked out and back in is still\n+        # the default page.\n+        folder = self.portal.docs\n+        doc = folder.doc1\n+        from Products.CMFDynamicViewFTI.interfaces import (\n+            ISelectableBrowserDefault,\n+        )  # noqa: C901\n+\n+        ISelectableBrowserDefault(folder).setDefaultPage("doc1")\n+        self.assertEqual(folder.getProperty("default_page", ""), "doc1")\n+        self.assertEqual(folder.getDefaultPage(), "doc1")\n+        # Note: when checking out to self.portal.workarea it surprisingly works\n+        # without changes.  But the default behavior in Plone is to check a\n+        # document out in its original folder, so that is what we check here.\n+        wc = ICheckinCheckoutPolicy(doc).checkout(folder)\n+        doc = ICheckinCheckoutPolicy(wc).checkin("updated")\n+        self.assertEqual(folder.getProperty("default_page", ""), "doc1")\n+        self.assertEqual(folder.getDefaultPage(), "doc1")\n+\n+    def test_container_control_checkin_allowed_with_no_policy(self):\n+        control = Control(self.portal, self.layer["request"])\n+        self.assertFalse(control.checkin_allowed())\n+\n+    def test_container_control_checkout_allowed_with_no_policy(self):\n+        control = Control(self.portal, self.layer["request"])\n+        self.assertFalse(control.checkout_allowed())\n+\n+    def test_container_control_cancel_allowed_with_no_policy(self):\n+        control = Control(self.portal, self.layer["request"])\n+        self.assertFalse(control.cancel_allowed())\n+\n+    def test_container_control_cancel_on_original_does_not_delete_original(self):\n+        # checkout document\n+        doc = self.portal.docs.doc1\n+        policy = ICheckinCheckoutPolicy(self.portal.docs.doc1, None)\n+        policy.checkout(self.portal.workarea)\n+\n+        # get cancel browser view\n+        from plone.app.iterate.browser.cancel import Cancel\n+\n+        cancel = Cancel(doc, self.layer["request"])\n+        self.layer["request"].form["form.button.Cancel"] = True\n+\n+        # check if cancel on original raises the correct exception\n+        from plone.app.iterate.interfaces import CheckoutException\n+\n+        with self.assertRaises(CheckoutException):\n+            cancel()\n+\n+    def test_container_relationship_deleted_on_checkin(self):\n+        # Ensure that the relationship between the baseline and the wc is\n+        # removed when the working copy is checked in\n+        folder = self.portal.docs\n+        doc = folder.doc1\n+\n+        intids = component.getUtility(IIntIds)\n+        catalog = component.getUtility(ICatalog)\n+        obj_id = intids.getId(doc)\n+        rels = list(catalog.findRelations({"from_id": obj_id}))\n+        self.assertEqual(len(rels), 0)\n+\n+        wc = ICheckinCheckoutPolicy(doc).checkout(folder)\n+        wc_id = intids.getId(wc)\n+\n+        rels = list(catalog.findRelations({"from_id": obj_id}))\n+        self.assertEqual(len(rels), 1)\n+        from_rel = rels[0]\n+\n+        rels = list(catalog.findRelations({"to_id": wc_id}))\n+        self.assertEqual(len(rels), 1)\n+        to_rel = rels[0]\n+\n+        self.assertEqual(from_rel, to_rel)\n+\n+        doc = ICheckinCheckoutPolicy(wc).checkin("updated")\n+\n+        rels = list(catalog.findRelations({"from_id": obj_id}))\n+\n+        self.assertEqual(len(rels), 0)\n+\n+    def test_relationship_deleted_on_cancel_checkout(self):\n+        # Ensure that the relationship between the baseline and the wc is\n+        # removed when the working copy is checked in\n+        folder = self.portal.docs\n+        doc = folder.doc1\n+\n+        intids = component.getUtility(IIntIds)\n+        catalog = component.getUtility(ICatalog)\n+        obj_id = intids.getId(doc)\n+        rels = list(catalog.findRelations({"from_id": obj_id}))\n+        self.assertEqual(len(rels), 0)\n+\n+        wc = ICheckinCheckoutPolicy(doc).checkout(folder)\n+        wc_id = intids.getId(wc)\n+\n+        rels = list(catalog.findRelations({"from_id": obj_id}))\n+        self.assertEqual(len(rels), 1)\n+        from_rel = rels[0]\n+\n+        rels = list(catalog.findRelations({"to_id": wc_id}))\n+        self.assertEqual(len(rels), 1)\n+        to_rel = rels[0]\n+\n+        self.assertEqual(from_rel, to_rel)\n+\n+        ICheckinCheckoutPolicy(wc).cancelCheckout()\n+\n+        rels = list(catalog.findRelations({"from_id": obj_id}))\n+\n+        self.assertEqual(len(rels), 0)\ndiff --git a/plone/app/iterate/tests/test_iterate.py b/plone/app/iterate/tests/test_iterate.py\nindex 9739f6a..f838f13 100644\n--- a/plone/app/iterate/tests/test_iterate.py\n+++ b/plone/app/iterate/tests/test_iterate.py\n@@ -21,7 +21,6 @@\n # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n ##################################################################\n \n-from AccessControl import getSecurityManager\n from plone.app.iterate.browser.control import Control\n from plone.app.iterate.interfaces import ICheckinCheckoutPolicy\n from plone.app.iterate.testing import PLONEAPPITERATEDEX_INTEGRATION_TESTING\n@@ -29,7 +28,6 @@\n from plone.app.testing import setRoles\n from plone.app.testing import TEST_USER_ID\n from plone.app.testing import TEST_USER_NAME\n-from Products.CMFCore.utils import getToolByName\n from zc.relation.interfaces import ICatalog\n from zope.intid.interfaces import IIntIds\n from zope import component\n@@ -59,36 +57,6 @@ def setUp(self):\n \n         self.repo = self.portal.portal_repository\n \n-    @unittest.skip("This test needs to be fixed for Dexterity content.")\n-    def test_workflowState(self):\n-        # ensure baseline workflow state is retained on checkin, including\n-        # security\n-\n-        doc = self.portal.docs.doc1\n-\n-        # sanity check that owner can edit visible docs\n-        setRoles(self.portal, TEST_USER_ID, ["Owner"])\n-        self.assertTrue(\n-            getSecurityManager().checkPermission(\n-                "Modify portal content", self.portal.docs.doc1\n-            )\n-        )\n-\n-        setRoles(self.portal, TEST_USER_ID, ["Manager"])\n-        self.wf.doActionFor(doc, "publish")\n-        state = self.wf.getInfoFor(doc, "review_state")\n-\n-        self.repo.save(doc)\n-        wc = ICheckinCheckoutPolicy(doc).checkout(self.portal.workarea)\n-        wc_state = self.wf.getInfoFor(wc, "review_state")\n-\n-        self.assertNotEqual(state, wc_state)\n-\n-        ICheckinCheckoutPolicy(wc).checkin("modified")\n-        bstate = self.wf.getInfoFor(wc, "review_state")\n-        self.assertEqual(state, bstate)\n-        setRoles(self.portal, TEST_USER_ID, ["Owner"])\n-\n     def test_baselineVersionCreated(self):\n         # if a baseline has no version ensure that one is created on checkout\n \n@@ -135,51 +103,6 @@ def test_folderOrder(self):\n         new_position = container.getObjectPosition(new_doc.getId())\n         self.assertEqual(new_position, original_position)\n \n-    @unittest.skip("This test needs to be fixed for Dexterity content.")\n-    def test_folderContents(self):\n-        """When an folder is checked out, and item is added, and then\n-        the folder is checked back in, the added item is in the new\n-        version of the folder.  UIDs of contained content are also\n-        preserved."""\n-        container = self.portal.docs\n-        folder = container[\n-            container.invokeFactory(type_name="Folder", id="foo-folder")\n-        ]\n-        existing_doc = folder[\n-            folder.invokeFactory(\n-                type_name="Document", id="existing-folder-item"\n-            )\n-        ]\n-        existing_doc_uid = existing_doc.UID()\n-\n-        self.repo.save(folder)\n-        wc = ICheckinCheckoutPolicy(folder).checkout(container)\n-        new_doc = wc[\n-            wc.invokeFactory(\n-                type_name="Document",\n-                id="new-folder-item",\n-                text="new folder item text",\n-            )\n-        ]\n-        new_doc_uid = new_doc.UID()\n-        new_folder = ICheckinCheckoutPolicy(wc).checkin("updated")\n-\n-        catalog = getToolByName(self.portal, "portal_catalog")\n-\n-        self.assertTrue("existing-folder-item" in new_folder)\n-        self.assertEqual(\n-            new_folder["existing-folder-item"].UID(), existing_doc_uid\n-        )\n-        self.assertTrue("new-folder-item" in new_folder)\n-        self.assertEqual(new_folder["new-folder-item"].UID(), new_doc_uid)\n-        brains = catalog(\n-            path="/".join(new_folder["new-folder-item"].getPhysicalPath())\n-        )\n-        self.assertTrue(brains)\n-        self.assertTrue(\n-            "new folder item text" in new_folder["new-folder-item"].getText()\n-        )\n-\n     def test_default_page_is_kept_in_folder(self):\n         # Ensure that a default page that is checked out and back in is still\n         # the default page.\n'

