Repository: plone.restapi


Branch: refs/heads/master
Date: 2020-05-11T12:48:12+02:00
Author: Tiberiu Ichim (tiberiuichim) <tiberiuichim@users.noreply.github.com>
Commit: https://github.com/plone/plone.restapi/commit/6c489bb6162e90d02da1261fee1c14648da5268f

Added block transformer concept (#915)

* Added block transformer concept

* Added WIP image attachment handler

* Removed image block related code

* Added coding magic comment

* Added news changelong entry

* Changed magic code comment

* Changed magic code comment

* Refactored blocks transformer to use deserialization

* Docstring tweak

* Removed IBlockTransformer interface

* Added one generic test for the block deserializer concept

* Fix flake8 problem

* Renamed block deserializer to block converter

* Fix test

* Fix adapter name in configure.zcml

* Rename to IBlockDeserializer; implement transformer as subscription adapters

* Added Image block deserializer

* Added test for multiple deserializer subscribers

* Integrate text deserialization resolveuid method from resolveuid-in-block-more-generic branch

* Better code formatting

* Added test for block_serializer

* Adjust news entry

* Rollback .gitignore

* Use current plone.restapi master version of path2uid

* Added test for block image deserializer

* Renamed interfaces to IBlockFieldSerializationTransformer and IBlockFieldDeserializationTransformer

* Added block_type attribute in ifaces declaration

* Run black on src/

Files changed:
A news/915.feature
A src/plone/restapi/tests/test_blocks_deserializer.py
A src/plone/restapi/tests/test_blocks_serializer.py
M docs/source/blocks.rst
M src/plone/restapi/deserializer/blocks.py
M src/plone/restapi/deserializer/configure.zcml
M src/plone/restapi/interfaces.py
M src/plone/restapi/serializer/blocks.py
M src/plone/restapi/serializer/configure.zcml

b'diff --git a/docs/source/blocks.rst b/docs/source/blocks.rst\nindex 49338603..3b3d37e8 100644\n--- a/docs/source/blocks.rst\n+++ b/docs/source/blocks.rst\n@@ -76,3 +76,72 @@ Storing blocks is done also via a default PATCH content operation::\n       }\n     }\n   }\n+\n+Block serializers and deserializers\n+-----------------------------------\n+\n+Practical experience has shown that it is useful to transform, server-side, the\n+value of block fields on inbound (deserialization) and also outbound\n+(serialization) operations. For example, HTML field values are cleaned up using\n+``portal_transforms``, paths in Image blocks are transformed to use resolveuid\n+and so on.\n+\n+It is possible to influence the transformation of block values per block type.\n+For example, to tweak the value stored in Image type block, we can create a\n+new subscriber like::\n+\n+  @implementer(IBlockFieldDeserializationTransformer)\n+  @adapter(IBlocks, IBrowserRequest)\n+  class ImageBlockDeserializeTransformer(object):\n+      order = 100\n+      block_type = \'image\'\n+\n+      def __init__(self, context, request):\n+          self.context = context\n+          self.request = request\n+\n+      def __call__(self, value):\n+          portal = getMultiAdapter(\n+              (self.context, self.request), name="plone_portal_state"\n+          ).portal()\n+          url = value.get(\'url\', \'\')\n+          deserialized_url = path2uid(\n+              context=self.context, portal=portal,\n+              href=url\n+          )\n+          value["url"] = deserialized_url\n+          return value\n+\n+Then register as a subscription adapter::\n+\n+  <subscriber factory=".blocks.ImageBlockDeserializeTransformer"\n+    provides="plone.restapi.interfaces.IBlockFieldDeserializationTransformer"/>\n+\n+This would replace the ``url`` value to use resolveuid instead of hardcoding\n+the image path.\n+\n+The ``block_type`` attribute needs to match the ``@type`` field of the block\n+value. The ``order`` attribute is used in sorting the subscribers for the same\n+field. Lower number has higher precedence (is executed first).\n+\n+On the serialization path, a block value can be tweaked with a similar\n+transformer, for example on an imaginary Database Listing block type::\n+\n+  @implementer(IBlockFieldDeserializationTransformer)\n+  @adapter(IBlocks, IBrowserRequest)\n+  class DatabaseQueryDeserializeTransformer(object):\n+      order = 100\n+      block_type = \'database_listing\'\n+\n+      def __init__(self, context, request):\n+          self.context = context\n+          self.request = request\n+\n+      def __call__(self, value):\n+          value["items"] = db.query(value)    # pseudocode\n+          return value\n+\n+Then register as a subscription adapter::\n+\n+  <subscriber factory=".blocks.DatabaseQueryDeserializeTransformer"\n+    provides="plone.restapi.interfaces.IBlockFieldDeserializationTransformer"/>\ndiff --git a/news/915.feature b/news/915.feature\nnew file mode 100644\nindex 00000000..51b770e8\n--- /dev/null\n+++ b/news/915.feature\n@@ -0,0 +1,14 @@\n+Added ``IBlockFieldDeserializationTransformer`` and its counterpart,\n+``IBlockFieldSerializationTransformer`` concepts, use subscribers to\n+convert/adjust value of blocks on serialization/deserialization, this enables\n+an extensible mechanism to transform block values when saving content.\n+\n+Added an html block deserializer transformer, it will clean the\n+content of the "html" block according to portal_transform x-html-safe settings.\n+\n+Added an image block deserializer transformer, it will use resolveuid mechanism\n+to transform the url field to a UID of content.\n+\n+Move the resolveuid code from the dexterity field deserializer to a dedicated\n+block converter adapter, using the above mechanism.\n+[tiberiuichim]\ndiff --git a/src/plone/restapi/deserializer/blocks.py b/src/plone/restapi/deserializer/blocks.py\nindex 0c731d49..333d13c4 100644\n--- a/src/plone/restapi/deserializer/blocks.py\n+++ b/src/plone/restapi/deserializer/blocks.py\n@@ -1,13 +1,17 @@\n # -*- coding: utf-8 -*-\n+\n from Acquisition import aq_parent\n+from plone import api\n from plone.restapi.behaviors import IBlocks\n from plone.restapi.deserializer.dxfields import DefaultFieldDeserializer\n+from plone.restapi.interfaces import IBlockFieldDeserializationTransformer\n from plone.restapi.interfaces import IFieldDeserializer\n from plone.schema import IJSONField\n from plone.uuid.interfaces import IUUID\n from plone.uuid.interfaces import IUUIDAware\n from zope.component import adapter\n from zope.component import getMultiAdapter\n+from zope.component import subscribers\n from zope.interface import implementer\n from zope.publisher.interfaces.browser import IBrowserRequest\n \n@@ -34,29 +38,117 @@ class BlocksJSONFieldDeserializer(DefaultFieldDeserializer):\n     def __call__(self, value):\n         value = super(BlocksJSONFieldDeserializer, self).__call__(value)\n \n+        if self.field.getName() == "blocks":\n+\n+            for id, block_value in value.items():\n+                block_type = block_value.get("@type", "")\n+\n+                handlers = [\n+                    h\n+                    for h in subscribers(\n+                        (self.context, self.request),\n+                        IBlockFieldDeserializationTransformer,\n+                    )\n+                    if h.block_type == block_type\n+                ]\n+\n+                for handler in sorted(handlers, key=lambda h: h.order):\n+                    block_value = handler(block_value)\n+\n+                value[id] = block_value\n+\n+        return value\n+\n+\n+@adapter(IBlocks, IBrowserRequest)\n+@implementer(IBlockFieldDeserializationTransformer)\n+class TextBlockDeserializer(object):\n+    order = 100\n+    block_type = "text"\n+\n+    def __init__(self, context, request):\n+        self.context = context\n+        self.request = request\n+\n+    def __call__(self, block):\n         # Convert absolute links to resolveuid\n+        # Assumes in-place mutations\n+\n         portal = getMultiAdapter(\n             (self.context, self.request), name="plone_portal_state"\n         ).portal()\n         portal_url = portal.absolute_url()\n         context_url = self.context.absolute_url()\n         relative_up = len(context_url.split("/")) - len(portal_url.split("/"))\n-        if self.field.getName() == "blocks":\n-            for block in value.values():\n-                if block.get("@type") == "text":\n-                    entity_map = block.get("text", {}).get("entityMap", {})\n-                    for entity in entity_map.values():\n-                        if entity.get("type") == "LINK":\n-                            href = entity.get("data", {}).get("url", "")\n-                            before = href  # noqa\n-                            if href and href.startswith(portal_url):\n-                                path = href[len(portal_url) + 1 :].encode("utf8")\n-                                uid, suffix = path2uid(portal, path)\n-                                if uid:\n-                                    href = relative_up * "../" + "resolveuid/" + uid\n-                                    if suffix:\n-                                        href += suffix\n-                                    entity["data"]["href"] = href\n-                                    entity["data"]["url"] = href\n-                                print("DESERIALIZE " + before + " -> " + href)  # noqa\n+        entity_map = block.get("text", {}).get("entityMap", {})\n+        for entity in entity_map.values():\n+            if entity.get("type") == "LINK":\n+                href = entity.get("data", {}).get("url", "")\n+                before = href  # noqa\n+                if href and href.startswith(portal_url):\n+                    path = href[len(portal_url) + 1 :].encode("utf8")\n+                    uid, suffix = path2uid(portal, path)\n+                    if uid:\n+                        href = relative_up * "../" + "resolveuid/" + uid\n+                        if suffix:\n+                            href += suffix\n+                        entity["data"]["href"] = href\n+                        entity["data"]["url"] = href\n+                    print("DESERIALIZE " + before + " -> " + href)  # noqa\n+\n+        return block\n+\n+\n+@adapter(IBlocks, IBrowserRequest)\n+@implementer(IBlockFieldDeserializationTransformer)\n+class HTMLBlockDeserializer(object):\n+    order = 100\n+    block_type = "html"\n+\n+    def __init__(self, context, request):\n+        self.context = context\n+        self.request = request\n+\n+    def __call__(self, value):\n+\n+        portal_transforms = api.portal.get_tool(name="portal_transforms")\n+        raw_html = value.get("html", "")\n+        data = portal_transforms.convertTo(\n+            "text/x-html-safe", raw_html, mimetype="text/html"\n+        )\n+        html = data.getData()\n+        value["html"] = html\n+\n+        return value\n+\n+\n+@adapter(IBlocks, IBrowserRequest)\n+@implementer(IBlockFieldDeserializationTransformer)\n+class ImageBlockDeserializer(object):\n+    order = 100\n+    block_type = "image"\n+\n+    def __init__(self, context, request):\n+        self.context = context\n+        self.request = request\n+\n+    def __call__(self, value):\n+        portal = getMultiAdapter(\n+            (self.context, self.request), name="plone_portal_state"\n+        ).portal()\n+        portal_url = portal.absolute_url()\n+        context_url = self.context.absolute_url()\n+        relative_up = len(context_url.split("/")) - len(portal_url.split("/"))\n+\n+        href = value.get("url", "")\n+\n+        if href and href.startswith(portal_url):\n+            path = href[len(portal_url) + 1 :].encode("utf8")\n+            uid, suffix = path2uid(portal, path)\n+            if uid:\n+                href = relative_up * "../" + "resolveuid/" + uid\n+                if suffix:\n+                    href += suffix\n+\n+        value["url"] = href\n         return value\ndiff --git a/src/plone/restapi/deserializer/configure.zcml b/src/plone/restapi/deserializer/configure.zcml\nindex 9c4f3f60..854e154e 100644\n--- a/src/plone/restapi/deserializer/configure.zcml\n+++ b/src/plone/restapi/deserializer/configure.zcml\n@@ -18,6 +18,13 @@\n   <adapter factory=".dxfields.RichTextFieldDeserializer" />\n   <adapter factory=".blocks.BlocksJSONFieldDeserializer" />\n \n+  <subscriber factory=".blocks.TextBlockDeserializer"\n+    provides="plone.restapi.interfaces.IBlockFieldDeserializationTransformer"/>\n+  <subscriber factory=".blocks.HTMLBlockDeserializer"\n+    provides="plone.restapi.interfaces.IBlockFieldDeserializationTransformer"/>\n+  <subscriber factory=".blocks.ImageBlockDeserializer"\n+    provides="plone.restapi.interfaces.IBlockFieldDeserializationTransformer"/>\n+\n   <adapter factory=".local_roles.DeserializeFromJson"\n            name="local_roles"/>\n \ndiff --git a/src/plone/restapi/interfaces.py b/src/plone/restapi/interfaces.py\nindex 494d4781..80be124b 100644\n--- a/src/plone/restapi/interfaces.py\n+++ b/src/plone/restapi/interfaces.py\n@@ -84,6 +84,47 @@ def __call__(value):\n         """\n \n \n+class IBlockFieldDeserializationTransformer(Interface):\n+    """Convert/adjust raw block deserialized value into block value.\n+    """\n+\n+    block_type = Attribute(\n+        "A string with the type of block, the @type from " "the block value"\n+    )\n+    order = Attribute(\n+        "A number used in sorting value transformers. " "Smaller is executed first"\n+    )\n+\n+    def __init__(field, context, request):\n+        """Adapts context and the request.\n+        """\n+\n+    def __call__(value):\n+        """Convert the provided raw Python value to a block value.\n+        """\n+\n+\n+class IBlockFieldSerializationTransformer(Interface):\n+    """Transform block value before final JSON serialization\n+    """\n+\n+    block_type = Attribute(\n+        "A string with the type of block, the @type from " "the block value"\n+    )\n+    order = Attribute(\n+        "A number used in sorting value transformers for the "\n+        "same block. Smaller is executed first"\n+    )\n+\n+    def __init__(field, context, request):\n+        """Adapts context and the request.\n+        """\n+\n+    def __call__(value):\n+        """Convert the provided raw Python value to a block value.\n+        """\n+\n+\n class IExpandableElement(Interface):\n     """A named adapter that deserializes an element in expanded or collapsed\n        form.\ndiff --git a/src/plone/restapi/serializer/blocks.py b/src/plone/restapi/serializer/blocks.py\nindex 58c948b8..31494b26 100644\n--- a/src/plone/restapi/serializer/blocks.py\n+++ b/src/plone/restapi/serializer/blocks.py\n@@ -1,13 +1,16 @@\n # -*- coding: utf-8 -*-\n from plone.outputfilters.browser.resolveuid import uuidToURL\n from plone.restapi.behaviors import IBlocks\n+from plone.restapi.interfaces import IBlockFieldSerializationTransformer\n from plone.restapi.interfaces import IFieldSerializer\n from plone.restapi.serializer.converters import json_compatible\n from plone.restapi.serializer.dxfields import DefaultFieldSerializer\n from plone.schema import IJSONField\n from zope.component import adapter\n+from zope.component import subscribers\n from zope.interface import implementer\n from zope.interface import Interface\n+from zope.publisher.interfaces.browser import IBrowserRequest\n \n import copy\n import re\n@@ -22,25 +25,55 @@ class BlocksJSONFieldSerializer(DefaultFieldSerializer):\n     def __call__(self):\n         value = copy.deepcopy(self.get_value())\n \n-        # Resolve UID links\n         if self.field.getName() == "blocks":\n-            for block in value.values():\n-                if block.get("@type") == "text":\n-                    entity_map = block.get("text", {}).get("entityMap", {})\n-                    for entity in entity_map.values():\n-                        if entity.get("type") == "LINK":\n-                            href = entity.get("data", {}).get("url", "")\n-                            before = href  # noqa\n-                            if href:\n-                                match = RESOLVEUID_RE.match(href)\n-                                if match is not None:\n-                                    uid, suffix = match.groups()\n-                                    href = uuidToURL(uid)\n-                                    if href is None:\n-                                        continue\n-                                    if suffix:\n-                                        href += "/" + suffix\n-                                    entity["data"]["href"] = href\n-                                    entity["data"]["url"] = href\n-                                    print("SERIALIZE " + before + " -> " + href)  # noqa\n+            for id, block_value in value.items():\n+                block_type = block_value.get("@type", "")\n+\n+                handlers = [\n+                    h\n+                    for h in subscribers(\n+                        (self.context, self.request),\n+                        IBlockFieldSerializationTransformer,\n+                    )\n+                    if h.block_type == block_type\n+                ]\n+\n+                for handler in sorted(handlers, key=lambda h: h.order):\n+                    block_value = handler(block_value)\n+\n+                value[id] = block_value\n+\n         return json_compatible(value)\n+\n+\n+@implementer(IBlockFieldSerializationTransformer)\n+@adapter(IBlocks, IBrowserRequest)\n+class TextBlockSerializer(object):\n+    order = 100\n+    block_type = "text"\n+\n+    def __init__(self, context, request):\n+        self.context = context\n+        self.request = request\n+\n+    def __call__(self, value):\n+        # Resolve UID links\n+        entity_map = value.get("text", {}).get("entityMap", {})\n+        for entity in entity_map.values():\n+            if entity.get("type") == "LINK":\n+                href = entity.get("data", {}).get("url", "")\n+                before = href  # noqa\n+                if href:\n+                    match = RESOLVEUID_RE.match(href)\n+                    if match is not None:\n+                        uid, suffix = match.groups()\n+                        href = uuidToURL(uid)\n+                        if href is None:\n+                            continue\n+                        if suffix:\n+                            href += "/" + suffix\n+                        entity["data"]["href"] = href\n+                        entity["data"]["url"] = href\n+                        print("SERIALIZE " + before + " -> " + href)  # noqa\n+\n+        return value\ndiff --git a/src/plone/restapi/serializer/configure.zcml b/src/plone/restapi/serializer/configure.zcml\nindex a86bce65..70307618 100644\n--- a/src/plone/restapi/serializer/configure.zcml\n+++ b/src/plone/restapi/serializer/configure.zcml\n@@ -24,6 +24,8 @@\n     <adapter factory=".dxfields.PrimaryFileFieldTarget" />\n \n     <adapter factory=".blocks.BlocksJSONFieldSerializer" />\n+    <subscriber factory=".blocks.TextBlockSerializer"\n+      provides="plone.restapi.interfaces.IBlockFieldSerializationTransformer"/>\n \n     <configure zcml:condition="installed Products.Archetypes">\n         <adapter factory=".atcontent.SerializeToJson" />\ndiff --git a/src/plone/restapi/tests/test_blocks_deserializer.py b/src/plone/restapi/tests/test_blocks_deserializer.py\nnew file mode 100644\nindex 00000000..f9dc4a7f\n--- /dev/null\n+++ b/src/plone/restapi/tests/test_blocks_deserializer.py\n@@ -0,0 +1,157 @@\n+# -*- coding: utf-8 -*-\n+\n+from plone.dexterity.interfaces import IDexterityFTI\n+from plone.dexterity.interfaces import IDexterityItem\n+from plone.restapi.behaviors import IBlocks\n+from plone.restapi.interfaces import IBlockFieldDeserializationTransformer\n+from plone.restapi.interfaces import IDeserializeFromJson\n+from plone.restapi.testing import PLONE_RESTAPI_DX_INTEGRATION_TESTING\n+from plone.uuid.interfaces import IUUID\n+from zope.component import adapter\n+from zope.component import getMultiAdapter\n+from zope.component import provideSubscriptionAdapter\n+from zope.component import queryUtility\n+from zope.interface import implementer\n+from zope.publisher.interfaces.browser import IBrowserRequest\n+\n+import json\n+import unittest\n+\n+\n+class TestBlocksDeserializer(unittest.TestCase):\n+\n+    layer = PLONE_RESTAPI_DX_INTEGRATION_TESTING\n+\n+    def setUp(self):\n+        self.app = self.layer["app"]\n+        self.portal = self.layer["portal"]\n+        self.request = self.layer["request"]\n+\n+        fti = queryUtility(IDexterityFTI, name="Document")\n+        behavior_list = [a for a in fti.behaviors]\n+        behavior_list.append("volto.blocks")\n+        fti.behaviors = tuple(behavior_list)\n+\n+        self.portal.invokeFactory(\n+            "Document", id=u"doc1",\n+        )\n+        self.image = self.portal[\n+            self.portal.invokeFactory("Image", id="image-1", title="Target image")\n+        ]\n+\n+    def deserialize(self, blocks=None, validate_all=False, context=None):\n+        blocks = blocks or ""\n+        context = context or self.portal.doc1\n+        self.request["BODY"] = json.dumps({"blocks": blocks})\n+        deserializer = getMultiAdapter((context, self.request), IDeserializeFromJson)\n+\n+        return deserializer(validate_all=validate_all)\n+\n+    def test_register_deserializer(self):\n+        @implementer(IBlockFieldDeserializationTransformer)\n+        @adapter(IBlocks, IBrowserRequest)\n+        class TestAdapter(object):\n+            order = 10\n+            block_type = "test"\n+\n+            def __init__(self, context, request):\n+                self.context = context\n+                self.request = request\n+\n+            def __call__(self, value):\n+                self.context._handler_called = True\n+\n+                value["value"] = u"changed: {}".format(value["value"])\n+\n+                return value\n+\n+        provideSubscriptionAdapter(\n+            TestAdapter, (IDexterityItem, IBrowserRequest),\n+        )\n+\n+        self.deserialize(blocks={"123": {"@type": "test", "value": u"text"}})\n+\n+        assert self.portal.doc1._handler_called is True\n+        assert self.portal.doc1.blocks["123"]["value"] == u"changed: text"\n+\n+    def test_register_multiple_transform(self):\n+        @implementer(IBlockFieldDeserializationTransformer)\n+        @adapter(IBlocks, IBrowserRequest)\n+        class TestAdapterA(object):\n+            order = 10\n+            block_type = "test_multi"\n+\n+            def __init__(self, context, request):\n+                self.context = context\n+                self.request = request\n+\n+            def __call__(self, value):\n+                self.context._handler_called_a = True\n+\n+                value["value"] = value["value"].replace(u"a", u"b")\n+\n+                return value\n+\n+        @implementer(IBlockFieldDeserializationTransformer)\n+        @adapter(IBlocks, IBrowserRequest)\n+        class TestAdapterB(object):\n+            order = 11\n+            block_type = "test_multi"\n+\n+            def __init__(self, context, request):\n+                self.context = context\n+                self.request = request\n+\n+            def __call__(self, value):\n+                self.context._handler_called_b = True\n+\n+                value["value"] = value["value"].replace(u"b", u"c")\n+\n+                return value\n+\n+        provideSubscriptionAdapter(\n+            TestAdapterB, (IDexterityItem, IBrowserRequest),\n+        )\n+\n+        provideSubscriptionAdapter(\n+            TestAdapterA, (IDexterityItem, IBrowserRequest),\n+        )\n+\n+        self.deserialize(blocks={"123": {"@type": "test_multi", "value": u"a"}})\n+\n+        self.assertTrue(self.portal.doc1._handler_called_a)\n+        self.assertTrue(self.portal.doc1._handler_called_b)\n+        self.assertEqual(self.portal.doc1.blocks["123"]["value"], u"c")\n+\n+    def test_blocks_html_cleanup(self):\n+        self.deserialize(\n+            blocks={\n+                "123": {\n+                    "@type": "html",\n+                    "html": u"<script>nasty</script><div>This stays</div>",\n+                }\n+            }\n+        )\n+\n+        self.assertEqual(\n+            self.portal.doc1.blocks["123"]["html"], u"<div>This stays</div>"\n+        )\n+\n+    def test_blocks_image_resolve2uid(self):\n+        image_uid = IUUID(self.image)\n+        self.deserialize(\n+            blocks={"123": {"@type": "image", "url": self.image.absolute_url()}}\n+        )\n+\n+        self.assertEqual(\n+            self.portal.doc1.blocks["123"]["url"], "../resolveuid/{}".format(image_uid)\n+        )\n+\n+    def test_blocks_image_href(self):\n+        self.deserialize(\n+            blocks={"123": {"@type": "image", "url": "http://example.com/1.jpg"}}\n+        )\n+\n+        self.assertEqual(\n+            self.portal.doc1.blocks["123"]["url"], "http://example.com/1.jpg"\n+        )\ndiff --git a/src/plone/restapi/tests/test_blocks_serializer.py b/src/plone/restapi/tests/test_blocks_serializer.py\nnew file mode 100644\nindex 00000000..4d8c81ca\n--- /dev/null\n+++ b/src/plone/restapi/tests/test_blocks_serializer.py\n@@ -0,0 +1,94 @@\n+# -*- coding: utf-8 -*-\n+\n+from plone.dexterity.interfaces import IDexterityFTI\n+from plone.dexterity.interfaces import IDexterityItem\n+from plone.dexterity.utils import iterSchemata\n+from plone.restapi.behaviors import IBlocks\n+from plone.restapi.interfaces import IBlockFieldSerializationTransformer\n+from plone.restapi.interfaces import IFieldSerializer\n+from plone.restapi.testing import PLONE_RESTAPI_DX_INTEGRATION_TESTING\n+from z3c.form.interfaces import IDataManager\n+from zope.component import adapter\n+from zope.component import getMultiAdapter\n+from zope.component import provideSubscriptionAdapter\n+from zope.component import queryUtility\n+from zope.interface import implementer\n+from zope.publisher.interfaces.browser import IBrowserRequest\n+\n+import unittest\n+\n+\n+class TestBlocksSerializer(unittest.TestCase):\n+\n+    layer = PLONE_RESTAPI_DX_INTEGRATION_TESTING\n+\n+    def setUp(self):\n+        self.app = self.layer["app"]\n+        self.portal = self.layer["portal"]\n+        self.request = self.layer["request"]\n+\n+        fti = queryUtility(IDexterityFTI, name="Document")\n+        behavior_list = [a for a in fti.behaviors]\n+        behavior_list.append("volto.blocks")\n+        fti.behaviors = tuple(behavior_list)\n+\n+        self.portal.invokeFactory(\n+            "Document", id=u"doc1",\n+        )\n+        self.image = self.portal[\n+            self.portal.invokeFactory("Image", id="image-1", title="Target image")\n+        ]\n+\n+    def serialize(self, context, blocks):\n+        fieldname = "blocks"\n+        for schema in iterSchemata(context):\n+            if fieldname in schema:\n+                field = schema.get(fieldname)\n+                break\n+        dm = getMultiAdapter((context, field), IDataManager)\n+        dm.set(blocks)\n+        serializer = getMultiAdapter((field, context, self.request), IFieldSerializer)\n+        return serializer()\n+\n+    def test_register_serializer(self):\n+        @adapter(IBlocks, IBrowserRequest)\n+        @implementer(IBlockFieldSerializationTransformer)\n+        class TestAdapterA(object):\n+            order = 10\n+            block_type = "test_multi"\n+\n+            def __init__(self, context, request):\n+                self.context = context\n+                self.request = request\n+\n+            def __call__(self, value):\n+                self.context._handler_called_a = True\n+\n+                value["value"] = value["value"].replace(u"a", u"b")\n+\n+                return value\n+\n+        @adapter(IBlocks, IBrowserRequest)\n+        @implementer(IBlockFieldSerializationTransformer)\n+        class TestAdapterB(object):\n+            order = 11\n+            block_type = "test_multi"\n+\n+            def __init__(self, context, request):\n+                self.context = context\n+                self.request = request\n+\n+            def __call__(self, value):\n+                self.context._handler_called_b = True\n+\n+                value["value"] = value["value"].replace(u"b", u"c")\n+\n+                return value\n+\n+        provideSubscriptionAdapter(TestAdapterA, (IDexterityItem, IBrowserRequest))\n+        provideSubscriptionAdapter(TestAdapterB, (IDexterityItem, IBrowserRequest))\n+        value = self.serialize(\n+            context=self.portal.doc1,\n+            blocks={"123": {"@type": "test_multi", "value": u"a"}},\n+        )\n+        self.assertEqual(value["123"]["value"], u"c")\n'

