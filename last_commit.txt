Repository: plone.app.iterate


Branch: refs/heads/master
Date: 2024-02-06T12:04:09+01:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.app.iterate/commit/d97ca8e0d13c0e5290c127b7146fc9f09b239ddb

Handle relation-fields for working copies of folderish content (https://github.com/plone/plone.app.iterate/issues/118)

Files changed:
M plone/app/iterate/dexterity/copier.py

b'diff --git a/plone/app/iterate/dexterity/copier.py b/plone/app/iterate/dexterity/copier.py\nindex 5a952b0..bfa8ab4 100644\n--- a/plone/app/iterate/dexterity/copier.py\n+++ b/plone/app/iterate/dexterity/copier.py\n@@ -5,11 +5,16 @@\n from plone.app.iterate.dexterity import ITERATE_RELATION_NAME\n from plone.app.iterate.dexterity.relation import StagingRelationValue\n from plone.app.iterate.event import AfterCheckinEvent\n+from plone.app.relationfield.event import update_behavior_relations\n from plone.dexterity.utils import createContentInContainer\n from plone.dexterity.utils import iterSchemata\n from Products.CMFCore.utils import getToolByName\n from Products.DCWorkflow.DCWorkflow import DCWorkflowDefinition\n from z3c.relationfield import event\n+from z3c.relationfield import RelationValue\n+from z3c.relationfield.event import updateRelations\n+from z3c.relationfield.schema import RelationChoice\n+from z3c.relationfield.schema import RelationList\n from zc.relation.interfaces import ICatalog\n from ZODB.PersistentMapping import PersistentMapping\n from zope import component\n@@ -191,9 +196,19 @@ def _copyBaseline(self, container):\n                     obj.expiration_date = self.context.expiration_date\n                 elif name == "subjects":\n                     obj.setSubject(self.context.Subject())\n+                elif isinstance(field, RelationList):\n+                    if value:\n+                        field.set(\n+                            obj,\n+                            [RelationValue(i.to_id) for i in value if not i.isBroken()],\n+                        )\n+                elif isinstance(field, RelationChoice):\n+                    if value and not value.isBroken():\n+                        field.set(obj, RelationValue(value.to_id))\n                 else:\n                     field.set(obj, value)\n \n+        update_relation_catalog(obj)\n         obj.reindexObject()\n \n         # copy annotations\n@@ -232,9 +247,18 @@ def _replaceBaseline(self, baseline):\n                     baseline.expiration_date = self.context.expiration_date\n                 elif name == "subjects":\n                     baseline.setSubject(self.context.Subject())\n+                elif isinstance(field, RelationList):\n+                    if value:\n+                        field.set(\n+                            baseline,\n+                            [RelationValue(i.to_id) for i in value if not i.isBroken()],\n+                        )\n+                elif isinstance(field, RelationChoice):\n+                    if value and not value.isBroken():\n+                        field.set(baseline, RelationValue(value.to_id))\n                 else:\n                     field.set(baseline, value)\n-\n+        update_relation_catalog(baseline)\n         baseline.reindexObject()\n \n         # Move working children (newly created objects)\n@@ -259,3 +283,12 @@ def _replaceBaseline(self, baseline):\n         wc_container._delObject(wc_id)\n \n         return baseline\n+\n+\n+def update_relation_catalog(obj):\n+    # updateRelations from z3c.relationfield does not properly update relations in behaviors\n+    # that are registered with a marker-interface.\n+    # update_behavior_relations from plone.app.relationfield does that but does not update\n+    # those in the main schema.\n+    updateRelations(obj, None)\n+    update_behavior_relations(obj, None)\n'

Repository: plone.app.iterate


Branch: refs/heads/master
Date: 2024-02-06T12:06:32+01:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.app.iterate/commit/86fa7f57b9bb5e8d8df04fabf4d92df3ca04eadf

add changenote and remove dead archetypes code

Files changed:
A news/118.bugfix
M plone/app/iterate/base.py

b'diff --git a/news/118.bugfix b/news/118.bugfix\nnew file mode 100644\nindex 0000000..c9ece02\n--- /dev/null\n+++ b/news/118.bugfix\n@@ -0,0 +1 @@\n+Fix handling of relation-fields for working copies of folderish content. [pbauer]\ndiff --git a/plone/app/iterate/base.py b/plone/app/iterate/base.py\nindex 001263e..062574c 100644\n--- a/plone/app/iterate/base.py\n+++ b/plone/app/iterate/base.py\n@@ -34,8 +34,6 @@\n from plone.app.iterate.interfaces import ICheckinCheckoutPolicy\n from plone.app.iterate.interfaces import IObjectCopier\n from plone.app.iterate.util import get_storage\n-from Products.CMFCore import interfaces as cmf_ifaces\n-from Products.CMFCore.utils import getToolByName\n from zc.relation.interfaces import ICatalog\n from zope import component\n from zope.component import queryAdapter\n@@ -114,43 +112,6 @@ class BaseContentCopier:\n     def __init__(self, context):\n         self.context = context\n \n-    def _recursivelyReattachUIDs(self, baseline, new_baseline):\n-        original_refs = len(new_baseline.getRefs())\n-        original_back_refs = len(new_baseline.getBRefs())\n-        new_baseline._setUID(baseline.UID())\n-        new_refs = len(new_baseline.getRefs())\n-        new_back_refs = len(new_baseline.getBRefs())\n-        if original_refs != new_refs:\n-            self._removeDuplicateReferences(new_baseline, backrefs=False)\n-        if original_back_refs != new_back_refs:\n-            self._removeDuplicateReferences(new_baseline, backrefs=True)\n-\n-        if cmf_ifaces.IFolderish.providedBy(baseline):\n-            new_ids = new_baseline.contentIds()\n-            for child in baseline.contentValues():\n-                if child.getId() in new_ids:\n-                    self._recursivelyReattachUIDs(child, new_baseline[child.getId()])\n-\n-    def _removeDuplicateReferences(self, item, backrefs=False):\n-        # Remove duplicate (back) references from this item.\n-        reference_tool = getToolByName(self.context, "reference_catalog")\n-        if backrefs:\n-            ref_func = reference_tool.getBackReferences\n-        else:\n-            ref_func = reference_tool.getReferences\n-        try:\n-            # Plone 4.1 or later\n-            brains = ref_func(item, objects=False)\n-        except TypeError:\n-            # Plone 4.0 or earlier.  Nothing to fix here\n-            return\n-        for brain in brains:\n-            if brain.getObject() is None:\n-                reference_tool.uncatalog_object(brain.getPath())\n-\n-    #################################\n-    # Checkout Support Methods\n-\n     def _copyBaseline(self, container):\n         # copy the context from source to the target container\n         source_container = aq_parent(aq_inner(self.context))\n'

Repository: plone.app.iterate


Branch: refs/heads/master
Date: 2024-02-06T12:08:33+01:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.app.iterate/commit/07e709721292a0f364c35d6d52537dde166a8d9d

add missing dependency

Files changed:
M setup.py

b'diff --git a/setup.py b/setup.py\nindex 9363559..13dd918 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -45,6 +45,7 @@\n     install_requires=[\n         "Acquisition",\n         "DateTime",\n+        "plone.app.relationfield",\n         "plone.locking",\n         "plone.memoize",\n         "Products.CMFEditions",\n'

Repository: plone.app.iterate


Branch: refs/heads/master
Date: 2024-02-12T16:58:06+01:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.app.iterate/commit/018265ec270461d84f3b9d04a4eb7d5d9910bd67

add test for relationfields

Files changed:
M plone/app/iterate/tests/test_containers.py

b'diff --git a/plone/app/iterate/tests/test_containers.py b/plone/app/iterate/tests/test_containers.py\nindex f295f3a..b79735d 100644\n--- a/plone/app/iterate/tests/test_containers.py\n+++ b/plone/app/iterate/tests/test_containers.py\n@@ -29,6 +29,7 @@\n from plone.app.testing import TEST_USER_ID\n from plone.app.testing import TEST_USER_NAME\n from plone.dexterity.utils import createContentInContainer\n+from z3c.relationfield import RelationValue\n from zc.relation.interfaces import ICatalog\n from zope import component\n from zope.intid.interfaces import IIntIds\n@@ -304,3 +305,28 @@ def test_relationship_deleted_on_cancel_checkout(self):\n         rels = list(catalog.findRelations({"from_id": obj_id}))\n \n         self.assertEqual(len(rels), 0)\n+\n+    def test_relationfield_handling(self):\n+        # relations are not simply copied\n+        folder = self.portal.docs\n+        doc = folder.doc1\n+        target = folder.doc2\n+        intids = component.getUtility(IIntIds)\n+        doc.relatedItems = [RelationValue(intids.getId(target))]\n+        wc = ICheckinCheckoutPolicy(doc).checkout(doc)\n+        self.assertNotEqual(doc.relatedItems[0], wc.relatedItems[0])\n+        self.assertEqual(doc.relatedItems[0].to_object, target)\n+        self.assertEqual(doc.relatedItems[0].from_object, doc)\n+        self.assertEqual(wc.relatedItems[0].to_object, target)\n+        self.assertEqual(wc.relatedItems[0].from_object, wc)\n+        wc = ICheckinCheckoutPolicy(wc).checkin("modified")\n+        self.assertEqual(doc.relatedItems[0].to_object, target)\n+        self.assertEqual(doc.relatedItems[0].from_object, doc)\n+        self.assertEqual(len(doc.relatedItems), 1)\n+\n+        wc = ICheckinCheckoutPolicy(doc).checkout(doc)\n+        wc.relatedItems = [RelationValue(intids.getId(folder))]\n+        wc = ICheckinCheckoutPolicy(wc).checkin("modified")\n+        self.assertEqual(doc.relatedItems[0].to_object, folder)\n+        self.assertEqual(doc.relatedItems[0].from_object, doc)\n+        self.assertEqual(len(doc.relatedItems), 1)\n'

Repository: plone.app.iterate


Branch: refs/heads/master
Date: 2024-02-19T10:56:15+01:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.app.iterate/commit/975b5d46e4e2500345c4530a842516e47d4766cb

Merge pull request #119 from plone/handle_relations

Handle relation-fields for working copies of folderish content

Files changed:
A news/118.bugfix
M plone/app/iterate/base.py
M plone/app/iterate/dexterity/copier.py
M plone/app/iterate/tests/test_containers.py
M setup.py

b'diff --git a/news/118.bugfix b/news/118.bugfix\nnew file mode 100644\nindex 0000000..c9ece02\n--- /dev/null\n+++ b/news/118.bugfix\n@@ -0,0 +1 @@\n+Fix handling of relation-fields for working copies of folderish content. [pbauer]\ndiff --git a/plone/app/iterate/base.py b/plone/app/iterate/base.py\nindex 001263e..062574c 100644\n--- a/plone/app/iterate/base.py\n+++ b/plone/app/iterate/base.py\n@@ -34,8 +34,6 @@\n from plone.app.iterate.interfaces import ICheckinCheckoutPolicy\n from plone.app.iterate.interfaces import IObjectCopier\n from plone.app.iterate.util import get_storage\n-from Products.CMFCore import interfaces as cmf_ifaces\n-from Products.CMFCore.utils import getToolByName\n from zc.relation.interfaces import ICatalog\n from zope import component\n from zope.component import queryAdapter\n@@ -114,43 +112,6 @@ class BaseContentCopier:\n     def __init__(self, context):\n         self.context = context\n \n-    def _recursivelyReattachUIDs(self, baseline, new_baseline):\n-        original_refs = len(new_baseline.getRefs())\n-        original_back_refs = len(new_baseline.getBRefs())\n-        new_baseline._setUID(baseline.UID())\n-        new_refs = len(new_baseline.getRefs())\n-        new_back_refs = len(new_baseline.getBRefs())\n-        if original_refs != new_refs:\n-            self._removeDuplicateReferences(new_baseline, backrefs=False)\n-        if original_back_refs != new_back_refs:\n-            self._removeDuplicateReferences(new_baseline, backrefs=True)\n-\n-        if cmf_ifaces.IFolderish.providedBy(baseline):\n-            new_ids = new_baseline.contentIds()\n-            for child in baseline.contentValues():\n-                if child.getId() in new_ids:\n-                    self._recursivelyReattachUIDs(child, new_baseline[child.getId()])\n-\n-    def _removeDuplicateReferences(self, item, backrefs=False):\n-        # Remove duplicate (back) references from this item.\n-        reference_tool = getToolByName(self.context, "reference_catalog")\n-        if backrefs:\n-            ref_func = reference_tool.getBackReferences\n-        else:\n-            ref_func = reference_tool.getReferences\n-        try:\n-            # Plone 4.1 or later\n-            brains = ref_func(item, objects=False)\n-        except TypeError:\n-            # Plone 4.0 or earlier.  Nothing to fix here\n-            return\n-        for brain in brains:\n-            if brain.getObject() is None:\n-                reference_tool.uncatalog_object(brain.getPath())\n-\n-    #################################\n-    # Checkout Support Methods\n-\n     def _copyBaseline(self, container):\n         # copy the context from source to the target container\n         source_container = aq_parent(aq_inner(self.context))\ndiff --git a/plone/app/iterate/dexterity/copier.py b/plone/app/iterate/dexterity/copier.py\nindex 5a952b0..bfa8ab4 100644\n--- a/plone/app/iterate/dexterity/copier.py\n+++ b/plone/app/iterate/dexterity/copier.py\n@@ -5,11 +5,16 @@\n from plone.app.iterate.dexterity import ITERATE_RELATION_NAME\n from plone.app.iterate.dexterity.relation import StagingRelationValue\n from plone.app.iterate.event import AfterCheckinEvent\n+from plone.app.relationfield.event import update_behavior_relations\n from plone.dexterity.utils import createContentInContainer\n from plone.dexterity.utils import iterSchemata\n from Products.CMFCore.utils import getToolByName\n from Products.DCWorkflow.DCWorkflow import DCWorkflowDefinition\n from z3c.relationfield import event\n+from z3c.relationfield import RelationValue\n+from z3c.relationfield.event import updateRelations\n+from z3c.relationfield.schema import RelationChoice\n+from z3c.relationfield.schema import RelationList\n from zc.relation.interfaces import ICatalog\n from ZODB.PersistentMapping import PersistentMapping\n from zope import component\n@@ -191,9 +196,19 @@ def _copyBaseline(self, container):\n                     obj.expiration_date = self.context.expiration_date\n                 elif name == "subjects":\n                     obj.setSubject(self.context.Subject())\n+                elif isinstance(field, RelationList):\n+                    if value:\n+                        field.set(\n+                            obj,\n+                            [RelationValue(i.to_id) for i in value if not i.isBroken()],\n+                        )\n+                elif isinstance(field, RelationChoice):\n+                    if value and not value.isBroken():\n+                        field.set(obj, RelationValue(value.to_id))\n                 else:\n                     field.set(obj, value)\n \n+        update_relation_catalog(obj)\n         obj.reindexObject()\n \n         # copy annotations\n@@ -232,9 +247,18 @@ def _replaceBaseline(self, baseline):\n                     baseline.expiration_date = self.context.expiration_date\n                 elif name == "subjects":\n                     baseline.setSubject(self.context.Subject())\n+                elif isinstance(field, RelationList):\n+                    if value:\n+                        field.set(\n+                            baseline,\n+                            [RelationValue(i.to_id) for i in value if not i.isBroken()],\n+                        )\n+                elif isinstance(field, RelationChoice):\n+                    if value and not value.isBroken():\n+                        field.set(baseline, RelationValue(value.to_id))\n                 else:\n                     field.set(baseline, value)\n-\n+        update_relation_catalog(baseline)\n         baseline.reindexObject()\n \n         # Move working children (newly created objects)\n@@ -259,3 +283,12 @@ def _replaceBaseline(self, baseline):\n         wc_container._delObject(wc_id)\n \n         return baseline\n+\n+\n+def update_relation_catalog(obj):\n+    # updateRelations from z3c.relationfield does not properly update relations in behaviors\n+    # that are registered with a marker-interface.\n+    # update_behavior_relations from plone.app.relationfield does that but does not update\n+    # those in the main schema.\n+    updateRelations(obj, None)\n+    update_behavior_relations(obj, None)\ndiff --git a/plone/app/iterate/tests/test_containers.py b/plone/app/iterate/tests/test_containers.py\nindex f295f3a..b79735d 100644\n--- a/plone/app/iterate/tests/test_containers.py\n+++ b/plone/app/iterate/tests/test_containers.py\n@@ -29,6 +29,7 @@\n from plone.app.testing import TEST_USER_ID\n from plone.app.testing import TEST_USER_NAME\n from plone.dexterity.utils import createContentInContainer\n+from z3c.relationfield import RelationValue\n from zc.relation.interfaces import ICatalog\n from zope import component\n from zope.intid.interfaces import IIntIds\n@@ -304,3 +305,28 @@ def test_relationship_deleted_on_cancel_checkout(self):\n         rels = list(catalog.findRelations({"from_id": obj_id}))\n \n         self.assertEqual(len(rels), 0)\n+\n+    def test_relationfield_handling(self):\n+        # relations are not simply copied\n+        folder = self.portal.docs\n+        doc = folder.doc1\n+        target = folder.doc2\n+        intids = component.getUtility(IIntIds)\n+        doc.relatedItems = [RelationValue(intids.getId(target))]\n+        wc = ICheckinCheckoutPolicy(doc).checkout(doc)\n+        self.assertNotEqual(doc.relatedItems[0], wc.relatedItems[0])\n+        self.assertEqual(doc.relatedItems[0].to_object, target)\n+        self.assertEqual(doc.relatedItems[0].from_object, doc)\n+        self.assertEqual(wc.relatedItems[0].to_object, target)\n+        self.assertEqual(wc.relatedItems[0].from_object, wc)\n+        wc = ICheckinCheckoutPolicy(wc).checkin("modified")\n+        self.assertEqual(doc.relatedItems[0].to_object, target)\n+        self.assertEqual(doc.relatedItems[0].from_object, doc)\n+        self.assertEqual(len(doc.relatedItems), 1)\n+\n+        wc = ICheckinCheckoutPolicy(doc).checkout(doc)\n+        wc.relatedItems = [RelationValue(intids.getId(folder))]\n+        wc = ICheckinCheckoutPolicy(wc).checkin("modified")\n+        self.assertEqual(doc.relatedItems[0].to_object, folder)\n+        self.assertEqual(doc.relatedItems[0].from_object, doc)\n+        self.assertEqual(len(doc.relatedItems), 1)\ndiff --git a/setup.py b/setup.py\nindex 9363559..13dd918 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -45,6 +45,7 @@\n     install_requires=[\n         "Acquisition",\n         "DateTime",\n+        "plone.app.relationfield",\n         "plone.locking",\n         "plone.memoize",\n         "Products.CMFEditions",\n'

