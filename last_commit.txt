Repository: plone.app.linkintegrity


Branch: refs/heads/master
Date: 2024-05-14T19:55:52+02:00
Author: Paul Grunewald (pgrunewald) <paul.grunewald@tu-dresden.de>
Commit: https://github.com/plone/plone.app.linkintegrity/commit/3d2a436b11960dd5a37c0b01b02b8b2c6f9960ab

Fix potential issue calculating breaches with objects sharing the same prefix

Files changed:
A news/97.bugfix
M plone/app/linkintegrity/browser/info.py
M plone/app/linkintegrity/tests/test_references.py

b'diff --git a/news/97.bugfix b/news/97.bugfix\nnew file mode 100644\nindex 0000000..ed4ac8f\n--- /dev/null\n+++ b/news/97.bugfix\n@@ -0,0 +1,2 @@\n+Fix potential issue calculating breaches with objects sharing the same prefix\n+[pgrunewald]\n\\ No newline at end of file\ndiff --git a/plone/app/linkintegrity/browser/info.py b/plone/app/linkintegrity/browser/info.py\nindex 4f6df41..41d7e35 100644\n--- a/plone/app/linkintegrity/browser/info.py\n+++ b/plone/app/linkintegrity/browser/info.py\n@@ -64,6 +64,8 @@ def get_breaches(self, items=None):\n             # list of uids that are ignored\n             uids_to_ignore.update([i.UID for i in brains_to_delete])\n \n+        excluded_paths = set(path2obj.keys())\n+\n         # determine breaches\n         for obj_path, obj in path2obj.items():\n             brains_to_delete = path2brains[obj_path]\n@@ -77,7 +79,7 @@ def get_breaches(self, items=None):\n                     continue\n                 # look into potential breach\n                 breach = self.check_object(\n-                    obj=obj_to_delete, excluded_paths=set(path2obj.keys())\n+                    obj=obj_to_delete, excluded_paths=excluded_paths\n                 )\n                 if breach:\n                     for source in breach["sources"]:\n@@ -134,7 +136,8 @@ def check_object(self, obj, excluded_path=None, excluded_paths=None):\n                 continue\n             if any(\n                 [\n-                    source_path.startswith(excluded_path)\n+                    source_path == excluded_path\n+                    or source_path.startswith(excluded_path + "/")\n                     for excluded_path in excluded_paths\n                 ]\n             ):\ndiff --git a/plone/app/linkintegrity/tests/test_references.py b/plone/app/linkintegrity/tests/test_references.py\nindex 1afb921..945b6cd 100644\n--- a/plone/app/linkintegrity/tests/test_references.py\n+++ b/plone/app/linkintegrity/tests/test_references.py\n@@ -278,3 +278,40 @@ def test_sources_with_multiple_links_can_appear_multiple_times(self):\n         view = self.portal.restrictedTraverse("@@delete_confirmation_info")\n         # deleting the two referenced document results in two reported breaches\n         self.assertEqual(len(view.get_breaches([doc1, doc2])), 2)\n+\n+    def test_if_breaches_under_excluded_paths_are_ignored(self):\n+        """Test, if breaches are ignored under certain conditions."""\n+        folder_containing_doc4 = self.portal.folder1\n+        doc4 = self.portal.folder1.doc4\n+        doc1 = self.portal.doc1\n+        set_text(doc4, \'<a href="doc1">d1</a>\')\n+        # sanity check: deleting doc1 causes one breach\n+        doc4_breaches = {r.to_object for r in getOutgoingLinks(doc4)}\n+        self.assertEqual({doc1}, doc4_breaches)\n+        view = self.portal.restrictedTraverse("@@delete_confirmation_info")\n+        self.assertEqual(len(view.get_breaches([doc1])), 1)\n+        # now check for other ways, that should do not produce any breach:\n+        # a) we delete the document that links to doc1\n+        self.assertEqual(len(view.get_breaches([doc1, doc4])), 0)\n+        # b) we delete the folder, containing the document that links to doc1\n+        self.assertEqual(len(view.get_breaches([doc1, folder_containing_doc4])), 0)\n+\n+    def test_if_same_prefix_and_breaches_work(self):\n+        """Verify that the same prefix does not lead to acciddental ignored\n+        links / breaches.\n+        """\n+        from plone.app.linkintegrity.testing import create\n+\n+        doc1 = self.portal.doc1\n+        my_page = create(self.portal, "Document", id="my-page", title="My page")\n+        my_page2 = create(\n+            self.portal,\n+            "Document",\n+            id="my-page-being-linked",\n+            title="My Page Being Linked",\n+        )\n+        # Create a link, that might be overlooked since both page\' ids start\n+        # with the same string ("my-page").\n+        set_text(doc1, \'<a href="my-page-being-linked">.</a>\')\n+        view = self.portal.restrictedTraverse("@@delete_confirmation_info")\n+        self.assertEqual(len(view.get_breaches([my_page, my_page2])), 1)\n'

Repository: plone.app.linkintegrity


Branch: refs/heads/master
Date: 2024-05-25T12:24:43-07:00
Author: David Glick (davisagli) <david.glick@plone.org>
Commit: https://github.com/plone/plone.app.linkintegrity/commit/bbf124e601cd3f0d3834904043fd4ca4ab45e355

Merge pull request #104 from plone/fix_97

Fix potential issue calculating breaches with objects sharing the same prefix

Files changed:
A news/97.bugfix
M plone/app/linkintegrity/browser/info.py
M plone/app/linkintegrity/tests/test_references.py

b'diff --git a/news/97.bugfix b/news/97.bugfix\nnew file mode 100644\nindex 0000000..ed4ac8f\n--- /dev/null\n+++ b/news/97.bugfix\n@@ -0,0 +1,2 @@\n+Fix potential issue calculating breaches with objects sharing the same prefix\n+[pgrunewald]\n\\ No newline at end of file\ndiff --git a/plone/app/linkintegrity/browser/info.py b/plone/app/linkintegrity/browser/info.py\nindex 4f6df41..41d7e35 100644\n--- a/plone/app/linkintegrity/browser/info.py\n+++ b/plone/app/linkintegrity/browser/info.py\n@@ -64,6 +64,8 @@ def get_breaches(self, items=None):\n             # list of uids that are ignored\n             uids_to_ignore.update([i.UID for i in brains_to_delete])\n \n+        excluded_paths = set(path2obj.keys())\n+\n         # determine breaches\n         for obj_path, obj in path2obj.items():\n             brains_to_delete = path2brains[obj_path]\n@@ -77,7 +79,7 @@ def get_breaches(self, items=None):\n                     continue\n                 # look into potential breach\n                 breach = self.check_object(\n-                    obj=obj_to_delete, excluded_paths=set(path2obj.keys())\n+                    obj=obj_to_delete, excluded_paths=excluded_paths\n                 )\n                 if breach:\n                     for source in breach["sources"]:\n@@ -134,7 +136,8 @@ def check_object(self, obj, excluded_path=None, excluded_paths=None):\n                 continue\n             if any(\n                 [\n-                    source_path.startswith(excluded_path)\n+                    source_path == excluded_path\n+                    or source_path.startswith(excluded_path + "/")\n                     for excluded_path in excluded_paths\n                 ]\n             ):\ndiff --git a/plone/app/linkintegrity/tests/test_references.py b/plone/app/linkintegrity/tests/test_references.py\nindex 1afb921..945b6cd 100644\n--- a/plone/app/linkintegrity/tests/test_references.py\n+++ b/plone/app/linkintegrity/tests/test_references.py\n@@ -278,3 +278,40 @@ def test_sources_with_multiple_links_can_appear_multiple_times(self):\n         view = self.portal.restrictedTraverse("@@delete_confirmation_info")\n         # deleting the two referenced document results in two reported breaches\n         self.assertEqual(len(view.get_breaches([doc1, doc2])), 2)\n+\n+    def test_if_breaches_under_excluded_paths_are_ignored(self):\n+        """Test, if breaches are ignored under certain conditions."""\n+        folder_containing_doc4 = self.portal.folder1\n+        doc4 = self.portal.folder1.doc4\n+        doc1 = self.portal.doc1\n+        set_text(doc4, \'<a href="doc1">d1</a>\')\n+        # sanity check: deleting doc1 causes one breach\n+        doc4_breaches = {r.to_object for r in getOutgoingLinks(doc4)}\n+        self.assertEqual({doc1}, doc4_breaches)\n+        view = self.portal.restrictedTraverse("@@delete_confirmation_info")\n+        self.assertEqual(len(view.get_breaches([doc1])), 1)\n+        # now check for other ways, that should do not produce any breach:\n+        # a) we delete the document that links to doc1\n+        self.assertEqual(len(view.get_breaches([doc1, doc4])), 0)\n+        # b) we delete the folder, containing the document that links to doc1\n+        self.assertEqual(len(view.get_breaches([doc1, folder_containing_doc4])), 0)\n+\n+    def test_if_same_prefix_and_breaches_work(self):\n+        """Verify that the same prefix does not lead to acciddental ignored\n+        links / breaches.\n+        """\n+        from plone.app.linkintegrity.testing import create\n+\n+        doc1 = self.portal.doc1\n+        my_page = create(self.portal, "Document", id="my-page", title="My page")\n+        my_page2 = create(\n+            self.portal,\n+            "Document",\n+            id="my-page-being-linked",\n+            title="My Page Being Linked",\n+        )\n+        # Create a link, that might be overlooked since both page\' ids start\n+        # with the same string ("my-page").\n+        set_text(doc1, \'<a href="my-page-being-linked">.</a>\')\n+        view = self.portal.restrictedTraverse("@@delete_confirmation_info")\n+        self.assertEqual(len(view.get_breaches([my_page, my_page2])), 1)\n'

