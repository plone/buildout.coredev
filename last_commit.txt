Repository: plone.reload


Branch: refs/heads/master
Date: 2024-01-23T16:58:40+01:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.reload/commit/816035702f1e177a3aacd1e8f9ec86646977acfe

Try to add support for Python 3.12

Files changed:
M plone/reload/code.py
M plone/reload/xreload.py

b'diff --git a/plone/reload/code.py b/plone/reload/code.py\nindex 14ee521..2ce7b10 100644\n--- a/plone/reload/code.py\n+++ b/plone/reload/code.py\n@@ -10,39 +10,17 @@\n _marker = object()\n MOD_TIMES = dict()\n \n+from importlib.util import cache_from_source, source_from_cache\n \n-try:\n-    # Py3\n-    from imp import cache_from_source, source_from_cache\n-\n-    def _cache_from_source(path):\n-        if \'__pycache__\' in path:\n-            return path\n-        return cache_from_source(path)\n-\n-    def _source_from_cache(path):\n-        if \'__pycache__\' in path:\n-            return source_from_cache(path)\n+def _cache_from_source(path):\n+    if \'__pycache__\' in path:\n         return path\n+    return cache_from_source(path)\n \n-except ImportError:\n-    # Py2\n-    def _cache_from_source(path):\n-        if path.endswith(\'pyc\') or path.endswith(\'pyo\'):\n-            cache = path\n-        else:\n-            cache = path + \'c\'\n-        if os.path.isfile(cache):\n-            path = cache\n-        return path\n-\n-    def _source_from_cache(path):\n-        source = path\n-        if path.endswith(\'pyc\') or path.endswith(\'pyo\'):\n-            source = path[:-1]\n-        if os.path.isfile(source):\n-            path = source\n-        return path\n+def _source_from_cache(path):\n+    if \'__pycache__\' in path:\n+        return source_from_cache(path)\n+    return path\n \n \n def in_search_path(path):\ndiff --git a/plone/reload/xreload.py b/plone/reload/xreload.py\nindex 4b5a56c..9f1ee36 100644\n--- a/plone/reload/xreload.py\n+++ b/plone/reload/xreload.py\n@@ -13,15 +13,16 @@\n """\n \n import marshal\n-import imp\n+import importlib\n import sys\n import types\n import inspect\n \n import six\n-from six.moves import reload_module\n+from importlib import reload as reload_module\n import zope.component\n \n+# from zope.interface.interface import Specification\n \n CLASS_STATICS = frozenset(["__dict__", "__doc__", "__module__", "__weakref__"])\n \n@@ -60,34 +61,24 @@ def reload(self):\n         if pkgname:\n             # We\'re not reloading the package, only the module in it\n             pkg = sys.modules[pkgname]\n-            path = pkg.__path__  # Search inside the package\n         else:\n             # Search the top-level module path\n             pkg = None\n-            path = None  # Make find_module() uses the default search path\n-        # Find the module; may raise ImportError\n-        (stream, filename, (suffix, mode, kind)) = imp.find_module(\n-            modname, path)\n-        # Turn it into a code object\n-        try:\n-            # Is it Python source code or byte code read from a file?\n-            # XXX Could handle frozen modules, zip-import modules\n-            if kind not in (imp.PY_COMPILED, imp.PY_SOURCE):\n-                # Fall back to built-in reload()\n-                return reload_module(self.mod)\n-            if kind == imp.PY_SOURCE:\n+        package_name = pkg.__name__ if pkg else None\n+        specs = importlib.util.find_spec(self.mod.__name__, package=package_name)\n+        filename = specs.origin\n+        if specs.has_location:\n+            with open(filename, \'rb\') as stream:\n                 source = stream.read()\n                 # PeterB: if we don\'t strip the source code and add newline we\n                 # get a SyntaxError even if `python $filename` is perfectly\n                 # happy.\n-                source = source.strip() + \'\\n\'\n+                source = source.strip() + b\'\\n\'\n                 code = compile(source, filename, "exec")\n-            else:\n-                # I have no idea how to test this one\n-                code = marshal.load(stream)  # pragma NO COVER\n-        finally:\n-            if stream:\n-                stream.close()\n+        else:\n+            # Fall back to built-in reload()\n+            return reload_module(self.mod)\n+\n         # Execute the code im a temporary namespace; if this fails, no changes\n         tmpns = {\'__name__\': \'%s.%s\' % (pkgname, modname),\n                  \'__file__\': filename,\n@@ -168,13 +159,12 @@ def _update_scope(oldscope, newscope):\n \n def _update_function(oldfunc, newfunc):\n     """Update a function object."""\n-    if _closure_changed(six.get_function_closure(oldfunc),\n-                        six.get_function_closure(newfunc)):\n+    if _closure_changed(oldfunc.__closure__,\n+                        newfunc.__closure__):\n         raise ClosureChanged()\n-    setattr(oldfunc, six._func_code, six.get_function_code(newfunc))\n-    setattr(oldfunc, six._func_defaults, six.get_function_defaults(newfunc))\n-    _update_scope(six.get_function_globals(oldfunc),\n-                  six.get_function_globals(newfunc))\n+    setattr(oldfunc, "__code__", newfunc.__code__)\n+    setattr(oldfunc, "__defaults__", newfunc.__defaults__)\n+    _update_scope(oldfunc.__globals__, newfunc.__globals__)\n     # XXX What else?\n     return oldfunc\n \n'

Repository: plone.reload


Branch: refs/heads/master
Date: 2024-01-23T17:00:55+01:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.reload/commit/65d6c5d9e2a39e6114ee0c736550ad706519214d

add classifier and changenote

Files changed:
M CHANGES.rst
M setup.py

b'diff --git a/CHANGES.rst b/CHANGES.rst\nindex f3853b5..1bc8d42 100644\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -6,7 +6,8 @@ Changelog\n \n Breaking changes:\n \n-- *add item here*\n+- Add support for Python 3.12. Drop support for Python 2\n+  [pbauer]\n \n New features:\n \ndiff --git a/setup.py b/setup.py\nindex c6c6e4f..955b797 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -13,16 +13,18 @@\n         "Environment :: Web Environment",\n         "Framework :: Plone",\n         "Framework :: Zope2",\n-        "Framework :: Zope :: 4",\n+        "Framework :: Zope :: 5",\n         "License :: OSI Approved :: BSD License",\n         "Operating System :: OS Independent",\n         "Programming Language :: Python",\n-        "Programming Language :: Python :: 2",\n-        "Programming Language :: Python :: 2.7",\n         "Programming Language :: Python :: 3",\n         "Programming Language :: Python :: 3.6",\n         "Programming Language :: Python :: 3.7",\n         "Programming Language :: Python :: 3.8",\n+        "Programming Language :: Python :: 3.9",\n+        "Programming Language :: Python :: 3.10",\n+        "Programming Language :: Python :: 3.11",\n+        "Programming Language :: Python :: 3.12",\n         "Programming Language :: Python :: Implementation :: CPython",\n     ],\n     keywords=\'zope plone reload\',\n'

Repository: plone.reload


Branch: refs/heads/master
Date: 2024-01-24T12:18:43+01:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.reload/commit/958bab347ec71c0e8993421c09193f26da367db5

drop six

Files changed:
M plone/reload/browser.py
M plone/reload/code.py
M plone/reload/interfaces.py
M plone/reload/template.py
M plone/reload/xreload.py
M plone/reload/zcml.py
M setup.py

b'diff --git a/plone/reload/browser.py b/plone/reload/browser.py\nindex 3feee43..127d9b5 100644\n--- a/plone/reload/browser.py\n+++ b/plone/reload/browser.py\n@@ -15,22 +15,21 @@\n \n @implementer(IReload)\n class Reload(BrowserView):\n-    """Reload view.\n-    """\n+    """Reload view."""\n \n     def __init__(self, context, request):\n         BrowserView.__init__(self, context, request)\n         self.message = None\n \n     def __call__(self):\n-        action = self.request.form.get(\'action\')\n+        action = self.request.form.get("action")\n         if action is not None:\n             if self.available():\n-                if action == \'code\':\n+                if action == "code":\n                     self.message = self.code_reload()\n-                elif action == \'zcml\':\n+                elif action == "zcml":\n                     self.message = self.zcml_reload()\n-            if action == \'template\':\n+            if action == "template":\n                 self.message = self.template_reload()\n         return self.index()\n \n@@ -49,9 +48,9 @@ def template_reload(self):\n         if HAS_CMF:\n             reloaded = reload_template(self.context)\n             if reloaded > 0:\n-                return \'%s templates reloaded.\' % reloaded\n-            return \'No templates reloaded.\'\n-        return \'CMF is not installed. Templates cannot be reloaded.\'\n+                return "%s templates reloaded." % reloaded\n+            return "No templates reloaded."\n+        return "CMF is not installed. Templates cannot be reloaded."\n \n     def code_reload(self):\n         if not self.available():\n@@ -59,12 +58,12 @@ def code_reload(self):\n \n         reloaded = reload_code()\n \n-        result = \'\'\n+        result = ""\n         if reloaded:\n-            result += \'Code reloaded:\\n\\n\'\n-            result += \'\\n\'.join(reloaded)\n+            result += "Code reloaded:\\n\\n"\n+            result += "\\n".join(reloaded)\n         else:\n-            result = \'No code reloaded!\'\n+            result = "No code reloaded!"\n         return result\n \n     def zcml_reload(self):\n@@ -79,11 +78,11 @@ def zcml_reload(self):\n         # TODO Minimize all caches, we only really want to invalidate the\n         # local site manager from all caches\n         self.context._p_jar.db().cacheMinimize()\n-        result = \'\'\n+        result = ""\n         if reloaded:\n-            result += \'Code reloaded:\\n\\n\'\n-            result += \'\\n\'.join(reloaded)\n+            result += "Code reloaded:\\n\\n"\n+            result += "\\n".join(reloaded)\n         else:\n-            result = \'No code reloaded!\'\n-        result += \'\\n\\nGlobal ZCML reloaded.\'\n+            result = "No code reloaded!"\n+        result += "\\n\\nGlobal ZCML reloaded."\n         return result\ndiff --git a/plone/reload/code.py b/plone/reload/code.py\nindex 2ce7b10..fefdefa 100644\n--- a/plone/reload/code.py\n+++ b/plone/reload/code.py\n@@ -1,45 +1,43 @@\n-import os\n-import sys\n-\n-from os.path import abspath\n-from os.path import isfile\n-\n+from importlib.util import cache_from_source, source_from_cache\n from plone.reload import config\n from plone.reload.xreload import Reloader\n \n+import os\n+import sys\n+\n _marker = object()\n MOD_TIMES = dict()\n \n-from importlib.util import cache_from_source, source_from_cache\n \n def _cache_from_source(path):\n-    if \'__pycache__\' in path:\n+    if "__pycache__" in path:\n         return path\n     return cache_from_source(path)\n \n+\n def _source_from_cache(path):\n-    if \'__pycache__\' in path:\n+    if "__pycache__" in path:\n         return source_from_cache(path)\n     return path\n \n \n def in_search_path(path):\n-    if \'site-packages\' in path:\n+    if "site-packages" in path:\n         return False\n-    elif \'.egg\' in path:\n+    elif ".egg" in path:\n         return False\n     return True\n \n \n def search_modules():\n     modules = []\n-    for name, module in sys.modules.items():\n+    for _, module in sys.modules.items():\n         if module is not None:\n-            f = getattr(module, \'__file__\', None)\n+            f = getattr(module, "__file__", None)\n             # Standard library modules don\'t have a __file__\n             if f is None:\n                 continue\n-            f = abspath(_source_from_cache(f))\n+            f = os.path.abspath(_source_from_cache(f))\n             if config.EXCLUDE_SITE_PACKAGES:\n                 if in_search_path(f):\n                     modules.append((f, module))\n@@ -53,7 +51,7 @@ def get_mod_time(path):\n     # If we have the compiled source, look for the source code change date\n     path = _source_from_cache(path)\n     # protect against missing and unaccessible files\n-    if isfile(path):\n+    if os.path.isfile(path):\n         mtime = os.stat(path)[8]\n     return mtime\n \ndiff --git a/plone/reload/interfaces.py b/plone/reload/interfaces.py\nindex 839c7b9..3f401c7 100644\n--- a/plone/reload/interfaces.py\n+++ b/plone/reload/interfaces.py\n@@ -2,8 +2,7 @@\n \n \n class IReload(Interface):\n-    """Interface for the ZCML reload view.\n-    """\n+    """Interface for the ZCML reload view."""\n \n     def status():\n         """Return a status text."""\ndiff --git a/plone/reload/template.py b/plone/reload/template.py\nindex 73873d1..fe28c58 100644\n--- a/plone/reload/template.py\n+++ b/plone/reload/template.py\n@@ -8,7 +8,7 @@ def reload_skins(tool):\n     for folder in tool.objectValues():\n         for obj in folder.objectValues():\n             if isinstance(obj, FSObject):\n-                parsed = getattr(obj, \'_parsed\', 0)\n+                parsed = getattr(obj, "_parsed", 0)\n                 if parsed:\n                     obj._parsed = 0\n                     counter += 1\n@@ -19,7 +19,7 @@ def reload_template(root):\n     counter = 0\n     for obj in root.objectValues():\n         if ISiteRoot.providedBy(obj):\n-            tool = getToolByName(obj, \'portal_skins\', None)\n+            tool = getToolByName(obj, "portal_skins", None)\n             if tool is not None:\n                 counter = reload_skins(tool)\n     return counter\ndiff --git a/plone/reload/xreload.py b/plone/reload/xreload.py\nindex 9f1ee36..c97c977 100644\n--- a/plone/reload/xreload.py\n+++ b/plone/reload/xreload.py\n@@ -12,17 +12,13 @@\n \n """\n \n-import marshal\n+from importlib import reload\n+from zope.interface.interface import Specification\n+\n import importlib\n+import inspect\n import sys\n import types\n-import inspect\n-\n-import six\n-from importlib import reload as reload_module\n-import zope.component\n-\n-# from zope.interface.interface import Specification\n \n CLASS_STATICS = frozenset(["__dict__", "__doc__", "__module__", "__weakref__"])\n \n@@ -54,7 +50,7 @@ def reload(self):\n         # \'whatever\'\n         i = modname.rfind(".")\n         if i >= 0:\n-            pkgname, modname = modname[:i], modname[i + 1:]\n+            pkgname, modname = modname[:i], modname[i + 1 :]\n         else:\n             pkgname = None\n         # Compute the search path\n@@ -68,21 +64,23 @@ def reload(self):\n         specs = importlib.util.find_spec(self.mod.__name__, package=package_name)\n         filename = specs.origin\n         if specs.has_location:\n-            with open(filename, \'rb\') as stream:\n+            with open(filename, "rb") as stream:\n                 source = stream.read()\n                 # PeterB: if we don\'t strip the source code and add newline we\n                 # get a SyntaxError even if `python $filename` is perfectly\n                 # happy.\n-                source = source.strip() + b\'\\n\'\n+                source = source.strip() + b"\\n"\n                 code = compile(source, filename, "exec")\n         else:\n             # Fall back to built-in reload()\n-            return reload_module(self.mod)\n+            return reload(self.mod)\n \n         # Execute the code im a temporary namespace; if this fails, no changes\n-        tmpns = {\'__name__\': \'%s.%s\' % (pkgname, modname),\n-                 \'__file__\': filename,\n-                 \'__doc__\': modns[\'__doc__\']}\n+        tmpns = {\n+            "__name__": "%s.%s" % (pkgname, modname),\n+            "__file__": filename,\n+            "__doc__": modns["__doc__"],\n+        }\n         exec(code, tmpns)\n         # Now we get to the hard part\n         _update_scope(modns, tmpns)\n@@ -108,13 +106,13 @@ def _update(self, oldobj, newobj):\n             # Cop-out: if the type changed, give up\n             return newobj\n \n-        new_module = getattr(newobj, \'__module__\', None)\n+        new_module = getattr(newobj, "__module__", None)\n         if new_module != self.mod.__name__:\n             # Do not update objects in-place that have been imported.\n             # Just update their references.\n             return newobj\n \n-        if isinstance(newobj, zope.interface.interface.Specification):\n+        if isinstance(newobj, Specification):\n             # XXX we can\'t update interfaces because their internal\n             # data structures break. We\'ll have to implement the reload method\n             # for those and patch it in.\n@@ -153,14 +151,13 @@ def _update_scope(oldscope, newscope):\n         oldscope[name] = newscope[name]\n     # Delete names that are no longer current\n     for name in oldnames - newnames:\n-        if not name.startswith(\'__\'):\n+        if not name.startswith("__"):\n             del oldscope[name]\n \n \n def _update_function(oldfunc, newfunc):\n     """Update a function object."""\n-    if _closure_changed(oldfunc.__closure__,\n-                        newfunc.__closure__):\n+    if _closure_changed(oldfunc.__closure__, newfunc.__closure__):\n         raise ClosureChanged()\n     setattr(oldfunc, "__code__", newfunc.__code__)\n     setattr(oldfunc, "__defaults__", newfunc.__defaults__)\n@@ -172,8 +169,7 @@ def _update_function(oldfunc, newfunc):\n def _update_method(oldmeth, newmeth):\n     """Update a method object."""\n     # XXX What if im_func is not a function?\n-    _update_function(six.get_unbound_function(oldmeth),\n-                     six.get_unbound_function(newmeth))\n+    _update_function(oldmeth, newmeth)\n     return oldmeth\n \n \n@@ -202,7 +198,7 @@ def _update_class(oldclass, newclass):\n             if isinstance(new, (types.FunctionType, types.MethodType)):\n                 if isinstance(old, property) and not isinstance(new, property):\n                     # Removing a decorator\n-                    setattr(oldclass, name, six.get_unbound_function(new))\n+                    setattr(oldclass, name, new)\n                 elif isinstance(new, types.FunctionType):\n                     # Under Py3 there are only functions\n                     _update_function(old, new)\n@@ -220,6 +216,6 @@ def _update_class(oldclass, newclass):\n                     setattr(oldclass, name, new)\n         except ClosureChanged:\n             # If the closure changed, we need to replace the entire function\n-            setattr(oldclass, name, six.get_unbound_function(new))\n+            setattr(oldclass, name, new)\n \n     return oldclass\ndiff --git a/plone/reload/zcml.py b/plone/reload/zcml.py\nindex 445353b..a5e5062 100644\n--- a/plone/reload/zcml.py\n+++ b/plone/reload/zcml.py\n@@ -1,34 +1,25 @@\n from zope.component import getGlobalSiteManager\n+from zope.component.hooks import setSite\n from zope.testing import cleanup\n-\n-try:\n-    from zope.component.hooks import setSite\n-except ImportError:\n-    from zope.site.hooks import setSite\n-\n-\n-# BBB: Zope 2.12\n-try:\n-    from Zope2.App import zcml\n-    zcml  # pyflakes\n-except ImportError:\n-    from Products.Five import zcml\n-\n-\n-CORE_CLEANUPS = frozenset([\n-    \'OFS.metaconfigure\',\n-    \'Products.Five.zcml\',\n-    \'Products.Five.eventconfigure\',\n-    \'Products.Five.fiveconfigure\',\n-    \'Products.Five.sizeconfigure\',\n-    \'zope.component.globalregistry\',\n-    \'zope.component.hooks\',\n-    \'zope.schema.vocabulary\',\n-    \'zope.security.management\',\n-    \'zope.security.checker\',\n-    \'zope.site.hooks\',\n-    \'Zope2.App.zcml\',\n-])\n+from Zope2.App import zcml\n+\n+\n+CORE_CLEANUPS = frozenset(\n+    [\n+        "OFS.metaconfigure",\n+        "Products.Five.zcml",\n+        "Products.Five.eventconfigure",\n+        "Products.Five.fiveconfigure",\n+        "Products.Five.sizeconfigure",\n+        "zope.component.globalregistry",\n+        "zope.component.hooks",\n+        "zope.schema.vocabulary",\n+        "zope.security.management",\n+        "zope.security.checker",\n+        "zope.site.hooks",\n+        "Zope2.App.zcml",\n+    ]\n+)\n \n \n def cleanups():\ndiff --git a/setup.py b/setup.py\nindex 955b797..201c9b9 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -1,13 +1,12 @@\n from setuptools import setup\n \n-version = \'3.0.3.dev0\'\n+version = "3.0.3.dev0"\n \n setup(\n-    name=\'plone.reload\',\n+    name="plone.reload",\n     version=version,\n     description="Configuration and code reload without server restarts.",\n-    long_description=(open(\'README.rst\').read() + \'\\n\' +\n-                      open(\'CHANGES.rst\').read()),\n+    long_description=(open("README.rst").read() + "\\n" + open("CHANGES.rst").read()),\n     classifiers=[\n         "Development Status :: 5 - Production/Stable",\n         "Environment :: Web Environment",\n@@ -27,28 +26,27 @@\n         "Programming Language :: Python :: 3.12",\n         "Programming Language :: Python :: Implementation :: CPython",\n     ],\n-    keywords=\'zope plone reload\',\n-    author=\'Hanno Schlichting\',\n-    author_email=\'hanno@hannosch.eu\',\n-    url=\'https://pypi.org/project/plone.reload\',\n-    license=\'BSD\',\n-    packages=[\'plone\', \'plone.reload\'],\n-    namespace_packages=[\'plone\'],\n+    keywords="zope plone reload",\n+    author="Hanno Schlichting",\n+    author_email="hanno@hannosch.eu",\n+    url="https://pypi.org/project/plone.reload",\n+    license="BSD",\n+    packages=["plone", "plone.reload"],\n+    namespace_packages=["plone"],\n     include_package_data=True,\n     zip_safe=False,\n     install_requires=[\n-        \'setuptools\',\n-        \'six\',\n-        \'zope.component\',\n-        \'zope.interface\',\n-        \'zope.processlifetime\',\n-        \'zope.publisher\',\n-        \'zope.site\',\n-        \'zope.testing\',\n-        \'Zope2 >= 2.13\',\n+        "setuptools",\n+        "zope.component",\n+        "zope.interface",\n+        "zope.processlifetime",\n+        "zope.publisher",\n+        "zope.site",\n+        "zope.testing",\n+        "Zope2 >= 2.13",\n     ],\n     extras_require=dict(\n-        cmf=[\'Products.CMFCore\'],\n+        cmf=["Products.CMFCore"],\n     ),\n     entry_points="""\n     [z3c.autoinclude.plugin]\n'

Repository: plone.reload


Branch: refs/heads/master
Date: 2024-04-22T11:58:37+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.reload/commit/cbdbb5859bbabdd622df7ccd87abd6ec5da9fd9a

Merge pull request #18 from plone/python312

Add Support for Python 3.12 and drop Python 2 Support

Files changed:
M CHANGES.rst
M plone/reload/browser.py
M plone/reload/code.py
M plone/reload/interfaces.py
M plone/reload/template.py
M plone/reload/xreload.py
M plone/reload/zcml.py
M setup.py

b'diff --git a/CHANGES.rst b/CHANGES.rst\nindex f3853b5..1bc8d42 100644\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -6,7 +6,8 @@ Changelog\n \n Breaking changes:\n \n-- *add item here*\n+- Add support for Python 3.12. Drop support for Python 2\n+  [pbauer]\n \n New features:\n \ndiff --git a/plone/reload/browser.py b/plone/reload/browser.py\nindex 3feee43..127d9b5 100644\n--- a/plone/reload/browser.py\n+++ b/plone/reload/browser.py\n@@ -15,22 +15,21 @@\n \n @implementer(IReload)\n class Reload(BrowserView):\n-    """Reload view.\n-    """\n+    """Reload view."""\n \n     def __init__(self, context, request):\n         BrowserView.__init__(self, context, request)\n         self.message = None\n \n     def __call__(self):\n-        action = self.request.form.get(\'action\')\n+        action = self.request.form.get("action")\n         if action is not None:\n             if self.available():\n-                if action == \'code\':\n+                if action == "code":\n                     self.message = self.code_reload()\n-                elif action == \'zcml\':\n+                elif action == "zcml":\n                     self.message = self.zcml_reload()\n-            if action == \'template\':\n+            if action == "template":\n                 self.message = self.template_reload()\n         return self.index()\n \n@@ -49,9 +48,9 @@ def template_reload(self):\n         if HAS_CMF:\n             reloaded = reload_template(self.context)\n             if reloaded > 0:\n-                return \'%s templates reloaded.\' % reloaded\n-            return \'No templates reloaded.\'\n-        return \'CMF is not installed. Templates cannot be reloaded.\'\n+                return "%s templates reloaded." % reloaded\n+            return "No templates reloaded."\n+        return "CMF is not installed. Templates cannot be reloaded."\n \n     def code_reload(self):\n         if not self.available():\n@@ -59,12 +58,12 @@ def code_reload(self):\n \n         reloaded = reload_code()\n \n-        result = \'\'\n+        result = ""\n         if reloaded:\n-            result += \'Code reloaded:\\n\\n\'\n-            result += \'\\n\'.join(reloaded)\n+            result += "Code reloaded:\\n\\n"\n+            result += "\\n".join(reloaded)\n         else:\n-            result = \'No code reloaded!\'\n+            result = "No code reloaded!"\n         return result\n \n     def zcml_reload(self):\n@@ -79,11 +78,11 @@ def zcml_reload(self):\n         # TODO Minimize all caches, we only really want to invalidate the\n         # local site manager from all caches\n         self.context._p_jar.db().cacheMinimize()\n-        result = \'\'\n+        result = ""\n         if reloaded:\n-            result += \'Code reloaded:\\n\\n\'\n-            result += \'\\n\'.join(reloaded)\n+            result += "Code reloaded:\\n\\n"\n+            result += "\\n".join(reloaded)\n         else:\n-            result = \'No code reloaded!\'\n-        result += \'\\n\\nGlobal ZCML reloaded.\'\n+            result = "No code reloaded!"\n+        result += "\\n\\nGlobal ZCML reloaded."\n         return result\ndiff --git a/plone/reload/code.py b/plone/reload/code.py\nindex 14ee521..fefdefa 100644\n--- a/plone/reload/code.py\n+++ b/plone/reload/code.py\n@@ -1,67 +1,43 @@\n-import os\n-import sys\n-\n-from os.path import abspath\n-from os.path import isfile\n-\n+from importlib.util import cache_from_source, source_from_cache\n from plone.reload import config\n from plone.reload.xreload import Reloader\n \n+import os\n+import sys\n+\n _marker = object()\n MOD_TIMES = dict()\n \n \n-try:\n-    # Py3\n-    from imp import cache_from_source, source_from_cache\n-\n-    def _cache_from_source(path):\n-        if \'__pycache__\' in path:\n-            return path\n-        return cache_from_source(path)\n-\n-    def _source_from_cache(path):\n-        if \'__pycache__\' in path:\n-            return source_from_cache(path)\n+def _cache_from_source(path):\n+    if "__pycache__" in path:\n         return path\n+    return cache_from_source(path)\n \n-except ImportError:\n-    # Py2\n-    def _cache_from_source(path):\n-        if path.endswith(\'pyc\') or path.endswith(\'pyo\'):\n-            cache = path\n-        else:\n-            cache = path + \'c\'\n-        if os.path.isfile(cache):\n-            path = cache\n-        return path\n \n-    def _source_from_cache(path):\n-        source = path\n-        if path.endswith(\'pyc\') or path.endswith(\'pyo\'):\n-            source = path[:-1]\n-        if os.path.isfile(source):\n-            path = source\n-        return path\n+def _source_from_cache(path):\n+    if "__pycache__" in path:\n+        return source_from_cache(path)\n+    return path\n \n \n def in_search_path(path):\n-    if \'site-packages\' in path:\n+    if "site-packages" in path:\n         return False\n-    elif \'.egg\' in path:\n+    elif ".egg" in path:\n         return False\n     return True\n \n \n def search_modules():\n     modules = []\n-    for name, module in sys.modules.items():\n+    for _, module in sys.modules.items():\n         if module is not None:\n-            f = getattr(module, \'__file__\', None)\n+            f = getattr(module, "__file__", None)\n             # Standard library modules don\'t have a __file__\n             if f is None:\n                 continue\n-            f = abspath(_source_from_cache(f))\n+            f = os.path.abspath(_source_from_cache(f))\n             if config.EXCLUDE_SITE_PACKAGES:\n                 if in_search_path(f):\n                     modules.append((f, module))\n@@ -75,7 +51,7 @@ def get_mod_time(path):\n     # If we have the compiled source, look for the source code change date\n     path = _source_from_cache(path)\n     # protect against missing and unaccessible files\n-    if isfile(path):\n+    if os.path.isfile(path):\n         mtime = os.stat(path)[8]\n     return mtime\n \ndiff --git a/plone/reload/interfaces.py b/plone/reload/interfaces.py\nindex 839c7b9..3f401c7 100644\n--- a/plone/reload/interfaces.py\n+++ b/plone/reload/interfaces.py\n@@ -2,8 +2,7 @@\n \n \n class IReload(Interface):\n-    """Interface for the ZCML reload view.\n-    """\n+    """Interface for the ZCML reload view."""\n \n     def status():\n         """Return a status text."""\ndiff --git a/plone/reload/template.py b/plone/reload/template.py\nindex 73873d1..fe28c58 100644\n--- a/plone/reload/template.py\n+++ b/plone/reload/template.py\n@@ -8,7 +8,7 @@ def reload_skins(tool):\n     for folder in tool.objectValues():\n         for obj in folder.objectValues():\n             if isinstance(obj, FSObject):\n-                parsed = getattr(obj, \'_parsed\', 0)\n+                parsed = getattr(obj, "_parsed", 0)\n                 if parsed:\n                     obj._parsed = 0\n                     counter += 1\n@@ -19,7 +19,7 @@ def reload_template(root):\n     counter = 0\n     for obj in root.objectValues():\n         if ISiteRoot.providedBy(obj):\n-            tool = getToolByName(obj, \'portal_skins\', None)\n+            tool = getToolByName(obj, "portal_skins", None)\n             if tool is not None:\n                 counter = reload_skins(tool)\n     return counter\ndiff --git a/plone/reload/xreload.py b/plone/reload/xreload.py\nindex 4b5a56c..c97c977 100644\n--- a/plone/reload/xreload.py\n+++ b/plone/reload/xreload.py\n@@ -12,16 +12,13 @@\n \n """\n \n-import marshal\n-import imp\n+from importlib import reload\n+from zope.interface.interface import Specification\n+\n+import importlib\n+import inspect\n import sys\n import types\n-import inspect\n-\n-import six\n-from six.moves import reload_module\n-import zope.component\n-\n \n CLASS_STATICS = frozenset(["__dict__", "__doc__", "__module__", "__weakref__"])\n \n@@ -53,45 +50,37 @@ def reload(self):\n         # \'whatever\'\n         i = modname.rfind(".")\n         if i >= 0:\n-            pkgname, modname = modname[:i], modname[i + 1:]\n+            pkgname, modname = modname[:i], modname[i + 1 :]\n         else:\n             pkgname = None\n         # Compute the search path\n         if pkgname:\n             # We\'re not reloading the package, only the module in it\n             pkg = sys.modules[pkgname]\n-            path = pkg.__path__  # Search inside the package\n         else:\n             # Search the top-level module path\n             pkg = None\n-            path = None  # Make find_module() uses the default search path\n-        # Find the module; may raise ImportError\n-        (stream, filename, (suffix, mode, kind)) = imp.find_module(\n-            modname, path)\n-        # Turn it into a code object\n-        try:\n-            # Is it Python source code or byte code read from a file?\n-            # XXX Could handle frozen modules, zip-import modules\n-            if kind not in (imp.PY_COMPILED, imp.PY_SOURCE):\n-                # Fall back to built-in reload()\n-                return reload_module(self.mod)\n-            if kind == imp.PY_SOURCE:\n+        package_name = pkg.__name__ if pkg else None\n+        specs = importlib.util.find_spec(self.mod.__name__, package=package_name)\n+        filename = specs.origin\n+        if specs.has_location:\n+            with open(filename, "rb") as stream:\n                 source = stream.read()\n                 # PeterB: if we don\'t strip the source code and add newline we\n                 # get a SyntaxError even if `python $filename` is perfectly\n                 # happy.\n-                source = source.strip() + \'\\n\'\n+                source = source.strip() + b"\\n"\n                 code = compile(source, filename, "exec")\n-            else:\n-                # I have no idea how to test this one\n-                code = marshal.load(stream)  # pragma NO COVER\n-        finally:\n-            if stream:\n-                stream.close()\n+        else:\n+            # Fall back to built-in reload()\n+            return reload(self.mod)\n+\n         # Execute the code im a temporary namespace; if this fails, no changes\n-        tmpns = {\'__name__\': \'%s.%s\' % (pkgname, modname),\n-                 \'__file__\': filename,\n-                 \'__doc__\': modns[\'__doc__\']}\n+        tmpns = {\n+            "__name__": "%s.%s" % (pkgname, modname),\n+            "__file__": filename,\n+            "__doc__": modns["__doc__"],\n+        }\n         exec(code, tmpns)\n         # Now we get to the hard part\n         _update_scope(modns, tmpns)\n@@ -117,13 +106,13 @@ def _update(self, oldobj, newobj):\n             # Cop-out: if the type changed, give up\n             return newobj\n \n-        new_module = getattr(newobj, \'__module__\', None)\n+        new_module = getattr(newobj, "__module__", None)\n         if new_module != self.mod.__name__:\n             # Do not update objects in-place that have been imported.\n             # Just update their references.\n             return newobj\n \n-        if isinstance(newobj, zope.interface.interface.Specification):\n+        if isinstance(newobj, Specification):\n             # XXX we can\'t update interfaces because their internal\n             # data structures break. We\'ll have to implement the reload method\n             # for those and patch it in.\n@@ -162,19 +151,17 @@ def _update_scope(oldscope, newscope):\n         oldscope[name] = newscope[name]\n     # Delete names that are no longer current\n     for name in oldnames - newnames:\n-        if not name.startswith(\'__\'):\n+        if not name.startswith("__"):\n             del oldscope[name]\n \n \n def _update_function(oldfunc, newfunc):\n     """Update a function object."""\n-    if _closure_changed(six.get_function_closure(oldfunc),\n-                        six.get_function_closure(newfunc)):\n+    if _closure_changed(oldfunc.__closure__, newfunc.__closure__):\n         raise ClosureChanged()\n-    setattr(oldfunc, six._func_code, six.get_function_code(newfunc))\n-    setattr(oldfunc, six._func_defaults, six.get_function_defaults(newfunc))\n-    _update_scope(six.get_function_globals(oldfunc),\n-                  six.get_function_globals(newfunc))\n+    setattr(oldfunc, "__code__", newfunc.__code__)\n+    setattr(oldfunc, "__defaults__", newfunc.__defaults__)\n+    _update_scope(oldfunc.__globals__, newfunc.__globals__)\n     # XXX What else?\n     return oldfunc\n \n@@ -182,8 +169,7 @@ def _update_function(oldfunc, newfunc):\n def _update_method(oldmeth, newmeth):\n     """Update a method object."""\n     # XXX What if im_func is not a function?\n-    _update_function(six.get_unbound_function(oldmeth),\n-                     six.get_unbound_function(newmeth))\n+    _update_function(oldmeth, newmeth)\n     return oldmeth\n \n \n@@ -212,7 +198,7 @@ def _update_class(oldclass, newclass):\n             if isinstance(new, (types.FunctionType, types.MethodType)):\n                 if isinstance(old, property) and not isinstance(new, property):\n                     # Removing a decorator\n-                    setattr(oldclass, name, six.get_unbound_function(new))\n+                    setattr(oldclass, name, new)\n                 elif isinstance(new, types.FunctionType):\n                     # Under Py3 there are only functions\n                     _update_function(old, new)\n@@ -230,6 +216,6 @@ def _update_class(oldclass, newclass):\n                     setattr(oldclass, name, new)\n         except ClosureChanged:\n             # If the closure changed, we need to replace the entire function\n-            setattr(oldclass, name, six.get_unbound_function(new))\n+            setattr(oldclass, name, new)\n \n     return oldclass\ndiff --git a/plone/reload/zcml.py b/plone/reload/zcml.py\nindex 445353b..a5e5062 100644\n--- a/plone/reload/zcml.py\n+++ b/plone/reload/zcml.py\n@@ -1,34 +1,25 @@\n from zope.component import getGlobalSiteManager\n+from zope.component.hooks import setSite\n from zope.testing import cleanup\n-\n-try:\n-    from zope.component.hooks import setSite\n-except ImportError:\n-    from zope.site.hooks import setSite\n-\n-\n-# BBB: Zope 2.12\n-try:\n-    from Zope2.App import zcml\n-    zcml  # pyflakes\n-except ImportError:\n-    from Products.Five import zcml\n-\n-\n-CORE_CLEANUPS = frozenset([\n-    \'OFS.metaconfigure\',\n-    \'Products.Five.zcml\',\n-    \'Products.Five.eventconfigure\',\n-    \'Products.Five.fiveconfigure\',\n-    \'Products.Five.sizeconfigure\',\n-    \'zope.component.globalregistry\',\n-    \'zope.component.hooks\',\n-    \'zope.schema.vocabulary\',\n-    \'zope.security.management\',\n-    \'zope.security.checker\',\n-    \'zope.site.hooks\',\n-    \'Zope2.App.zcml\',\n-])\n+from Zope2.App import zcml\n+\n+\n+CORE_CLEANUPS = frozenset(\n+    [\n+        "OFS.metaconfigure",\n+        "Products.Five.zcml",\n+        "Products.Five.eventconfigure",\n+        "Products.Five.fiveconfigure",\n+        "Products.Five.sizeconfigure",\n+        "zope.component.globalregistry",\n+        "zope.component.hooks",\n+        "zope.schema.vocabulary",\n+        "zope.security.management",\n+        "zope.security.checker",\n+        "zope.site.hooks",\n+        "Zope2.App.zcml",\n+    ]\n+)\n \n \n def cleanups():\ndiff --git a/setup.py b/setup.py\nindex c6c6e4f..201c9b9 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -1,52 +1,52 @@\n from setuptools import setup\n \n-version = \'3.0.3.dev0\'\n+version = "3.0.3.dev0"\n \n setup(\n-    name=\'plone.reload\',\n+    name="plone.reload",\n     version=version,\n     description="Configuration and code reload without server restarts.",\n-    long_description=(open(\'README.rst\').read() + \'\\n\' +\n-                      open(\'CHANGES.rst\').read()),\n+    long_description=(open("README.rst").read() + "\\n" + open("CHANGES.rst").read()),\n     classifiers=[\n         "Development Status :: 5 - Production/Stable",\n         "Environment :: Web Environment",\n         "Framework :: Plone",\n         "Framework :: Zope2",\n-        "Framework :: Zope :: 4",\n+        "Framework :: Zope :: 5",\n         "License :: OSI Approved :: BSD License",\n         "Operating System :: OS Independent",\n         "Programming Language :: Python",\n-        "Programming Language :: Python :: 2",\n-        "Programming Language :: Python :: 2.7",\n         "Programming Language :: Python :: 3",\n         "Programming Language :: Python :: 3.6",\n         "Programming Language :: Python :: 3.7",\n         "Programming Language :: Python :: 3.8",\n+        "Programming Language :: Python :: 3.9",\n+        "Programming Language :: Python :: 3.10",\n+        "Programming Language :: Python :: 3.11",\n+        "Programming Language :: Python :: 3.12",\n         "Programming Language :: Python :: Implementation :: CPython",\n     ],\n-    keywords=\'zope plone reload\',\n-    author=\'Hanno Schlichting\',\n-    author_email=\'hanno@hannosch.eu\',\n-    url=\'https://pypi.org/project/plone.reload\',\n-    license=\'BSD\',\n-    packages=[\'plone\', \'plone.reload\'],\n-    namespace_packages=[\'plone\'],\n+    keywords="zope plone reload",\n+    author="Hanno Schlichting",\n+    author_email="hanno@hannosch.eu",\n+    url="https://pypi.org/project/plone.reload",\n+    license="BSD",\n+    packages=["plone", "plone.reload"],\n+    namespace_packages=["plone"],\n     include_package_data=True,\n     zip_safe=False,\n     install_requires=[\n-        \'setuptools\',\n-        \'six\',\n-        \'zope.component\',\n-        \'zope.interface\',\n-        \'zope.processlifetime\',\n-        \'zope.publisher\',\n-        \'zope.site\',\n-        \'zope.testing\',\n-        \'Zope2 >= 2.13\',\n+        "setuptools",\n+        "zope.component",\n+        "zope.interface",\n+        "zope.processlifetime",\n+        "zope.publisher",\n+        "zope.site",\n+        "zope.testing",\n+        "Zope2 >= 2.13",\n     ],\n     extras_require=dict(\n-        cmf=[\'Products.CMFCore\'],\n+        cmf=["Products.CMFCore"],\n     ),\n     entry_points="""\n     [z3c.autoinclude.plugin]\n'

