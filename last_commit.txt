Repository: Products.CMFPlone


Branch: refs/heads/6.0.x
Date: 2023-06-06T11:49:30+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/Products.CMFPlone/commit/de784457007129fc0a772a49ffe21abb8aee0117

Relation helper fix by Katja.

Files changed:
A Products/CMFPlone/tests/test_relationhelper.py
A news/3457.bugfix
M Products/CMFPlone/relationhelper.py

b'diff --git a/Products/CMFPlone/relationhelper.py b/Products/CMFPlone/relationhelper.py\nindex 7a0a501aa9..fb1183998a 100644\n--- a/Products/CMFPlone/relationhelper.py\n+++ b/Products/CMFPlone/relationhelper.py\n@@ -1,5 +1,6 @@\n from collections import Counter\n from collections import defaultdict\n+from collections import OrderedDict\n from five.intid.intid import addIntIdSubscriber\n from plone.app.linkintegrity.handlers import modifiedContent\n from plone.app.linkintegrity.utils import referencedRelationship\n@@ -51,6 +52,7 @@ def rebuild_relations(context=None, flush_and_rebuild_intids=False):\n     else:\n         cleanup_intids()\n     restore_relations()\n+    log_relations()\n \n \n def get_relations_stats():\n@@ -62,7 +64,7 @@ def get_relations_stats():\n             rel = relation_catalog.resolveRelationToken(token)\n         except ObjectMissingError:\n             broken["Object is missing"] += 1\n-            logger.info(f"Token {token} has no object.")\n+            logger.warning(f"Token {token} has no object.")\n             continue\n \n         if rel.isBroken():\n@@ -73,8 +75,13 @@ def get_relations_stats():\n \n \n def get_all_relations():\n-    """Get all data from zc.relation catalog.\n-    Logs some useful statistics.\n+    """Get relations from zc.relation catalog.\n+\n+    Log statistics.\n+    Return list of dictionaries:\n+        from_uuid: source UID if available else None\n+        to_uuid: target UID if available else None\n+        from_attribute: relation name\n     """\n     results = []\n     info = defaultdict(int)\n@@ -84,25 +91,27 @@ def get_all_relations():\n         try:\n             rel = relation_catalog.resolveRelationToken(token)\n         except ObjectMissingError:\n-            logger.info(f"Token {token} has no object.")\n+            logger.warning(f"No relation for relation token \'{token}\'.")\n             continue\n \n-        if rel.from_object and rel.to_object:\n-            try:\n-                results.append(\n-                    {\n-                        "from_uuid": rel.from_object.UID(),\n-                        "to_uuid": rel.to_object.UID(),\n-                        "from_attribute": rel.from_attribute,\n-                    }\n-                )\n-                info[rel.from_attribute] += 1\n-            except AttributeError as ex:\n-                logger.info(f"Something went wrong while storing {rel}: \\n {ex}")\n-        else:\n-            logger.info(\n-                f"Dropping relation {rel.from_attribute} from {rel.from_object} to {rel.to_object}"\n+        rel_uid_info = OrderedDict()\n+        rel_uid_info["from_attribute"] = rel.from_attribute\n+        try:\n+            rel_uid_info["from_uuid"] = (\n+                rel.from_object.UID() if rel.from_object else None\n             )\n+        except AttributeError as e:\n+            rel_uid_info["from_uuid"] = None\n+            logger.warning(f"Broken relation: {rel_uid_info} \'{str(e)}\'")\n+        try:\n+            rel_uid_info["to_uuid"] = rel.to_object.UID() if rel.to_object else None\n+        except AttributeError as e:\n+            rel_uid_info["to_uuid"] = None\n+            logger.warning(f"Broken relation: {rel_uid_info} \'{str(e)}\'")\n+        info[rel.from_attribute] += 1\n+        results.append(rel_uid_info)\n+\n+    # Log stats\n     msg = ""\n     for key, value in info.items():\n         msg += f"{key}: {value}\\n"\n@@ -115,131 +124,142 @@ def store_relations(context=None):\n     all_relations = get_all_relations()\n     portal = getSite()\n     IAnnotations(portal)[RELATIONS_KEY] = all_relations\n-    logger.info(f"Stored {len(all_relations)} relations on the portal")\n \n \n def purge_relations(context=None):\n     """Removes all entries form zc.relation catalog.\n+\n     RelationValues that were set as attribute on content are still there!\n     These are removed/overwritten when restoring the relations.\n     """\n-    rel_catalog = getUtility(ICatalog)\n-    rel_catalog.clear()\n-    logger.info("Purged zc.relation catalog")\n+    relation_catalog = getUtility(ICatalog)\n+    relation_catalog.clear()\n+    logger.info("zc.relation catalog purged.")\n \n \n def restore_relations(context=None, all_relations=None):\n-    """Restore relations from a annotation on the portal."""\n+    """Restore relations from an annotation on the portal."""\n \n     portal = getSite()\n     if all_relations is None:\n         all_relations = IAnnotations(portal)[RELATIONS_KEY]\n-    logger.info(f"Loaded {len(all_relations)} relations to restore")\n+    logger.info(f"Loaded {len(all_relations)} relations to restore.")\n     update_linkintegrity = set()\n     modified_items = set()\n     modified_relation_lists = defaultdict(list)\n \n-    # remove duplicates but keep original order\n+    # Remove duplicates but keep original order.\n     unique_relations = []\n     seen = set()\n-    seen_add = seen.add\n     for rel in all_relations:\n         hashable = tuple(rel.items())\n         if hashable not in seen:\n             unique_relations.append(rel)\n-            seen_add(hashable)\n+            seen.add(hashable)\n         else:\n             logger.info(f"Dropping duplicate: {hashable}")\n \n     if len(unique_relations) < len(all_relations):\n         logger.info(f"Dropping {len(all_relations) - len(unique_relations)} duplicates")\n-        all_relations = unique_relations\n \n+    # Update relations.\n     intids = getUtility(IIntIds)\n-    for index, item in enumerate(all_relations, start=1):\n-        if not index % 500:\n-            logger.info(f"Restored {index} of {len(all_relations)} relations...")\n-\n-        try:\n-            source_obj = uuidToObject(item["from_uuid"])\n-        except KeyError:\n-            # brain exists but no object\n-            source_obj = None\n-        try:\n-            target_obj = uuidToObject(item["to_uuid"])\n-        except KeyError:\n-            # brain exists but no object\n-            target_obj = None\n-\n-        if not source_obj:\n-            logger.info(f\'{item["from_uuid"]} is missing\')\n-            continue\n-\n-        if not target_obj:\n-            logger.info(f\'{item["to_uuid"]} is missing\')\n+    new_index = 0\n+    for index, item in enumerate(unique_relations, start=1):\n+        # Get source object for UID. Skip relation if no object found.\n+        if item["from_uuid"] is None:\n+            logger.warning(f"No source object. {tuple(item.items())}.")\n             continue\n+        else:\n+            try:\n+                source_obj = uuidToObject(item["from_uuid"])\n+            except KeyError:\n+                # brain exists but no object\n+                source_obj = None\n \n+        # Get target object of UID. Do not skip relation, but update source_obj below.\n+        if item["to_uuid"] is None:\n+            target_obj = None\n+        else:\n+            try:\n+                target_obj = uuidToObject(item["to_uuid"])\n+            except KeyError:\n+                # brain exists but no object\n+                target_obj = None\n+        if target_obj is None:\n+            logger.warning(f"No target object. {tuple(item.items())}")\n+            # The source_obj will be updated to remove the broken relation below.\n+\n+        # source_obj and target_obj are dexterity content types.\n         if not IDexterityContent.providedBy(source_obj):\n-            logger.info(f"{source_obj} is no dexterity content")\n+            logger.warning(f"Source {source_obj} is no dexterity content.")\n             continue\n-\n         if not IDexterityContent.providedBy(target_obj):\n-            logger.info(f"{target_obj} is no dexterity content")\n-            continue\n+            logger.warning(f"Target {target_obj} is no dexterity content.")\n \n-        from_attribute = item["from_attribute"]\n+        # Get intId for target_obj.\n         try:\n             to_id = intids.getId(target_obj)\n         except KeyError:\n-            logger.warning(f"No intid for {target_obj}")\n-            continue\n+            logger.warning(f"No intId for {target_obj}")\n+            to_id = None\n \n+        # Postpone linkintegrity check.\n+        from_attribute = item["from_attribute"]\n         if from_attribute == referencedRelationship:\n-            # Ignore linkintegrity for now. We\'ll rebuilt it at the end!\n             update_linkintegrity.add(item["from_uuid"])\n             continue\n \n+        # Working copy relations\n         if HAS_ITERATE and from_attribute == ITERATE_RELATION_NAME:\n             # Iterate relations are not set as values of fields\n-            relation = StagingRelationValue(to_id)\n-            event._setRelation(source_obj, ITERATE_RELATION_NAME, relation)\n+            if to_id:\n+                relation = StagingRelationValue(to_id)\n+                event._setRelation(source_obj, ITERATE_RELATION_NAME, relation)\n             continue\n \n+        # Relations not based on schema field\n         field_and_schema = get_field_and_schema_for_fieldname(\n             from_attribute, source_obj.portal_type\n         )\n         if field_and_schema is None:\n             # the from_attribute is no field\n-            logger.info(f"No field. Setting relation: {item}")\n+            logger.info(f"No field. Setting relation: {tuple(item.items())}")\n             event._setRelation(source_obj, from_attribute, RelationValue(to_id))\n             continue\n \n         field, schema = field_and_schema\n-        relation = RelationValue(to_id)\n+        relationvalue = RelationValue(to_id) if to_id else None\n \n+        # schema field relations: RelationList, RelationChoice, Relation\n+        #\n+        # RelationList\n         if isinstance(field, RelationList):\n-            logger.info(\n-                f"Add relation to relationslist {from_attribute} from {source_obj.absolute_url()} to {target_obj.absolute_url()}"\n-            )\n+            if not target_obj:\n+                logger.warning(\n+                    f"Broken relation not restored: {from_attribute} from {source_obj.absolute_url()}"\n+                )\n+\n             if item["from_uuid"] in modified_relation_lists.get(from_attribute, []):\n                 # Do not purge relations\n                 existing_relations = getattr(source_obj, from_attribute, [])\n             else:\n                 # First touch. Make sure we purge!\n                 existing_relations = []\n-            existing_relations.append(relation)\n+            if relationvalue:\n+                existing_relations.append(relationvalue)\n             setattr(source_obj, from_attribute, existing_relations)\n             modified_items.add(item["from_uuid"])\n             modified_relation_lists[from_attribute].append(item["from_uuid"])\n-            continue\n \n+        # Relation, RelationChoice\n         elif isinstance(field, (Relation, RelationChoice)):\n-            logger.info(\n-                f"Add relation {from_attribute} from {source_obj.absolute_url()} to {target_obj.absolute_url()}"\n-            )\n-            setattr(source_obj, from_attribute, relation)\n+            if not target_obj:\n+                logger.info(\n+                    f"Broken relation not restored: {from_attribute} from {source_obj.absolute_url()}"\n+                )\n+            setattr(source_obj, from_attribute, relationvalue)\n             modified_items.add(item["from_uuid"])\n-            continue\n \n         else:\n             # we should never end up here!\n@@ -247,11 +267,18 @@ def restore_relations(context=None, all_relations=None):\n                 f"Unexpected relation {from_attribute} from {source_obj.absolute_url()} to {target_obj.absolute_url()}"\n             )\n \n+        new_index += 1\n+        if not new_index % 500:\n+            logger.info(f"Restored {new_index} relations.")\n+\n+    # Link integrity\n     update_linkintegrity = set(update_linkintegrity)\n-    logger.info(f"Updating linkintegrity for {len(update_linkintegrity)} items")\n+    logger.info(f"Updating linkintegrity for {len(update_linkintegrity)} items.")\n     for uuid in sorted(update_linkintegrity):\n         modifiedContent(uuidToObject(uuid), None)\n-    logger.info(f"Updating relations for {len(modified_items)} items")\n+\n+    # Reindex relations in relations catalog.\n+    logger.info(f"Updating relations for {len(modified_items)} items.")\n     for uuid in sorted(modified_items):\n         obj = uuidToObject(uuid)\n         # updateRelations from z3c.relationfield does not properly update relations in behaviors\n@@ -261,10 +288,25 @@ def restore_relations(context=None, all_relations=None):\n         updateRelations(obj, None)\n         update_behavior_relations(obj, None)\n \n-    # purge annotation from portal if they exist\n+    # Purge annotation from portal.\n     if RELATIONS_KEY in IAnnotations(portal):\n         del IAnnotations(portal)[RELATIONS_KEY]\n-    logger.info("Done!")\n+\n+    logger.info("All valid relations restored.")\n+\n+\n+def log_relations():\n+    info, broken = get_relations_stats()\n+    msg = ""\n+    for key, value in info.items():\n+        msg += f"{key}: {value}\\n"\n+    logger.info(f"\\nRestored relations: \\n{msg}")\n+\n+    if len(broken.items()) > 0:\n+        msg = ""\n+        for key, value in broken.items():\n+            msg += f"{key}: {value}\\n"\n+        logger.info(f"\\nStill broken relations: \\n{msg}")\n \n \n def get_intid(obj):\n@@ -291,6 +333,7 @@ def get_field_and_schema_for_fieldname(field_id, portal_type):\n \n \n def cleanup_intids(context=None):\n+    logger.info("Clean up intIds.")\n     intids = getUtility(IIntIds)\n     all_refs = [\n         f"{i.object.__class__.__module__}.{i.object.__class__.__name__}"\n@@ -298,6 +341,7 @@ def cleanup_intids(context=None):\n     ]\n     logger.info(Counter(all_refs))\n \n+    # Unregister RelationValues\n     count = 0\n     refs = [i for i in intids.refs.values() if isinstance(i.object, RelationValue)]\n     for ref in refs:\n@@ -305,31 +349,33 @@ def cleanup_intids(context=None):\n         count += 1\n     logger.info(f"Removed all {count} RelationValues from IntId-tool")\n \n+    # Unregister broken references\n     count = 0\n     for ref in intids.refs.values():\n         if "broken" in repr(ref.object):\n             intids.unregister(ref)\n-    logger.info(f"Removed {count} broken refs from IntId-tool")\n+    logger.info(f"Removed {count} broken references from IntId-tool")\n+\n     all_refs = [\n-        "{i.object.__class__.__module__}.{i.object.__class__.__name__}"\n+        f"{i.object.__class__.__module__}.{i.object.__class__.__name__}"\n         for i in intids.refs.values()\n     ]\n     logger.info(Counter(all_refs))\n \n \n def flush_intids():\n-    """Flush all intids"""\n+    """Flush all intIds"""\n     intids = getUtility(IIntIds)\n     intids.ids = intids.family.OI.BTree()\n     intids.refs = intids.family.IO.BTree()\n \n \n def rebuild_intids():\n-    """Create new intids"""\n+    """Create new intIds"""\n \n     def add_to_intids(obj, path):\n         if IContentish.providedBy(obj):\n-            logger.info(f"Added {obj} at {path} to intid")\n+            # logger.info(f"Added intId for {obj} at {path} to intId utility.")\n             addIntIdSubscriber(obj, None)\n \n     portal = getSite()\ndiff --git a/Products/CMFPlone/tests/test_relationhelper.py b/Products/CMFPlone/tests/test_relationhelper.py\nnew file mode 100644\nindex 0000000000..699c142dcf\n--- /dev/null\n+++ b/Products/CMFPlone/tests/test_relationhelper.py\n@@ -0,0 +1,139 @@\n+from plone import api\n+from plone.app.testing import setRoles\n+from plone.app.testing import TEST_USER_ID\n+from Products.CMFPlone.testing import PRODUCTS_CMFPLONE_INTEGRATION_TESTING\n+from zope.component import getUtility\n+from Products.CMFPlone.relationhelper import (\n+    get_relations_stats,\n+    purge_relations,\n+    rebuild_relations,\n+    restore_relations,\n+    store_relations,\n+)\n+from zope.intid.interfaces import IIntIds\n+\n+import unittest\n+\n+\n+class TestRelationhelper(unittest.TestCase):\n+    layer = PRODUCTS_CMFPLONE_INTEGRATION_TESTING\n+\n+    def setUp(self):\n+        self.portal = self.layer["portal"]\n+        self.request = self.layer["request"]\n+        setRoles(self.portal, TEST_USER_ID, ("Manager",))\n+\n+    def test_relations_stats(self):\n+        doc1 = api.content.create(type="Document", title="doc1", container=self.portal)\n+        doc2 = api.content.create(type="Document", title="doc2", container=self.portal)\n+        api.relation.create(doc1, doc2, "relatedItems")\n+\n+        stats, broken = get_relations_stats()\n+        self.assertEqual(dict(stats), {"relatedItems": 1})\n+        self.assertEqual(dict(broken), {})\n+\n+    def test_relations_stats_broken(self):\n+        doc1 = api.content.create(type="Document", title="doc1", container=self.portal)\n+        doc2 = api.content.create(type="Document", title="doc2", container=self.portal)\n+        api.relation.create(doc1, doc2, "relatedItems")\n+        self.portal._delObject("doc2")\n+\n+        stats, broken = get_relations_stats()\n+        self.assertEqual(dict(stats), {})\n+        self.assertEqual(dict(broken), {"relatedItems": 1})\n+\n+    def test_rebuild_relations(self):\n+        doc1 = api.content.create(type="Document", title="doc1", container=self.portal)\n+        doc2 = api.content.create(type="Document", title="doc2", container=self.portal)\n+        doc3 = api.content.create(type="Document", title="doc3", container=self.portal)\n+        intids = getUtility(IIntIds)\n+        doc1_intid = intids.getId(doc1)\n+        doc2_intid = intids.getId(doc2)\n+        doc3_intid = intids.getId(doc3)\n+\n+        api.relation.create(doc1, doc2, "relatedItems")\n+        api.relation.create(doc1, doc3, "relatedItems")\n+\n+        stats, broken = get_relations_stats()\n+        self.assertEqual(dict(stats), {"relatedItems": 2})\n+        self.assertEqual(dict(broken), {})\n+\n+        rebuild_relations()\n+\n+        # Relations are the same after a rebuild.\n+        stats, broken = get_relations_stats()\n+        self.assertEqual(dict(stats), {"relatedItems": 2})\n+        self.assertEqual(dict(broken), {})\n+\n+        # intids are not changed.\n+        doc1_intid_after = intids.getId(doc1)\n+        doc2_intid_after = intids.getId(doc2)\n+        doc3_intid_after = intids.getId(doc3)\n+        self.assertEqual(doc1_intid, doc1_intid_after)\n+        self.assertEqual(doc2_intid, doc2_intid_after)\n+        self.assertEqual(doc3_intid, doc3_intid_after)\n+\n+        # Break a relation by target.\n+        self.portal._delObject("doc2")\n+\n+        stats, broken = get_relations_stats()\n+        self.assertEqual(dict(stats), {"relatedItems": 1})\n+        self.assertEqual(dict(broken), {"relatedItems": 1})\n+\n+        # Broken relations are removed after rebuilding.\n+        rebuild_relations()\n+        stats, broken = get_relations_stats()\n+        self.assertEqual(dict(stats), {"relatedItems": 1})\n+        self.assertEqual(dict(broken), {})\n+\n+        # Break a relation by source.\n+        self.portal._delObject("doc1")\n+\n+        # Broken relation is removed. No rebuild necessary.\n+        stats, broken = get_relations_stats()\n+        self.assertEqual(dict(stats), {})\n+        self.assertEqual(dict(broken), {})\n+\n+    def test_rebuild_relations_with_intid_flush(self):\n+        doc1 = api.content.create(type="Document", title="doc1", container=self.portal)\n+        doc2 = api.content.create(type="Document", title="doc2", container=self.portal)\n+        doc3 = api.content.create(type="Document", title="doc3", container=self.portal)\n+        intids = getUtility(IIntIds)\n+        doc1_intid = intids.getId(doc1)\n+        doc2_intid = intids.getId(doc2)\n+        doc3_intid = intids.getId(doc3)\n+\n+        api.relation.create(doc1, doc2, "relatedItems")\n+        api.relation.create(doc1, doc3, "relatedItems")\n+\n+        stats, broken = get_relations_stats()\n+        self.assertEqual(dict(stats), {"relatedItems": 2})\n+        self.assertEqual(dict(broken), {})\n+\n+        rebuild_relations(flush_and_rebuild_intids=True)\n+\n+        # Relations are the same after a rebuild.\n+        stats, broken = get_relations_stats()\n+        self.assertEqual(dict(stats), {"relatedItems": 2})\n+        self.assertEqual(dict(broken), {})\n+\n+        # intids are now changed.\n+        doc1_intid_after = intids.getId(doc1)\n+        doc2_intid_after = intids.getId(doc2)\n+        doc3_intid_after = intids.getId(doc3)\n+        self.assertNotEqual(doc1_intid, doc1_intid_after)\n+        self.assertNotEqual(doc2_intid, doc2_intid_after)\n+        self.assertNotEqual(doc3_intid, doc3_intid_after)\n+\n+        # Break a relation.\n+        self.portal._delObject("doc2")\n+\n+        stats, broken = get_relations_stats()\n+        self.assertEqual(dict(stats), {"relatedItems": 1})\n+        self.assertEqual(dict(broken), {"relatedItems": 1})\n+\n+        # Broken relations are gone after rebuilding.\n+        rebuild_relations(flush_and_rebuild_intids=True)\n+        stats, broken = get_relations_stats()\n+        self.assertEqual(dict(stats), {"relatedItems": 1})\n+        self.assertEqual(dict(broken), {})\ndiff --git a/news/3457.bugfix b/news/3457.bugfix\nnew file mode 100644\nindex 0000000000..e913ca08d6\n--- /dev/null\n+++ b/news/3457.bugfix\n@@ -0,0 +1,2 @@\n+Fix repairing relations.\n+[ksuess]\n\\ No newline at end of file\n'

Repository: Products.CMFPlone


Branch: refs/heads/6.0.x
Date: 2023-06-16T11:12:16+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/Products.CMFPlone/commit/5b7a95430cdb668f7019959ecef308443c43b4cd

Merge pull request #3797 from plone/relationhelper-fix-relations-6.0.x-maurits

Backport relation helper fix by Katja. [6.0.x]

Files changed:
A Products/CMFPlone/tests/test_relationhelper.py
A news/3457.bugfix
M Products/CMFPlone/relationhelper.py

b'diff --git a/Products/CMFPlone/relationhelper.py b/Products/CMFPlone/relationhelper.py\nindex 7a0a501aa9..fb1183998a 100644\n--- a/Products/CMFPlone/relationhelper.py\n+++ b/Products/CMFPlone/relationhelper.py\n@@ -1,5 +1,6 @@\n from collections import Counter\n from collections import defaultdict\n+from collections import OrderedDict\n from five.intid.intid import addIntIdSubscriber\n from plone.app.linkintegrity.handlers import modifiedContent\n from plone.app.linkintegrity.utils import referencedRelationship\n@@ -51,6 +52,7 @@ def rebuild_relations(context=None, flush_and_rebuild_intids=False):\n     else:\n         cleanup_intids()\n     restore_relations()\n+    log_relations()\n \n \n def get_relations_stats():\n@@ -62,7 +64,7 @@ def get_relations_stats():\n             rel = relation_catalog.resolveRelationToken(token)\n         except ObjectMissingError:\n             broken["Object is missing"] += 1\n-            logger.info(f"Token {token} has no object.")\n+            logger.warning(f"Token {token} has no object.")\n             continue\n \n         if rel.isBroken():\n@@ -73,8 +75,13 @@ def get_relations_stats():\n \n \n def get_all_relations():\n-    """Get all data from zc.relation catalog.\n-    Logs some useful statistics.\n+    """Get relations from zc.relation catalog.\n+\n+    Log statistics.\n+    Return list of dictionaries:\n+        from_uuid: source UID if available else None\n+        to_uuid: target UID if available else None\n+        from_attribute: relation name\n     """\n     results = []\n     info = defaultdict(int)\n@@ -84,25 +91,27 @@ def get_all_relations():\n         try:\n             rel = relation_catalog.resolveRelationToken(token)\n         except ObjectMissingError:\n-            logger.info(f"Token {token} has no object.")\n+            logger.warning(f"No relation for relation token \'{token}\'.")\n             continue\n \n-        if rel.from_object and rel.to_object:\n-            try:\n-                results.append(\n-                    {\n-                        "from_uuid": rel.from_object.UID(),\n-                        "to_uuid": rel.to_object.UID(),\n-                        "from_attribute": rel.from_attribute,\n-                    }\n-                )\n-                info[rel.from_attribute] += 1\n-            except AttributeError as ex:\n-                logger.info(f"Something went wrong while storing {rel}: \\n {ex}")\n-        else:\n-            logger.info(\n-                f"Dropping relation {rel.from_attribute} from {rel.from_object} to {rel.to_object}"\n+        rel_uid_info = OrderedDict()\n+        rel_uid_info["from_attribute"] = rel.from_attribute\n+        try:\n+            rel_uid_info["from_uuid"] = (\n+                rel.from_object.UID() if rel.from_object else None\n             )\n+        except AttributeError as e:\n+            rel_uid_info["from_uuid"] = None\n+            logger.warning(f"Broken relation: {rel_uid_info} \'{str(e)}\'")\n+        try:\n+            rel_uid_info["to_uuid"] = rel.to_object.UID() if rel.to_object else None\n+        except AttributeError as e:\n+            rel_uid_info["to_uuid"] = None\n+            logger.warning(f"Broken relation: {rel_uid_info} \'{str(e)}\'")\n+        info[rel.from_attribute] += 1\n+        results.append(rel_uid_info)\n+\n+    # Log stats\n     msg = ""\n     for key, value in info.items():\n         msg += f"{key}: {value}\\n"\n@@ -115,131 +124,142 @@ def store_relations(context=None):\n     all_relations = get_all_relations()\n     portal = getSite()\n     IAnnotations(portal)[RELATIONS_KEY] = all_relations\n-    logger.info(f"Stored {len(all_relations)} relations on the portal")\n \n \n def purge_relations(context=None):\n     """Removes all entries form zc.relation catalog.\n+\n     RelationValues that were set as attribute on content are still there!\n     These are removed/overwritten when restoring the relations.\n     """\n-    rel_catalog = getUtility(ICatalog)\n-    rel_catalog.clear()\n-    logger.info("Purged zc.relation catalog")\n+    relation_catalog = getUtility(ICatalog)\n+    relation_catalog.clear()\n+    logger.info("zc.relation catalog purged.")\n \n \n def restore_relations(context=None, all_relations=None):\n-    """Restore relations from a annotation on the portal."""\n+    """Restore relations from an annotation on the portal."""\n \n     portal = getSite()\n     if all_relations is None:\n         all_relations = IAnnotations(portal)[RELATIONS_KEY]\n-    logger.info(f"Loaded {len(all_relations)} relations to restore")\n+    logger.info(f"Loaded {len(all_relations)} relations to restore.")\n     update_linkintegrity = set()\n     modified_items = set()\n     modified_relation_lists = defaultdict(list)\n \n-    # remove duplicates but keep original order\n+    # Remove duplicates but keep original order.\n     unique_relations = []\n     seen = set()\n-    seen_add = seen.add\n     for rel in all_relations:\n         hashable = tuple(rel.items())\n         if hashable not in seen:\n             unique_relations.append(rel)\n-            seen_add(hashable)\n+            seen.add(hashable)\n         else:\n             logger.info(f"Dropping duplicate: {hashable}")\n \n     if len(unique_relations) < len(all_relations):\n         logger.info(f"Dropping {len(all_relations) - len(unique_relations)} duplicates")\n-        all_relations = unique_relations\n \n+    # Update relations.\n     intids = getUtility(IIntIds)\n-    for index, item in enumerate(all_relations, start=1):\n-        if not index % 500:\n-            logger.info(f"Restored {index} of {len(all_relations)} relations...")\n-\n-        try:\n-            source_obj = uuidToObject(item["from_uuid"])\n-        except KeyError:\n-            # brain exists but no object\n-            source_obj = None\n-        try:\n-            target_obj = uuidToObject(item["to_uuid"])\n-        except KeyError:\n-            # brain exists but no object\n-            target_obj = None\n-\n-        if not source_obj:\n-            logger.info(f\'{item["from_uuid"]} is missing\')\n-            continue\n-\n-        if not target_obj:\n-            logger.info(f\'{item["to_uuid"]} is missing\')\n+    new_index = 0\n+    for index, item in enumerate(unique_relations, start=1):\n+        # Get source object for UID. Skip relation if no object found.\n+        if item["from_uuid"] is None:\n+            logger.warning(f"No source object. {tuple(item.items())}.")\n             continue\n+        else:\n+            try:\n+                source_obj = uuidToObject(item["from_uuid"])\n+            except KeyError:\n+                # brain exists but no object\n+                source_obj = None\n \n+        # Get target object of UID. Do not skip relation, but update source_obj below.\n+        if item["to_uuid"] is None:\n+            target_obj = None\n+        else:\n+            try:\n+                target_obj = uuidToObject(item["to_uuid"])\n+            except KeyError:\n+                # brain exists but no object\n+                target_obj = None\n+        if target_obj is None:\n+            logger.warning(f"No target object. {tuple(item.items())}")\n+            # The source_obj will be updated to remove the broken relation below.\n+\n+        # source_obj and target_obj are dexterity content types.\n         if not IDexterityContent.providedBy(source_obj):\n-            logger.info(f"{source_obj} is no dexterity content")\n+            logger.warning(f"Source {source_obj} is no dexterity content.")\n             continue\n-\n         if not IDexterityContent.providedBy(target_obj):\n-            logger.info(f"{target_obj} is no dexterity content")\n-            continue\n+            logger.warning(f"Target {target_obj} is no dexterity content.")\n \n-        from_attribute = item["from_attribute"]\n+        # Get intId for target_obj.\n         try:\n             to_id = intids.getId(target_obj)\n         except KeyError:\n-            logger.warning(f"No intid for {target_obj}")\n-            continue\n+            logger.warning(f"No intId for {target_obj}")\n+            to_id = None\n \n+        # Postpone linkintegrity check.\n+        from_attribute = item["from_attribute"]\n         if from_attribute == referencedRelationship:\n-            # Ignore linkintegrity for now. We\'ll rebuilt it at the end!\n             update_linkintegrity.add(item["from_uuid"])\n             continue\n \n+        # Working copy relations\n         if HAS_ITERATE and from_attribute == ITERATE_RELATION_NAME:\n             # Iterate relations are not set as values of fields\n-            relation = StagingRelationValue(to_id)\n-            event._setRelation(source_obj, ITERATE_RELATION_NAME, relation)\n+            if to_id:\n+                relation = StagingRelationValue(to_id)\n+                event._setRelation(source_obj, ITERATE_RELATION_NAME, relation)\n             continue\n \n+        # Relations not based on schema field\n         field_and_schema = get_field_and_schema_for_fieldname(\n             from_attribute, source_obj.portal_type\n         )\n         if field_and_schema is None:\n             # the from_attribute is no field\n-            logger.info(f"No field. Setting relation: {item}")\n+            logger.info(f"No field. Setting relation: {tuple(item.items())}")\n             event._setRelation(source_obj, from_attribute, RelationValue(to_id))\n             continue\n \n         field, schema = field_and_schema\n-        relation = RelationValue(to_id)\n+        relationvalue = RelationValue(to_id) if to_id else None\n \n+        # schema field relations: RelationList, RelationChoice, Relation\n+        #\n+        # RelationList\n         if isinstance(field, RelationList):\n-            logger.info(\n-                f"Add relation to relationslist {from_attribute} from {source_obj.absolute_url()} to {target_obj.absolute_url()}"\n-            )\n+            if not target_obj:\n+                logger.warning(\n+                    f"Broken relation not restored: {from_attribute} from {source_obj.absolute_url()}"\n+                )\n+\n             if item["from_uuid"] in modified_relation_lists.get(from_attribute, []):\n                 # Do not purge relations\n                 existing_relations = getattr(source_obj, from_attribute, [])\n             else:\n                 # First touch. Make sure we purge!\n                 existing_relations = []\n-            existing_relations.append(relation)\n+            if relationvalue:\n+                existing_relations.append(relationvalue)\n             setattr(source_obj, from_attribute, existing_relations)\n             modified_items.add(item["from_uuid"])\n             modified_relation_lists[from_attribute].append(item["from_uuid"])\n-            continue\n \n+        # Relation, RelationChoice\n         elif isinstance(field, (Relation, RelationChoice)):\n-            logger.info(\n-                f"Add relation {from_attribute} from {source_obj.absolute_url()} to {target_obj.absolute_url()}"\n-            )\n-            setattr(source_obj, from_attribute, relation)\n+            if not target_obj:\n+                logger.info(\n+                    f"Broken relation not restored: {from_attribute} from {source_obj.absolute_url()}"\n+                )\n+            setattr(source_obj, from_attribute, relationvalue)\n             modified_items.add(item["from_uuid"])\n-            continue\n \n         else:\n             # we should never end up here!\n@@ -247,11 +267,18 @@ def restore_relations(context=None, all_relations=None):\n                 f"Unexpected relation {from_attribute} from {source_obj.absolute_url()} to {target_obj.absolute_url()}"\n             )\n \n+        new_index += 1\n+        if not new_index % 500:\n+            logger.info(f"Restored {new_index} relations.")\n+\n+    # Link integrity\n     update_linkintegrity = set(update_linkintegrity)\n-    logger.info(f"Updating linkintegrity for {len(update_linkintegrity)} items")\n+    logger.info(f"Updating linkintegrity for {len(update_linkintegrity)} items.")\n     for uuid in sorted(update_linkintegrity):\n         modifiedContent(uuidToObject(uuid), None)\n-    logger.info(f"Updating relations for {len(modified_items)} items")\n+\n+    # Reindex relations in relations catalog.\n+    logger.info(f"Updating relations for {len(modified_items)} items.")\n     for uuid in sorted(modified_items):\n         obj = uuidToObject(uuid)\n         # updateRelations from z3c.relationfield does not properly update relations in behaviors\n@@ -261,10 +288,25 @@ def restore_relations(context=None, all_relations=None):\n         updateRelations(obj, None)\n         update_behavior_relations(obj, None)\n \n-    # purge annotation from portal if they exist\n+    # Purge annotation from portal.\n     if RELATIONS_KEY in IAnnotations(portal):\n         del IAnnotations(portal)[RELATIONS_KEY]\n-    logger.info("Done!")\n+\n+    logger.info("All valid relations restored.")\n+\n+\n+def log_relations():\n+    info, broken = get_relations_stats()\n+    msg = ""\n+    for key, value in info.items():\n+        msg += f"{key}: {value}\\n"\n+    logger.info(f"\\nRestored relations: \\n{msg}")\n+\n+    if len(broken.items()) > 0:\n+        msg = ""\n+        for key, value in broken.items():\n+            msg += f"{key}: {value}\\n"\n+        logger.info(f"\\nStill broken relations: \\n{msg}")\n \n \n def get_intid(obj):\n@@ -291,6 +333,7 @@ def get_field_and_schema_for_fieldname(field_id, portal_type):\n \n \n def cleanup_intids(context=None):\n+    logger.info("Clean up intIds.")\n     intids = getUtility(IIntIds)\n     all_refs = [\n         f"{i.object.__class__.__module__}.{i.object.__class__.__name__}"\n@@ -298,6 +341,7 @@ def cleanup_intids(context=None):\n     ]\n     logger.info(Counter(all_refs))\n \n+    # Unregister RelationValues\n     count = 0\n     refs = [i for i in intids.refs.values() if isinstance(i.object, RelationValue)]\n     for ref in refs:\n@@ -305,31 +349,33 @@ def cleanup_intids(context=None):\n         count += 1\n     logger.info(f"Removed all {count} RelationValues from IntId-tool")\n \n+    # Unregister broken references\n     count = 0\n     for ref in intids.refs.values():\n         if "broken" in repr(ref.object):\n             intids.unregister(ref)\n-    logger.info(f"Removed {count} broken refs from IntId-tool")\n+    logger.info(f"Removed {count} broken references from IntId-tool")\n+\n     all_refs = [\n-        "{i.object.__class__.__module__}.{i.object.__class__.__name__}"\n+        f"{i.object.__class__.__module__}.{i.object.__class__.__name__}"\n         for i in intids.refs.values()\n     ]\n     logger.info(Counter(all_refs))\n \n \n def flush_intids():\n-    """Flush all intids"""\n+    """Flush all intIds"""\n     intids = getUtility(IIntIds)\n     intids.ids = intids.family.OI.BTree()\n     intids.refs = intids.family.IO.BTree()\n \n \n def rebuild_intids():\n-    """Create new intids"""\n+    """Create new intIds"""\n \n     def add_to_intids(obj, path):\n         if IContentish.providedBy(obj):\n-            logger.info(f"Added {obj} at {path} to intid")\n+            # logger.info(f"Added intId for {obj} at {path} to intId utility.")\n             addIntIdSubscriber(obj, None)\n \n     portal = getSite()\ndiff --git a/Products/CMFPlone/tests/test_relationhelper.py b/Products/CMFPlone/tests/test_relationhelper.py\nnew file mode 100644\nindex 0000000000..699c142dcf\n--- /dev/null\n+++ b/Products/CMFPlone/tests/test_relationhelper.py\n@@ -0,0 +1,139 @@\n+from plone import api\n+from plone.app.testing import setRoles\n+from plone.app.testing import TEST_USER_ID\n+from Products.CMFPlone.testing import PRODUCTS_CMFPLONE_INTEGRATION_TESTING\n+from zope.component import getUtility\n+from Products.CMFPlone.relationhelper import (\n+    get_relations_stats,\n+    purge_relations,\n+    rebuild_relations,\n+    restore_relations,\n+    store_relations,\n+)\n+from zope.intid.interfaces import IIntIds\n+\n+import unittest\n+\n+\n+class TestRelationhelper(unittest.TestCase):\n+    layer = PRODUCTS_CMFPLONE_INTEGRATION_TESTING\n+\n+    def setUp(self):\n+        self.portal = self.layer["portal"]\n+        self.request = self.layer["request"]\n+        setRoles(self.portal, TEST_USER_ID, ("Manager",))\n+\n+    def test_relations_stats(self):\n+        doc1 = api.content.create(type="Document", title="doc1", container=self.portal)\n+        doc2 = api.content.create(type="Document", title="doc2", container=self.portal)\n+        api.relation.create(doc1, doc2, "relatedItems")\n+\n+        stats, broken = get_relations_stats()\n+        self.assertEqual(dict(stats), {"relatedItems": 1})\n+        self.assertEqual(dict(broken), {})\n+\n+    def test_relations_stats_broken(self):\n+        doc1 = api.content.create(type="Document", title="doc1", container=self.portal)\n+        doc2 = api.content.create(type="Document", title="doc2", container=self.portal)\n+        api.relation.create(doc1, doc2, "relatedItems")\n+        self.portal._delObject("doc2")\n+\n+        stats, broken = get_relations_stats()\n+        self.assertEqual(dict(stats), {})\n+        self.assertEqual(dict(broken), {"relatedItems": 1})\n+\n+    def test_rebuild_relations(self):\n+        doc1 = api.content.create(type="Document", title="doc1", container=self.portal)\n+        doc2 = api.content.create(type="Document", title="doc2", container=self.portal)\n+        doc3 = api.content.create(type="Document", title="doc3", container=self.portal)\n+        intids = getUtility(IIntIds)\n+        doc1_intid = intids.getId(doc1)\n+        doc2_intid = intids.getId(doc2)\n+        doc3_intid = intids.getId(doc3)\n+\n+        api.relation.create(doc1, doc2, "relatedItems")\n+        api.relation.create(doc1, doc3, "relatedItems")\n+\n+        stats, broken = get_relations_stats()\n+        self.assertEqual(dict(stats), {"relatedItems": 2})\n+        self.assertEqual(dict(broken), {})\n+\n+        rebuild_relations()\n+\n+        # Relations are the same after a rebuild.\n+        stats, broken = get_relations_stats()\n+        self.assertEqual(dict(stats), {"relatedItems": 2})\n+        self.assertEqual(dict(broken), {})\n+\n+        # intids are not changed.\n+        doc1_intid_after = intids.getId(doc1)\n+        doc2_intid_after = intids.getId(doc2)\n+        doc3_intid_after = intids.getId(doc3)\n+        self.assertEqual(doc1_intid, doc1_intid_after)\n+        self.assertEqual(doc2_intid, doc2_intid_after)\n+        self.assertEqual(doc3_intid, doc3_intid_after)\n+\n+        # Break a relation by target.\n+        self.portal._delObject("doc2")\n+\n+        stats, broken = get_relations_stats()\n+        self.assertEqual(dict(stats), {"relatedItems": 1})\n+        self.assertEqual(dict(broken), {"relatedItems": 1})\n+\n+        # Broken relations are removed after rebuilding.\n+        rebuild_relations()\n+        stats, broken = get_relations_stats()\n+        self.assertEqual(dict(stats), {"relatedItems": 1})\n+        self.assertEqual(dict(broken), {})\n+\n+        # Break a relation by source.\n+        self.portal._delObject("doc1")\n+\n+        # Broken relation is removed. No rebuild necessary.\n+        stats, broken = get_relations_stats()\n+        self.assertEqual(dict(stats), {})\n+        self.assertEqual(dict(broken), {})\n+\n+    def test_rebuild_relations_with_intid_flush(self):\n+        doc1 = api.content.create(type="Document", title="doc1", container=self.portal)\n+        doc2 = api.content.create(type="Document", title="doc2", container=self.portal)\n+        doc3 = api.content.create(type="Document", title="doc3", container=self.portal)\n+        intids = getUtility(IIntIds)\n+        doc1_intid = intids.getId(doc1)\n+        doc2_intid = intids.getId(doc2)\n+        doc3_intid = intids.getId(doc3)\n+\n+        api.relation.create(doc1, doc2, "relatedItems")\n+        api.relation.create(doc1, doc3, "relatedItems")\n+\n+        stats, broken = get_relations_stats()\n+        self.assertEqual(dict(stats), {"relatedItems": 2})\n+        self.assertEqual(dict(broken), {})\n+\n+        rebuild_relations(flush_and_rebuild_intids=True)\n+\n+        # Relations are the same after a rebuild.\n+        stats, broken = get_relations_stats()\n+        self.assertEqual(dict(stats), {"relatedItems": 2})\n+        self.assertEqual(dict(broken), {})\n+\n+        # intids are now changed.\n+        doc1_intid_after = intids.getId(doc1)\n+        doc2_intid_after = intids.getId(doc2)\n+        doc3_intid_after = intids.getId(doc3)\n+        self.assertNotEqual(doc1_intid, doc1_intid_after)\n+        self.assertNotEqual(doc2_intid, doc2_intid_after)\n+        self.assertNotEqual(doc3_intid, doc3_intid_after)\n+\n+        # Break a relation.\n+        self.portal._delObject("doc2")\n+\n+        stats, broken = get_relations_stats()\n+        self.assertEqual(dict(stats), {"relatedItems": 1})\n+        self.assertEqual(dict(broken), {"relatedItems": 1})\n+\n+        # Broken relations are gone after rebuilding.\n+        rebuild_relations(flush_and_rebuild_intids=True)\n+        stats, broken = get_relations_stats()\n+        self.assertEqual(dict(stats), {"relatedItems": 1})\n+        self.assertEqual(dict(broken), {})\ndiff --git a/news/3457.bugfix b/news/3457.bugfix\nnew file mode 100644\nindex 0000000000..e913ca08d6\n--- /dev/null\n+++ b/news/3457.bugfix\n@@ -0,0 +1,2 @@\n+Fix repairing relations.\n+[ksuess]\n\\ No newline at end of file\n'

