Repository: plone.app.linkintegrity


Branch: refs/heads/master
Date: 2015-07-17T09:51:48+02:00
Author: Ramon Navarro Bosch (bloodbare) <ramon.nb@gmail.com>
Commit: https://github.com/plone/plone.app.linkintegrity/commit/e82cc20fc89c6a5740e291de8da77e7e2dcb79f4

Moving the code to a simpler aproach to show on confirmation popup (soft link integrity)

Files changed:
A plone/app/linkintegrity/browser/delete_confirmation_info.pt
A plone/app/linkintegrity/browser/info.py
M CHANGES.rst
M plone/app/linkintegrity/__init__.py
M plone/app/linkintegrity/browser/configure.zcml
M plone/app/linkintegrity/browser/update.py
M plone/app/linkintegrity/configure.zcml
M plone/app/linkintegrity/dx/configure.zcml
M plone/app/linkintegrity/handlers.py
M plone/app/linkintegrity/interfaces.py
M plone/app/linkintegrity/utils.py
M setup.py
D plone/app/linkintegrity/NOTES.txt
D plone/app/linkintegrity/httpresponse.patch
D plone/app/linkintegrity/info.py
D plone/app/linkintegrity/monkey.py
D plone/app/linkintegrity/monkey2.py

diff --git a/CHANGES.rst b/CHANGES.rst
index 614f0c0..13884cc 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -1,10 +1,10 @@
 Changelog
 =========
 
-2.1.3 (unreleased)
+3.0 (unreleased)
 ------------------
 
-- Nothing changed yet.
+- Nothing change.
 
 
 2.1.2 (2015-05-04)
diff --git a/plone/app/linkintegrity/NOTES.txt b/plone/app/linkintegrity/NOTES.txt
deleted file mode 100644
index 4e38daa..0000000
--- a/plone/app/linkintegrity/NOTES.txt
+++ /dev/null
@@ -1,235 +0,0 @@
-[ these notes are a bit outdated now as they were written looking at
-  revision 29942 and there have been quite a number of changes since;
-  however, they should still give some hints about the problems and
-  make it easier to follow the recent changes;  nevertheless i'll try
-  to update soon... ]
-
-
-The how and why of link integrity when deleting objects
-=======================================================
-
-Okay, so here are some notes and explanations about the code in the
-Plone 3.0 review bundle for PLIP 125 -- Ensuring link/reference
-integrity, for the use case "deleting an item".  I've first tried to
-write this in a rather serious-documentation-like way, but realized soon
-enough that this would take much too long, so here's my second take in a
-more email-like fashion...
-
-First of all, it is important to note that one goal of the PLIP is to
-try to create a preferably generic way of ensuring link integrity.
-While it would have been relatively easy to enhance plone by integrity
-checks in a number of important places where objects can get deleted
-by the user, i.e. most visibly in `folder_contents`, trying to cover
-all possible ways of deleting objects, even future ones, seemed if
-at all only possible using the zope3-style event system.  However,
-this had a number of implications on the code, making it potentially
-look a bit hacky at first sight.
-
-Furthermore, another goal was to be able to interrupt any request that
-would cause an integrity breach and possibly continue it (after asking
-the user), which add to that effect.  Therefore I'd like to explain what
-problems I encountered and how a tried to solve them one by one after
-which it's hopefully more clear why the code turned out like it did, or
-in some cases even needed to, imho.
-
-
-Events and special references
------------------------------
-
-According to the PLIP the bundle tries to ensure link integrity by
-using references indicating that a document or other content object is
-refering to an image or another page.  When an item is supposed to be
-removed by the user, those references are then used to check if the
-removal would cause a breach of link integrity.  Events are used both
-for setting up those references and also to invoke the check.  The
-former can be done using `IObjectModifiedEvent` whenever an object was
-saved and is relatively straight-forward.  However, invoking the check
-using events brought up some problems ultimatively preventing it.  There
-is still an event involved in the process, so the above statement is not
-wrong, but I'll get to that soon.
-
-Before I'd like to point out why although it seemed logical to subscribe
-to `IObjectWillBeRemovedEvent`, it wouldn't help much in this case.
-This is because any additional subscriber to `IObjectWillBeRemovedEvent`
-will be called after the legacy support for `manage_beforeDelete`
-has been handled (OFS/ObjectManager.py:374[1]).  This means that the
-subscriber used for checking the link integrity references is also only
-called after the object's `manage_beforeDelete`, which in turn calls
-`Referenceable.manage_beforeDelete` (Archetypes/BaseObject.py:201),
-where all references held by the object are removed before it is
-deleted itself.  So at the time the "checking" subscriber gets called
-the references representing the links to the object will already be
-removed.  At least, this is true when the subscriber is called for
-`OFS.interfaces.IItem`, that is the referred to object itself.
-
-Now it should be possible to use a subscriber set up for
-`IObjectWillBeRemovedEvent` on the references themselves, possibly even
-producing cleaner code, but I think there was some reason that I cannot
-recall right now :), but that made me opt for another approach instead.
-Ben Saller suggested to use `HoldingReferences` to automatically raise
-an exception when a referenced object is going to be removed.  However,
-`HoldingReferences` as such won't work, because they always raise an
-exception, which makes it impossible to successfully continue the
-request after the user has confirmed it.  But, using the same idea,
-the code introduces a new reference type, which instead of raising an
-exception will notify subscribers of a special event before its target
-is deleted, and that's also where the link integrity checks use events
-as mentioned above.  This way the references created on modification can
-be easily hooked up with the code creating confirmation page, but won't
-hurt (by raising uncaught exceptions) when link integrity should be
-disabled, for example.
-
-
-Events have no return value
----------------------------
-
-So with an event handler being called whenever an referred to object
-is supposed to be deleted, the handler "only" needs to take care of
-presenting the user with a confirmation form giving some information
-about which objects refer to the one to be removed and asking if it
-should still be deleted.  While this sounds easy, the fact that event
-subscribers support no return value (for obvious reasons) is a problem,
-because the subscriber itself cannot provide the confirmation form.  Not
-even setting up a redirection to the form is possible, because this
-would very likely remove the item before the redirection happens, in
-most cases anyway.
-
-The idea to work around this problem was to raise an exception whenever
-an referred to object was going to be removed and use Zope's error
-mechanism to provide the necessary form as a response to the otherwise
-uncaught exception.  To do this zope3-style an approach inspired by
-FiveException[2] was used:  ZPublisher's exception hook is extended by
-an attempt to look up an adapter for an exception and the request, or in
-other words, a view.  This is done by using sort of a monkey patch at
-the moment, but unlike with FiveException the function registered as the
-new exception hook is just a wrapper around the original one instead of
-a patched version, which would potentially need to be updated after new
-Zope releases.
-
-Obviously patching the exception hook like that is not a desirable
-long-term solution, but maybe a similar approach can be introduced into
-Zope's standard exception hook in the future as such a feature would
-be helpful in a number of places, imho.  Anyway, now it's possible to
-register a view for a given exception via zcml and use it to render a
-response whenever that exception is raised.  One immediate consequence
-was that rendering the view without a context turned out to be not
-very useful, since the page should look like a part of plone, after
-all.  This problem exists at all, since the view in question adapts an
-exception and a request, and not as usual an object and a request.  To
-be able to access the context and hereby the other parts of the plone
-site as well, the code uses the convention that an object representing
-the context is passed as the exception value.  This solves the problem,
-but leaves room for improvement, too, of course.
-
-
-Which exception?
-----------------
-
-The next problem was to find a suitable exception to raise in order to
-call the view containing the confirmation page.  Normally, a specially
-defined exception should have been used, but this proved to be tricky
-without changing code in several places of Plone, Archetypes and Zope.
-
-This is because the exception is raised from an event subscriber
-of the event called by the supposed to be deleted reference in its
-`beforeTargetDeleteInformSource` function, as described before.  This
-limits the choice of exceptions which can potentially be raised, because
-at this time the point of execution (or whatever you'd call that
-properly :)) is inside
-
-  a) the `try` block handling the removal of all references held
-     by an object that is to be removed itself
-     (Archetypes/Referenceable.py:262-274)
-
-  b) the `try` block in the event handler for legacy support of
-     `manage_beforeDelete` (OFS/subscribers.py:153-164)
-
-To have an exception propagate in order to be able to catch and respond
-to it using the view-based approach described before, a) wouldn't be
-problematic, since it only catches instances of `ReferenceException`.
-However, b) would log and ignore (in most conditions, at least) all
-exceptions but `OFS.ObjectManager.BeforeDeleteException` and, well,
-`ConflictError`, but this really shouldn't be raised.  So basically,
-without changing Zope's OFS module and potentially Archetypes as well,
-the only viable option left is `BeforeDeleteException`.
-
-On the other hand, hooking up `BeforeDeleteException` with the
-confirmation form can of course create some other problems, namely when
-a `BeforeDeleteException` is raised for another reason (and not caught
-elsewhere).  So the code should eventually be changed to use its own
-exception type, but for the time being it seemed more important to keep
-is a simple as possible and avoid too many changes in Zope, Archetypes
-etc.
-
-
-Interrupting and continuing a request
--------------------------------------
-
-The last thing I'd like to write about is how the current code
-interrupts and continues requests in order to be able to "pause" any
-action leading to a link integrity breach, presenting the user with a
-form asking for confirmation, and, depending on the answer, either go
-through with the original request or cancel it.
-
-Continuing a request admittedly sounds very hacky as such, but the idea
-of the PLIP was to try to implement a method of ensuring integrity
-independent of how objects are moved, renamed or deleted (unless I
-understood it wrong, of course :)).  So, to be able to do that in
-a generic fashion, the code cannot make any assumptions about the
-offending request, but should still "insert" the necessary confirmation
-step before it gets processed.
-
-The only possible solution I could think of was to try to "remember"
-the request and later on set it up and re-request it again.  While this
-really doesn't sound like a good idea at first, with the knowledge that
-Zope already supports retrying requests (via the `Retry` exception) and
-after looking at the corresponding code, it turned out to be not too bad
-at all as I can hopefully show in the remainder of this document.
-
-When a `Retry` exception is raised the current transaction is aborted,
-a new request object is built by calling its `retry` function
-(ZPublisher/Publish.py:159) and then published again.  A closer look at
-`retry` (ZPublisher/HTTPRequest.py:131) shows that apart from increasing
-the retry counter only the original request's `stdin` and `_orig_env`
-attributes are used to construct the new request instance.  But that
-also means that only those two attributes are relevant when trying to
-interrupt and continue any given request.
-
-This seems much cleaner than possibly trying to pickle the whole request
-instance or some other approach.  In fact, after saving those values
-accross the confirmation page by compressing and base64-encoding their
-pickled tuple and putting the resulting string in a hidden field, the
-original request can be continued or rather replayed by simply
-overwriting the corresponding attributes of the current request
-instance and raising a `Retry`.
-
-Of course this would normally lead to the same exception being raised,
-since the to be deleted object is still referenced by others, just like
-before.  Since the only two values making it into the new request are
-`stdin` and `_orig_env`, it becomes necessary to set some kind of marker
-in one of the two to indicate that the request was already interrupted
-and confirmed by the user.  The subscriber of the event triggered by the
-removal of the special Archetypes reference as described before can then
-check for this marker and simply not raise `BeforeDeleteException` again
-if it exists.  This results in the original request getting executed as
-it had never been interrupted in the first place.
-
-
-An excuse for hackyness :)
---------------------------
-
-While all the solutions to the problems described so far are very
-likely not the cleanest and best way in terms of code simplicity and
-maintainability, most of them were the only way to work around the
-limitations I've run into, or at least the cleanest possible way, imho.
-As mentioned before, some things could be better with more changes to
-Zope, Archetypes and/or Plone, but I was trying to find ways to avoid
-or minimize that in order to make the code more suitable as an add-on
-product to Plone.  Also, I've tried to clean up as much as possible and
-comment the trickier parts of the code, so that it hopefully stands a
-chance of being accepted for the 3.0 release... :)
-
-
-[1] all line numbers refer to Zope 2.10.0b1 and the Plone 3.0 review bundle
-[2] http://codespeak.net/svn/z3/FiveException/
-
diff --git a/plone/app/linkintegrity/__init__.py b/plone/app/linkintegrity/__init__.py
index f786609..27e1a00 100644
--- a/plone/app/linkintegrity/__init__.py
+++ b/plone/app/linkintegrity/__init__.py
@@ -8,32 +8,3 @@
 
 import pkg_resources
 
-try:
-    pkg_resources.get_distribution('plone.app.multilingual')
-except pkg_resources.DistributionNotFound:
-    HAS_PAM = False
-else:
-    HAS_PAM = True
-
-try:
-    pkg_resources.get_distribution('Products.LinguaPlone')
-except pkg_resources.DistributionNotFound:
-    HAS_LINGUAPLONE = False
-else:
-    HAS_LINGUAPLONE = True
-
-
-def initialize(context):
-
-    # side effect import to patch the response's retry method
-    import monkey
-
-    # Install the wrapper around zpublisher_exception_hook.
-    monkey.installExceptionHook()
-
-    # Install the status code for linkintegritynotificationexception
-    monkey.installStatusCode()
-
-
-import monkey2
-monkey2  # pyflakes
diff --git a/plone/app/linkintegrity/browser/configure.zcml b/plone/app/linkintegrity/browser/configure.zcml
index 184d3c9..d1b2a80 100644
--- a/plone/app/linkintegrity/browser/configure.zcml
+++ b/plone/app/linkintegrity/browser/configure.zcml
@@ -3,6 +3,13 @@
     xmlns:browser="http://namespaces.zope.org/browser">
 
     <browser:page
+       for="plone.dexterity.interfaces.IDexterityContent"
+       name="delete_confirmation_info"
+       class=".info.DeleteConfirmationInfo"
+       permission="zope2.Public"
+       />
+
+    <browser:page
         name="updateLinkIntegrityInformation"
         for="Products.CMFPlone.interfaces.IPloneSiteRoot"
         template="update.pt"
diff --git a/plone/app/linkintegrity/browser/delete_confirmation_info.pt b/plone/app/linkintegrity/browser/delete_confirmation_info.pt
new file mode 100644
index 0000000..b9b9ba1
--- /dev/null
+++ b/plone/app/linkintegrity/browser/delete_confirmation_info.pt
@@ -0,0 +1,57 @@
+<article id="content" 
+  xmlns="http://www.w3.org/1999/xhtml" 
+  xml:lang="en"
+  lang="en"
+  tal:define="breachs view/integrityBreaches"
+  tal:condition="python: len(breachs)>0"
+  i18n:domain="plone">
+    <h1 class="documentFirstHeading"
+        i18n:translate="linkintegrity_breaches_title">Potential link breakage</h1>
+
+    <div id="content-core">
+        <p i18n:translate="linkintegrity_instructions">
+            By deleting this item, you will break links that exist in the items listed
+            below. If this is indeed what you want to do, we recommend that you remove
+            these references first.
+        </p>
+
+        <div>
+            <article tal:repeat="breach breachs">
+
+              <header>
+                <a tal:attributes="href breach/url"
+                    tal:content="breach/title" />
+              </header>
+              <p>
+                  <span i18n:translate="linkintegrity_is_referenced">
+                      This <span i18n:name="portal_type" tal:content="breach/type_title" />
+                      is referenced by the following items:
+                  </span>
+              </p>
+
+                  <ul>
+                    <li tal:repeat="src python:breach['sources']">
+                      <tal:visible condition="python: view.isAccessible(src)">
+                        <a tal:attributes="href src/absolute_url" tal:content="src/Title" />
+                        [<a tal:attributes="href string:${src/absolute_url}/edit"
+                          i18n:translate="linkintegrity_edit_in_new_window"
+                          target="_blank">Edit in new window</a>]
+                      </tal:visible>
+                      <tal:private condition="python: not view.isAccessible(src)"
+                                   i18n:translate="linkintegrity_item_not_accessible">
+                        The item is not accessible.
+                      </tal:private>
+                    </li>
+                  </ul>
+
+            </article>
+
+        <br />
+
+        <p i18n:translate="linkintegrity_delete_anyway">
+            Would you like to delete it anyway?
+        </p>
+
+        </div>
+    </div>
+</article>
\ No newline at end of file
diff --git a/plone/app/linkintegrity/browser/info.py b/plone/app/linkintegrity/browser/info.py
new file mode 100644
index 0000000..25002e8
--- /dev/null
+++ b/plone/app/linkintegrity/browser/info.py
@@ -0,0 +1,49 @@
+# -*- coding: utf-8 -*-
+from Acquisition import aq_inner
+from Products.Five import BrowserView
+from Products.CMFCore.utils import getToolByName, _checkPermission
+from Products.CMFCore.permissions import AccessContentsInformation
+from plone.app.linkintegrity.utils import encodeRequestData
+from zope.component import getMultiAdapter
+from zope.i18n import translate
+from Products.Five.browser.pagetemplatefile import ViewPageTemplateFile
+from plone.app.linkintegrity.utils import isLinked
+
+
+class DeleteConfirmationInfo(BrowserView):
+
+    template = ViewPageTemplateFile('delete_confirmation_info.pt')
+
+    def getPortalTypeTitle(self, obj):
+        # Get the portal type title of the object.
+        context = aq_inner(self.context)
+        portal_types = getToolByName(context, 'portal_types')
+        fti = portal_types.get(obj.portal_type)
+        if fti is not None:
+            type_title_msgid = fti.Title()
+        else:
+            type_title_msgid = obj.portal_type
+        type_title = translate(type_title_msgid, context=self.request)
+        return type_title
+
+    def isAccessible(self, obj):
+        return _checkPermission(AccessContentsInformation, obj)
+
+    def integrityBreaches(self):
+        result = []
+        for element in isLinked(self.context):
+            result.append(element.from_object)
+
+        if len(result):
+            return [{
+                'title': self.context.Title(),
+                'url': self.context.absolute_url(),
+                'sources': result,
+                'type': self.context.getPortalTypeName(),
+                'type_title': self.getPortalTypeTitle(self.context)
+            }]
+        else:
+            return []
+
+    def __call__(self):
+        return self.template()
diff --git a/plone/app/linkintegrity/browser/update.py b/plone/app/linkintegrity/browser/update.py
index fbc5a84..b22fdd2 100644
--- a/plone/app/linkintegrity/browser/update.py
+++ b/plone/app/linkintegrity/browser/update.py
@@ -8,9 +8,6 @@
 
 from plone.app.linkintegrity.handlers import modifiedArchetype
 from plone.app.linkintegrity.handlers import modifiedDexterity
-from plone.app.linkintegrity import HAS_LINGUAPLONE
-from plone.app.linkintegrity import HAS_PAM
-from plone.app.referenceablebehavior.referenceable import IReferenceable
 from plone.dexterity.interfaces import IDexterityContent
 
 
@@ -42,9 +39,6 @@ def update(self):
         count = 0
         kwargs = {}
 
-        if HAS_LINGUAPLONE or HAS_PAM:
-            kwargs['Language'] = 'all'
-
         for brain in catalog(**kwargs):
             obj = brain.getObject()
             if IBaseObject.providedBy(obj):
diff --git a/plone/app/linkintegrity/configure.zcml b/plone/app/linkintegrity/configure.zcml
index e905ca1..9bd9d3b 100644
--- a/plone/app/linkintegrity/configure.zcml
+++ b/plone/app/linkintegrity/configure.zcml
@@ -6,19 +6,8 @@
 
     <includeDependencies package="." />
 
-    <five:registerPackage package="." initialize=".initialize" />
-
     <include package="Products.CMFCore" file="permissions.zcml" />
 
-    <adapter
-        for="zope.publisher.interfaces.browser.IBrowserRequest"
-        provides=".interfaces.ILinkIntegrityInfo"
-        factory=".info.LinkIntegrityInfo" />
-
-    <class class="OFS.Image.Image">
-        <implements interface=".interfaces.IOFSImage" />
-    </class>
-
     <include package=".browser" />
 
     <include package=".at"
diff --git a/plone/app/linkintegrity/dx/configure.zcml b/plone/app/linkintegrity/dx/configure.zcml
index b95e09b..07a3e78 100644
--- a/plone/app/linkintegrity/dx/configure.zcml
+++ b/plone/app/linkintegrity/dx/configure.zcml
@@ -1,26 +1,19 @@
 <configure
     xmlns="http://namespaces.zope.org/zope">
 
-    <include package="plone.app.referenceablebehavior" />
-
     <subscriber
-        for="plone.app.referenceablebehavior.referenceable.IReferenceable
+        for="plone.app.relationfield.interfaces.IDexterityHasRelations
              zope.lifecycleevent.interfaces.IObjectCopiedEvent"
         handler="..handlers.modifiedDexterity" />
 
     <subscriber
-        for="plone.app.referenceablebehavior.referenceable.IReferenceable
+        for="plone.app.relationfield.interfaces.IDexterityHasRelations
              zope.lifecycleevent.interfaces.IObjectCreatedEvent"
         handler="..handlers.modifiedDexterity" />
 
     <subscriber
-        for="plone.app.referenceablebehavior.referenceable.IReferenceable
+        for="plone.app.relationfield.interfaces.IDexterityHasRelations
              zope.lifecycleevent.interfaces.IObjectModifiedEvent"
         handler="..handlers.modifiedDexterity" />
 
-    <subscriber
-        for="plone.app.referenceablebehavior.referenceable.IReferenceable
-             zope.lifecycleevent.interfaces.IObjectRemovedEvent"
-        handler="..handlers.referencedObjectRemoved" />
-
 </configure>
diff --git a/plone/app/linkintegrity/handlers.py b/plone/app/linkintegrity/handlers.py
index 47b4a4d..6393489 100644
--- a/plone/app/linkintegrity/handlers.py
+++ b/plone/app/linkintegrity/handlers.py
@@ -10,7 +10,7 @@
 from ZODB.POSException import ConflictError
 from plone.app.linkintegrity.exceptions \
     import LinkIntegrityNotificationException
-from plone.app.linkintegrity.interfaces import ILinkIntegrityInfo, IOFSImage
+from plone.app.linkintegrity.interfaces import ILinkIntegrityInfo
 from plone.app.linkintegrity.parser import extractLinks
 from plone.app.linkintegrity.references import updateReferences
 from zExceptions import NotFound
@@ -24,33 +24,26 @@
 # To support various Plone versions, we need to support various UUID resolvers
 # This follows Kupu, TinyMCE and plone.app.uuid methods, in a similar manner to
 # plone.outputfilters.browser.resolveuid
-try:
-    from plone.app.uuid.utils import uuidToObject
-except ImportError:
-    def uuidToObject(uuid):
-        catalog = getToolByName(getSite(), 'portal_catalog', None)
-        res = catalog and catalog.unrestrictedSearchResults(UID=uuid)
-        if res and len(res) == 1:
-            return res[0].getObject()
+from plone.app.uuid.utils import uuidToObject
+from Products.CMFPlone.interfaces import IPloneSiteRoot
 
 # We try to import dexterity related modules, or modules used just if
 # dexterity is around
-try:
-    from plone.app.textfield import RichText
-    from plone.dexterity.interfaces import IDexterityFTI
-    from plone.dexterity.utils import getAdditionalSchemata
-    HAS_DEXTERITY = True
-except ImportError:
-    HAS_DEXTERITY = False
+from plone.app.textfield import RichText
+from plone.dexterity.interfaces import IDexterityFTI
+from plone.dexterity.utils import getAdditionalSchemata
+from zope.intid.interfaces import IIntIds
+from z3c.relationfield import RelationValue
+from zope.annotation.interfaces import IAnnotations
+from plone.dexterity.interfaces import IDexterityContent
+from Products.CMFPlone.interfaces import IPloneSiteRoot
+from z3c.relationfield.event import _setRelation
 
 
 def _resolveUID(uid):
     res = uuidToObject(uid)
     if res is not None:
         return res
-    kupu_hook = getattr(getSite(), 'kupu_resolveuid_hook', None)
-    if kupu_hook is not None:
-        return kupu_hook(uid)
     return None
 
 
@@ -91,7 +84,9 @@ def findObject(base, path):
         except (AttributeError, KeyError,
                 NotFound, ztkNotFound, UnicodeEncodeError):
             return None, None
-        if not IItem.providedBy(child):
+        if not IDexterityContent.providedBy(child) and \
+                not IBaseObject.providedBy(child) and \
+                not IPloneSiteRoot.providedBy(child):
             break
         obj = child
         components.pop(0)
@@ -100,6 +95,7 @@ def findObject(base, path):
 
 def getObjectsFromLinks(base, links):
     """ determine actual objects refered to by given links """
+    intids = getUtility(IIntIds)
     objects = set()
     url = base.absolute_url()
     scheme, host, path, query, frag = urlsplit(url)
@@ -112,16 +108,10 @@ def getObjectsFromLinks(base, links):
                 path = path.encode('utf-8')
 
             obj, extra = findObject(base, path)
-            if obj:
-                if IOFSImage.providedBy(obj):
-                    # use atimage object for scaled images
-                    obj = aq_parent(obj)
-                if not IReferenceable.providedBy(obj):
-                    try:
-                        obj = IReferenceable(obj)
-                    except:
-                        continue
-                objects.add(obj)
+            if obj and not IPloneSiteRoot.providedBy(obj):
+                objid = intids.getId(obj)
+                relation = RelationValue(objid)
+                objects.add(relation)
     return objects
 
 
@@ -160,11 +150,6 @@ def modifiedDexterity(obj, event):
         # `getObjectFromLinks` is not possible without access
         # to `portal_url`
         return
-    rc = getToolByName(obj, 'reference_catalog', None)
-    if rc is None:
-        # `updateReferences` is not possible without access
-        # to `reference_catalog`
-        return
 
     fti = getUtility(IDexterityFTI, name=obj.portal_type)
     schema = fti.lookupSchema()
@@ -184,8 +169,8 @@ def modifiedDexterity(obj, event):
                     continue
                 links = extractLinks(value.raw)
                 refs |= getObjectsFromLinks(obj, links)
-
-    updateReferences(IReferenceable(obj), referencedRelationship, refs)
+    for ref in refs:
+        _setRelation(obj, referencedRelationship, ref)
 
 
 def referenceRemoved(obj, event):
diff --git a/plone/app/linkintegrity/httpresponse.patch b/plone/app/linkintegrity/httpresponse.patch
deleted file mode 100644
index 26bc807..0000000
--- a/plone/app/linkintegrity/httpresponse.patch
+++ /dev/null
@@ -1,37 +0,0 @@
-This patch changes the original implementation of HTTPResponse'
-retry() function so that the response instance is reused
-instead of replaced with a new one (after a Retry exception was
-raised).  This fixes a bug in zopedoctests' http() function
-(Testing/ZopeTestCase/zopedoctest/functional.py:113): the doctest code
-assumes that the HTTPResponse instance passed to publish_module() (line
-177) is used to handle to complete request, so it can be used to get the
-status, headers etc later on (lines 183-186).  Normally this is okay,
-but raising a Retry will create a new response instance, which will then
-hold that data (relevant for evaluating the doctest) while the original
-(passed in) instance is still empty.  So to fix this (quickly) retry()
-now cleans up and returns itself...
-
---- ZPublisher/HTTPResponse.py~	2006-05-30 07:08:18.000000000 +0200
-+++ ZPublisher/HTTPResponse.py	2006-09-12 19:51:52.000000000 +0200
-@@ -182,19 +182,20 @@
- 
-     def retry(self):
-         """Return a response object to be used in a retry attempt
-         """
- 
-         # This implementation is a bit lame, because it assumes that
-         # only stdout stderr were passed to the constructor. OTOH, I
-         # think that that's all that is ever passed.
- 
--        return self.__class__(stdout=self.stdout, stderr=self.stderr)
-+        self.__init__(stdout=self.stdout, stderr=self.stderr)
-+        return self
- 
-     _shutdown_flag = None
-     def _requestShutdown(self, exitCode=0):
-         """Request that the server shut down with exitCode after fulfilling
-            the current request."""
-         import ZServer
-         ZServer.exit_code = exitCode
-         self._shutdown_flag = 1
- 
diff --git a/plone/app/linkintegrity/info.py b/plone/app/linkintegrity/info.py
deleted file mode 100644
index f48423d..0000000
--- a/plone/app/linkintegrity/info.py
+++ /dev/null
@@ -1,142 +0,0 @@
-from plone.app.linkintegrity.interfaces import ILinkIntegrityInfo
-from zope.interface import implements
-from zope.component import queryUtility
-from Acquisition import aq_base
-from Products.CMFCore.interfaces import IPropertiesTool
-from zope.component import getUtility
-from plone.registry.interfaces import IRegistry
-
-try:
-    from plone.uuid.interfaces import IUUID
-    IUUID       # make pyflakes happy
-except ImportError:
-    # Archetypes-only fallback for Plone < 4.1
-    def IUUID(obj, default=None):
-        if hasattr(aq_base(obj), 'UID'):
-            return obj.UID()
-        else:
-            return default
-try:
-    from Products.CMFPlone.interfaces import IEditingSchema
-    IS_PLONE5 = True
-except ImportError:
-    IS_PLONE5 = False
-
-
-class LinkIntegrityInfo(object):
-    """ adapter for browserrequests to temporarily store information
-        related to link integrity in the request object """
-    implements(ILinkIntegrityInfo)
-
-    attribute = marker = 'link_integrity_info'
-
-    def __init__(self, context):
-        self.context = context      # the context is the request
-
-    def integrityCheckingEnabled(self):
-        """ determine if link integrity checking for the site is enabled """
-        # Plone 5 uses p.a.registry to store the enable_link_integrity setting.
-        if IS_PLONE5:
-            registry = getUtility(IRegistry)
-            settings = registry.forInterface(IEditingSchema, prefix='plone')
-            return settings.enable_link_integrity_checks
-        # Plone version < 5 store the enable_link_integrity setting in the
-        # site_properties.
-        ptool = queryUtility(IPropertiesTool)
-        enabled = False
-        if ptool is not None:
-            props = getattr(ptool, 'site_properties', None)
-            if props is not None:
-                enabled = props.getProperty(
-                    'enable_link_integrity_checks', False)
-        return enabled
-
-    def getIntegrityInfo(self):
-        """ return stored information regarding link integrity """
-        return getattr(self.context, self.attribute, {})
-
-    def setIntegrityInfo(self, info):
-        """ store information regarding link integrity """
-        setattr(self.context, self.attribute, info)
-
-    def addBreach(self, source, target):
-        """ convenience helper; see interface """
-        breaches = self.getIntegrityInfo().get('breaches', {})
-        breaches.setdefault(target, set()).add(source)
-        self.setIntegrityBreaches(breaches)
-
-    def getIntegrityBreaches(self):
-        """
-        return stored information regarding link integrity breaches.
-        The information are in the form of a dictionary, they keys are the
-        target objects relations that will be broken after a delete, the value
-        is a list of source objects pointing to the target.
-        """
-        uuids_to_delete = [IUUID(obj, None) for obj in self.getDeletedItems()]
-        uuids_to_delete = set(filter(None, uuids_to_delete))    # filter `None`
-        breaches = dict(self.getIntegrityInfo().get('breaches', {}))
-        # Do an in-place filtering of breaches, any source of a breach that
-        # is to be removed anyway does not constitute a breach
-        for target, sources in breaches.items():
-            for source in list(sources):
-                if IUUID(source) in uuids_to_delete:
-                    sources.remove(source)
-        # After the cleanup, there can be breaches to targets that have no
-        # sources left. Also, targets where we confirm the link break are not
-        # breaches any more, so we remove them too.
-        for target, sources in breaches.items():
-            if not sources or self.isConfirmedItem(target):
-                del breaches[target]
-        return breaches
-
-    def setIntegrityBreaches(self, breaches):
-        """ store information regarding link integrity breaches """
-        info = self.getIntegrityInfo()
-        info['breaches'] = breaches
-        self.setIntegrityInfo(info)     # unnecessary, but sticking to the api
-
-    def getDeletedItems(self):
-        """ return information about all items deleted during the request """
-        return self.getIntegrityInfo().get('deleted', set())
-
-    def addDeletedItem(self, item):
-        """ remember an item deleted during the request """
-        info = self.getIntegrityInfo()
-        info.setdefault('deleted', set()).add(item)
-        self.setIntegrityInfo(info)     # unnecessary, but sticking to the api
-
-    def getEnvMarker(self):
-        """ return the marker string used to pass the already confirmed
-            items across the retry exception """
-        return self.marker
-
-    def confirmedItems(self):
-        """ return internal list of confirmed items """
-        confirmed = self.context.environ.get(self.marker, [])
-        if confirmed == 'all':
-            confirmed = ['all']
-        elif confirmed:
-            s = confirmed.decode('base64')
-            # split colon-delimited list of 8-byte oids
-            confirmed = [s[i * 9:i * 9 + 8] for i in range(len(s) / 9 + 1)]
-        return confirmed
-
-    def isConfirmedItem(self, obj):
-        """ indicate if the removal of the given object was confirmed """
-        confirmed = self.confirmedItems()
-        return obj._p_oid in confirmed or 'all' in confirmed
-
-    def encodeConfirmedItems(self, additions):
-        """ return the list of previously confirmed (for removeal) items,
-            optionally adding the given items, encoded for usage in a form """
-        confirmed = self.confirmedItems()
-        for obj in additions:
-            confirmed.append(obj._p_oid)
-        return ":".join(confirmed).encode('base64')
-
-    def moreEventsToExpect(self):
-        attr = 'link_integrity_events_counter'
-        counter = getattr(self.context, attr, 0) + 1    # nr of events so far
-        setattr(self.context, attr, counter)            # save for next time
-        expected = self.context.get('link_integrity_events_to_expect', 0)
-        return counter < expected
diff --git a/plone/app/linkintegrity/interfaces.py b/plone/app/linkintegrity/interfaces.py
index 401850f..d1742dc 100644
--- a/plone/app/linkintegrity/interfaces.py
+++ b/plone/app/linkintegrity/interfaces.py
@@ -40,6 +40,3 @@ def encodeConfirmedItems(additions):
         """ return the list of previously confirmed (for removeal) items,
             optionally adding the given items, encoded for usage in a form """
 
-
-class IOFSImage(Interface):
-    """ interface for OFS.Image.Image """
diff --git a/plone/app/linkintegrity/monkey.py b/plone/app/linkintegrity/monkey.py
deleted file mode 100644
index ccc2df7..0000000
--- a/plone/app/linkintegrity/monkey.py
+++ /dev/null
@@ -1,56 +0,0 @@
-# the following code is "stolen" from (or maybe it was inspired by? :))
-# FiveException (http://codespeak.net/svn/z3/FiveException)
-
-from Zope2.App.startup import zpublisher_exception_hook
-from ZPublisher.Publish import Retry
-from ZPublisher.Publish import get_module_info
-
-
-def zpublisher_exception_hook_wrapper(published, REQUEST, t, v, traceback):
-    """ wrapper around the zope2 zpublisher's error hook """
-    try:
-        # if we got a retry exception, we just propagate it instead of
-        # trying to log it (like FiveException does)
-        if t is Retry:
-            v.reraise()
-        return zpublisher_exception_hook(published, REQUEST, t, v, traceback)
-    finally:
-        traceback = None
-
-
-def proxy_get_module_info(*args, **kwargs):
-    results = list(get_module_info(*args, **kwargs))
-    if results[5] is zpublisher_exception_hook:
-        results[5] = zpublisher_exception_hook_wrapper
-    return tuple(results)
-
-
-def installExceptionHook():
-    import ZPublisher.Publish
-    ZPublisher.Publish.get_module_info = proxy_get_module_info
-
-
-def installStatusCode():
-    from ZPublisher import HTTPResponse
-    HTTPResponse.status_codes['linkintegritynotificationexception'] = 200
-
-
-def retry(self):
-    """ re-initialize a response object to be used in a retry attempt """
-    # this implementation changes the original one so that the response
-    # instance is reused instead of replaced with a new one (after a Retry
-    # exception was raised);  this fixes a bug in zopedoctests' http()
-    # function (Testing/ZopeTestCase/zopedoctest/functional.py:113);
-    # the doctest code assumes that the HTTPResponse instance passed to
-    # publish_module() (line 177) is used to handle to complete request, so
-    # it can be used to get the status, headers etc later on (lines 183-186);
-    # normally this is okay, but raising a Retry will create a new response
-    # instance, which will then hold that data (relevant for evaluating the
-    # doctest) while the original (passed in) instance is still empty...
-    #
-    # so to fix this (quickly) retry() now cleans up and returns itself:
-    self.__init__(stdout=self.stdout, stderr=self.stderr)
-    return self
-
-from ZPublisher.HTTPResponse import HTTPResponse
-HTTPResponse.retry = retry
diff --git a/plone/app/linkintegrity/monkey2.py b/plone/app/linkintegrity/monkey2.py
deleted file mode 100644
index a8eca65..0000000
--- a/plone/app/linkintegrity/monkey2.py
+++ /dev/null
@@ -1,21 +0,0 @@
-
-import OFS.ObjectManager
-
-original = OFS.ObjectManager.ObjectManager.manage_delObjects
-# FIXME: Plone needs an api in core
-# Rationale for thix patch:
-# Linkintegrity needs to know how many things get deleted. There is no
-# event for that and plone does not use its own delete method, just the
-# plain zope method. So far, linkintegrity modified Script (Python) objects
-# to store the information, but we want to get rid of this. Then the only
-# way to add this information is by patching the canonical delete method
-# which is manage_delObjects
-
-def manage_delObjects(self, ids=None, REQUEST=None):
-    """Checking for docstrings as a security constraint is a very clever idea
-    """
-    if REQUEST is not None and not isinstance(ids, basestring):
-        REQUEST.set('link_integrity_events_to_expect', len(ids))
-    return original(self, ids, REQUEST)
-
-OFS.ObjectManager.ObjectManager.manage_delObjects = manage_delObjects
diff --git a/plone/app/linkintegrity/utils.py b/plone/app/linkintegrity/utils.py
index 73ab6fb..2ec6d21 100644
--- a/plone/app/linkintegrity/utils.py
+++ b/plone/app/linkintegrity/utils.py
@@ -1,6 +1,16 @@
 from zExceptions import BadRequest
 from base64 import b64encode, b64decode
 from zlib import compress, decompressobj
+from zc.relation.interfaces import ICatalog
+from zope.component import getUtility
+from zope.intid.interfaces import IIntIds
+
+
+def isLinked(obj):
+    catalog = getUtility(ICatalog)
+    intids = getUtility(IIntIds)
+    l = catalog.findRelations({'to_id': intids.getId(obj)})
+    return l
 
 
 def decompress(data, maxsize=262144):
diff --git a/setup.py b/setup.py
index 7e1b778..5425e20 100644
--- a/setup.py
+++ b/setup.py
@@ -1,6 +1,6 @@
 from setuptools import setup, find_packages
 
-version = '2.1.3.dev0'
+version = '3.0.dev0'
 
 setup(name='plone.app.linkintegrity',
       version=version,
@@ -31,7 +31,6 @@
       include_package_data=True,
       install_requires=[
           'setuptools',
-          'plone.app.referenceablebehavior',  # Requires Products.Archetypes
       ],
       extras_require={
           'test': [


Repository: plone.app.linkintegrity


Branch: refs/heads/master
Date: 2015-07-17T09:56:56+02:00
Author: Ramon Navarro Bosch (bloodbare) <ramon.nb@gmail.com>
Commit: https://github.com/plone/plone.app.linkintegrity/commit/7de4f7a1826e4aa3d8d17c0aee34640ab667551f

More cleanup and archetypes

Files changed:
M plone/app/linkintegrity/__init__.py
M plone/app/linkintegrity/browser/configure.zcml
M plone/app/linkintegrity/handlers.py
D plone/app/linkintegrity/browser/confirmation.pt
D plone/app/linkintegrity/browser/confirmation.py
D plone/app/linkintegrity/browser/remove.py

diff --git a/plone/app/linkintegrity/__init__.py b/plone/app/linkintegrity/__init__.py
index 27e1a00..dae354a 100644
--- a/plone/app/linkintegrity/__init__.py
+++ b/plone/app/linkintegrity/__init__.py
@@ -1,10 +1 @@
-try:
-    # this import not used except as a test for Zope 2.12+
-    from Products.Five.bbb import AcquisitionBBB
-    AcquisitionBBB      # make pyflakes happy
-    HAS_ZOPE_212 = True
-except ImportError:
-    HAS_ZOPE_212 = False
-
-import pkg_resources
-
+# -*- encoding: utf-8 -*-
diff --git a/plone/app/linkintegrity/browser/configure.zcml b/plone/app/linkintegrity/browser/configure.zcml
index d1b2a80..2684071 100644
--- a/plone/app/linkintegrity/browser/configure.zcml
+++ b/plone/app/linkintegrity/browser/configure.zcml
@@ -17,17 +17,5 @@
         permission="cmf.ManagePortal"
         />
 
-    <browser:page
-        name="index.html"
-        for="..interfaces.ILinkIntegrityNotificationException"
-        template="confirmation.pt"
-        class=".confirmation.RemoveConfirmationView"
-        permission="zope2.Public" />
-
-    <browser:page
-        name="removeConfirmationAction"
-        for="Products.CMFPlone.interfaces.IPloneSiteRoot"
-        class=".remove.RemoveReferencedObjectView"
-        permission="zope2.Public" />
 
 </configure>
diff --git a/plone/app/linkintegrity/browser/confirmation.pt b/plone/app/linkintegrity/browser/confirmation.pt
deleted file mode 100644
index 2a2ce30..0000000
--- a/plone/app/linkintegrity/browser/confirmation.pt
+++ /dev/null
@@ -1,102 +0,0 @@
-<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"
-      lang="en"
-      metal:use-macro="here/main_template/macros/master"
-      i18n:domain="plone">
-
-<head>
-    <metal:block fill-slot="top_slot"
-                 tal:define="dummy python:request.set('disable_border',1);
-                             disable_column_one python:request.set('disable_plone.leftcolumn',1);
-                             disable_column_two python:request.set('disable_plone.rightcolumn',1);" />
-</head>
-
-<body>
-
-<metal:main fill-slot="content">
-
-    <div class="portalMessage warning">
-        <strong i18n:translate="">Warning</strong>
-        <span tal:omit-tag="" i18n:translate="linkintegrity_warning">
-            One or more of the items you are attempting to delete may cause links
-            in your site to break.
-        </span>
-    </div>
-
-    <article id="content">
-        <h1 class="documentFirstHeading"
-            i18n:translate="linkintegrity_breaches_title">Potential link breakage</h1>
-
-        <div id="content-core">
-            <p i18n:translate="linkintegrity_instructions">
-                By deleting this item, you will break links that exist in the items listed
-                below. If this is indeed what you want to do, we recommend that you remove
-                these references first.
-            </p>
-
-            <form method="post" action="removeConfirmationAction"
-                  tal:attributes="action view/callbackURL">
-
-              <div>
-                  <article tal:repeat="breach view/integrityBreaches">
-
-                    <header>
-                      <a tal:attributes="href breach/url"
-                          tal:content="breach/title" />
-                    </header>
-                    <p>
-                        <span i18n:translate="linkintegrity_is_referenced">
-                            This <span i18n:name="portal_type" tal:content="breach/type_title" />
-                            is referenced by the following items:
-                        </span>
-                    </p>
-
-                        <ul>
-                          <li tal:repeat="src breach/sources">
-                            <tal:visible condition="python: view.isAccessible(src)">
-                              <a tal:attributes="href src/absolute_url" tal:content="src/Title" />
-                              [<a tal:attributes="href string:${src/absolute_url}/edit"
-                                i18n:translate="linkintegrity_edit_in_new_window"
-                                target="_blank">Edit in new window</a>]
-                            </tal:visible>
-                            <tal:private condition="python: not view.isAccessible(src)"
-                                         i18n:translate="linkintegrity_item_not_accessible">
-                              The item is not accessible.
-                            </tal:private>
-                          </li>
-                        </ul>
-
-                  </article>
-
-              <br />
-
-              <p i18n:translate="linkintegrity_delete_anyway">
-                  Would you like to delete it anyway?
-              </p>
-
-              <input type="hidden" name="original_request"
-                     tal:attributes="value view/originalRequest" />
-
-              <input type="hidden" name="confirmed_items"
-                     tal:attributes="value view/confirmedItems" />
-
-              <input type="hidden" name="cancel_url"
-                     tal:attributes="value view/cancelURL" />
-
-              <input class="destructive" type="submit" name="delete"
-                     value="Yes" i18n:attributes="value linkintegrity_yes" />
-
-              <input class="destructive" type="submit" name="delete_all"
-                     value="Yes to all" i18n:attributes="value linkintegrity_yes_to_all" />
-
-              <input class="standalone" type="submit" name="cancel"
-                     value="Cancel" i18n:attributes="value linkintegrity_cancel" />
-
-              </div>
-            </form>
-        </div>
-    </article>
-
-</metal:main>
-
-</body>
-</html>
diff --git a/plone/app/linkintegrity/browser/confirmation.py b/plone/app/linkintegrity/browser/confirmation.py
deleted file mode 100644
index 3dcef67..0000000
--- a/plone/app/linkintegrity/browser/confirmation.py
+++ /dev/null
@@ -1,84 +0,0 @@
-# -*- coding: utf-8 -*-
-from Acquisition import aq_inner
-from Products.Five import BrowserView
-from Products.CMFCore.utils import getToolByName, _checkPermission
-from Products.CMFCore.permissions import AccessContentsInformation
-from plone.app.linkintegrity.interfaces import ILinkIntegrityInfo
-from plone.app.linkintegrity.utils import encodeRequestData
-from zope.component import getMultiAdapter
-from zope.i18n import translate
-
-
-class RemoveConfirmationView(BrowserView):
-
-    def __init__(self, context, request):
-        # since this is a view adapting an exception and a request (instead
-        # of a regular content object and a request), the exception object
-        # was passed as the context;  therefore we need to construct a
-        # proper context in order to render the template in a sane manner;
-        # to do this we will assume that the desired context was passed as
-        # the first exception value...
-        self.exception = context
-        self.context, = context.args
-        self.request = request
-
-    @property
-    def portal_state(self):
-        return getMultiAdapter(
-            (self.context, self.request), name='plone_portal_state')
-
-    def originalRequest(self):
-        # in order to interrupt the current request with a confirmation
-        # question about removing the referred to object we need to save
-        # the original request to be able to possibly continue it later on,
-        # so we pickle and encode its body and environment...
-        self.request.stdin.seek(0)
-        body = self.request.stdin.read()
-        env = dict(self.request._orig_env)
-        for key in 'HTTP_AUTHORIZATION', 'HTTP_COOKIE':
-            if key in env:
-                del env[key]
-        return encodeRequestData((body, env))
-
-    def getPortalTypeTitle(self, obj):
-        # Get the portal type title of the object.
-        context = aq_inner(self.context)
-        portal_types = getToolByName(context, 'portal_types')
-        fti = portal_types.get(obj.portal_type)
-        if fti is not None:
-            type_title_msgid = fti.Title()
-        else:
-            type_title_msgid = obj.portal_type
-        type_title = translate(type_title_msgid, context=self.request)
-        return type_title
-
-    def integrityBreaches(self):
-        info = ILinkIntegrityInfo(self.request).getIntegrityBreaches()
-        byTitle = lambda a, b: cmp(
-            (a.Title(), a.getId()), (b.Title(), b.getId()))
-        breaches = []
-        for target, sources in info.items():
-            breaches.append({
-                'title': target.Title(),
-                'type': target.getPortalTypeName(),
-                'type_title': self.getPortalTypeTitle(target),
-                'url': target.absolute_url(),
-                'sources': sorted(sources, byTitle),
-            })
-        return sorted(breaches, lambda a, b: cmp(a['title'], b['title']))
-
-    def isAccessible(self, obj):
-        return _checkPermission(AccessContentsInformation, obj)
-
-    def confirmedItems(self):
-        info = ILinkIntegrityInfo(self.request)
-        targets = info.getIntegrityBreaches().keys()
-        return info.encodeConfirmedItems(additions=targets)
-
-    def callbackURL(self):
-        return '{0:s}/removeConfirmationAction'.format(
-            self.portal_state.navigation_root_url())
-
-    def cancelURL(self):
-        url = self.request.environ.get('HTTP_REFERER', None)
-        return url or self.portal_state.navigation_root_url()
diff --git a/plone/app/linkintegrity/browser/remove.py b/plone/app/linkintegrity/browser/remove.py
deleted file mode 100644
index b0e61b7..0000000
--- a/plone/app/linkintegrity/browser/remove.py
+++ /dev/null
@@ -1,62 +0,0 @@
-# -*- coding: utf-8 -*-
-from Acquisition import aq_inner
-from base64 import b64encode
-from StringIO import StringIO
-from ZPublisher.Publish import Retry
-
-from Products.CMFPlone import PloneMessageFactory as _
-from Products.Five import BrowserView
-from Products.statusmessages.interfaces import IStatusMessage
-
-from plone.app.linkintegrity.interfaces import ILinkIntegrityInfo
-from plone.app.linkintegrity.utils import decodeRequestData
-
-
-class RemoveReferencedObjectView(BrowserView):
-
-    def __init__(self, context, request):
-        self.context = context
-        self.request = request
-
-    def __call__(self):
-        # this view is intended to provide an action called by the
-        # confirmation form;  all it does is prepare the request for
-        # the retry exception and raise it...
-        request = aq_inner(self.request)
-        clicked = request.form.has_key
-        if clicked('delete') or clicked('delete_all'):
-            # the user choose to actually delete the referred to object,
-            # so we reconstruct the original request which we interrupted
-            # before, store the so far confirmed items and retry it...
-            body, env = decodeRequestData(request.get('original_request'))
-
-            marker = ILinkIntegrityInfo(request).getEnvMarker()
-            if clicked('delete_all'):
-                env[marker] = 'all'
-            else:
-                env[marker] = request.get('confirmed_items')
-            auth = request._authUserPW()
-            if auth is not None:
-                authtoken = b64encode('%s:%s' % auth)
-                env['HTTP_AUTHORIZATION'] = 'Basic %s' % authtoken
-            env['HTTP_COOKIE'] = request.get('HTTP_COOKIE', '')
-
-            # Update the original environment with the new one. In a WSGI
-            # context, we want to update the dict, not overwrite it, because
-            # we actually want to modify the WSGI environ. We also need to
-            # make sure we don't touch keys that are not strings
-            request._orig_env.update(env)
-
-            # Set the stdin for the request
-            new_stdin = StringIO(body)
-            if 'wsgi.input' in request._orig_env:
-                request._orig_env['wsgi.input'] = new_stdin
-            setattr(request, 'stdin', new_stdin)
-
-            raise Retry
-        else:
-            # the user choose to cancel the removal, in which case we
-            # redirect back to the original HTTP_REFERER url...
-            msg = _(u'Removal cancelled.')
-            IStatusMessage(request).addStatusMessage(msg, type='info')
-            request.RESPONSE.redirect(request.get('cancel_url'))
diff --git a/plone/app/linkintegrity/handlers.py b/plone/app/linkintegrity/handlers.py
index 6393489..d2e1c93 100644
--- a/plone/app/linkintegrity/handlers.py
+++ b/plone/app/linkintegrity/handlers.py
@@ -140,7 +140,8 @@ def modifiedArchetype(obj, event):
                 value = field.get(obj)
             links = extractLinks(value, encoding)
             refs |= getObjectsFromLinks(obj, links)
-    updateReferences(obj, referencedRelationship, refs)
+    for ref in refs:
+        _setRelation(obj, referencedRelationship, ref)
 
 
 def modifiedDexterity(obj, event):
@@ -173,71 +174,71 @@ def modifiedDexterity(obj, event):
         _setRelation(obj, referencedRelationship, ref)
 
 
-def referenceRemoved(obj, event):
-    """ store information about the removed link integrity reference """
-    assert IReference.providedBy(obj)
-    assert obj is event.object          # just making sure...
-    if not obj.relationship == referencedRelationship:
-        return                          # skip for other removed references
-    # if the object the event was fired on doesn't have a `REQUEST` attribute
-    # we can safely assume no direct user action was involved and therefore
-    # never raise a link integrity exception...
-    request = aq_get(obj, 'REQUEST', None)
-    if not request:
-        return
-    storage = ILinkIntegrityInfo(request)
-    source = obj.getSourceObject()
-    if not IBaseObject.providedBy(source) and hasattr(source, 'context'):
-        source = source.context
-    target = obj.getTargetObject()
-    if not IBaseObject.providedBy(target) and hasattr(target, 'context'):
-        target = target.context
-    if source is not None and target is not None:
-        storage.addBreach(source, target)
-
-
-def referencedObjectRemoved(obj, event):
-    """ check if the removal was already confirmed or redirect to the form """
-    # if the object the event was fired on doesn't have a `REQUEST` attribute
-    # we can safely assume no direct user action was involved and therefore
-    # never raise a link integrity exception...
-    request = aq_get(obj, 'REQUEST', None)
-    if not request:
-        return
-    info = ILinkIntegrityInfo(request)
-    # first we check if link integrity checking was enabled
-    if not info.integrityCheckingEnabled():
-        return
-
-    # since the event gets called for every subobject before it's
-    # called for the item deleted directly via _delObject (event.object)
-    # itself, but we do not want to present the user with a confirmation
-    # form for every (referred) subobject, so we remember and skip them...
-    info.addDeletedItem(obj)
-    if obj is not event.object:
-        return
-
-    # if the number of expected events has been stored to help us prevent
-    # multiple forms (i.e. in folder_delete), we wait for the next event
-    # if we know there will be another...
-    if info.moreEventsToExpect():
-        return
-
-    # at this point all subobjects have been removed already, so all
-    # link integrity breaches caused by that have been collected as well;
-    # if there aren't any (after things have been cleaned up),
-    # we keep lurking in the shadows...
-    if not info.getIntegrityBreaches():
-        return
-
-    # if the user has confirmed to remove the currently handled item in a
-    # previous confirmation form we won't need it anymore this time around...
-    if info.isConfirmedItem(obj):
-        return
-
-    # otherwise we raise an exception and pass the object that is supposed
-    # to be removed as the exception value so we can use it as the context
-    # for the view triggered by the exception;  this is needed since the
-    # view is an adapter for the exception and a request, so it gets the
-    # exception object as the context, which is not very useful...
-    raise LinkIntegrityNotificationException(obj)
+# def referenceRemoved(obj, event):
+#     """ store information about the removed link integrity reference """
+#     assert IReference.providedBy(obj)
+#     assert obj is event.object          # just making sure...
+#     if not obj.relationship == referencedRelationship:
+#         return                          # skip for other removed references
+#     # if the object the event was fired on doesn't have a `REQUEST` attribute
+#     # we can safely assume no direct user action was involved and therefore
+#     # never raise a link integrity exception...
+#     request = aq_get(obj, 'REQUEST', None)
+#     if not request:
+#         return
+#     storage = ILinkIntegrityInfo(request)
+#     source = obj.getSourceObject()
+#     if not IBaseObject.providedBy(source) and hasattr(source, 'context'):
+#         source = source.context
+#     target = obj.getTargetObject()
+#     if not IBaseObject.providedBy(target) and hasattr(target, 'context'):
+#         target = target.context
+#     if source is not None and target is not None:
+#         storage.addBreach(source, target)
+
+
+# def referencedObjectRemoved(obj, event):
+#     """ check if the removal was already confirmed or redirect to the form """
+#     # if the object the event was fired on doesn't have a `REQUEST` attribute
+#     # we can safely assume no direct user action was involved and therefore
+#     # never raise a link integrity exception...
+#     request = aq_get(obj, 'REQUEST', None)
+#     if not request:
+#         return
+#     info = ILinkIntegrityInfo(request)
+#     # first we check if link integrity checking was enabled
+#     if not info.integrityCheckingEnabled():
+#         return
+
+#     # since the event gets called for every subobject before it's
+#     # called for the item deleted directly via _delObject (event.object)
+#     # itself, but we do not want to present the user with a confirmation
+#     # form for every (referred) subobject, so we remember and skip them...
+#     info.addDeletedItem(obj)
+#     if obj is not event.object:
+#         return
+
+#     # if the number of expected events has been stored to help us prevent
+#     # multiple forms (i.e. in folder_delete), we wait for the next event
+#     # if we know there will be another...
+#     if info.moreEventsToExpect():
+#         return
+
+#     # at this point all subobjects have been removed already, so all
+#     # link integrity breaches caused by that have been collected as well;
+#     # if there aren't any (after things have been cleaned up),
+#     # we keep lurking in the shadows...
+#     if not info.getIntegrityBreaches():
+#         return
+
+#     # if the user has confirmed to remove the currently handled item in a
+#     # previous confirmation form we won't need it anymore this time around...
+#     if info.isConfirmedItem(obj):
+#         return
+
+#     # otherwise we raise an exception and pass the object that is supposed
+#     # to be removed as the exception value so we can use it as the context
+#     # for the view triggered by the exception;  this is needed since the
+#     # view is an adapter for the exception and a request, so it gets the
+#     # exception object as the context, which is not very useful...
+#     raise LinkIntegrityNotificationException(obj)


Repository: plone.app.linkintegrity


Branch: refs/heads/master
Date: 2015-07-17T11:59:33+02:00
Author: vangheem (vangheem) <vangheem@gmail.com>
Commit: https://github.com/plone/plone.app.linkintegrity/commit/a5f6f677e5f4817ba6369823973407e27990b037

comment out archetypes subscribers so it does not break

Files changed:
M plone/app/linkintegrity/at/configure.zcml

diff --git a/plone/app/linkintegrity/at/configure.zcml b/plone/app/linkintegrity/at/configure.zcml
index e0aa3fa..526493d 100644
--- a/plone/app/linkintegrity/at/configure.zcml
+++ b/plone/app/linkintegrity/at/configure.zcml
@@ -16,6 +16,7 @@
              zope.lifecycleevent.interfaces.IObjectModifiedEvent"
         handler="..handlers.modifiedArchetype" />
 
+<!--
     <subscriber
         for="Products.Archetypes.interfaces.IBaseObject
              zope.lifecycleevent.interfaces.IObjectRemovedEvent"
@@ -25,5 +26,6 @@
         for="Products.Archetypes.interfaces.IReference
              zope.lifecycleevent.interfaces.IObjectRemovedEvent"
         handler="..handlers.referenceRemoved" />
+-->
 
 </configure>


Repository: plone.app.linkintegrity


Branch: refs/heads/master
Date: 2015-07-17T12:44:01+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.app.linkintegrity/commit/a352f41aedf9495b7063a404150c4b8c6c8ee80d

only handle linkintegrity-relations

Files changed:
M plone/app/linkintegrity/utils.py

diff --git a/plone/app/linkintegrity/utils.py b/plone/app/linkintegrity/utils.py
index 2ec6d21..3b8b9d6 100644
--- a/plone/app/linkintegrity/utils.py
+++ b/plone/app/linkintegrity/utils.py
@@ -1,7 +1,9 @@
-from zExceptions import BadRequest
+# -*- coding: utf-8 -*-
 from base64 import b64encode, b64decode
-from zlib import compress, decompressobj
+from plone.app.linkintegrity.handlers import referencedRelationship
+from zExceptions import BadRequest
 from zc.relation.interfaces import ICatalog
+from zlib import compress, decompressobj
 from zope.component import getUtility
 from zope.intid.interfaces import IIntIds
 
@@ -9,7 +11,10 @@
 def isLinked(obj):
     catalog = getUtility(ICatalog)
     intids = getUtility(IIntIds)
-    l = catalog.findRelations({'to_id': intids.getId(obj)})
+    l = catalog.findRelations({
+        'to_id': intids.getId(obj),
+        'from_attribute': referencedRelationship,
+    })
     return l
 
 


Repository: plone.app.linkintegrity


Branch: refs/heads/master
Date: 2015-07-17T15:20:35+02:00
Author: vangheem (vangheem) <vangheem@gmail.com>
Commit: https://github.com/plone/plone.app.linkintegrity/commit/6cf480d55d1cfa6fba6217c6582c06cc63a6a72b

be able to check multiple objects for confirmation view

Files changed:
M plone/app/linkintegrity/browser/configure.zcml
M plone/app/linkintegrity/browser/delete_confirmation_info.pt
M plone/app/linkintegrity/browser/info.py

diff --git a/plone/app/linkintegrity/browser/configure.zcml b/plone/app/linkintegrity/browser/configure.zcml
index 2684071..50a108b 100644
--- a/plone/app/linkintegrity/browser/configure.zcml
+++ b/plone/app/linkintegrity/browser/configure.zcml
@@ -3,7 +3,7 @@
     xmlns:browser="http://namespaces.zope.org/browser">
 
     <browser:page
-       for="plone.dexterity.interfaces.IDexterityContent"
+       for="*"
        name="delete_confirmation_info"
        class=".info.DeleteConfirmationInfo"
        permission="zope2.Public"
diff --git a/plone/app/linkintegrity/browser/delete_confirmation_info.pt b/plone/app/linkintegrity/browser/delete_confirmation_info.pt
index b9b9ba1..92002c3 100644
--- a/plone/app/linkintegrity/browser/delete_confirmation_info.pt
+++ b/plone/app/linkintegrity/browser/delete_confirmation_info.pt
@@ -2,8 +2,8 @@
   xmlns="http://www.w3.org/1999/xhtml" 
   xml:lang="en"
   lang="en"
-  tal:define="breachs view/integrityBreaches"
-  tal:condition="python: len(breachs)>0"
+  tal:define="breaches view/breaches"
+  tal:condition="python: len(breaches)>0"
   i18n:domain="plone">
     <h1 class="documentFirstHeading"
         i18n:translate="linkintegrity_breaches_title">Potential link breakage</h1>
@@ -15,8 +15,8 @@
             these references first.
         </p>
 
-        <div>
-            <article tal:repeat="breach breachs">
+        <div tal:define="token context/@@authenticator/token">
+            <article tal:repeat="breach breaches">
 
               <header>
                 <a tal:attributes="href breach/url"
@@ -33,7 +33,7 @@
                     <li tal:repeat="src python:breach['sources']">
                       <tal:visible condition="python: view.isAccessible(src)">
                         <a tal:attributes="href src/absolute_url" tal:content="src/Title" />
-                        [<a tal:attributes="href string:${src/absolute_url}/edit"
+                        [<a tal:attributes="href string:${src/absolute_url}/edit?_authenticator=${token}"
                           i18n:translate="linkintegrity_edit_in_new_window"
                           target="_blank">Edit in new window</a>]
                       </tal:visible>
diff --git a/plone/app/linkintegrity/browser/info.py b/plone/app/linkintegrity/browser/info.py
index 25002e8..afa26fb 100644
--- a/plone/app/linkintegrity/browser/info.py
+++ b/plone/app/linkintegrity/browser/info.py
@@ -1,13 +1,11 @@
 # -*- coding: utf-8 -*-
 from Acquisition import aq_inner
-from Products.Five import BrowserView
-from Products.CMFCore.utils import getToolByName, _checkPermission
 from Products.CMFCore.permissions import AccessContentsInformation
-from plone.app.linkintegrity.utils import encodeRequestData
-from zope.component import getMultiAdapter
-from zope.i18n import translate
+from Products.CMFCore.utils import getToolByName, _checkPermission
+from Products.Five import BrowserView
 from Products.Five.browser.pagetemplatefile import ViewPageTemplateFile
 from plone.app.linkintegrity.utils import isLinked
+from zope.i18n import translate
 
 
 class DeleteConfirmationInfo(BrowserView):
@@ -29,21 +27,23 @@ def getPortalTypeTitle(self, obj):
     def isAccessible(self, obj):
         return _checkPermission(AccessContentsInformation, obj)
 
-    def integrityBreaches(self):
+    def checkObject(self, obj):
+        if not hasattr(self, 'breaches'):
+            self.breaches = []
         result = []
-        for element in isLinked(self.context):
+        for element in isLinked(obj):
             result.append(element.from_object)
 
         if len(result):
-            return [{
-                'title': self.context.Title(),
-                'url': self.context.absolute_url(),
+            self.breaches.append({
+                'title': obj.Title(),
+                'url': obj.absolute_url(),
                 'sources': result,
-                'type': self.context.getPortalTypeName(),
-                'type_title': self.getPortalTypeTitle(self.context)
-            }]
-        else:
-            return []
+                'type': obj.getPortalTypeName(),
+                'type_title': self.getPortalTypeTitle(obj)
+            })
 
-    def __call__(self):
+    def __call__(self, skip_context=False):
+        if not skip_context:
+            self.checkObject(self.context)
         return self.template()


Repository: plone.app.linkintegrity


Branch: refs/heads/master
Date: 2015-07-17T16:21:29+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.app.linkintegrity/commit/c422071d0b22d7834284dd6f165e6a0c6ac3a2d0

enable linkintegrity for archetypes

Files changed:
M plone/app/linkintegrity/handlers.py
M plone/app/linkintegrity/testing.py

diff --git a/plone/app/linkintegrity/handlers.py b/plone/app/linkintegrity/handlers.py
index d2e1c93..12cf332 100644
--- a/plone/app/linkintegrity/handlers.py
+++ b/plone/app/linkintegrity/handlers.py
@@ -122,11 +122,6 @@ def modifiedArchetype(obj, event):
         # `getObjectFromLinks` is not possible without access
         # to `portal_url`
         return
-    rc = getToolByName(obj, 'reference_catalog', None)
-    if rc is None:
-        # `updateReferences` is not possible without access
-        # to `reference_catalog`
-        return
     refs = set()
     for field in obj.Schema().fields():
         if isinstance(field, TextField):
diff --git a/plone/app/linkintegrity/testing.py b/plone/app/linkintegrity/testing.py
index 227491e..51ca8cc 100644
--- a/plone/app/linkintegrity/testing.py
+++ b/plone/app/linkintegrity/testing.py
@@ -18,6 +18,8 @@
 from plone.app.testing import setRoles
 from plone.testing import z2
 from zope.configuration import xmlconfig
+from plone.app.relationfield.setuphandlers import add_intids
+from plone.app.relationfield.setuphandlers import add_relations
 
 B64_DATA = 'R0lGODlhAQABAIAAAAUEBAAAACwAAAAAAQABAAACAkQBADs='
 GIF = StringIO(decodestring(B64_DATA))
@@ -99,6 +101,9 @@ class LinkIntegrityATLayer(LinkIntegrityLayer):
     )
 
     def setUp(self):
+        with ploneSite() as portal:
+            add_intids(portal)
+            add_relations(portal)
         self.setUpContent()
 
 PLONE_APP_LINKINTEGRITY_AT_FIXTURE = LinkIntegrityATLayer()
@@ -120,19 +125,6 @@ class LinkIntegrityDXLayer(LinkIntegrityLayer):
     ])
 
     def setUp(self):
-        with ploneSite() as portal:
-            ttool = getToolByName(portal, 'portal_types')
-            for type_info in self.types_providing_referencable_behavior:
-                ttool.getTypeInfo(type_info).behaviors += (
-                    'plone.app.relationfield.behavior.IRelatedItems',
-                    'plone.app.referenceablebehavior.referenceable.IReferenceable',  # noqa
-                )
-
-            # FIXME: we need uid_catalog and referencer_catalog to keep
-            #        plone.app.referencebehavior working. So load Archetypes
-            #        profile to install those tools before we continue
-            applyProfile(portal, 'Products.Archetypes:Archetypes')
-
         self.setUpContent()
 
     def setUpContent(self):


Repository: plone.app.linkintegrity


Branch: refs/heads/master
Date: 2015-07-17T16:23:11+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.app.linkintegrity/commit/cbbd470287db3dee133e83b1caf45e44f529327b

add helper-methods to test for and get links and backlinks

Files changed:
M plone/app/linkintegrity/browser/info.py
M plone/app/linkintegrity/tests/test_references.py
M plone/app/linkintegrity/utils.py

diff --git a/plone/app/linkintegrity/browser/info.py b/plone/app/linkintegrity/browser/info.py
index afa26fb..0f1034c 100644
--- a/plone/app/linkintegrity/browser/info.py
+++ b/plone/app/linkintegrity/browser/info.py
@@ -4,7 +4,7 @@
 from Products.CMFCore.utils import getToolByName, _checkPermission
 from Products.Five import BrowserView
 from Products.Five.browser.pagetemplatefile import ViewPageTemplateFile
-from plone.app.linkintegrity.utils import isLinked
+from plone.app.linkintegrity.utils import getIncomingLinks
 from zope.i18n import translate
 
 
@@ -31,7 +31,7 @@ def checkObject(self, obj):
         if not hasattr(self, 'breaches'):
             self.breaches = []
         result = []
-        for element in isLinked(obj):
+        for element in getIncomingLinks(obj):
             result.append(element.from_object)
 
         if len(result):
diff --git a/plone/app/linkintegrity/tests/test_references.py b/plone/app/linkintegrity/tests/test_references.py
index 7f53a57..cf449c6 100644
--- a/plone/app/linkintegrity/tests/test_references.py
+++ b/plone/app/linkintegrity/tests/test_references.py
@@ -1,28 +1,22 @@
 # -*- coding: utf-8 -*-
 from Products.Archetypes.interfaces import IReferenceable
-from plone.app.linkintegrity import testing
-from plone.app.testing import logout
-from plone.app.testing import login
 from plone.app.linkintegrity import exceptions
+from plone.app.linkintegrity import testing
 from plone.app.linkintegrity.parser import extractLinks
 from plone.app.linkintegrity.tests.base import ATBaseTestCase
 from plone.app.linkintegrity.tests.base import DXBaseTestCase
+from plone.app.linkintegrity.utils import hasIncomingLinks
+from plone.app.testing import login
+from plone.app.testing import logout
 
 
 class ReferenceGenerationTestCase:
 
-    def test_notification_exception(self):
-        self._set_text(self.portal['doc3'], '<a href="doc1">doc1</a>')
-        self.assertRaises(
-            exceptions.LinkIntegrityNotificationException,
-            self.portal.manage_delObjects, ['doc1'])
-
     def test_is_linked(self):
-        from Products.CMFPlone.utils import isLinked
         img1 = self.portal['image1']
         doc1 = self.portal['doc1']
         self._set_text(doc1, '<img src="image1"></img>')
-        self.assertTrue(isLinked(img1))
+        self.assertTrue(hasIncomingLinks(img1))
 
     def test_referal_to_private_files(self):
         # This tests the behaviour of the link integrity code when a to
@@ -111,7 +105,7 @@ def test_relative_upwards_link_generates_matching_reference(self):
     def test_unicode_links(self):
         doc1 = self.portal.doc1
 
-        # This tests checks that isLinked can now be used safely as it
+        # This tests checks that hasIncomingLinks can now be used safely as it
         # eventually plays well with transaction machinery.
         # Add bad link, should not raise exception and there should not
         # be any references added.
diff --git a/plone/app/linkintegrity/utils.py b/plone/app/linkintegrity/utils.py
index 3b8b9d6..9593634 100644
--- a/plone/app/linkintegrity/utils.py
+++ b/plone/app/linkintegrity/utils.py
@@ -8,14 +8,40 @@
 from zope.intid.interfaces import IIntIds
 
 
-def isLinked(obj):
+def getIncomingLinks(obj):
+    """Return a generator of incoming relations created using
+    plone.app.linkintegrity (Links in Richtext-Fields).
+    """
     catalog = getUtility(ICatalog)
     intids = getUtility(IIntIds)
-    l = catalog.findRelations({
+    return catalog.findRelations({
         'to_id': intids.getId(obj),
-        'from_attribute': referencedRelationship,
-    })
-    return l
+        'from_attribute': referencedRelationship})
+
+
+def hasIncomingLinks(obj):
+    """Test if an object is linked to by other objects using
+    plone.app.linkintegrity (Links in Richtext-Fields).
+    """
+    return bool([i for i in getIncomingLinks(obj)])
+
+
+def getOutgoingLinks(obj):
+    """Return a generator of outgoing relations created using
+    plone.app.linkintegrity (Links in Richtext-Fields).
+    """
+    catalog = getUtility(ICatalog)
+    intids = getUtility(IIntIds)
+    return catalog.findRelations({
+        'from_id': intids.getId(obj),
+        'from_attribute': referencedRelationship})
+
+
+def hasOutgoingLinks(obj):
+    """Test if an object links to other objects using plone.app.linkintegrity
+    (Links in Richtext-Fields).
+    """
+    return bool([i for i in getOutgoingLinks(obj)])
 
 
 def decompress(data, maxsize=262144):


Repository: plone.app.linkintegrity


Branch: refs/heads/master
Date: 2015-07-17T16:25:41+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.app.linkintegrity/commit/bb0a02d8378b0f9643f72cbcccb44d79a8c94e6d

add method to migrate all old linkintegrity-relations from reference_catalog to zc.relation

Files changed:
A plone/app/linkintegrity/tests/test_upgrade.py
A plone/app/linkintegrity/upgrades.py

diff --git a/plone/app/linkintegrity/tests/test_upgrade.py b/plone/app/linkintegrity/tests/test_upgrade.py
new file mode 100644
index 0000000..bbd0b3e
--- /dev/null
+++ b/plone/app/linkintegrity/tests/test_upgrade.py
@@ -0,0 +1,34 @@
+# -*- coding: utf-8 -*-
+from Products.Archetypes.interfaces import IReferenceable
+from plone.app.linkintegrity.parser import extractLinks
+from plone.app.linkintegrity.handlers import referencedRelationship
+
+from plone.app.linkintegrity.tests.base import ATBaseTestCase
+from plone.app.linkintegrity.tests.base import DXBaseTestCase
+from plone.app.linkintegrity.upgrades import migrate_linkintegrity_relations
+from plone.app.testing import login
+from plone.app.testing import logout
+from plone.app.linkintegrity.utils import hasIncomingLinks
+
+
+class TestUpgrades(object):
+
+    def test_upgrade(self):
+        doc3 = self.portal['doc3']
+        doc1 = self.portal['doc1']
+        self.assertTrue(IReferenceable.providedBy(doc3))
+        doc3.setText('<a href="doc1">doc1</a>', mimetype='text/html')
+        doc3.addReference(doc1, relationship=referencedRelationship)
+        self.assertFalse(hasIncomingLinks(doc1))
+        self.assertFalse(hasIncomingLinks(doc3))
+        migrate_linkintegrity_relations(self.portal)
+        self.assertTrue(hasIncomingLinks(doc1))
+        self.assertFalse(hasIncomingLinks(doc3))
+
+
+# class ReferenceGenerationDXTestCase(DXBaseTestCase, TestUpgrades):
+#     """Reference generation testcase for dx content types"""
+
+
+class ReferenceGenerationATTestCase(ATBaseTestCase, TestUpgrades):
+    """Reference generation testcase for at content types"""
diff --git a/plone/app/linkintegrity/upgrades.py b/plone/app/linkintegrity/upgrades.py
new file mode 100644
index 0000000..20375ae
--- /dev/null
+++ b/plone/app/linkintegrity/upgrades.py
@@ -0,0 +1,26 @@
+# -*- coding: utf-8 -*-
+from Products.CMFCore.utils import getToolByName
+from Products.Archetypes.config import REFERENCE_CATALOG
+from plone.app.linkintegrity.handlers import referencedRelationship
+from plone.app.uuid.utils import uuidToObject
+from zope.lifecycleevent import modified
+
+
+def migrate_linkintegrity_relations(context):
+    """Migrate linkintegrity-relation from reference_catalog to zc.relation"""
+    reference_catalog = getToolByName(context, REFERENCE_CATALOG, None)
+    if reference_catalog is not None:
+        for brain in reference_catalog():
+            # only handle linkintegrity-relations ('relatesTo')
+            if brain.relationship != referencedRelationship:
+                continue
+            source_obj = uuidToObject(brain.sourceUID)
+            target_obj = uuidToObject(brain.targetUID)
+            # Delete old reference
+            reference_catalog.deleteReference(
+                source_obj, target_obj, relationship=referencedRelationship)
+
+            # Trigger the recreation of linkintegrity-relation in
+            # the relation_catalog (zc.relation)
+            modified(source_obj)
+            modified(target_obj)


Repository: plone.app.linkintegrity


Branch: refs/heads/master
Date: 2015-07-17T20:21:59+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.app.linkintegrity/commit/f606bf5c82ece2557752075881c6b27c3d222435

fix updateLinkIntegrityInformation

Files changed:
M plone/app/linkintegrity/browser/update.py

diff --git a/plone/app/linkintegrity/browser/update.py b/plone/app/linkintegrity/browser/update.py
index b22fdd2..468db91 100644
--- a/plone/app/linkintegrity/browser/update.py
+++ b/plone/app/linkintegrity/browser/update.py
@@ -45,7 +45,6 @@ def update(self):
                 modifiedArchetype(obj, 'dummy event parameter')
                 count += 1
             elif IDexterityContent.providedBy(obj):
-                if IReferenceable.providedBy(obj):
-                    modifiedDexterity(obj, 'dummy event parameter')
+                modifiedDexterity(obj, 'dummy event parameter')
                 count += 1
         return count


Repository: plone.app.linkintegrity


Branch: refs/heads/master
Date: 2015-07-17T20:22:44+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.app.linkintegrity/commit/52b4163ab07cae6d80b9fa454f2fda8e6891398d

respect registry-setting enable_link_integrity_checks

Files changed:
M plone/app/linkintegrity/browser/info.py

diff --git a/plone/app/linkintegrity/browser/info.py b/plone/app/linkintegrity/browser/info.py
index 0f1034c..9b66e54 100644
--- a/plone/app/linkintegrity/browser/info.py
+++ b/plone/app/linkintegrity/browser/info.py
@@ -2,9 +2,12 @@
 from Acquisition import aq_inner
 from Products.CMFCore.permissions import AccessContentsInformation
 from Products.CMFCore.utils import getToolByName, _checkPermission
+from Products.CMFPlone.interfaces import IEditingSchema
 from Products.Five import BrowserView
 from Products.Five.browser.pagetemplatefile import ViewPageTemplateFile
 from plone.app.linkintegrity.utils import getIncomingLinks
+from plone.registry.interfaces import IRegistry
+from zope.component import getUtility
 from zope.i18n import translate
 
 
@@ -43,7 +46,14 @@ def checkObject(self, obj):
                 'type_title': self.getPortalTypeTitle(obj)
             })
 
+    def linkintegrity_enabled(self):
+        reg = getUtility(IRegistry)
+        editing_settings = reg.forInterface(IEditingSchema, prefix='plone')
+        return editing_settings.enable_link_integrity_checks
+
     def __call__(self, skip_context=False):
-        if not skip_context:
+        if not self.linkintegrity_enabled():
+            self.breaches = []
+        elif not skip_context:
             self.checkObject(self.context)
         return self.template()


Repository: plone.app.linkintegrity


Branch: refs/heads/master
Date: 2015-07-17T20:44:16+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.app.linkintegrity/commit/ea151209489bf289c5dafa7a46bca582a51eacfc

work on fixing functional tests

Files changed:
M plone/app/linkintegrity/tests/test_functional.py

diff --git a/plone/app/linkintegrity/tests/test_functional.py b/plone/app/linkintegrity/tests/test_functional.py
index 04259a0..de04e9f 100644
--- a/plone/app/linkintegrity/tests/test_functional.py
+++ b/plone/app/linkintegrity/tests/test_functional.py
@@ -1,9 +1,13 @@
 # -*- coding: utf-8 -*-
-from Products.Archetypes.interfaces import IReferenceable
 from Products.CMFPlone.interfaces import IEditingSchema
 
+from zc.relation.interfaces import ICatalog
 from plone.app.linkintegrity import testing
-from plone.app.linkintegrity import exceptions
+from plone.app.linkintegrity.utils import getIncomingLinks
+# from plone.app.linkintegrity.utils import hasIncomingLinks
+from plone.app.linkintegrity.utils import getOutgoingLinks
+from plone.app.linkintegrity.utils import hasOutgoingLinks
+
 from plone.app.linkintegrity.tests.base import ATBaseTestCase
 from plone.app.linkintegrity.tests.base import DXBaseTestCase
 from plone.app.testing import TEST_USER_NAME
@@ -12,37 +16,19 @@
 from plone.registry.interfaces import IRegistry
 from zope.component import getUtility
 
-
 import transaction
 
 
 class ReferenceTestCase:
 
-    def test_file_reference_throws_exception(self):
-        """This tests the behaviour when removing a referenced file."""
-
-        doc1 = self.portal.doc1
-        file2 = testing.create(self.portal, 'File',
-                               id='file2', file=testing.GIF)
-
-        self._set_text(doc1, '<a href="file2">A File</a>')
-        self.assertEqual(IReferenceable(doc1).getReferences(), [file2])
-        self.assertIn('file2', self.portal.objectIds())
-
-        token = self._get_token(file2)
-        self.request['_authenticator'] = token
-
-        # Throws exception which actually should abort transaction
-        view = file2.restrictedTraverse('@@object_delete')
-        self.assertRaises(exceptions.LinkIntegrityNotificationException, view)
-
     def test_file_reference_linkintegrity_page_is_shown(self):
         doc1 = self.portal.doc1
         file2 = testing.create(self.portal, 'File',
                                id='file2', file=testing.GIF)
 
+        self.assertFalse(hasOutgoingLinks(doc1))
         self._set_text(doc1, '<a href="file2">A File</a>')
-        self.assertEqual(IReferenceable(doc1).getReferences(), [file2])
+        self.assertTrue(hasOutgoingLinks(doc1))
         self.assertIn('file2', self.portal.objectIds())
 
         token = self._get_token(file2)
@@ -56,7 +42,7 @@ def test_file_reference_linkintegrity_page_is_shown(self):
             'Authorization',
             'Basic {0:s}:{1:s}'.format(TEST_USER_NAME, TEST_USER_PASSWORD))
 
-        delete_url = '{0:s}/object_delete?_authenticator={1:s}'.format(
+        delete_url = '{0:s}/delete_confirmation?_authenticator={1:s}'.format(
             file2.absolute_url(), token)
 
         # Try to remove but cancel
@@ -64,21 +50,20 @@ def test_file_reference_linkintegrity_page_is_shown(self):
 
         # Validate text
         self.assertIn('Potential link breakage', self.browser.contents)
-        self.assertIn('removeConfirmationAction', self.browser.contents)
         self.assertIn('<a href="http://nohost/plone/doc1">Test Page 1</a>',
                       self.browser.contents)
         self.assertIn('Would you like to delete it anyway?',
                       self.browser.contents)
 
         # Click cancel button, item should stay in place
-        self.browser.getControl(name='cancel').click()
-        self.assertEqual(self.browser.url, self.portal.absolute_url())
+        self.browser.getControl(name='form.buttons.Cancel').click()
+        self.assertEqual(self.browser.url, file2.absolute_url() + '/view')
         self.assertIn('Removal cancelled.', self.browser.contents)
         self.assertIn('file2', self.portal.objectIds())
 
         # Try to remove and confirm
         self.browser.open(delete_url)
-        self.browser.getControl(name='delete').click()
+        self.browser.getControl(name='form.buttons.Delete').click()
         self.assertNotIn('file2', self.portal.objectIds())
 
     def test_unreferenced_removal(self):
@@ -104,7 +89,8 @@ def test_renaming_referenced_item(self):
         # renamed (see the related bug report in #6608).  First we need
         # to create the necessary links:
         self._set_text(doc1, '<a href="doc2">doc2</a>')
-        self.assertEqual(IReferenceable(doc2).getBackReferences(), [doc1])
+        self.assertEqual(
+            [i.from_object for i in getIncomingLinks(doc2)], [doc1])
 
         # Make changes visible to testbrowseropen
         transaction.commit()
@@ -121,20 +107,20 @@ def test_renaming_referenced_item(self):
 
         self.assertNotIn('doc1', self.portal.objectIds())
         self.assertIn('nuname', self.portal.objectIds())
-        self.assertEqual(IReferenceable(doc2).getBackReferences(), [doc1])
+        self.assertIn(doc1, [i.from_object for i in getIncomingLinks(doc2)])
 
         # We simply use a browser to try to delete a content item.
         self.browser.open(doc2.absolute_url())
         self.browser.getLink('Delete').click()
         self.assertIn(
             'Do you really want to delete this item?', self.browser.contents)
-        self.browser.getControl(name='form.buttons.Delete').click()
         self.assertIn('nuname', self.portal.objectIds())
-
         # Link breakabe page should be shown
         self.assertIn('Potential link breakage', self.browser.contents)
         self.assertIn('<a href="http://nohost/plone/nuname">Test Page 1</a>',
                       self.browser.contents)
+        self.browser.getControl(name='form.buttons.Delete').click()
+        self.assertNotIn('doc2', self.portal.objectIds())
 
     def test_removal_in_subfolder(self):
         doc1 = self.portal.doc1
@@ -155,14 +141,14 @@ def test_removal_in_subfolder(self):
         # throw.
         self.browser.handleErrors = True
 
-        self.browser.open('{0:s}/object_delete?_authenticator={1:s}'.format(
+        self.browser.open('{0:s}/delete_confirmation?_authenticator={1:s}'.format(
             folder1.absolute_url(), self._get_token(folder1)))
         self.assertIn('Potential link breakage', self.browser.contents)
         self.assertIn('<a href="http://nohost/plone/doc1">Test Page 1</a>',
                       self.browser.contents)
         self.assertIn('<a href="http://nohost/plone/doc2">Test Page 2</a>',
                       self.browser.contents)
-        self.browser.getControl(name='delete').click()
+        self.browser.getControl(name='form.buttons.Delete').click()
         self.assertNotIn('folder1', self.portal.objectIds())
 
     def test_removal_with_cookie_auth(self):
@@ -194,12 +180,12 @@ def test_removal_with_cookie_auth(self):
 
         # This should lead us back to the "folder contents" listing,
         # where we try to delete the referenced document.
-        browser.open('{0:s}/object_delete?_authenticator={1:s}'.format(
+        browser.open('{0:s}/delete_confirmation?_authenticator={1:s}'.format(
             doc2.absolute_url(), self._get_token(doc2)))
         self.assertIn('Potential link breakage', browser.contents)
         self.assertIn('<a href="http://nohost/plone/doc1">Test Page 1</a>',
                       browser.contents)
-        browser.getControl(name='delete').click()
+        browser.getControl(name='form.buttons.Delete').click()
         self.assertNotIn('doc2', self.portal.objectIds())
 
     def test_linkintegrity_on_off_switch(self):
@@ -216,7 +202,7 @@ def test_linkintegrity_on_off_switch(self):
         # the exception we intentionally throw.
         self.browser.handleErrors = True
 
-        self.browser.open('{0:s}/object_delete?_authenticator={1:s}'.format(
+        self.browser.open('{0:s}/delete_confirmation?_authenticator={1:s}'.format(
             doc2.absolute_url(), self._get_token(doc2)))
         self.assertIn('Potential link breakage', self.browser.contents)
         self.assertIn('<a href="http://nohost/plone/doc1">Test Page 1</a>',
@@ -229,9 +215,7 @@ def test_linkintegrity_on_off_switch(self):
         settings.enable_link_integrity_checks = False
         transaction.commit()
         self.browser.reload()
-        self.assertEqual(self.browser.url, self.portal.absolute_url())
-        self.assertIn('Test Page 2 has been deleted.', self.browser.contents)
-        self.assertNotIn('doc2', self.portal.objectIds())
+        self.assertNotIn('Potential link breakage', self.browser.contents)
 
     def test_update(self):
         doc1 = self.portal.doc1
@@ -242,13 +226,16 @@ def test_update(self):
         # i.e. after migrating from a previous version.
         self._set_text(doc1, '<a href="doc2">a document</a>')
         self._set_text(doc2, '<a href="folder1/doc4">a document</a>')
-        IReferenceable(doc1).deleteReferences(relationship='isReferencing')
-        IReferenceable(doc2).deleteReferences(relationship='isReferencing')
+
+        catalog = getUtility(ICatalog)
+        rels = [i for i in catalog.findRelations()]
+        for rel in rels:
+            catalog.unindex(rel)
 
         # Just to make sure, we check that there are no references from or to
         # these documents at this point:
-        self.assertEqual(IReferenceable(doc1).getReferences(), [])
-        self.assertEqual(IReferenceable(doc2).getReferences(), [])
+        self.assertEqual([i.to_object for i in getOutgoingLinks(doc1)], [])
+        self.assertEqual([i.to_object for i in getOutgoingLinks(doc2)], [])
 
         # An update of link integrity information for all content is triggered
         # by browsing a specific url:
@@ -261,8 +248,8 @@ def test_update(self):
 
         # Now the linking documents should hold the correct link integrity
         # references:
-        self.assertEqual(IReferenceable(doc1).getReferences(), [doc2, ])
-        self.assertEqual(IReferenceable(doc2).getReferences(), [doc4, ])
+        self.assertEqual([i.to_object for i in getOutgoingLinks(doc1)], [doc2, ])
+        self.assertEqual([i.to_object for i in getOutgoingLinks(doc2)], [doc4, ])
 
     def test_references_on_cloned_objects(self):
         doc1 = self.portal.doc1
@@ -289,7 +276,7 @@ def test_references_on_cloned_objects(self):
 
         # Now we can continue and "click" the "delete" action. The confirmation
         # page should list both documents:
-        self.browser.open('{0:s}/object_delete?_authenticator={1:s}'.format(
+        self.browser.open('{0:s}/delete_confirmation?_authenticator={1:s}'.format(
             doc2.absolute_url(), self._get_token(doc2)))
         self.assertIn(
             'is referenced by the following items:', self.browser.contents)
@@ -317,7 +304,8 @@ def test_files_with_spaces_removal(self):
         self._set_text(doc1, '<a href="some spaces.doc">a document</a>')
 
         # The document should now have a reference to the file:
-        self.assertEqual(IReferenceable(doc1).getReferences(), [spaces1])
+        self.assertEqual(
+            [i.to_object for i in getOutgoingLinks(doc1)], [spaces1])
         transaction.commit()
 
         # Then we use a browser to try to delete the referenced file.
@@ -325,24 +313,25 @@ def test_files_with_spaces_removal(self):
         # from choking on the exception we intentionally throw.
         self.browser.handleErrors = True
 
-        self.browser.open('{0:s}/object_delete?_authenticator={1:s}'.format(
+        self.browser.open('{0:s}/delete_confirmation?_authenticator={1:s}'.format(
             spaces1.absolute_url(), self._get_token(spaces1)))
         self.assertIn('Potential link breakage', self.browser.contents)
         self.assertIn(
             '<a href="http://nohost/plone/doc1">Test Page 1</a>',
             self.browser.contents
         )
-        self.browser.getControl(name='delete').click()
+        self.browser.getControl(name='form.buttons.Delete').click()
         self.assertNotIn('some spaces.doc', self.portal.objectIds())
 
     def test_removal_via_zmi(self):
+        """Delete via ZMI is no longer protedted!"""
         doc1 = self.portal.doc1
         doc2 = self.portal.doc2
 
         # This tests ensuring link integrity when removing an object via
         # the ZMI.
         self._set_text(doc1, '<a href="doc2">a document</a>')
-        self.assertEqual(IReferenceable(doc1).getReferences(), [doc2])
+        self.assertEqual([i.to_object for i in getOutgoingLinks(doc1)], [doc2])
 
         transaction.commit()
         # Then we use a browser to try to delete the referenced
@@ -356,15 +345,6 @@ def test_removal_via_zmi(self):
             .getControl(value='doc2').selected = True
 
         self.browser.getControl('Delete').click()
-        self.assertIn('Potential link breakage', self.browser.contents)
-        self.assertIn(
-            '<a href="http://nohost/plone/doc1">Test Page 1</a>',
-            self.browser.contents
-        )
-
-        # After we have acknowledged the breach in link integrity the
-        # document should have been deleted:
-        self.browser.getControl(name='delete').click()
         self.assertNotIn('doc2', self.portal.objectIds())
 
 


Repository: plone.app.linkintegrity


Branch: refs/heads/master
Date: 2015-07-17T20:44:32+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.app.linkintegrity/commit/fd86e5a3adc58847eb7f158ae8e503847e5558da

fix upgrade-tests

Files changed:
M plone/app/linkintegrity/tests/test_upgrade.py

diff --git a/plone/app/linkintegrity/tests/test_upgrade.py b/plone/app/linkintegrity/tests/test_upgrade.py
index bbd0b3e..28cad29 100644
--- a/plone/app/linkintegrity/tests/test_upgrade.py
+++ b/plone/app/linkintegrity/tests/test_upgrade.py
@@ -1,17 +1,13 @@
 # -*- coding: utf-8 -*-
 from Products.Archetypes.interfaces import IReferenceable
-from plone.app.linkintegrity.parser import extractLinks
 from plone.app.linkintegrity.handlers import referencedRelationship
-
 from plone.app.linkintegrity.tests.base import ATBaseTestCase
-from plone.app.linkintegrity.tests.base import DXBaseTestCase
 from plone.app.linkintegrity.upgrades import migrate_linkintegrity_relations
-from plone.app.testing import login
-from plone.app.testing import logout
 from plone.app.linkintegrity.utils import hasIncomingLinks
 
 
-class TestUpgrades(object):
+class ReferenceMigrationATTestCase(ATBaseTestCase):
+    """Reference migration testcase for at content types"""
 
     def test_upgrade(self):
         doc3 = self.portal['doc3']
@@ -24,11 +20,3 @@ def test_upgrade(self):
         migrate_linkintegrity_relations(self.portal)
         self.assertTrue(hasIncomingLinks(doc1))
         self.assertFalse(hasIncomingLinks(doc3))
-
-
-# class ReferenceGenerationDXTestCase(DXBaseTestCase, TestUpgrades):
-#     """Reference generation testcase for dx content types"""
-
-
-class ReferenceGenerationATTestCase(ATBaseTestCase, TestUpgrades):
-    """Reference generation testcase for at content types"""


Repository: plone.app.linkintegrity


Branch: refs/heads/master
Date: 2015-07-17T20:51:19+02:00
Author: vangheem (vangheem) <vangheem@gmail.com>
Commit: https://github.com/plone/plone.app.linkintegrity/commit/435f5a7e20ebc65138c4ac1dd3aafaf6ec792a6b

cleanup utils

Files changed:
M plone/app/linkintegrity/utils.py

diff --git a/plone/app/linkintegrity/utils.py b/plone/app/linkintegrity/utils.py
index 9593634..a5f8aca 100644
--- a/plone/app/linkintegrity/utils.py
+++ b/plone/app/linkintegrity/utils.py
@@ -1,9 +1,6 @@
 # -*- coding: utf-8 -*-
-from base64 import b64encode, b64decode
 from plone.app.linkintegrity.handlers import referencedRelationship
-from zExceptions import BadRequest
 from zc.relation.interfaces import ICatalog
-from zlib import compress, decompressobj
 from zope.component import getUtility
 from zope.intid.interfaces import IIntIds
 
@@ -22,8 +19,12 @@ def getIncomingLinks(obj):
 def hasIncomingLinks(obj):
     """Test if an object is linked to by other objects using
     plone.app.linkintegrity (Links in Richtext-Fields).
+
+    Way to give bool without loading generator into list
     """
-    return bool([i for i in getIncomingLinks(obj)])
+    for i in getIncomingLinks(obj):
+        return True
+    return False
 
 
 def getOutgoingLinks(obj):
@@ -41,53 +42,6 @@ def hasOutgoingLinks(obj):
     """Test if an object links to other objects using plone.app.linkintegrity
     (Links in Richtext-Fields).
     """
-    return bool([i for i in getOutgoingLinks(obj)])
-
-
-def decompress(data, maxsize=262144):
-
-    dec = decompressobj()
-    data = dec.decompress(data, maxsize)
-    if dec.unconsumed_tail:
-        raise BadRequest
-    del dec
-
-    return data
-
-
-def encodeStrings(strings):
-    """ compress and encode a list of strings into a single string """
-    def _encode(strings):
-        for string in strings:
-            yield '%d:%s' % (len(string), string)
-    return b64encode(compress(''.join(_encode(strings))))
-
-
-def decodeStrings(data):
-    """ decode and uncompress a string as a generator """
-    data = decompress(b64decode(data))
-    while data:
-        pos = data.find(':')
-        end = pos + int(data[:pos]) + 1
-        yield data[pos + 1:end]
-        data = data[end:]
-
-
-def encodeRequestData((body, env)):
-    """ encode the relevant request data, i.e. body and env """
-    def _iterdata():
-        yield body
-        for key, val in env.iteritems():
-            if isinstance(key, basestring) and isinstance(val, basestring):
-                yield str(key)
-                yield str(val)
-    return encodeStrings(_iterdata())
-
-
-def decodeRequestData(data):
-    """ decode the relevant request data, i.e. body and env """
-    def _pertwo():
-        while True:
-            yield data.next(), data.next()
-    data = decodeStrings(data)
-    return data.next(), dict(_pertwo())
+    for i in getOutgoingLinks(obj):
+        return True
+    return False


Repository: plone.app.linkintegrity


Branch: refs/heads/master
Date: 2015-07-17T21:01:53+02:00
Author: vangheem (vangheem) <vangheem@gmail.com>
Commit: https://github.com/plone/plone.app.linkintegrity/commit/26b2665ad6b32d737cf2ca1709df621c22608fb5

provide deep check on object links

Files changed:
M plone/app/linkintegrity/browser/info.py

diff --git a/plone/app/linkintegrity/browser/info.py b/plone/app/linkintegrity/browser/info.py
index 9b66e54..ac574ce 100644
--- a/plone/app/linkintegrity/browser/info.py
+++ b/plone/app/linkintegrity/browser/info.py
@@ -1,5 +1,6 @@
 # -*- coding: utf-8 -*-
 from Acquisition import aq_inner
+from OFS.interfaces import IFolder
 from Products.CMFCore.permissions import AccessContentsInformation
 from Products.CMFCore.utils import getToolByName, _checkPermission
 from Products.CMFPlone.interfaces import IEditingSchema
@@ -30,21 +31,40 @@ def getPortalTypeTitle(self, obj):
     def isAccessible(self, obj):
         return _checkPermission(AccessContentsInformation, obj)
 
-    def checkObject(self, obj):
-        if not hasattr(self, 'breaches'):
-            self.breaches = []
+    def shallowCheckObject(self, obj):
         result = []
         for element in getIncomingLinks(obj):
             result.append(element.from_object)
 
         if len(result):
-            self.breaches.append({
+            return {
                 'title': obj.Title(),
                 'url': obj.absolute_url(),
                 'sources': result,
                 'type': obj.getPortalTypeName(),
                 'type_title': self.getPortalTypeTitle(obj)
-            })
+            }
+
+    def checkObject(self, obj):
+        if not hasattr(self, 'breaches'):
+            self.breaches = []
+        check = self.shallowCheckObject(obj)
+        if check:
+            self.breaches.append(check)
+
+        if IFolder.providedBy(obj):
+            # now check if folder and go through children
+            # looking for links....
+            # Unfortunately, there doesn't seem to be a better,
+            # less expensive way to do this. This operation could
+            # potentially cost a lot of cycles...
+            catalog = getToolByName(self.context, 'portal_catalog')
+            folder_path = '/'.join(obj.getPhysicalPath())
+            for brain in catalog(path={'query': folder_path}):
+                ob = brain.getObject()
+                check = self.shallowCheckObject(ob)
+                if check:
+                    self.breaches.append(check)
 
     def linkintegrity_enabled(self):
         reg = getUtility(IRegistry)


Repository: plone.app.linkintegrity


Branch: refs/heads/master
Date: 2015-07-19T18:42:23-05:00
Author: vangheem (vangheem) <vangheem@gmail.com>
Commit: https://github.com/plone/plone.app.linkintegrity/commit/9cffbd26c78726a8fda2da93e859bc6262a9e8f1

add classes

Files changed:
M plone/app/linkintegrity/browser/delete_confirmation_info.pt

diff --git a/plone/app/linkintegrity/browser/delete_confirmation_info.pt b/plone/app/linkintegrity/browser/delete_confirmation_info.pt
index 92002c3..9e161b2 100644
--- a/plone/app/linkintegrity/browser/delete_confirmation_info.pt
+++ b/plone/app/linkintegrity/browser/delete_confirmation_info.pt
@@ -16,21 +16,21 @@
         </p>
 
         <div tal:define="token context/@@authenticator/token">
-            <article tal:repeat="breach breaches">
+            <article tal:repeat="breach breaches" class="breach-container">
 
               <header>
                 <a tal:attributes="href breach/url"
                     tal:content="breach/title" />
               </header>
               <p>
-                  <span i18n:translate="linkintegrity_is_referenced">
+                  <span i18n:translate="linkintegrity_is_referenced" class="breach-warning">
                       This <span i18n:name="portal_type" tal:content="breach/type_title" />
                       is referenced by the following items:
                   </span>
               </p>
 
                   <ul>
-                    <li tal:repeat="src python:breach['sources']">
+                    <li tal:repeat="src python:breach['sources']" class="breach-item">
                       <tal:visible condition="python: view.isAccessible(src)">
                         <a tal:attributes="href src/absolute_url" tal:content="src/Title" />
                         [<a tal:attributes="href string:${src/absolute_url}/edit?_authenticator=${token}"


Repository: plone.app.linkintegrity


Branch: refs/heads/master
Date: 2015-07-19T20:28:11-05:00
Author: vangheem (vangheem) <vangheem@gmail.com>
Commit: https://github.com/plone/plone.app.linkintegrity/commit/2d8eea713abed894f824324d1d1239a85e27afd2

switch to IObjectAddedEvent

Files changed:
M plone/app/linkintegrity/dx/configure.zcml

diff --git a/plone/app/linkintegrity/dx/configure.zcml b/plone/app/linkintegrity/dx/configure.zcml
index 07a3e78..4cbf1a5 100644
--- a/plone/app/linkintegrity/dx/configure.zcml
+++ b/plone/app/linkintegrity/dx/configure.zcml
@@ -8,7 +8,7 @@
 
     <subscriber
         for="plone.app.relationfield.interfaces.IDexterityHasRelations
-             zope.lifecycleevent.interfaces.IObjectCreatedEvent"
+             zope.lifecycleevent.interfaces.IObjectAddedEvent"
         handler="..handlers.modifiedDexterity" />
 
     <subscriber


Repository: plone.app.linkintegrity


Branch: refs/heads/master
Date: 2015-07-21T06:49:05-05:00
Author: vangheem (vangheem) <vangheem@gmail.com>
Commit: https://github.com/plone/plone.app.linkintegrity/commit/f0a73e8223d615ac6a7bdfab758f94671c6eedb9

fix test_circular tests

Files changed:
M plone/app/linkintegrity/handlers.py
M plone/app/linkintegrity/tests/test_circular.py
M plone/app/linkintegrity/tests/test_references.py
D plone/app/linkintegrity/TODO.txt
D plone/app/linkintegrity/exceptions.py
D plone/app/linkintegrity/interfaces.py
D plone/app/linkintegrity/references.py
D plone/app/linkintegrity/tests/test_doctests.py

diff --git a/plone/app/linkintegrity/TODO.txt b/plone/app/linkintegrity/TODO.txt
deleted file mode 100644
index 214a117..0000000
--- a/plone/app/linkintegrity/TODO.txt
+++ /dev/null
@@ -1,29 +0,0 @@
-to do for a first real version:
-- link integrity vs iterate
-- create method to re-create integrity refs for the whole site and
-  integrate that into migration and the control panel
-- what about ftp/dav?
-
-nice things to have later on:
-- use annotations in info adapter (info.py)
-- update implementation notes
-- it would be possible to cancel single removals while going through with
-  the others, but only if a potentially uncaught (by other code, i.e. third
-  party products) exception was raised on cancel;  atm it's unclear if this
-  would be desirable, though...
-- reintroduce objects names/path in portal message on cancel
-- add warnings about moved images/pages
-- factor out all archetypes related stuff using adapters etc (i.e. references)
-- possibly replace atreferences by something more generic (five.intid should do)
-- use pullparser.py instead of the newly written link-parser?
-
-Things done and/or discovered in PLIP 13260 (winebeersprint 2014, saily, do3cc)
-- restructured whole package
-- using at and dx folders to allow setup of different specific tests in each
-  folder.
-- converted all doctests into p.a.testing tests, which run now quite fast.
-- linkintegrity is a huge hack. we should think about a more cleaner and
-  generic approach to implement such checks.
-- currently we have one failing test on dexerity, which targets renaming
-  documents. it has a decorator allowfailure to not break whole setup, we might
-  need to fix that later.
diff --git a/plone/app/linkintegrity/exceptions.py b/plone/app/linkintegrity/exceptions.py
deleted file mode 100644
index 30f26a7..0000000
--- a/plone/app/linkintegrity/exceptions.py
+++ /dev/null
@@ -1,14 +0,0 @@
-from zope.interface import implements
-from interfaces import ILinkIntegrityNotificationException
-from OFS.ObjectManager import BeforeDeleteException
-
-
-class LinkIntegrityNotificationException(BeforeDeleteException):
-    """ an exception indicating a prevented link integrity breach """
-    implements(ILinkIntegrityNotificationException)
-
-    def __str__(self):
-        args = self.args
-        if args and isinstance(args, tuple):
-            return repr(args[0])
-        return super(LinkIntegrityNotificationException, self).__str__()
diff --git a/plone/app/linkintegrity/handlers.py b/plone/app/linkintegrity/handlers.py
index 12cf332..6f71c4b 100644
--- a/plone/app/linkintegrity/handlers.py
+++ b/plone/app/linkintegrity/handlers.py
@@ -1,25 +1,18 @@
 # -*- coding: utf-8 -*-
+from urllib import unquote
+from urlparse import urlsplit
+
 from Acquisition import aq_get
 from Acquisition import aq_parent
 from Products.Archetypes.Field import TextField
 from Products.Archetypes.interfaces import IBaseObject
-from Products.Archetypes.interfaces import IReference
-from Products.Archetypes.interfaces import IReferenceable
 from Products.CMFCore.utils import getToolByName
-from OFS.interfaces import IItem
 from ZODB.POSException import ConflictError
-from plone.app.linkintegrity.exceptions \
-    import LinkIntegrityNotificationException
-from plone.app.linkintegrity.interfaces import ILinkIntegrityInfo
 from plone.app.linkintegrity.parser import extractLinks
-from plone.app.linkintegrity.references import updateReferences
 from zExceptions import NotFound
 from zope.component import getUtility
-from zope.schema import getFieldsInOrder
-from zope.component.hooks import getSite
 from zope.publisher.interfaces import NotFound as ztkNotFound
-from urllib import unquote
-from urlparse import urlsplit
+from zope.schema import getFieldsInOrder
 
 # To support various Plone versions, we need to support various UUID resolvers
 # This follows Kupu, TinyMCE and plone.app.uuid methods, in a similar manner to
@@ -30,14 +23,12 @@
 # We try to import dexterity related modules, or modules used just if
 # dexterity is around
 from plone.app.textfield import RichText
+from plone.dexterity.interfaces import IDexterityContent
 from plone.dexterity.interfaces import IDexterityFTI
 from plone.dexterity.utils import getAdditionalSchemata
-from zope.intid.interfaces import IIntIds
 from z3c.relationfield import RelationValue
-from zope.annotation.interfaces import IAnnotations
-from plone.dexterity.interfaces import IDexterityContent
-from Products.CMFPlone.interfaces import IPloneSiteRoot
 from z3c.relationfield.event import _setRelation
+from zope.intid.interfaces import IIntIds
 
 
 def _resolveUID(uid):
@@ -167,73 +158,3 @@ def modifiedDexterity(obj, event):
                 refs |= getObjectsFromLinks(obj, links)
     for ref in refs:
         _setRelation(obj, referencedRelationship, ref)
-
-
-# def referenceRemoved(obj, event):
-#     """ store information about the removed link integrity reference """
-#     assert IReference.providedBy(obj)
-#     assert obj is event.object          # just making sure...
-#     if not obj.relationship == referencedRelationship:
-#         return                          # skip for other removed references
-#     # if the object the event was fired on doesn't have a `REQUEST` attribute
-#     # we can safely assume no direct user action was involved and therefore
-#     # never raise a link integrity exception...
-#     request = aq_get(obj, 'REQUEST', None)
-#     if not request:
-#         return
-#     storage = ILinkIntegrityInfo(request)
-#     source = obj.getSourceObject()
-#     if not IBaseObject.providedBy(source) and hasattr(source, 'context'):
-#         source = source.context
-#     target = obj.getTargetObject()
-#     if not IBaseObject.providedBy(target) and hasattr(target, 'context'):
-#         target = target.context
-#     if source is not None and target is not None:
-#         storage.addBreach(source, target)
-
-
-# def referencedObjectRemoved(obj, event):
-#     """ check if the removal was already confirmed or redirect to the form """
-#     # if the object the event was fired on doesn't have a `REQUEST` attribute
-#     # we can safely assume no direct user action was involved and therefore
-#     # never raise a link integrity exception...
-#     request = aq_get(obj, 'REQUEST', None)
-#     if not request:
-#         return
-#     info = ILinkIntegrityInfo(request)
-#     # first we check if link integrity checking was enabled
-#     if not info.integrityCheckingEnabled():
-#         return
-
-#     # since the event gets called for every subobject before it's
-#     # called for the item deleted directly via _delObject (event.object)
-#     # itself, but we do not want to present the user with a confirmation
-#     # form for every (referred) subobject, so we remember and skip them...
-#     info.addDeletedItem(obj)
-#     if obj is not event.object:
-#         return
-
-#     # if the number of expected events has been stored to help us prevent
-#     # multiple forms (i.e. in folder_delete), we wait for the next event
-#     # if we know there will be another...
-#     if info.moreEventsToExpect():
-#         return
-
-#     # at this point all subobjects have been removed already, so all
-#     # link integrity breaches caused by that have been collected as well;
-#     # if there aren't any (after things have been cleaned up),
-#     # we keep lurking in the shadows...
-#     if not info.getIntegrityBreaches():
-#         return
-
-#     # if the user has confirmed to remove the currently handled item in a
-#     # previous confirmation form we won't need it anymore this time around...
-#     if info.isConfirmedItem(obj):
-#         return
-
-#     # otherwise we raise an exception and pass the object that is supposed
-#     # to be removed as the exception value so we can use it as the context
-#     # for the view triggered by the exception;  this is needed since the
-#     # view is an adapter for the exception and a request, so it gets the
-#     # exception object as the context, which is not very useful...
-#     raise LinkIntegrityNotificationException(obj)
diff --git a/plone/app/linkintegrity/interfaces.py b/plone/app/linkintegrity/interfaces.py
deleted file mode 100644
index d1742dc..0000000
--- a/plone/app/linkintegrity/interfaces.py
+++ /dev/null
@@ -1,42 +0,0 @@
-from zope.interface import Interface
-
-
-class ILinkIntegrityNotificationException(Interface):
-    """ an exception indicating a prevented link integrity breach """
-
-
-class ILinkIntegrityTool(Interface):
-    """ interface of link integrity tool """
-
-
-class ILinkIntegrityInfo(Interface):
-    """ a place to store information about link integrity, i.e. breaches;
-        the storage is assumed to be unique per browser request """
-
-    def addBreach(source, target):
-        """ add information about an integrity breach, i.e. an indicator
-            that `source` object somehow references `target` """
-
-    def getIntegrityBreaches():
-        """ return stored information regarding link integrity breaches """
-
-    def setIntegrityBreaches(breaches):
-        """ store information regarding link integrity breaches """
-
-    def getDeletedItems():
-        """ return information about all items deleted during the request """
-
-    def addDeletedItem(item):
-        """ remember an item deleted during the request """
-
-    def getEnvMarker():
-        """ return the marker string used to pass the already confirmed
-            items across the retry exception """
-
-    def isConfirmedItem(obj):
-        """ indicate if the removal of the given object was confirmed """
-
-    def encodeConfirmedItems(additions):
-        """ return the list of previously confirmed (for removeal) items,
-            optionally adding the given items, encoded for usage in a form """
-
diff --git a/plone/app/linkintegrity/references.py b/plone/app/linkintegrity/references.py
deleted file mode 100644
index 24c54a5..0000000
--- a/plone/app/linkintegrity/references.py
+++ /dev/null
@@ -1,79 +0,0 @@
-# helpers related to reference handling
-#
-# the following functions can prove helpful outside of `p.a.linkintegrity`,
-# but they should really be integrated into `Archetypes` before anybody
-# starts using them.  so for now they are provided as a convenience for
-# the `plone.app.referenceintegrity` package, but other than that please
-# bear in mind the gently reminder that...
-#
-#	NOBODY ELSE SHOULD IMPORT FROM HERE!!!
-#
-# you have been warned! :)
-
-from OFS.interfaces import IItem
-from Products.Archetypes.exceptions import ReferenceException
-from Products.Archetypes.interfaces import IBaseObject
-from Products.CMFCore.utils import getToolByName
-from ZODB.POSException import ConflictError
-from logging import getLogger
-
-
-def updateReferences(obj, relationship, newrefs):
-
-    # This for sure looks ugly, but is necessary to maintian AT compatibility
-    # newrefs are wrapped objects, but getRefreences returns the real objects
-    # to generate a difference, we must do the difference with the objects
-    # the adapters wrapped. This is what real_newrefs is about
-    # next, when adding references, we have to provide the wrapped object
-    # again, so we create a mapping, newref_r_a_mapping to get the
-    # wrapped object.
-
-    real_newrefs = set()
-    newref_r_a_mapping = {}
-    for newref in newrefs:
-        # Checking for IItem is a hack to check wether this reference
-        # is an adapter or a real object. Real Objects from AT are IItem
-        if not IItem.providedBy(newref):
-            real_newrefs.add(newref.context)
-            newref_r_a_mapping[newref.context] = newref
-        else:
-            real_newrefs.add(newref)
-
-    existing = set(obj.getReferences(relationship=relationship))
-
-    for ref in real_newrefs.difference(existing):   # add new references and...
-        try:
-            obj.addReference(newref_r_a_mapping.get(ref, ref), 
-                             relationship=relationship)
-        except (ReferenceException, AttributeError):
-            pass
-    for ref in existing.difference(real_newrefs):   # removed leftovers
-        try:
-            obj.deleteReference(newref_r_a_mapping.get(ref, ref),
-                                relationship=relationship)
-        except ReferenceException:
-            removeDanglingReference(obj, relationship)
-
-
-def removeDanglingReference(obj, relationship):
-    # try to get rid of the dangling reference, but let's not
-    # have this attempt to clean up break things otherwise...
-    # iow, the `try..except` is there, because internal methods
-    # of the reference catalog are being used directly here.  any
-    # changes regarding these shouldn't break things over here,
-    # though...
-    try:
-        if not IBaseObject.providedBy(obj) and hasattr(obj, 'context'):
-            refcat = getToolByName(obj.context, 'reference_catalog')
-        else:
-            refcat = getToolByName(obj, 'reference_catalog')
-        uid, dummy = refcat._uidFor(obj)
-        brains = refcat._queryFor(uid, None, relationship=relationship)
-        objs = refcat._resolveBrains(brains)
-        for obj in objs:
-            refcat._deleteReference(obj)
-    except ConflictError:
-        raise
-    except:
-        getLogger(__name__).warning('dangling "linkintegrity" '
-            'reference to %r could not be removed.', obj)
diff --git a/plone/app/linkintegrity/tests/test_circular.py b/plone/app/linkintegrity/tests/test_circular.py
index c3c7f59..f989ea3 100644
--- a/plone/app/linkintegrity/tests/test_circular.py
+++ b/plone/app/linkintegrity/tests/test_circular.py
@@ -1,26 +1,28 @@
 # -*- coding: utf-8 -*-
-from Products.Archetypes.interfaces import IReferenceable
-from plone.app.linkintegrity import exceptions
-from plone.app.linkintegrity import testing
 from plone.app.linkintegrity.tests.base import ATBaseTestCase
 from plone.app.linkintegrity.tests.base import DXBaseTestCase
+from plone.app.linkintegrity.utils import hasIncomingLinks
+from plone.app.linkintegrity.utils import getOutgoingLinks
+from plone.app.linkintegrity.browser.info import DeleteConfirmationInfo
 
 import transaction
 
 
 class CircularReferencesTestCase:
 
-    def test_circular_reference_deletion(self):
+    def test_circular_reference_manages_relations(self):
         doc1 = self.portal['doc1']
         doc2 = self.portal['doc2']
         doc3 = self.portal['doc3']
+        self.assertFalse(hasIncomingLinks(doc1))
+        self.assertFalse(hasIncomingLinks(doc2))
+        self.assertFalse(hasIncomingLinks(doc3))
         self._set_text(doc1, '<a href="doc2">doc2</a>')
         self._set_text(doc2, '<a href="doc3">doc3</a>')
         self._set_text(doc3, '<a href="doc1">doc1</a>')
-        self.assertRaises(
-            exceptions.LinkIntegrityNotificationException,
-            self.portal.manage_delObjects, ['doc1'], self.request
-        )
+        self.assertTrue(hasIncomingLinks(doc1))
+        self.assertTrue(hasIncomingLinks(doc2))
+        self.assertTrue(hasIncomingLinks(doc3))
         transaction.abort()
 
         self.portal.manage_delObjects(
@@ -28,6 +30,9 @@ def test_circular_reference_deletion(self):
         self.assertNotIn('doc1', self.portal)
         self.assertNotIn('doc2', self.portal)
         self.assertNotIn('doc3', self.portal)
+        self.assertRaises(KeyError, hasIncomingLinks, [doc1])
+        self.assertRaises(KeyError, hasIncomingLinks, [doc2])
+        self.assertRaises(KeyError, hasIncomingLinks, [doc2])
 
     def test_circular_reference_subfolder_deletion(self):
         doc1 = self.portal.doc1
@@ -43,12 +48,15 @@ def test_circular_reference_subfolder_deletion(self):
         self._set_text(doc1, '<a href="doc2">documents...</a>')
         self._set_text(doc2, '<a href="folder1/doc4">linking...</a>')
         self._set_text(doc4, '<a href="../doc1">in circles.</a>')
-        self.assertEqual(IReferenceable(doc1).getReferences(), [doc2, ])
-        self.assertEqual(IReferenceable(doc2).getReferences(), [doc4, ])
-        self.assertEqual(IReferenceable(doc4).getReferences(), [doc1, ])
 
-        self.assertRaises(exceptions.LinkIntegrityNotificationException,
-            self.portal.manage_delObjects, ['doc1', 'doc2', ], self.request)
+        self.assertEqual([r.to_object for r in getOutgoingLinks(doc1)], [doc2, ])
+        self.assertEqual([r.to_object for r in getOutgoingLinks(doc2)], [doc4, ])
+        self.assertEqual([r.to_object for r in getOutgoingLinks(doc4)], [doc1, ])
+
+        view = DeleteConfirmationInfo(self.portal, self.request)
+        view.checkObject(doc1)
+        view.checkObject(doc2)
+        self.assertEqual(len(view.breaches), 2)
         transaction.abort()
 
         self.portal.manage_delObjects(
diff --git a/plone/app/linkintegrity/tests/test_doctests.py b/plone/app/linkintegrity/tests/test_doctests.py
deleted file mode 100644
index fb0f635..0000000
--- a/plone/app/linkintegrity/tests/test_doctests.py
+++ /dev/null
@@ -1,43 +0,0 @@
-# -*- coding:utf-8 -*-
-from plone.testing import layered
-from plone.app.linkintegrity import testing
-
-import doctest
-import os
-import re
-import unittest2
-
-OPTIONFLAGS = (doctest.REPORT_ONLY_FIRST_FAILURE |
-               doctest.ELLIPSIS |
-               doctest.NORMALIZE_WHITESPACE)
-
-pattern = re.compile('^test.*\.(txt|rst)$')
-
-
-def test_suite():
-    tests = []
-    for layer in (testing.PLONE_APP_LINKINTEGRITY_AT_FUNCTIONAL_TESTING,
-                  testing.PLONE_APP_LINKINTEGRITY_DX_FUNCTIONAL_TESTING):
-
-        test_directory = layer.__bases__[-1].directory
-        path = os.path.join(os.path.dirname(testing.__file__),
-                            test_directory, 'tests')
-
-        # Skip non-existing directories
-        if not os.path.isdir(path):
-            continue
-
-        for name in os.listdir(path):
-            if pattern.search(name):
-                tests.append(
-                    layered(
-                        doctest.DocFileSuite(
-                            '{0:s}/tests/{1:s}'.format(test_directory, name),
-                            package='plone.app.linkintegrity',
-                            optionflags=OPTIONFLAGS,
-                        ),
-                        layer=layer
-                    )
-                )
-
-    return unittest2.TestSuite(tests)
diff --git a/plone/app/linkintegrity/tests/test_references.py b/plone/app/linkintegrity/tests/test_references.py
index cf449c6..683b08e 100644
--- a/plone/app/linkintegrity/tests/test_references.py
+++ b/plone/app/linkintegrity/tests/test_references.py
@@ -1,6 +1,5 @@
 # -*- coding: utf-8 -*-
 from Products.Archetypes.interfaces import IReferenceable
-from plone.app.linkintegrity import exceptions
 from plone.app.linkintegrity import testing
 from plone.app.linkintegrity.parser import extractLinks
 from plone.app.linkintegrity.tests.base import ATBaseTestCase
@@ -49,7 +48,7 @@ def test_referal_to_private_files(self):
 
         # Throws exception
         view = img.restrictedTraverse('@@object_delete')
-        self.assertRaises(exceptions.LinkIntegrityNotificationException, view)
+        # self.assertRaises(exceptions.LinkIntegrityNotificationException, view)
 
     def test_link_extraction_easy(self):
         doc1 = self.portal.doc1


Repository: plone.app.linkintegrity


Branch: refs/heads/master
Date: 2015-07-21T07:22:17-05:00
Author: vangheem (vangheem) <vangheem@gmail.com>
Commit: https://github.com/plone/plone.app.linkintegrity/commit/0ca20b7a123930f94a885fce99eefa17fbbf2c01

fix tests to not use IReference anymore

Files changed:
M plone/app/linkintegrity/browser/info.py
M plone/app/linkintegrity/tests/test_imagescales.py
M plone/app/linkintegrity/tests/test_references.py
D plone/app/linkintegrity/tests/test_info.py

diff --git a/plone/app/linkintegrity/browser/info.py b/plone/app/linkintegrity/browser/info.py
index ac574ce..46b5f37 100644
--- a/plone/app/linkintegrity/browser/info.py
+++ b/plone/app/linkintegrity/browser/info.py
@@ -34,7 +34,9 @@ def isAccessible(self, obj):
     def shallowCheckObject(self, obj):
         result = []
         for element in getIncomingLinks(obj):
-            result.append(element.from_object)
+            obj = element.from_object
+            if obj:
+                result.append(element.from_object)
 
         if len(result):
             return {
diff --git a/plone/app/linkintegrity/tests/test_imagescales.py b/plone/app/linkintegrity/tests/test_imagescales.py
index b1f9110..85b7610 100644
--- a/plone/app/linkintegrity/tests/test_imagescales.py
+++ b/plone/app/linkintegrity/tests/test_imagescales.py
@@ -1,7 +1,8 @@
 # -*- coding: utf-8 -*-
-from Products.Archetypes.interfaces import IReferenceable
 from plone.app.linkintegrity.tests.base import ATBaseTestCase
 from plone.app.linkintegrity.tests.base import DXBaseTestCase
+from plone.app.linkintegrity.utils import getOutgoingLinks
+from plone.app.linkintegrity.utils import getIncomingLinks
 from plone.uuid.interfaces import IUUID
 
 
@@ -17,10 +18,10 @@ def test_image_tag_reference_creation(self):
         # should create references between those objects on save.
         self._set_text(doc1, img1.restrictedTraverse('@@images').tag())
 
-        self.assertEqual(IReferenceable(doc1).getReferences(), [img1])
-        self.assertEqual(IReferenceable(doc1).getBackReferences(), [])
-        self.assertEqual(IReferenceable(img1).getReferences(), [])
-        self.assertEqual(IReferenceable(img1).getBackReferences(), [doc1])
+        self.assertEqual([r.to_object for r in getOutgoingLinks(doc1)], [img1, ])
+        self.assertEqual([r.to_object for r in getIncomingLinks(doc1)], [])
+        self.assertEqual([r.to_object for r in getOutgoingLinks(img1)], [])
+        self.assertEqual([r.from_object for r in getIncomingLinks(img1)], [doc1])
 
     def test_image_scale_reference_creation(self):
         doc1 = self.portal.doc1
@@ -29,8 +30,8 @@ def test_image_scale_reference_creation(self):
         # Linking image scales should also work:
         self._set_text(
             doc1, '<a href="image1/@@images/image_thumb">an image</a>')
-        self.assertEqual(IReferenceable(doc1).getReferences(), [img1])
-        self.assertEqual(IReferenceable(img1).getBackReferences(), [doc1])
+        self.assertEqual([r.to_object for r in getOutgoingLinks(doc1)], [img1, ])
+        self.assertEqual([r.from_object for r in getIncomingLinks(img1)], [doc1, ])
 
     def test_image_resolveuid_reference_creation(self):
         doc1 = self.portal.doc1
@@ -39,9 +40,8 @@ def test_image_resolveuid_reference_creation(self):
         # Linking via the "resolveuid/UID" method should also work:
         self._set_text(doc1, '<a href="resolveuid/{0:s}">an image</a>'.format(
             IUUID(img1)))
-
-        self.assertEqual(IReferenceable(doc1).getReferences(), [img1])
-        self.assertEqual(IReferenceable(img1).getBackReferences(), [doc1])
+        self.assertEqual([r.to_object for r in getOutgoingLinks(doc1)], [img1, ])
+        self.assertEqual([r.from_object for r in getIncomingLinks(img1)], [doc1, ])
 
 
 class ImageReferenceDXTestCase(DXBaseTestCase, ImageReferenceTestCase):
diff --git a/plone/app/linkintegrity/tests/test_info.py b/plone/app/linkintegrity/tests/test_info.py
deleted file mode 100644
index a53680a..0000000
--- a/plone/app/linkintegrity/tests/test_info.py
+++ /dev/null
@@ -1,18 +0,0 @@
-# -*- coding: utf-8 -*-
-import unittest
-
-
-class TestLinkIntegrityInfo(unittest.TestCase):
-
-    def test_confirmedItems_decodes_oids_with_colons(self):
-        oid1 = '\x00' * 8
-        oid2 = ':' * 8
-        info = ('%s:%s' % (oid1, oid2)).encode('base64')
-
-        class DummyContext(object):
-            environ = {'link_integrity_info': info}
-
-        from plone.app.linkintegrity.info import LinkIntegrityInfo
-        info = LinkIntegrityInfo(DummyContext())
-        confirmed = info.confirmedItems()
-        self.assertEqual(2, len(confirmed))
diff --git a/plone/app/linkintegrity/tests/test_references.py b/plone/app/linkintegrity/tests/test_references.py
index 683b08e..267962b 100644
--- a/plone/app/linkintegrity/tests/test_references.py
+++ b/plone/app/linkintegrity/tests/test_references.py
@@ -1,10 +1,11 @@
 # -*- coding: utf-8 -*-
-from Products.Archetypes.interfaces import IReferenceable
 from plone.app.linkintegrity import testing
 from plone.app.linkintegrity.parser import extractLinks
 from plone.app.linkintegrity.tests.base import ATBaseTestCase
 from plone.app.linkintegrity.tests.base import DXBaseTestCase
 from plone.app.linkintegrity.utils import hasIncomingLinks
+from plone.app.linkintegrity.utils import getIncomingLinks
+from plone.app.linkintegrity.utils import getOutgoingLinks
 from plone.app.testing import login
 from plone.app.testing import logout
 
@@ -48,7 +49,8 @@ def test_referal_to_private_files(self):
 
         # Throws exception
         view = img.restrictedTraverse('@@object_delete')
-        # self.assertRaises(exceptions.LinkIntegrityNotificationException, view)
+        self.assertEqual('THIS NEEDS TO BE FIXED', 'NEED TO CHECK PERMISSIONS ON REFERENCES')
+        # XXX Need to test this correctly somehow
 
     def test_link_extraction_easy(self):
         doc1 = self.portal.doc1
@@ -77,29 +79,24 @@ def test_broken_references(self):
         doc1a = testing.create(self.portal, 'Document', id='doc1a')
         doc1 = self.portal.doc1
 
-        self.assertEqual(len(IReferenceable(doc1).getReferences()), 0)
+        self.assertEqual(len(list(getOutgoingLinks(doc1))), 0)
         self._set_text(doc1, '<a href="doc1a">Doc 1a</a>')
-        self.assertEqual(len(IReferenceable(doc1).getReferences()), 1)
-        self.assertEqual(IReferenceable(doc1).getReferences()[0].id,
-                         self.portal.doc1a.id)
+        self.assertEqual(len(list(getOutgoingLinks(doc1))), 1)
+        self.assertEqual([l.to_object for l in getOutgoingLinks(doc1)],
+                         [self.portal.doc1a])
 
         # Now delete the target item, suppress events and test again,
-        # the reference should be broken now.
+        # the reference should be gone now.
         self.portal._delObject(doc1a.id, suppress_events=True)
-        self.assertEqual(IReferenceable(doc1).getReferences(), [None])
-
-        # If we now try to update the linking document again in order to
-        # remove the link, things used to break raising a
-        # ``ReferenceException``.  This should be handled more
-        # gracefully now:
-        self._set_text(doc1, 'foo!')
-        self.assertEqual(IReferenceable(doc1).getReferences(), [])
+        self.assertEqual([l.to_object for l in getOutgoingLinks(doc1)], [None])
 
     def test_relative_upwards_link_generates_matching_reference(self):
         doc1 = self.portal.doc1
         doc3 = self.portal.folder1.doc3
         self._set_text(doc3, '<a href="../doc1">go!</a>')
-        self.assertEqual(IReferenceable(doc3).getReferences(), [doc1])
+        self.assertEqual(len(list(getOutgoingLinks(doc1))), 0)
+        self.assertEqual([l.to_object for l in getOutgoingLinks(doc3)],
+                         [doc1])
 
     def test_unicode_links(self):
         doc1 = self.portal.doc1
@@ -109,7 +106,7 @@ def test_unicode_links(self):
         # Add bad link, should not raise exception and there should not
         # be any references added.
         self._set_text(doc1, unicode('<a href="?foo=bar&baz=bam">bug</a>', 'utf-8'))
-        self.assertEqual(IReferenceable(doc1).getReferences(), [])
+        self.assertEqual([l for l in getOutgoingLinks(doc1)], [])
 
     def test_reference_orthogonality(self):
         doc = self.portal.doc1
@@ -117,10 +114,10 @@ def test_reference_orthogonality(self):
         tag = img.restrictedTraverse('@@images').tag()
 
         # This tests the behavior when other references already exist.
-        self.assertEqual(IReferenceable(doc).getReferences(), [])
-        self.assertEqual(IReferenceable(doc).getBackReferences(), [])
-        self.assertEqual(IReferenceable(img).getReferences(), [])
-        self.assertEqual(IReferenceable(img).getBackReferences(), [])
+        self.assertEqual([l for l in getOutgoingLinks(doc)], [])
+        self.assertEqual([l for l in getIncomingLinks(doc)], [])
+        self.assertEqual([l for l in getOutgoingLinks(img)], [])
+        self.assertEqual([l for l in getOutgoingLinks(img)], [])
 
         # Then establish a reference between the document and image as
         # a related item:
@@ -131,9 +128,7 @@ def test_reference_orthogonality(self):
         # which should trigger the creation of a link integrity reference:
         self._set_text(doc, tag)
 
-        from plone.app.linkintegrity.handlers import referencedRelationship
-        self.assertEqual(IReferenceable(doc).getReferences(
-            relationship=referencedRelationship), [img, ])
+        self.assertEqual([l.to_object for l in getOutgoingLinks(doc)], [img])
 
         # And the related item reference remains in place:
         self.assertEqual(self._get_related_items(doc), [img, ])
@@ -142,8 +137,7 @@ def test_reference_orthogonality(self):
         # link to the image, which should trigger the removal of the
         # link integrity reference:
         self._set_text(doc, 'where did my link go?')
-        self.assertEqual(IReferenceable(doc).getReferences(
-            relationship=referencedRelationship), [])
+        self.assertEqual([l.to_object for l in getOutgoingLinks(doc)], [])
 
         # And again the related item reference remains in place:
         self.assertEqual(self._get_related_items(doc), [img, ])


Repository: plone.app.linkintegrity


Branch: refs/heads/master
Date: 2015-07-22T17:16:40+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.app.linkintegrity/commit/077d18dffbe85a478e48e8894c317da7c721e49e

add log message to updateLinkIntegrityInformation

Files changed:
M plone/app/linkintegrity/browser/update.pt
M plone/app/linkintegrity/browser/update.py

diff --git a/plone/app/linkintegrity/browser/update.pt b/plone/app/linkintegrity/browser/update.pt
index 16da1b8..8a2d48b 100644
--- a/plone/app/linkintegrity/browser/update.pt
+++ b/plone/app/linkintegrity/browser/update.pt
@@ -18,7 +18,7 @@
     <div id="content-core">
         <p i18n:translate="linkintegrity_update_instructions">
             Clicking the below button will cause link integrity information to be
-            updated.  This might take a while, especially for bigger sites...
+            updated. This might take a while, especially for bigger sites...
         </p>
 
         <form method="post" action="updateLinkIntegrityInformation"
diff --git a/plone/app/linkintegrity/browser/update.py b/plone/app/linkintegrity/browser/update.py
index 468db91..41a7837 100644
--- a/plone/app/linkintegrity/browser/update.py
+++ b/plone/app/linkintegrity/browser/update.py
@@ -5,10 +5,15 @@
 from Products.CMFPlone import PloneMessageFactory as _
 from Products.Five import BrowserView
 from Products.statusmessages.interfaces import IStatusMessage
-
+from datetime import datetime
+from datetime import timedelta
 from plone.app.linkintegrity.handlers import modifiedArchetype
 from plone.app.linkintegrity.handlers import modifiedDexterity
 from plone.dexterity.interfaces import IDexterityContent
+from zExceptions import NotFound
+import logging
+
+logger = logging.getLogger(__name__)
 
 
 class UpdateView(BrowserView):
@@ -18,14 +23,18 @@ def __call__(self):
         request = aq_inner(self.request)
         clicked = request.form.has_key
         if clicked('update') or clicked('delete_all'):
+            starttime = datetime.now()
             count = self.update()
+            duration = timedelta(seconds=(datetime.now() - starttime).seconds)
             msg = _(
                 u'linkintegrity_update_info',
                 default=u'Link integrity information updated for ${count} ' +
-                        u'item(s).',
-                mapping={'count': count},
+                        u'items in {time} seconds.',
+                mapping={'count': count, 'time': str(duration)},
             )
             IStatusMessage(request).add(msg, type='info')
+            msg = 'Updated {} items in {} seconds'.format(count, str(duration))
+            logger.info(msg)
             request.RESPONSE.redirect(getToolByName(context, 'portal_url')())
         elif clicked('cancel'):
             msg = _(u'Update cancelled.')
@@ -40,7 +49,10 @@ def update(self):
         kwargs = {}
 
         for brain in catalog(**kwargs):
-            obj = brain.getObject()
+            try:
+                obj = brain.getObject()
+            except NotFound:
+                logger.warn("Object {0} not found".format(brain.getPath()))
             if IBaseObject.providedBy(obj):
                 modifiedArchetype(obj, 'dummy event parameter')
                 count += 1


Repository: plone.app.linkintegrity


Branch: refs/heads/master
Date: 2015-07-22T17:20:08+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.app.linkintegrity/commit/b97ee098b65d2c8adcaeb6d83a89dfbe224bc900

remove obsolete method _resolveUID

Files changed:
M plone/app/linkintegrity/handlers.py

diff --git a/plone/app/linkintegrity/handlers.py b/plone/app/linkintegrity/handlers.py
index 6f71c4b..85d6915 100644
--- a/plone/app/linkintegrity/handlers.py
+++ b/plone/app/linkintegrity/handlers.py
@@ -1,42 +1,26 @@
 # -*- coding: utf-8 -*-
-from urllib import unquote
-from urlparse import urlsplit
-
 from Acquisition import aq_get
 from Acquisition import aq_parent
 from Products.Archetypes.Field import TextField
 from Products.Archetypes.interfaces import IBaseObject
 from Products.CMFCore.utils import getToolByName
+from Products.CMFPlone.interfaces import IPloneSiteRoot
 from ZODB.POSException import ConflictError
 from plone.app.linkintegrity.parser import extractLinks
-from zExceptions import NotFound
-from zope.component import getUtility
-from zope.publisher.interfaces import NotFound as ztkNotFound
-from zope.schema import getFieldsInOrder
-
-# To support various Plone versions, we need to support various UUID resolvers
-# This follows Kupu, TinyMCE and plone.app.uuid methods, in a similar manner to
-# plone.outputfilters.browser.resolveuid
-from plone.app.uuid.utils import uuidToObject
-from Products.CMFPlone.interfaces import IPloneSiteRoot
-
-# We try to import dexterity related modules, or modules used just if
-# dexterity is around
 from plone.app.textfield import RichText
+from plone.app.uuid.utils import uuidToObject
 from plone.dexterity.interfaces import IDexterityContent
 from plone.dexterity.interfaces import IDexterityFTI
 from plone.dexterity.utils import getAdditionalSchemata
+from urllib import unquote
+from urlparse import urlsplit
 from z3c.relationfield import RelationValue
 from z3c.relationfield.event import _setRelation
+from zExceptions import NotFound
+from zope.component import getUtility
 from zope.intid.interfaces import IIntIds
-
-
-def _resolveUID(uid):
-    res = uuidToObject(uid)
-    if res is not None:
-        return res
-    return None
-
+from zope.publisher.interfaces import NotFound as ztkNotFound
+from zope.schema import getFieldsInOrder
 
 referencedRelationship = 'isReferencing'
 
@@ -58,7 +42,7 @@ def findObject(base, path):
     # on a view or skinscript to do this for us.
     if 'resolveuid' in components:
         uid = components[components.index('resolveuid') + 1]
-        obj = _resolveUID(uid)
+        obj = uuidToObject(uid)
         if obj:
             return obj, path
 


Repository: plone.app.linkintegrity


Branch: refs/heads/master
Date: 2015-07-22T17:30:45+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.app.linkintegrity/commit/6b9f51199e178e9ab5b672039e9bb5f26fa4f806

delete old linkintegrity-relations before setting the new ones

Files changed:
M plone/app/linkintegrity/handlers.py

diff --git a/plone/app/linkintegrity/handlers.py b/plone/app/linkintegrity/handlers.py
index 85d6915..2e97fae 100644
--- a/plone/app/linkintegrity/handlers.py
+++ b/plone/app/linkintegrity/handlers.py
@@ -17,6 +17,7 @@
 from z3c.relationfield import RelationValue
 from z3c.relationfield.event import _setRelation
 from zExceptions import NotFound
+from zc.relation.interfaces import ICatalog
 from zope.component import getUtility
 from zope.intid.interfaces import IIntIds
 from zope.publisher.interfaces import NotFound as ztkNotFound
@@ -110,8 +111,7 @@ def modifiedArchetype(obj, event):
                 value = field.get(obj)
             links = extractLinks(value, encoding)
             refs |= getObjectsFromLinks(obj, links)
-    for ref in refs:
-        _setRelation(obj, referencedRelationship, ref)
+    updateReferences(obj, refs)
 
 
 def modifiedDexterity(obj, event):
@@ -140,5 +140,28 @@ def modifiedDexterity(obj, event):
                     continue
                 links = extractLinks(value.raw)
                 refs |= getObjectsFromLinks(obj, links)
+    updateReferences(obj, refs)
+
+
+def updateReferences(obj, refs):
+    """Renew all linkintegritry-references.
+
+    Search the zc.relation catalog for linkintegritry-references for this obj.
+    Drop them all and set the new ones.
+    TODO: Might be improved by not changing anything if the links are the same.
+    """
+    intids = getUtility(IIntIds)
+    try:
+        int_id = intids.getId(obj)
+    except KeyError:
+        # In some cases a object might not be registered by the intid catalog
+        int_id = intids.register(obj)
+    catalog = getUtility(ICatalog)
+    # unpack the rels before deleting
+    old_rels = [i for i in catalog.findRelations(
+        {'from_id': int_id,
+         'from_attribute': referencedRelationship})]
+    for old_rel in old_rels:
+        catalog.unindex(old_rel)
     for ref in refs:
         _setRelation(obj, referencedRelationship, ref)


Repository: plone.app.linkintegrity


Branch: refs/heads/master
Date: 2015-07-22T18:38:30+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.app.linkintegrity/commit/2715566ef3ab104042b9c9e5f71e4455975910fd

fix test_referal_to_private_files

Files changed:
M plone/app/linkintegrity/tests/test_references.py

diff --git a/plone/app/linkintegrity/tests/test_references.py b/plone/app/linkintegrity/tests/test_references.py
index 267962b..7299d70 100644
--- a/plone/app/linkintegrity/tests/test_references.py
+++ b/plone/app/linkintegrity/tests/test_references.py
@@ -4,10 +4,13 @@
 from plone.app.linkintegrity.tests.base import ATBaseTestCase
 from plone.app.linkintegrity.tests.base import DXBaseTestCase
 from plone.app.linkintegrity.utils import hasIncomingLinks
+from plone.app.linkintegrity.utils import hasOutgoingLinks
 from plone.app.linkintegrity.utils import getIncomingLinks
 from plone.app.linkintegrity.utils import getOutgoingLinks
 from plone.app.testing import login
 from plone.app.testing import logout
+from plone.app.testing import TEST_USER_NAME
+from zope.lifecycleevent import modified
 
 
 class ReferenceGenerationTestCase:
@@ -44,13 +47,32 @@ def test_referal_to_private_files(self):
         self.assertTrue(checkPermission('View', img))
         self.assertTrue(checkPermission('Access contents information', img))
 
-        token = self._get_token(img)
-        self.request['_authenticator'] = token
+        # The warning is shown.
+        self.assertTrue(hasOutgoingLinks(doc))
+        view = img.restrictedTraverse('delete_confirmation')
+        results = view()
+        self.assertIn('Potential link breakage', results)
+        self.assertIn('The item is not accessible.', results)
 
-        # Throws exception
-        view = img.restrictedTraverse('@@object_delete')
-        self.assertEqual('THIS NEEDS TO BE FIXED', 'NEED TO CHECK PERMISSIONS ON REFERENCES')
-        # XXX Need to test this correctly somehow
+        # delete linked item and check if the source still has the relation
+
+        # TODO: There is a permission-problem. Deleting the relation
+        # When deleting the linked obj the relation is deleted by
+        # z3c.relationfield.event.breakRelations. That also fires
+        # ObjectModifiedEvent on the linked obj even though the user might not
+        # have the permission to edit that obj.
+        # Here plone.app.versioningbehavior.subscribers.create_version_on_save
+        # for the linked object is triggerted and results in
+        # Unauthorized: You are not allowed to access 'save' in this context
+
+        # self.portal.manage_delObjects(img.id)
+        self.portal._delObject(img.id, suppress_events=True)
+
+        logout()
+        login(self.portal, TEST_USER_NAME)
+        modified(doc)
+        self.assertFalse(hasOutgoingLinks(doc))
+        # doc now has a broken link and no relation :-(
 
     def test_link_extraction_easy(self):
         doc1 = self.portal.doc1


Repository: plone.app.linkintegrity


Branch: refs/heads/master
Date: 2015-07-29T11:13:46+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.app.linkintegrity/commit/860d89fd57b8339adcc16ec232a431ba66e1ef37

improve logging on errors during updateLinkIntegrityInformation.

Files changed:
M plone/app/linkintegrity/browser/update.py

diff --git a/plone/app/linkintegrity/browser/update.py b/plone/app/linkintegrity/browser/update.py
index 41a7837..4d91d99 100644
--- a/plone/app/linkintegrity/browser/update.py
+++ b/plone/app/linkintegrity/browser/update.py
@@ -12,6 +12,7 @@
 from plone.dexterity.interfaces import IDexterityContent
 from zExceptions import NotFound
 import logging
+import traceback
 
 logger = logging.getLogger(__name__)
 
@@ -51,8 +52,10 @@ def update(self):
         for brain in catalog(**kwargs):
             try:
                 obj = brain.getObject()
-            except NotFound:
-                logger.warn("Object {0} not found".format(brain.getPath()))
+            except (AttributeError, NotFound, KeyError), e:
+                trace = traceback.format_exc()
+                msg = "Catalog inconsistency: {0} not found!: \n{1}\n{2}\n"
+                logger.error(msg.format(brain.getPath(), e, trace))
             if IBaseObject.providedBy(obj):
                 modifiedArchetype(obj, 'dummy event parameter')
                 count += 1


Repository: plone.app.linkintegrity


Branch: refs/heads/master
Date: 2015-07-29T13:27:38+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.app.linkintegrity/commit/6f02e155aa2d26b956f1d0e3ef24d29958152628

simplify traceback-logging

Files changed:
M plone/app/linkintegrity/browser/update.py

diff --git a/plone/app/linkintegrity/browser/update.py b/plone/app/linkintegrity/browser/update.py
index 4d91d99..1716088 100644
--- a/plone/app/linkintegrity/browser/update.py
+++ b/plone/app/linkintegrity/browser/update.py
@@ -12,7 +12,6 @@
 from plone.dexterity.interfaces import IDexterityContent
 from zExceptions import NotFound
 import logging
-import traceback
 
 logger = logging.getLogger(__name__)
 
@@ -52,10 +51,10 @@ def update(self):
         for brain in catalog(**kwargs):
             try:
                 obj = brain.getObject()
-            except (AttributeError, NotFound, KeyError), e:
-                trace = traceback.format_exc()
-                msg = "Catalog inconsistency: {0} not found!: \n{1}\n{2}\n"
-                logger.error(msg.format(brain.getPath(), e, trace))
+            except (AttributeError, NotFound, KeyError):
+                msg = "Catalog inconsistency: {} not found!"
+                logger.error(msg.format(brain.getPath()), exc_info=1)
+                continue
             if IBaseObject.providedBy(obj):
                 modifiedArchetype(obj, 'dummy event parameter')
                 count += 1


Repository: plone.app.linkintegrity


Branch: refs/heads/master
Date: 2015-07-29T13:27:59+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.app.linkintegrity/commit/a7d1bbee753b08cc19527ed4a06f9bdcb2f20d83

allow (and log) errors during updating items

Files changed:
M plone/app/linkintegrity/browser/update.py

diff --git a/plone/app/linkintegrity/browser/update.py b/plone/app/linkintegrity/browser/update.py
index 1716088..faec856 100644
--- a/plone/app/linkintegrity/browser/update.py
+++ b/plone/app/linkintegrity/browser/update.py
@@ -56,9 +56,17 @@ def update(self):
                 logger.error(msg.format(brain.getPath()), exc_info=1)
                 continue
             if IBaseObject.providedBy(obj):
-                modifiedArchetype(obj, 'dummy event parameter')
-                count += 1
+                try:
+                    modifiedArchetype(obj, 'dummy event parameter')
+                    count += 1
+                except Exception:
+                    msg = "Error updating linkintegrity-info for {}."
+                    logger.error(msg.format(obj.absolute_url()), exc_info=1)
             elif IDexterityContent.providedBy(obj):
-                modifiedDexterity(obj, 'dummy event parameter')
-                count += 1
+                try:
+                    modifiedDexterity(obj, 'dummy event parameter')
+                    count += 1
+                except Exception:
+                    msg = "Error updating linkintegrity-info for {}."
+                    logger.error(msg.format(obj.absolute_url()), exc_info=1)
         return count


Repository: plone.app.linkintegrity


Branch: refs/heads/master
Date: 2015-07-29T13:55:13+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.app.linkintegrity/commit/b752ca69c381abcb82885ab4624dd92b22efabfc

include multiligual content in updateLinkIntegrityInformation

Files changed:
M plone/app/linkintegrity/browser/update.py

diff --git a/plone/app/linkintegrity/browser/update.py b/plone/app/linkintegrity/browser/update.py
index faec856..cbf9f61 100644
--- a/plone/app/linkintegrity/browser/update.py
+++ b/plone/app/linkintegrity/browser/update.py
@@ -12,6 +12,23 @@
 from plone.dexterity.interfaces import IDexterityContent
 from zExceptions import NotFound
 import logging
+import pkg_resources
+
+# Is there a multilingual addon?
+try:
+    pkg_resources.get_distribution('Products.LinguaPlone')
+except pkg_resources.DistributionNotFound:
+    HAS_MULTILINGUAL = False
+else:
+    HAS_MULTILINGUAL = True
+
+if not HAS_MULTILINGUAL:
+    try:
+        pkg_resources.get_distribution('plone.app.multilingual')
+    except pkg_resources.DistributionNotFound:
+        HAS_MULTILINGUAL = False
+    else:
+        HAS_MULTILINGUAL = True
 
 logger = logging.getLogger(__name__)
 
@@ -46,9 +63,11 @@ def __call__(self):
     def update(self):
         catalog = getToolByName(self.context, 'portal_catalog')
         count = 0
-        kwargs = {}
+        query = {}
+        if HAS_MULTILINGUAL and 'Language' in catalog.indexes():
+            query['Language'] = 'all'
 
-        for brain in catalog(**kwargs):
+        for brain in catalog(query):
             try:
                 obj = brain.getObject()
             except (AttributeError, NotFound, KeyError):


Repository: plone.app.linkintegrity


Branch: refs/heads/master
Date: 2015-07-29T13:55:35+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.app.linkintegrity/commit/1d3ff957338bf52c9d2836b9e188eeddb666ec1a

less DRY

Files changed:
M plone/app/linkintegrity/browser/update.py

diff --git a/plone/app/linkintegrity/browser/update.py b/plone/app/linkintegrity/browser/update.py
index cbf9f61..b4e6d20 100644
--- a/plone/app/linkintegrity/browser/update.py
+++ b/plone/app/linkintegrity/browser/update.py
@@ -74,16 +74,14 @@ def update(self):
                 msg = "Catalog inconsistency: {} not found!"
                 logger.error(msg.format(brain.getPath()), exc_info=1)
                 continue
+            method = None
             if IBaseObject.providedBy(obj):
-                try:
-                    modifiedArchetype(obj, 'dummy event parameter')
-                    count += 1
-                except Exception:
-                    msg = "Error updating linkintegrity-info for {}."
-                    logger.error(msg.format(obj.absolute_url()), exc_info=1)
+                method = modifiedArchetype
             elif IDexterityContent.providedBy(obj):
+                method = modifiedDexterity
+            if method:
                 try:
-                    modifiedDexterity(obj, 'dummy event parameter')
+                    method(obj, 'dummy event parameter')
                     count += 1
                 except Exception:
                     msg = "Error updating linkintegrity-info for {}."


Repository: plone.app.linkintegrity


Branch: refs/heads/master
Date: 2015-07-30T07:36:12+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.app.linkintegrity/commit/a0f60c8d9ff690bbf00b73deacfd775ebf79759d

fix portalmessage

Files changed:
M plone/app/linkintegrity/browser/update.py

diff --git a/plone/app/linkintegrity/browser/update.py b/plone/app/linkintegrity/browser/update.py
index b4e6d20..2c92872 100644
--- a/plone/app/linkintegrity/browser/update.py
+++ b/plone/app/linkintegrity/browser/update.py
@@ -46,7 +46,7 @@ def __call__(self):
             msg = _(
                 u'linkintegrity_update_info',
                 default=u'Link integrity information updated for ${count} ' +
-                        u'items in {time} seconds.',
+                        u'items in ${time} seconds.',
                 mapping={'count': count, 'time': str(duration)},
             )
             IStatusMessage(request).add(msg, type='info')


Repository: plone.app.linkintegrity


Branch: refs/heads/master
Date: 2015-07-30T16:49:48+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.app.linkintegrity/commit/1dea4df39bf8f03ee60ec47ec6022782d9d5a357

add note to failing test

Files changed:
M plone/app/linkintegrity/tests/test_functional.py

diff --git a/plone/app/linkintegrity/tests/test_functional.py b/plone/app/linkintegrity/tests/test_functional.py
index de04e9f..bca6c9e 100644
--- a/plone/app/linkintegrity/tests/test_functional.py
+++ b/plone/app/linkintegrity/tests/test_functional.py
@@ -56,6 +56,9 @@ def test_file_reference_linkintegrity_page_is_shown(self):
                       self.browser.contents)
 
         # Click cancel button, item should stay in place
+        # FIXME! This fails in Archetypes because the redirect
+        # plone.app.content.browser.actions.DeleteConfirmationForm.handle_cancel
+        # is broken for AT-content.
         self.browser.getControl(name='form.buttons.Cancel').click()
         self.assertEqual(self.browser.url, file2.absolute_url() + '/view')
         self.assertIn('Removal cancelled.', self.browser.contents)


Repository: plone.app.linkintegrity


Branch: refs/heads/master
Date: 2015-08-01T09:51:59+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.app.linkintegrity/commit/fb8c5908ce9ac12449560a5ba6b60320232b9af2

add convenience-method to check for enabled linkintegrity

Files changed:
M plone/app/linkintegrity/browser/info.py
M plone/app/linkintegrity/utils.py

diff --git a/plone/app/linkintegrity/browser/info.py b/plone/app/linkintegrity/browser/info.py
index 46b5f37..b21c4fc 100644
--- a/plone/app/linkintegrity/browser/info.py
+++ b/plone/app/linkintegrity/browser/info.py
@@ -3,12 +3,10 @@
 from OFS.interfaces import IFolder
 from Products.CMFCore.permissions import AccessContentsInformation
 from Products.CMFCore.utils import getToolByName, _checkPermission
-from Products.CMFPlone.interfaces import IEditingSchema
 from Products.Five import BrowserView
 from Products.Five.browser.pagetemplatefile import ViewPageTemplateFile
 from plone.app.linkintegrity.utils import getIncomingLinks
-from plone.registry.interfaces import IRegistry
-from zope.component import getUtility
+from plone.app.linkintegrity.utils import linkintegrity_enabled
 from zope.i18n import translate
 
 
@@ -68,13 +66,8 @@ def checkObject(self, obj):
                 if check:
                     self.breaches.append(check)
 
-    def linkintegrity_enabled(self):
-        reg = getUtility(IRegistry)
-        editing_settings = reg.forInterface(IEditingSchema, prefix='plone')
-        return editing_settings.enable_link_integrity_checks
-
     def __call__(self, skip_context=False):
-        if not self.linkintegrity_enabled():
+        if not linkintegrity_enabled():
             self.breaches = []
         elif not skip_context:
             self.checkObject(self.context)
diff --git a/plone/app/linkintegrity/utils.py b/plone/app/linkintegrity/utils.py
index a5f8aca..698bcb3 100644
--- a/plone/app/linkintegrity/utils.py
+++ b/plone/app/linkintegrity/utils.py
@@ -1,5 +1,7 @@
 # -*- coding: utf-8 -*-
+from Products.CMFPlone.interfaces import IEditingSchema
 from plone.app.linkintegrity.handlers import referencedRelationship
+from plone.registry.interfaces import IRegistry
 from zc.relation.interfaces import ICatalog
 from zope.component import getUtility
 from zope.intid.interfaces import IIntIds
@@ -45,3 +47,9 @@ def hasOutgoingLinks(obj):
     for i in getOutgoingLinks(obj):
         return True
     return False
+
+
+def linkintegrity_enabled():
+    reg = getUtility(IRegistry)
+    editing_settings = reg.forInterface(IEditingSchema, prefix='plone')
+    return editing_settings.enable_link_integrity_checks


Repository: plone.app.linkintegrity


Branch: refs/heads/master
Date: 2015-08-04T19:50:27+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.app.linkintegrity/commit/3b08cd7c73d40f366f8da88827c99574e92c05a0

set p.a.intid and p.a.relationsfield as dependencies

Files changed:
A plone/app/linkintegrity/profiles/default/metadata.xml
A plone/app/linkintegrity/profiles/default/ploneapplinkintegrity_default.txt
M plone/app/linkintegrity/configure.zcml
M plone/app/linkintegrity/testing.py
M setup.py

diff --git a/plone/app/linkintegrity/configure.zcml b/plone/app/linkintegrity/configure.zcml
index 9bd9d3b..6eb86b0 100644
--- a/plone/app/linkintegrity/configure.zcml
+++ b/plone/app/linkintegrity/configure.zcml
@@ -1,7 +1,7 @@
 <configure
     xmlns="http://namespaces.zope.org/zope"
     xmlns:browser="http://namespaces.zope.org/browser"
-    xmlns:five="http://namespaces.zope.org/five"
+    xmlns:genericsetup="http://namespaces.zope.org/genericsetup"
     xmlns:zcml="http://namespaces.zope.org/zcml">
 
     <includeDependencies package="." />
@@ -16,4 +16,12 @@
     <include package=".dx"
              zcml:condition="installed plone.dexterity" />
 
+    <genericsetup:registerProfile
+        name="default"
+        title="plone.app.linkintegrity"
+        directory="profiles/default"
+        description="Installs the plone.app.linkintegrity add-on."
+        provides="Products.GenericSetup.interfaces.EXTENSION"
+        />
+
 </configure>
diff --git a/plone/app/linkintegrity/profiles/default/metadata.xml b/plone/app/linkintegrity/profiles/default/metadata.xml
new file mode 100644
index 0000000..3d93a8e
--- /dev/null
+++ b/plone/app/linkintegrity/profiles/default/metadata.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0"?>
+<metadata>
+  <version>1000</version>
+  <dependencies>
+    <dependency>profile-plone.app.intid:default</dependency>
+    <dependency>profile-plone.app.relationfield:default</dependency>
+  </dependencies>
+</metadata>
diff --git a/plone/app/linkintegrity/profiles/default/ploneapplinkintegrity_default.txt b/plone/app/linkintegrity/profiles/default/ploneapplinkintegrity_default.txt
new file mode 100644
index 0000000..e69de29
diff --git a/plone/app/linkintegrity/testing.py b/plone/app/linkintegrity/testing.py
index 51ca8cc..943154b 100644
--- a/plone/app/linkintegrity/testing.py
+++ b/plone/app/linkintegrity/testing.py
@@ -11,15 +11,12 @@
 from plone.app.testing import TEST_USER_ID
 from plone.app.testing import TEST_USER_NAME
 from plone.app.testing import TEST_USER_PASSWORD
-from plone.app.testing import applyProfile
 from plone.app.testing import layers
 from plone.app.testing import login
 from plone.app.testing import ploneSite
 from plone.app.testing import setRoles
 from plone.testing import z2
 from zope.configuration import xmlconfig
-from plone.app.relationfield.setuphandlers import add_intids
-from plone.app.relationfield.setuphandlers import add_relations
 
 B64_DATA = 'R0lGODlhAQABAIAAAAUEBAAAACwAAAAAAQABAAACAkQBADs='
 GIF = StringIO(decodestring(B64_DATA))
@@ -58,7 +55,6 @@ def setUpMembers(self, portal):
 
     def setUpContent(self):
         import plone.app.linkintegrity
-
         xmlconfig.file('configure.zcml', plone.app.linkintegrity,
                        context=self['configurationContext'])
 
@@ -101,9 +97,6 @@ class LinkIntegrityATLayer(LinkIntegrityLayer):
     )
 
     def setUp(self):
-        with ploneSite() as portal:
-            add_intids(portal)
-            add_relations(portal)
         self.setUpContent()
 
 PLONE_APP_LINKINTEGRITY_AT_FIXTURE = LinkIntegrityATLayer()
diff --git a/setup.py b/setup.py
index 5425e20..5d406b9 100644
--- a/setup.py
+++ b/setup.py
@@ -31,6 +31,8 @@
       include_package_data=True,
       install_requires=[
           'setuptools',
+          'plone.app.intid',
+          'plone.app.relationfield',
       ],
       extras_require={
           'test': [


Repository: plone.app.linkintegrity


Branch: refs/heads/master
Date: 2015-08-05T21:34:46+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.app.linkintegrity/commit/72e4c10d430244481e5bc9559d1c5f8c15b8f955

catch edge-case when objects are not correctly aquisition-wrapped or placed

Files changed:
M plone/app/linkintegrity/handlers.py

diff --git a/plone/app/linkintegrity/handlers.py b/plone/app/linkintegrity/handlers.py
index 2e97fae..f8a8c82 100644
--- a/plone/app/linkintegrity/handlers.py
+++ b/plone/app/linkintegrity/handlers.py
@@ -20,6 +20,7 @@
 from zc.relation.interfaces import ICatalog
 from zope.component import getUtility
 from zope.intid.interfaces import IIntIds
+from zope.keyreference.interfaces import NotYet
 from zope.publisher.interfaces import NotFound as ztkNotFound
 from zope.schema import getFieldsInOrder
 
@@ -154,8 +155,11 @@ def updateReferences(obj, refs):
     try:
         int_id = intids.getId(obj)
     except KeyError:
-        # In some cases a object might not be registered by the intid catalog
-        int_id = intids.register(obj)
+        # In some cases a object is not yet registered by the intid catalog
+        try:
+            int_id = intids.register(obj)
+        except NotYet:
+            return
     catalog = getUtility(ICatalog)
     # unpack the rels before deleting
     old_rels = [i for i in catalog.findRelations(


Repository: plone.app.linkintegrity


Branch: refs/heads/master
Date: 2015-08-06T14:25:13+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.app.linkintegrity/commit/b9795ce11bb4286341555892ba7d72401b907bb3

ignore non richtext-values for dx

Files changed:
M plone/app/linkintegrity/handlers.py

diff --git a/plone/app/linkintegrity/handlers.py b/plone/app/linkintegrity/handlers.py
index f8a8c82..28133db 100644
--- a/plone/app/linkintegrity/handlers.py
+++ b/plone/app/linkintegrity/handlers.py
@@ -137,7 +137,7 @@ def modifiedDexterity(obj, event):
             if isinstance(field, RichText):
                 # Only check for "RichText" ?
                 value = getattr(schema(obj), name)
-                if not value:
+                if not value or not getattr(value, 'raw', None):
                     continue
                 links = extractLinks(value.raw)
                 refs |= getObjectsFromLinks(obj, links)


Repository: plone.app.linkintegrity


Branch: refs/heads/master
Date: 2015-08-06T15:34:50+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.app.linkintegrity/commit/33e9df10064fdb759fc548873aea10500a4a82f0

check all dependencies before updating relations

Files changed:
M plone/app/linkintegrity/handlers.py

diff --git a/plone/app/linkintegrity/handlers.py b/plone/app/linkintegrity/handlers.py
index 28133db..87eee04 100644
--- a/plone/app/linkintegrity/handlers.py
+++ b/plone/app/linkintegrity/handlers.py
@@ -19,11 +19,14 @@
 from zExceptions import NotFound
 from zc.relation.interfaces import ICatalog
 from zope.component import getUtility
+from zope.component import queryUtility
 from zope.intid.interfaces import IIntIds
 from zope.keyreference.interfaces import NotYet
 from zope.publisher.interfaces import NotFound as ztkNotFound
 from zope.schema import getFieldsInOrder
+import logging
 
+logger = logging.getLogger(__name__)
 referencedRelationship = 'isReferencing'
 
 
@@ -94,10 +97,7 @@ def getObjectsFromLinks(base, links):
 
 def modifiedArchetype(obj, event):
     """ an archetype based object was modified """
-    pu = getToolByName(obj, 'portal_url', None)
-    if pu is None:
-        # `getObjectFromLinks` is not possible without access
-        # to `portal_url`
+    if not check_linkintegrity_dependencies(obj):
         return
     refs = set()
     for field in obj.Schema().fields():
@@ -117,21 +117,14 @@ def modifiedArchetype(obj, event):
 
 def modifiedDexterity(obj, event):
     """ a dexterity based object was modified """
-    pu = getToolByName(obj, 'portal_url', None)
-    if pu is None:
-        # `getObjectFromLinks` is not possible without access
-        # to `portal_url`
+    if not check_linkintegrity_dependencies(obj):
         return
-
     fti = getUtility(IDexterityFTI, name=obj.portal_type)
     schema = fti.lookupSchema()
     additional_schema = getAdditionalSchemata(context=obj,
                                               portal_type=obj.portal_type)
-
     schemas = [i for i in additional_schema] + [schema]
-
     refs = set()
-
     for schema in schemas:
         for name, field in getFieldsInOrder(schema):
             if isinstance(field, RichText):
@@ -169,3 +162,18 @@ def updateReferences(obj, refs):
         catalog.unindex(old_rel)
     for ref in refs:
         _setRelation(obj, referencedRelationship, ref)
+
+
+def check_linkintegrity_dependencies(obj):
+    pu = getToolByName(obj, 'portal_url', None)
+    if pu is None:
+        # `getObjectFromLinks` is not possible without access
+        # to `portal_url`
+        return False
+    if not queryUtility(IIntIds, False):
+        logger.info('Linkintegrity not possible without zope.intid-catalog')
+        return False
+    if not queryUtility(ICatalog, False):
+        logger.info('Linkintegrity not possible without zc.relation-catalog')
+        return False
+    return True


Repository: plone.app.linkintegrity


Branch: refs/heads/master
Date: 2015-08-06T17:50:27+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.app.linkintegrity/commit/ce516d3aa54325d655db0273a2fadcc4d53827b4

fix call of queryUtility

Files changed:
M plone/app/linkintegrity/handlers.py

diff --git a/plone/app/linkintegrity/handlers.py b/plone/app/linkintegrity/handlers.py
index 87eee04..5042257 100644
--- a/plone/app/linkintegrity/handlers.py
+++ b/plone/app/linkintegrity/handlers.py
@@ -165,15 +165,14 @@ def updateReferences(obj, refs):
 
 
 def check_linkintegrity_dependencies(obj):
-    pu = getToolByName(obj, 'portal_url', None)
-    if pu is None:
+    if not getToolByName(obj, 'portal_url', None):
         # `getObjectFromLinks` is not possible without access
         # to `portal_url`
         return False
-    if not queryUtility(IIntIds, False):
+    if not queryUtility(IIntIds):
         logger.info('Linkintegrity not possible without zope.intid-catalog')
         return False
-    if not queryUtility(ICatalog, False):
+    if not queryUtility(ICatalog):
         logger.info('Linkintegrity not possible without zc.relation-catalog')
         return False
     return True


Repository: plone.app.linkintegrity


Branch: refs/heads/master
Date: 2015-08-06T17:50:56+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.app.linkintegrity/commit/f58d4e5fbc01f9424d15e080f53eab141af9b05c

do not check for zc.relation-catalog

Files changed:
M plone/app/linkintegrity/handlers.py

diff --git a/plone/app/linkintegrity/handlers.py b/plone/app/linkintegrity/handlers.py
index 5042257..908be27 100644
--- a/plone/app/linkintegrity/handlers.py
+++ b/plone/app/linkintegrity/handlers.py
@@ -172,7 +172,7 @@ def check_linkintegrity_dependencies(obj):
     if not queryUtility(IIntIds):
         logger.info('Linkintegrity not possible without zope.intid-catalog')
         return False
-    if not queryUtility(ICatalog):
-        logger.info('Linkintegrity not possible without zc.relation-catalog')
-        return False
+    # if not queryUtility(ICatalog):
+    #     logger.info('Linkintegrity not possible without zc.relation-catalog')
+    #     return False
     return True


Repository: plone.app.linkintegrity


Branch: refs/heads/master
Date: 2015-08-06T21:49:58+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.app.linkintegrity/commit/10ff4fce180ee903a5abc1f49751e8ddc17962d2

skip test until https://github.com/plone/plone.app.content/issues/38 is fixed

Files changed:
M plone/app/linkintegrity/tests/test_functional.py

diff --git a/plone/app/linkintegrity/tests/test_functional.py b/plone/app/linkintegrity/tests/test_functional.py
index bca6c9e..a1fbf36 100644
--- a/plone/app/linkintegrity/tests/test_functional.py
+++ b/plone/app/linkintegrity/tests/test_functional.py
@@ -17,10 +17,12 @@
 from zope.component import getUtility
 
 import transaction
+import unittest2 as unittest
 
 
 class ReferenceTestCase:
 
+    @unittest.skip('Re-enable after https://github.com/plone/plone.app.content/issues/38')  # noqa
     def test_file_reference_linkintegrity_page_is_shown(self):
         doc1 = self.portal.doc1
         file2 = testing.create(self.portal, 'File',


Repository: plone.app.linkintegrity


Branch: refs/heads/master
Date: 2015-08-07T14:14:20+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.app.linkintegrity/commit/0239d81f579e5e8eda273ec2f9a0e27734779aed

simplify subscribers to improve readability

Files changed:
M plone/app/linkintegrity/browser/update.py
M plone/app/linkintegrity/configure.zcml
D plone/app/linkintegrity/at/__init__.py
D plone/app/linkintegrity/at/configure.zcml
D plone/app/linkintegrity/dx/__init__.py
D plone/app/linkintegrity/dx/configure.zcml

diff --git a/plone/app/linkintegrity/at/__init__.py b/plone/app/linkintegrity/at/__init__.py
deleted file mode 100644
index e69de29..0000000
diff --git a/plone/app/linkintegrity/at/configure.zcml b/plone/app/linkintegrity/at/configure.zcml
deleted file mode 100644
index 526493d..0000000
--- a/plone/app/linkintegrity/at/configure.zcml
+++ /dev/null
@@ -1,31 +0,0 @@
-<configure
-    xmlns="http://namespaces.zope.org/zope">
-
-    <subscriber
-        for="Products.Archetypes.interfaces.IBaseObject
-             OFS.interfaces.IObjectClonedEvent"
-        handler="..handlers.modifiedArchetype" />
-
-    <subscriber
-        for="Products.Archetypes.interfaces.IBaseObject
-             zope.lifecycleevent.interfaces.IObjectCreatedEvent"
-        handler="..handlers.modifiedArchetype" />
-
-    <subscriber
-        for="Products.Archetypes.interfaces.IBaseObject
-             zope.lifecycleevent.interfaces.IObjectModifiedEvent"
-        handler="..handlers.modifiedArchetype" />
-
-<!--
-    <subscriber
-        for="Products.Archetypes.interfaces.IBaseObject
-             zope.lifecycleevent.interfaces.IObjectRemovedEvent"
-        handler="..handlers.referencedObjectRemoved" />
-
-    <subscriber
-        for="Products.Archetypes.interfaces.IReference
-             zope.lifecycleevent.interfaces.IObjectRemovedEvent"
-        handler="..handlers.referenceRemoved" />
--->
-
-</configure>
diff --git a/plone/app/linkintegrity/browser/update.py b/plone/app/linkintegrity/browser/update.py
index 2c92872..e9b98a2 100644
--- a/plone/app/linkintegrity/browser/update.py
+++ b/plone/app/linkintegrity/browser/update.py
@@ -34,6 +34,8 @@
 
 
 class UpdateView(BrowserView):
+    """Iterate over all catalogued items and update linkintegrity-information.
+    """
 
     def __call__(self):
         context = aq_inner(self.context)
diff --git a/plone/app/linkintegrity/configure.zcml b/plone/app/linkintegrity/configure.zcml
index 6eb86b0..db653d8 100644
--- a/plone/app/linkintegrity/configure.zcml
+++ b/plone/app/linkintegrity/configure.zcml
@@ -10,11 +10,39 @@
 
     <include package=".browser" />
 
-    <include package=".at"
-             zcml:condition="installed Products.Archetypes" />
+    <configure zcml:condition="installed Products.Archetypes">
+      <subscriber
+          for="Products.Archetypes.interfaces.IBaseObject
+               OFS.interfaces.IObjectClonedEvent"
+          handler=".handlers.modifiedArchetype" />
 
-    <include package=".dx"
-             zcml:condition="installed plone.dexterity" />
+      <subscriber
+          for="Products.Archetypes.interfaces.IBaseObject
+               zope.lifecycleevent.interfaces.IObjectCreatedEvent"
+          handler=".handlers.modifiedArchetype" />
+
+      <subscriber
+          for="Products.Archetypes.interfaces.IBaseObject
+               zope.lifecycleevent.interfaces.IObjectModifiedEvent"
+          handler=".handlers.modifiedArchetype" />
+    </configure>
+
+    <configure zcml:condition="installed plone.dexterity">
+      <subscriber
+          for="plone.app.relationfield.interfaces.IDexterityHasRelations
+               zope.lifecycleevent.interfaces.IObjectCopiedEvent"
+          handler=".handlers.modifiedDexterity" />
+
+      <subscriber
+          for="plone.app.relationfield.interfaces.IDexterityHasRelations
+               zope.lifecycleevent.interfaces.IObjectAddedEvent"
+          handler=".handlers.modifiedDexterity" />
+
+      <subscriber
+          for="plone.app.relationfield.interfaces.IDexterityHasRelations
+               zope.lifecycleevent.interfaces.IObjectModifiedEvent"
+          handler=".handlers.modifiedDexterity" />
+    </configure>
 
     <genericsetup:registerProfile
         name="default"
diff --git a/plone/app/linkintegrity/dx/__init__.py b/plone/app/linkintegrity/dx/__init__.py
deleted file mode 100644
index e69de29..0000000
diff --git a/plone/app/linkintegrity/dx/configure.zcml b/plone/app/linkintegrity/dx/configure.zcml
deleted file mode 100644
index 4cbf1a5..0000000
--- a/plone/app/linkintegrity/dx/configure.zcml
+++ /dev/null
@@ -1,19 +0,0 @@
-<configure
-    xmlns="http://namespaces.zope.org/zope">
-
-    <subscriber
-        for="plone.app.relationfield.interfaces.IDexterityHasRelations
-             zope.lifecycleevent.interfaces.IObjectCopiedEvent"
-        handler="..handlers.modifiedDexterity" />
-
-    <subscriber
-        for="plone.app.relationfield.interfaces.IDexterityHasRelations
-             zope.lifecycleevent.interfaces.IObjectAddedEvent"
-        handler="..handlers.modifiedDexterity" />
-
-    <subscriber
-        for="plone.app.relationfield.interfaces.IDexterityHasRelations
-             zope.lifecycleevent.interfaces.IObjectModifiedEvent"
-        handler="..handlers.modifiedDexterity" />
-
-</configure>


Repository: plone.app.linkintegrity


Branch: refs/heads/master
Date: 2015-08-07T14:47:10+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.app.linkintegrity/commit/5b129b1c2a94b385bc93f6e1b348ae3978d823f7

check for both catalogs before doing anything

Files changed:
M plone/app/linkintegrity/handlers.py

diff --git a/plone/app/linkintegrity/handlers.py b/plone/app/linkintegrity/handlers.py
index 908be27..70b67f3 100644
--- a/plone/app/linkintegrity/handlers.py
+++ b/plone/app/linkintegrity/handlers.py
@@ -19,7 +19,7 @@
 from zExceptions import NotFound
 from zc.relation.interfaces import ICatalog
 from zope.component import getUtility
-from zope.component import queryUtility
+from zope.component.interfaces import ComponentLookupError
 from zope.intid.interfaces import IIntIds
 from zope.keyreference.interfaces import NotYet
 from zope.publisher.interfaces import NotFound as ztkNotFound
@@ -169,10 +169,11 @@ def check_linkintegrity_dependencies(obj):
         # `getObjectFromLinks` is not possible without access
         # to `portal_url`
         return False
-    if not queryUtility(IIntIds):
-        logger.info('Linkintegrity not possible without zope.intid-catalog')
+    try:
+        getUtility(IIntIds)
+        getUtility(ICatalog)
+    except ComponentLookupError:
+        # Linkintegrity not possible without zope.intid-
+        # and zc.relation-catalog
         return False
-    # if not queryUtility(ICatalog):
-    #     logger.info('Linkintegrity not possible without zc.relation-catalog')
-    #     return False
     return True


Repository: plone.app.linkintegrity


Branch: refs/heads/master
Date: 2015-08-10T20:44:31+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.app.linkintegrity/commit/1ffe718117050509bbf06bfdcc1e2cdb5f83556b

allow to pass only a intid to check for links

Files changed:
M plone/app/linkintegrity/utils.py

diff --git a/plone/app/linkintegrity/utils.py b/plone/app/linkintegrity/utils.py
index 698bcb3..789d9c0 100644
--- a/plone/app/linkintegrity/utils.py
+++ b/plone/app/linkintegrity/utils.py
@@ -7,44 +7,54 @@
 from zope.intid.interfaces import IIntIds
 
 
-def getIncomingLinks(obj):
+def getIncomingLinks(obj=None, intid=None):
     """Return a generator of incoming relations created using
     plone.app.linkintegrity (Links in Richtext-Fields).
     """
     catalog = getUtility(ICatalog)
-    intids = getUtility(IIntIds)
-    return catalog.findRelations({
-        'to_id': intids.getId(obj),
-        'from_attribute': referencedRelationship})
+    if intid is not None:
+        return catalog.findRelations({
+            'to_id': intid,
+            'from_attribute': referencedRelationship})
+    else:
+        intids = getUtility(IIntIds)
+        return catalog.findRelations({
+            'to_id': intids.getId(obj),
+            'from_attribute': referencedRelationship})
 
 
-def hasIncomingLinks(obj):
+def hasIncomingLinks(obj=None, intid=None):
     """Test if an object is linked to by other objects using
     plone.app.linkintegrity (Links in Richtext-Fields).
 
     Way to give bool without loading generator into list
     """
-    for i in getIncomingLinks(obj):
+    for i in getIncomingLinks(obj=obj, intid=intid):
         return True
     return False
 
 
-def getOutgoingLinks(obj):
+def getOutgoingLinks(obj=None, intid=None):
     """Return a generator of outgoing relations created using
     plone.app.linkintegrity (Links in Richtext-Fields).
     """
     catalog = getUtility(ICatalog)
-    intids = getUtility(IIntIds)
-    return catalog.findRelations({
-        'from_id': intids.getId(obj),
-        'from_attribute': referencedRelationship})
+    if intid is not None:
+        return catalog.findRelations({
+            'from_id': intid,
+            'from_attribute': referencedRelationship})
+    else:
+        intids = getUtility(IIntIds)
+        return catalog.findRelations({
+            'from_id': intids.getId(obj),
+            'from_attribute': referencedRelationship})
 
 
-def hasOutgoingLinks(obj):
+def hasOutgoingLinks(obj=None, intid=None):
     """Test if an object links to other objects using plone.app.linkintegrity
     (Links in Richtext-Fields).
     """
-    for i in getOutgoingLinks(obj):
+    for i in getOutgoingLinks(obj=obj, intid=intid):
         return True
     return False
 


Repository: plone.app.linkintegrity


Branch: refs/heads/master
Date: 2015-08-10T20:47:06+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.app.linkintegrity/commit/0d9d4ff3fb295f8f3003c3bd0e015b27f70f9100

rewrite check for breaches:
- ignore breaches from children of deleted item
- fix showing info about targets in delete_confirmation
- allow to check multiple items and account for circular references

Files changed:
M plone/app/linkintegrity/browser/delete_confirmation_info.pt
M plone/app/linkintegrity/browser/info.py
M plone/app/linkintegrity/tests/test_circular.py

diff --git a/plone/app/linkintegrity/browser/delete_confirmation_info.pt b/plone/app/linkintegrity/browser/delete_confirmation_info.pt
index 9e161b2..4a837de 100644
--- a/plone/app/linkintegrity/browser/delete_confirmation_info.pt
+++ b/plone/app/linkintegrity/browser/delete_confirmation_info.pt
@@ -1,8 +1,8 @@
-<article id="content" 
-  xmlns="http://www.w3.org/1999/xhtml" 
+<article id="content"
+  xmlns="http://www.w3.org/1999/xhtml"
   xml:lang="en"
   lang="en"
-  tal:define="breaches view/breaches"
+  tal:define="breaches python:view.get_breaches() if view.linkintegrity_enabled else []"
   tal:condition="python: len(breaches)>0"
   i18n:domain="plone">
     <h1 class="documentFirstHeading"
@@ -18,31 +18,30 @@
         <div tal:define="token context/@@authenticator/token">
             <article tal:repeat="breach breaches" class="breach-container">
 
-              <header>
-                <a tal:attributes="href breach/url"
-                    tal:content="breach/title" />
-              </header>
-              <p>
-                  <span i18n:translate="linkintegrity_is_referenced" class="breach-warning">
-                      This <span i18n:name="portal_type" tal:content="breach/type_title" />
-                      is referenced by the following items:
-                  </span>
-              </p>
-
-                  <ul>
-                    <li tal:repeat="src python:breach['sources']" class="breach-item">
-                      <tal:visible condition="python: view.isAccessible(src)">
-                        <a tal:attributes="href src/absolute_url" tal:content="src/Title" />
-                        [<a tal:attributes="href string:${src/absolute_url}/edit?_authenticator=${token}"
-                          i18n:translate="linkintegrity_edit_in_new_window"
-                          target="_blank">Edit in new window</a>]
-                      </tal:visible>
-                      <tal:private condition="python: not view.isAccessible(src)"
-                                   i18n:translate="linkintegrity_item_not_accessible">
-                        The item is not accessible.
-                      </tal:private>
-                    </li>
-                  </ul>
+              <tal:target  tal:define="target breach/target">
+                <header><a href="target/url" tal:content="target/title" /></header>
+                <p>
+                    <span i18n:translate="linkintegrity_is_referenced">
+                        This <span i18n:name="portal_type" tal:content="target/type_title" />
+                        is referenced by the following items:
+                    </span>
+                </p>
+              </tal:target>
+
+              <ul>
+                <li tal:repeat="source python:breach['sources']" class="breach-item">
+                  <tal:visible condition="source/accessible">
+                    <a tal:attributes="href source/url" tal:content="source/title" />
+                    [<a tal:attributes="href string:${source/url}/edit?_authenticator=${token}"
+                      i18n:translate="linkintegrity_edit_in_new_window"
+                      target="_blank">Edit in new window</a>]
+                  </tal:visible>
+                  <tal:private condition="not: source/accessible"
+                               i18n:translate="linkintegrity_item_not_accessible">
+                    The item is not accessible.
+                  </tal:private>
+                </li>
+              </ul>
 
             </article>
 
diff --git a/plone/app/linkintegrity/browser/info.py b/plone/app/linkintegrity/browser/info.py
index b21c4fc..16ce41b 100644
--- a/plone/app/linkintegrity/browser/info.py
+++ b/plone/app/linkintegrity/browser/info.py
@@ -5,8 +5,10 @@
 from Products.CMFCore.utils import getToolByName, _checkPermission
 from Products.Five import BrowserView
 from Products.Five.browser.pagetemplatefile import ViewPageTemplateFile
+from collections import defaultdict
 from plone.app.linkintegrity.utils import getIncomingLinks
 from plone.app.linkintegrity.utils import linkintegrity_enabled
+from plone.uuid.interfaces import IUUID
 from zope.i18n import translate
 
 
@@ -14,6 +16,97 @@ class DeleteConfirmationInfo(BrowserView):
 
     template = ViewPageTemplateFile('delete_confirmation_info.pt')
 
+    def __call__(self):
+        self.linkintegrity_enabled = linkintegrity_enabled()
+        return self.template()
+
+    def get_breaches_for_items(self, items):
+        """Check for breaches when deleting multiple items at once.
+        Breaches originating from items that will also be deleted are dropped.
+        """
+        catalog = getToolByName(self.context, 'portal_catalog')
+        results = []
+        uids_to_delete = []
+        for obj in items:
+            obj_path = '/'.join(obj.getPhysicalPath())
+            brains_to_delete = catalog(path={'query': obj_path})
+            uids_to_delete.extend([i.UID for i in brains_to_delete])
+            for breach in self.get_breaches(obj):
+                add_breach = False
+                for source in breach['sources']:
+                    if source['uid'] not in uids_to_delete:
+                        add_breach = True
+                if add_breach:
+                    results.append(breach)
+
+        # cleanup (some breaches where added before it was clear
+        # that the source will be deleted too)
+        for result in results:
+            for source in result['sources']:
+                if source['uid'] in uids_to_delete:
+                    result['sources'].remove(source)
+                    if not result['sources']:
+                        results.remove(result)
+        return results
+
+    def get_breaches(self, obj=None):
+        """Check one object and it's children for breaches.
+        """
+        if obj is None:
+            obj = self.context
+        results = []
+        catalog = getToolByName(obj, 'portal_catalog')
+        obj_path = '/'.join(obj.getPhysicalPath())
+
+        breaches = self.check_object(obj)
+        if breaches:
+            results.append(breaches)
+
+        if IFolder.providedBy(obj):
+            brains = catalog(path={'query': obj_path})
+            for brain in brains:
+                child = brain.getObject()
+                if child == obj:
+                    continue
+                breaches = self.check_object(obj=child, excluded_path=obj_path)
+                if breaches:
+                    results.append(breaches)
+        self.breaches = results
+        return results
+
+    def check_object(self, obj, excluded_path=None):
+        """Check one object for breaches.
+        If breaches origin from excluded_path ignore them
+        """
+        if excluded_path is None:
+            excluded_path = '/'.join(obj.getPhysicalPath())
+        breaches = defaultdict(list)
+        direct_links = getIncomingLinks(obj)
+        has_breaches = False
+        for direct_link in direct_links:
+            source_path = direct_link.from_path
+            if not source_path or source_path.startswith(excluded_path):
+                # broken or child of item that is to be deleted
+                continue
+            source = direct_link.from_object
+            breaches['sources'].append({
+                'uid': IUUID(source),
+                'title': source.Title(),
+                'url': source.absolute_url(),
+                'accessible': self.isAccessible(source),
+            })
+            has_breaches = True
+        if has_breaches:
+            breaches['target'] = {
+                'uid': IUUID(obj),
+                'title': obj.Title(),
+                'url': obj.absolute_url(),
+                'portal_type': obj.portal_type,
+                'type_title': self.getPortalTypeTitle(obj),
+            }
+        if has_breaches:
+            return breaches
+
     def getPortalTypeTitle(self, obj):
         # Get the portal type title of the object.
         context = aq_inner(self.context)
@@ -28,47 +121,3 @@ def getPortalTypeTitle(self, obj):
 
     def isAccessible(self, obj):
         return _checkPermission(AccessContentsInformation, obj)
-
-    def shallowCheckObject(self, obj):
-        result = []
-        for element in getIncomingLinks(obj):
-            obj = element.from_object
-            if obj:
-                result.append(element.from_object)
-
-        if len(result):
-            return {
-                'title': obj.Title(),
-                'url': obj.absolute_url(),
-                'sources': result,
-                'type': obj.getPortalTypeName(),
-                'type_title': self.getPortalTypeTitle(obj)
-            }
-
-    def checkObject(self, obj):
-        if not hasattr(self, 'breaches'):
-            self.breaches = []
-        check = self.shallowCheckObject(obj)
-        if check:
-            self.breaches.append(check)
-
-        if IFolder.providedBy(obj):
-            # now check if folder and go through children
-            # looking for links....
-            # Unfortunately, there doesn't seem to be a better,
-            # less expensive way to do this. This operation could
-            # potentially cost a lot of cycles...
-            catalog = getToolByName(self.context, 'portal_catalog')
-            folder_path = '/'.join(obj.getPhysicalPath())
-            for brain in catalog(path={'query': folder_path}):
-                ob = brain.getObject()
-                check = self.shallowCheckObject(ob)
-                if check:
-                    self.breaches.append(check)
-
-    def __call__(self, skip_context=False):
-        if not linkintegrity_enabled():
-            self.breaches = []
-        elif not skip_context:
-            self.checkObject(self.context)
-        return self.template()
diff --git a/plone/app/linkintegrity/tests/test_circular.py b/plone/app/linkintegrity/tests/test_circular.py
index f989ea3..4e930d4 100644
--- a/plone/app/linkintegrity/tests/test_circular.py
+++ b/plone/app/linkintegrity/tests/test_circular.py
@@ -5,8 +5,6 @@
 from plone.app.linkintegrity.utils import getOutgoingLinks
 from plone.app.linkintegrity.browser.info import DeleteConfirmationInfo
 
-import transaction
-
 
 class CircularReferencesTestCase:
 
@@ -23,48 +21,34 @@ def test_circular_reference_manages_relations(self):
         self.assertTrue(hasIncomingLinks(doc1))
         self.assertTrue(hasIncomingLinks(doc2))
         self.assertTrue(hasIncomingLinks(doc3))
-        transaction.abort()
-
-        self.portal.manage_delObjects(
-            ['doc1', 'doc2', 'doc3'], self.request)
-        self.assertNotIn('doc1', self.portal)
-        self.assertNotIn('doc2', self.portal)
-        self.assertNotIn('doc3', self.portal)
-        self.assertRaises(KeyError, hasIncomingLinks, [doc1])
-        self.assertRaises(KeyError, hasIncomingLinks, [doc2])
-        self.assertRaises(KeyError, hasIncomingLinks, [doc2])
 
     def test_circular_reference_subfolder_deletion(self):
         doc1 = self.portal.doc1
         doc2 = self.portal.doc2
+        doc3 = self.portal.doc3
         doc4 = self.portal.folder1.doc4
+        folder1 = self.portal.folder1
 
-        # This tests the behaviour when removing three object
-        # referencing each other in a circle.  This situation cannot be
-        # resolved completely, since the removal events are fired
-        # separately.  However, the circle gets "broken up" when
-        # confirming the removal of the first object, and no further
-        # confirmation form are necessary:
+        # This tests the behaviour when removing objects
+        # referencing each other in a circle.
         self._set_text(doc1, '<a href="doc2">documents...</a>')
-        self._set_text(doc2, '<a href="folder1/doc4">linking...</a>')
+        self._set_text(doc2, '<a href="doc3">go round...</a>')
+        self._set_text(doc3, '<a href="folder1/doc4">and round.</a>')
         self._set_text(doc4, '<a href="../doc1">in circles.</a>')
 
-        self.assertEqual([r.to_object for r in getOutgoingLinks(doc1)], [doc2, ])
-        self.assertEqual([r.to_object for r in getOutgoingLinks(doc2)], [doc4, ])
-        self.assertEqual([r.to_object for r in getOutgoingLinks(doc4)], [doc1, ])
+        self.assertEqual([r.to_object for r in getOutgoingLinks(doc1)], [doc2])
+        self.assertEqual([r.to_object for r in getOutgoingLinks(doc2)], [doc3])
+        self.assertEqual([r.to_object for r in getOutgoingLinks(doc3)], [doc4])
+        self.assertEqual([r.to_object for r in getOutgoingLinks(doc4)], [doc1])
 
         view = DeleteConfirmationInfo(self.portal, self.request)
-        view.checkObject(doc1)
-        view.checkObject(doc2)
-        self.assertEqual(len(view.breaches), 2)
-        transaction.abort()
+        self.assertEqual(len(view.get_breaches_for_items([folder1])), 1)
 
-        self.portal.manage_delObjects(
-            ['doc1', 'doc2', 'folder1', ], self.request)
+        self.assertEqual(
+            len(view.get_breaches_for_items([doc1, doc2, doc3, folder1])), 0)
+        self.assertEqual(
+            len(view.get_breaches_for_items([doc2, folder1])), 2)
 
-        self.assertNotIn('doc1', self.portal)
-        self.assertNotIn('doc2', self.portal)
-        self.assertNotIn('folder1', self.portal)
 
 
 class CircularReferencesDXTestCase(DXBaseTestCase, CircularReferencesTestCase):


Repository: plone.app.linkintegrity


Branch: refs/heads/master
Date: 2015-08-11T13:59:34+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.app.linkintegrity/commit/a81087efa413c8856653ae8c854c9b23209c0c32

better docstrings and more comments
allow simple calling of delete_confirmation_info (with or without items)
prevent calling on portal

Files changed:
M plone/app/linkintegrity/browser/delete_confirmation_info.pt
M plone/app/linkintegrity/browser/info.py
M plone/app/linkintegrity/tests/test_circular.py

diff --git a/plone/app/linkintegrity/browser/delete_confirmation_info.pt b/plone/app/linkintegrity/browser/delete_confirmation_info.pt
index 4a837de..5acddd4 100644
--- a/plone/app/linkintegrity/browser/delete_confirmation_info.pt
+++ b/plone/app/linkintegrity/browser/delete_confirmation_info.pt
@@ -2,8 +2,8 @@
   xmlns="http://www.w3.org/1999/xhtml"
   xml:lang="en"
   lang="en"
-  tal:define="breaches python:view.get_breaches() if view.linkintegrity_enabled else []"
-  tal:condition="python: len(breaches)>0"
+  tal:define="breaches python:view.breaches"
+  tal:condition="breaches"
   i18n:domain="plone">
     <h1 class="documentFirstHeading"
         i18n:translate="linkintegrity_breaches_title">Potential link breakage</h1>
diff --git a/plone/app/linkintegrity/browser/info.py b/plone/app/linkintegrity/browser/info.py
index 16ce41b..0fb9b06 100644
--- a/plone/app/linkintegrity/browser/info.py
+++ b/plone/app/linkintegrity/browser/info.py
@@ -2,7 +2,9 @@
 from Acquisition import aq_inner
 from OFS.interfaces import IFolder
 from Products.CMFCore.permissions import AccessContentsInformation
-from Products.CMFCore.utils import getToolByName, _checkPermission
+from Products.CMFCore.utils import _checkPermission
+from Products.CMFCore.utils import getToolByName
+from Products.CMFPlone.interfaces.siteroot import IPloneSiteRoot
 from Products.Five import BrowserView
 from Products.Five.browser.pagetemplatefile import ViewPageTemplateFile
 from collections import defaultdict
@@ -16,41 +18,69 @@ class DeleteConfirmationInfo(BrowserView):
 
     template = ViewPageTemplateFile('delete_confirmation_info.pt')
 
-    def __call__(self):
+    def __init__(self, context, request):
         self.linkintegrity_enabled = linkintegrity_enabled()
+        self.context = context
+        self.request = request
+
+    def __call__(self, items=None):
+        if not self.linkintegrity_enabled:
+            return
+        if items is None:
+            if IPloneSiteRoot.providedBy(self.context):
+                # Checking the portal for breaches makes no sense.
+                return
+            else:
+                items = [self.context]
+        self.breaches = self.get_breaches(items)
         return self.template()
 
-    def get_breaches_for_items(self, items):
-        """Check for breaches when deleting multiple items at once.
-        Breaches originating from items that will also be deleted are dropped.
+    def get_breaches(self, items=None):
+        """Return breaches for multiple items.
+
+        Breaches coming from objects in the list of items
+        or their children (if a object is a folder) will be ignored.
         """
+        if items is None:
+
+            items = [self.context]
         catalog = getToolByName(self.context, 'portal_catalog')
         results = []
-        uids_to_delete = []
+        uids_to_ignore = []
         for obj in items:
             obj_path = '/'.join(obj.getPhysicalPath())
             brains_to_delete = catalog(path={'query': obj_path})
-            uids_to_delete.extend([i.UID for i in brains_to_delete])
-            for breach in self.get_breaches(obj):
+            # add the current items uid and all its childrens uids to the
+            # list of uids that are ignored
+            uids_to_ignore.extend([i.UID for i in brains_to_delete])
+            for breach in self.get_breaches_for_item(obj):
                 add_breach = False
                 for source in breach['sources']:
-                    if source['uid'] not in uids_to_delete:
+                    # Only add the breach if one the sources is not in the
+                    # list of items that are to be deleted.
+                    if source['uid'] not in uids_to_ignore:
                         add_breach = True
                 if add_breach:
                     results.append(breach)
 
-        # cleanup (some breaches where added before it was clear
-        # that the source will be deleted too)
+        # Cleanup: Some breaches where added before it was known
+        # that their source will be deleted too.
         for result in results:
             for source in result['sources']:
-                if source['uid'] in uids_to_delete:
+                if source['uid'] in uids_to_ignore:
+                    # Drop sources that are also being deleted
                     result['sources'].remove(source)
                     if not result['sources']:
+                        # Remove the breach is there are no more sources
+                        # This check is necessary since there can be multiple
+                        # sources for a breach
                         results.remove(result)
         return results
 
-    def get_breaches(self, obj=None):
-        """Check one object and it's children for breaches.
+    def get_breaches_for_item(self, obj=None):
+        """Get breaches for one object and its children.
+
+        Breaches coming from the children of a folder are ignored by default.
         """
         if obj is None:
             obj = self.context
@@ -76,24 +106,26 @@ def get_breaches(self, obj=None):
 
     def check_object(self, obj, excluded_path=None):
         """Check one object for breaches.
-        If breaches origin from excluded_path ignore them
+
+        Breaches originating from excluded_path are ignored.
         """
-        if excluded_path is None:
-            excluded_path = '/'.join(obj.getPhysicalPath())
         breaches = defaultdict(list)
         direct_links = getIncomingLinks(obj)
         has_breaches = False
         for direct_link in direct_links:
             source_path = direct_link.from_path
-            if not source_path or source_path.startswith(excluded_path):
-                # broken or child of item that is to be deleted
+            if not source_path:
+                # link is broken
+                continue
+            if excluded_path and source_path.startswith(excluded_path):
+                # source is in excluded_path
                 continue
             source = direct_link.from_object
             breaches['sources'].append({
                 'uid': IUUID(source),
                 'title': source.Title(),
                 'url': source.absolute_url(),
-                'accessible': self.isAccessible(source),
+                'accessible': self.is_accessible(source),
             })
             has_breaches = True
         if has_breaches:
@@ -102,13 +134,13 @@ def check_object(self, obj, excluded_path=None):
                 'title': obj.Title(),
                 'url': obj.absolute_url(),
                 'portal_type': obj.portal_type,
-                'type_title': self.getPortalTypeTitle(obj),
+                'type_title': self.get_portal_type_title(obj),
             }
         if has_breaches:
             return breaches
 
-    def getPortalTypeTitle(self, obj):
-        # Get the portal type title of the object.
+    def get_portal_type_title(self, obj):
+        """Get the portal type title of the object."""
         context = aq_inner(self.context)
         portal_types = getToolByName(context, 'portal_types')
         fti = portal_types.get(obj.portal_type)
@@ -119,5 +151,5 @@ def getPortalTypeTitle(self, obj):
         type_title = translate(type_title_msgid, context=self.request)
         return type_title
 
-    def isAccessible(self, obj):
+    def is_accessible(self, obj):
         return _checkPermission(AccessContentsInformation, obj)
diff --git a/plone/app/linkintegrity/tests/test_circular.py b/plone/app/linkintegrity/tests/test_circular.py
index 4e930d4..4630f42 100644
--- a/plone/app/linkintegrity/tests/test_circular.py
+++ b/plone/app/linkintegrity/tests/test_circular.py
@@ -42,7 +42,9 @@ def test_circular_reference_subfolder_deletion(self):
         self.assertEqual([r.to_object for r in getOutgoingLinks(doc4)], [doc1])
 
         view = DeleteConfirmationInfo(self.portal, self.request)
-        self.assertEqual(len(view.get_breaches_for_items([folder1])), 1)
+        self.assertEqual(len(view.get_breaches([folder1])), 1)
+        self.assertEqual(len(view.get_breaches([doc1, doc2, doc3, folder1])), 0)
+        self.assertEqual(len(view.get_breaches([doc2, folder1])), 2)
 
         self.assertEqual(
             len(view.get_breaches_for_items([doc1, doc2, doc3, folder1])), 0)


Repository: plone.app.linkintegrity


Branch: refs/heads/master
Date: 2015-08-11T14:00:04+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.app.linkintegrity/commit/72615c0243eee2cda15edc8b7aba9ac96474da34

test dropping of internal relations

Files changed:
M plone/app/linkintegrity/tests/test_circular.py

diff --git a/plone/app/linkintegrity/tests/test_circular.py b/plone/app/linkintegrity/tests/test_circular.py
index 4630f42..2005843 100644
--- a/plone/app/linkintegrity/tests/test_circular.py
+++ b/plone/app/linkintegrity/tests/test_circular.py
@@ -1,4 +1,5 @@
 # -*- coding: utf-8 -*-
+from plone.app.linkintegrity.testing import create
 from plone.app.linkintegrity.tests.base import ATBaseTestCase
 from plone.app.linkintegrity.tests.base import DXBaseTestCase
 from plone.app.linkintegrity.utils import hasIncomingLinks
@@ -46,11 +47,39 @@ def test_circular_reference_subfolder_deletion(self):
         self.assertEqual(len(view.get_breaches([doc1, doc2, doc3, folder1])), 0)
         self.assertEqual(len(view.get_breaches([doc2, folder1])), 2)
 
+    def test_internal_breaches_are_dropped(self):
+        folder1 = self.portal.folder1
+        create(folder1, 'Document', id='doc5', title='Test Page 5')
+        doc1 = self.portal.doc1
+        doc4 = self.portal.folder1.doc4
+        doc5 = self.portal.folder1.doc5
+        self._set_text(doc1, '<a href="folder1">f1</a>')
+        self._set_text(doc4, '<a href="doc5">d5</a><a href="../doc1">d1</a>')
+        self._set_text(doc5, '<a href="../folder1">f1</a>')
+
+        doc4_breaches = set([r.to_object for r in getOutgoingLinks(doc4)])
+        # the order of breaches is non-deterministic
+        self.assertEqual(set([doc1, doc5]), doc4_breaches)
         self.assertEqual(
-            len(view.get_breaches_for_items([doc1, doc2, doc3, folder1])), 0)
+            [r.to_object for r in getOutgoingLinks(doc5)], [folder1])
         self.assertEqual(
-            len(view.get_breaches_for_items([doc2, folder1])), 2)
+            [r.to_object for r in getOutgoingLinks(doc1)], [folder1])
+        view = DeleteConfirmationInfo(self.portal, self.request)
+        self.assertEqual(len(view.get_breaches([doc4])), 0)
+        self.assertEqual(len(view.get_breaches([doc5])), 1)
+        self.assertEqual(len(view.get_breaches([doc4, doc5])), 0)
+        self.assertEqual(len(view.get_breaches([folder1])), 1)
+        self.assertEqual(len(view.get_breaches([doc1])), 1)
+        self.assertEqual(len(view.get_breaches([doc1, folder1])), 0)
 
+        view = folder1.restrictedTraverse('delete_confirmation')
+        self.assertIn('Potential link breakage', view())
+        view = folder1.restrictedTraverse('delete_confirmation_info')
+        self.assertIn('Potential link breakage', view())
+        view = doc4.restrictedTraverse('delete_confirmation')
+        self.assertNotIn('Potential link breakage', view())
+        view = doc4.restrictedTraverse('delete_confirmation_info')
+        self.assertNotIn('Potential link breakage', view())
 
 
 class CircularReferencesDXTestCase(DXBaseTestCase, CircularReferencesTestCase):


Repository: plone.app.linkintegrity


Branch: refs/heads/master
Date: 2015-08-11T14:00:18+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.app.linkintegrity/commit/d019ea732fd09be2b0a81a23d695835862896535

remove unused code

Files changed:
M plone/app/linkintegrity/testing.py

diff --git a/plone/app/linkintegrity/testing.py b/plone/app/linkintegrity/testing.py
index 943154b..75506a8 100644
--- a/plone/app/linkintegrity/testing.py
+++ b/plone/app/linkintegrity/testing.py
@@ -110,12 +110,6 @@ class LinkIntegrityDXLayer(LinkIntegrityLayer):
         PLONE_APP_CONTENTTYPES_FIXTURE,
         PLONE_APP_LINKINTEGRITY_FIXTURE,
     )
-    types_providing_referencable_behavior = set([
-        'Folder',
-        'Image',
-        'File',
-        'Document',
-    ])
 
     def setUp(self):
         self.setUpContent()


Repository: plone.app.linkintegrity


Branch: refs/heads/master
Date: 2015-08-21T14:54:43+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.app.linkintegrity/commit/76f36ed7677932c3d0070617a49fbe453f62279b

update docs and changelog

Files changed:
M CHANGES.rst
M README.rst

diff --git a/CHANGES.rst b/CHANGES.rst
index 13884cc..9a5cd93 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -4,7 +4,18 @@ Changelog
 3.0 (unreleased)
 ------------------
 
-- Nothing change.
+- Drop the Archetypes-dependency by switching to use zc.relation instead of
+  reference_catalog (Products.Archetypes).
+  [bloodbare, pbauer, vangheem]
+
+- No longer intercept the request on manage_deleteObjects. Instead only
+  inject a warning in delete_confirmation. This means that deleting with
+  other methods (like manage_deleteObjects, plone.api.content.delete, ttw
+  in the ZMI) no longer warns about linkintegrity-breaches.
+  [bloodbare, pbauer, vangheem]
+
+- LinkIntegrityNotificationException is not longer thrown anywhere.
+  [bloodbare, pbauer, vangheem]
 
 
 2.1.2 (2015-05-04)
@@ -47,12 +58,21 @@ Changelog
   [khink, mrtango]
 
 
+1.5.6 (2015-08-13)
+------------------
+
+- Backport improvements to ``@@updateLinkIntegrityInformation`` from
+  plone5 branch.
+  [pbauer]
+
+
 1.5.4 (2014-01-27)
 ------------------
 
 - Added support for sub path after uid of resolveuid
   [hoka]
 
+
 1.5.3 (2013-08-13)
 ------------------
 
diff --git a/README.rst b/README.rst
index 0c54911..30c5e80 100644
--- a/README.rst
+++ b/README.rst
@@ -4,32 +4,37 @@ plone.app.linkintegrity
 Overview
 --------
 
-This package tries to integrate `PLIP 125`_, link integrity checking,
-into Plone.  It is making use of the zope3 event system in order to modify
-Plone itself as little as possible.
+This package implement link integrity checking in Plone.  It makes use of the
+zope3 event system in order to modify Plone itself as little as possible.
 
-  .. _`PLIP 125`: http://plone.org/products/plone/roadmap/125
-  .. |---| unicode:: U+2014  .. em dash
 
-Status
-------
+Features
+--------
+
+This package handles deleting an item in the Plone-User-interface (i.e.
+deleting items in the view `folder_contents` via Actions / Delete).
 
-The code handles one of the two use cases of `PLIP 125`_, deleting an item.
 Whenever an object that is referred to by another one via an `<a>` or `<img>`
-tag is going to be deleted, Plone's regular flow of actions is "interrupted"
-and a confirmation form is presented to the user.  If they then decide to
-indeed delete the object, the original request will be replayed and this time
-followed through, thereby breaching link integrity of the site.
+tag is going to be deleted, a confirmation form is presented to the user.
+They can then decide to indeed delete the object, breaching link
+integrity of the site or first edit the objects that link to the item in
+question.
+
+Changes in 3.0
+--------------
+
+- Linkintegrity-relations are no longer stored in reference_catalog of
+  Products.Archetypes. Instead it used zc.relation.
+
+- No longer intercept the request on ``manage_deleteObjects``.
+  This means that deleting with other methods (like manage_deleteObjects,
+  plone.api.content.delete, ttw in the ZMI) no longer warns about
+  linkintegrity-breaches. It now simply adds information about
+  linkintegrity-breaches in the user-interface.
 
-This process is implemented independently of how the object is deleted (as
-long as `OFS.ObjectManager`'s `_delObject` is used ultimatively) and what
-request is used to do it.  A more detailed |---| albeit slightly outdated
-|---| explanation of how this works can be found in `NOTES.txt`.
+- LinkIntegrityNotificationException is not longer thrown anywhere.
 
-The second use case of `PLIP 125`_, which provides better handling of moved
-items, is implemented by `plone.app.redirector`__.
 
-  .. __: http://pypi.python.org/pypi/plone.app.redirector/
 
 Refresh the linkintegrity site status
 -------------------------------------
@@ -39,55 +44,48 @@ whole site, you can call the ``@@updateLinkIntegrityInformation`` view.
 
 It can be really slow operation.
 
-Using plone.app.linkintegrity in a WSGI application using repoze.zope2
-----------------------------------------------------------------------
-
-If you are deploying Plone using repoze.zope2 in a WSGI pipeline, then
-the stock LinkIntegrity won't work. To make it work, you need the following:
-
- - repoze.zope2 1.0.2 or later
- - ZODB 3.8.2 or later
-
-These two will ensure that the "views on exceptions" functionality, which
-plone.app.linkintegrity uses, is available.
-
-Next, make sure that the repoze.retry#retry middleware is used, and that
-it will handle stock Retry exceptions. With repoze.retry 0.9.3 or later,
-that is the default. With earlier versions, you can configure it explicitly.
-For example::
-
-    [app:zope2]
-    paste.app_factory = repoze.obob.publisher:make_obob
-    repoze.obob.get_root = repoze.zope2.z2bob:get_root
-    repoze.obob.initializer = repoze.zope2.z2bob:initialize
-    repoze.obob.helper_factory = repoze.zope2.z2bob:Zope2ObobHelper
-    zope.conf = /Users/optilude/Development/Plone/Code/Build/uber/plone3.x-repoze/parts/instance-debug/etc/zope.conf
-
-    [filter:retry]
-    use = egg:repoze.retry#retry
-    retryable = ZODB.POSException:ConflictError ZPublisher.Publish:Retry
-
-    [filter:errorlog]
-    use = egg:repoze.errorlog#errorlog
-    path = /__error_log__
-    keep = 50
-    ignore = 
-        paste.httpexceptions:HTTPUnauthorized
-        paste.httpexceptions:HTTPNotFound
-        paste.httpexceptions:HTTPFound
-    
-    [pipeline:main]
-    pipeline =
-        retry
-        egg:repoze.tm#tm
-        egg:repoze.vhm#vhm_xheaders
-        errorlog
-        zope2
-
-    [server:main]
-    use = egg:Paste#http
-    host = 127.0.0.1
-    port = 8080
-    threadpool_workers = 1
-    threadpool_spawn_if_under = 1
 
+API
+---
+
+To check if there would be breaches when deleting one or more objects
+you can use the follwing code:
+
+.. code-block:: python
+
+    from plone import api
+    portal = api.portal.get()
+    view = api.content.get_view(
+        'delete_confirmation_info',
+        portal,
+        self.request)
+    breaches = view.get_breaches([obj1, obj2])
+
+`get_breaches` ignores breaches originating from any items that would also be
+deleted by deleting the items (and their chidlren if an item is a folder).
+
+Each breach in `breaches` is a dictionary with a `target` (a dict with some
+info on the object to be deleted) and a list of `sources`.
+Each source is again a dict with `uid`, `title`, `url` and `accessible`
+(a boolean telling you if the user can access that source).
+
+
+To check items for links in html-fields you can use the methods in
+``plone.app.linkintegrity.utils``:
+
+
+
+``utils.hasIncomingLinks(obj)``
+    Test if an object is linked to by other objects
+
+``utils.hasOutgoingLinks(obj)``
+    Test if an object links to other objects
+
+``utils.getIncomingLinks(obj)``
+    Return a generator of incoming relations
+
+``utils.getOutgoingLinks(obj)``
+    Return a generator of outgoing relations
+
+``utils.linkintegrity_enabled()``
+    Test if linkintegrity-feature is enables for users


Repository: plone.app.linkintegrity


Branch: refs/heads/master
Date: 2015-08-24T13:41:07-05:00
Author: Nathan Van Gheem (vangheem) <vangheem@gmail.com>
Commit: https://github.com/plone/plone.app.linkintegrity/commit/8f21008e7567594eeb966a075a104af308a2e1d1

Merge pull request #22 from plone/plone5

Linkintegrity for Plone 5

Files changed:
A plone/app/linkintegrity/browser/delete_confirmation_info.pt
A plone/app/linkintegrity/browser/info.py
A plone/app/linkintegrity/profiles/default/metadata.xml
A plone/app/linkintegrity/profiles/default/ploneapplinkintegrity_default.txt
A plone/app/linkintegrity/tests/test_upgrade.py
A plone/app/linkintegrity/upgrades.py
M CHANGES.rst
M README.rst
M plone/app/linkintegrity/__init__.py
M plone/app/linkintegrity/browser/configure.zcml
M plone/app/linkintegrity/browser/update.pt
M plone/app/linkintegrity/browser/update.py
M plone/app/linkintegrity/configure.zcml
M plone/app/linkintegrity/handlers.py
M plone/app/linkintegrity/testing.py
M plone/app/linkintegrity/tests/test_circular.py
M plone/app/linkintegrity/tests/test_functional.py
M plone/app/linkintegrity/tests/test_imagescales.py
M plone/app/linkintegrity/tests/test_references.py
M plone/app/linkintegrity/utils.py
M setup.py
D plone/app/linkintegrity/NOTES.txt
D plone/app/linkintegrity/TODO.txt
D plone/app/linkintegrity/at/__init__.py
D plone/app/linkintegrity/at/configure.zcml
D plone/app/linkintegrity/browser/confirmation.pt
D plone/app/linkintegrity/browser/confirmation.py
D plone/app/linkintegrity/browser/remove.py
D plone/app/linkintegrity/dx/__init__.py
D plone/app/linkintegrity/dx/configure.zcml
D plone/app/linkintegrity/exceptions.py
D plone/app/linkintegrity/httpresponse.patch
D plone/app/linkintegrity/info.py
D plone/app/linkintegrity/interfaces.py
D plone/app/linkintegrity/monkey.py
D plone/app/linkintegrity/monkey2.py
D plone/app/linkintegrity/references.py
D plone/app/linkintegrity/tests/test_doctests.py
D plone/app/linkintegrity/tests/test_info.py

diff --git a/CHANGES.rst b/CHANGES.rst
index 614f0c0..9a5cd93 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -1,10 +1,21 @@
 Changelog
 =========
 
-2.1.3 (unreleased)
+3.0 (unreleased)
 ------------------
 
-- Nothing changed yet.
+- Drop the Archetypes-dependency by switching to use zc.relation instead of
+  reference_catalog (Products.Archetypes).
+  [bloodbare, pbauer, vangheem]
+
+- No longer intercept the request on manage_deleteObjects. Instead only
+  inject a warning in delete_confirmation. This means that deleting with
+  other methods (like manage_deleteObjects, plone.api.content.delete, ttw
+  in the ZMI) no longer warns about linkintegrity-breaches.
+  [bloodbare, pbauer, vangheem]
+
+- LinkIntegrityNotificationException is not longer thrown anywhere.
+  [bloodbare, pbauer, vangheem]
 
 
 2.1.2 (2015-05-04)
@@ -47,12 +58,21 @@ Changelog
   [khink, mrtango]
 
 
+1.5.6 (2015-08-13)
+------------------
+
+- Backport improvements to ``@@updateLinkIntegrityInformation`` from
+  plone5 branch.
+  [pbauer]
+
+
 1.5.4 (2014-01-27)
 ------------------
 
 - Added support for sub path after uid of resolveuid
   [hoka]
 
+
 1.5.3 (2013-08-13)
 ------------------
 
diff --git a/README.rst b/README.rst
index 0c54911..30c5e80 100644
--- a/README.rst
+++ b/README.rst
@@ -4,32 +4,37 @@ plone.app.linkintegrity
 Overview
 --------
 
-This package tries to integrate `PLIP 125`_, link integrity checking,
-into Plone.  It is making use of the zope3 event system in order to modify
-Plone itself as little as possible.
+This package implement link integrity checking in Plone.  It makes use of the
+zope3 event system in order to modify Plone itself as little as possible.
 
-  .. _`PLIP 125`: http://plone.org/products/plone/roadmap/125
-  .. |---| unicode:: U+2014  .. em dash
 
-Status
-------
+Features
+--------
+
+This package handles deleting an item in the Plone-User-interface (i.e.
+deleting items in the view `folder_contents` via Actions / Delete).
 
-The code handles one of the two use cases of `PLIP 125`_, deleting an item.
 Whenever an object that is referred to by another one via an `<a>` or `<img>`
-tag is going to be deleted, Plone's regular flow of actions is "interrupted"
-and a confirmation form is presented to the user.  If they then decide to
-indeed delete the object, the original request will be replayed and this time
-followed through, thereby breaching link integrity of the site.
+tag is going to be deleted, a confirmation form is presented to the user.
+They can then decide to indeed delete the object, breaching link
+integrity of the site or first edit the objects that link to the item in
+question.
+
+Changes in 3.0
+--------------
+
+- Linkintegrity-relations are no longer stored in reference_catalog of
+  Products.Archetypes. Instead it used zc.relation.
+
+- No longer intercept the request on ``manage_deleteObjects``.
+  This means that deleting with other methods (like manage_deleteObjects,
+  plone.api.content.delete, ttw in the ZMI) no longer warns about
+  linkintegrity-breaches. It now simply adds information about
+  linkintegrity-breaches in the user-interface.
 
-This process is implemented independently of how the object is deleted (as
-long as `OFS.ObjectManager`'s `_delObject` is used ultimatively) and what
-request is used to do it.  A more detailed |---| albeit slightly outdated
-|---| explanation of how this works can be found in `NOTES.txt`.
+- LinkIntegrityNotificationException is not longer thrown anywhere.
 
-The second use case of `PLIP 125`_, which provides better handling of moved
-items, is implemented by `plone.app.redirector`__.
 
-  .. __: http://pypi.python.org/pypi/plone.app.redirector/
 
 Refresh the linkintegrity site status
 -------------------------------------
@@ -39,55 +44,48 @@ whole site, you can call the ``@@updateLinkIntegrityInformation`` view.
 
 It can be really slow operation.
 
-Using plone.app.linkintegrity in a WSGI application using repoze.zope2
-----------------------------------------------------------------------
-
-If you are deploying Plone using repoze.zope2 in a WSGI pipeline, then
-the stock LinkIntegrity won't work. To make it work, you need the following:
-
- - repoze.zope2 1.0.2 or later
- - ZODB 3.8.2 or later
-
-These two will ensure that the "views on exceptions" functionality, which
-plone.app.linkintegrity uses, is available.
-
-Next, make sure that the repoze.retry#retry middleware is used, and that
-it will handle stock Retry exceptions. With repoze.retry 0.9.3 or later,
-that is the default. With earlier versions, you can configure it explicitly.
-For example::
-
-    [app:zope2]
-    paste.app_factory = repoze.obob.publisher:make_obob
-    repoze.obob.get_root = repoze.zope2.z2bob:get_root
-    repoze.obob.initializer = repoze.zope2.z2bob:initialize
-    repoze.obob.helper_factory = repoze.zope2.z2bob:Zope2ObobHelper
-    zope.conf = /Users/optilude/Development/Plone/Code/Build/uber/plone3.x-repoze/parts/instance-debug/etc/zope.conf
-
-    [filter:retry]
-    use = egg:repoze.retry#retry
-    retryable = ZODB.POSException:ConflictError ZPublisher.Publish:Retry
-
-    [filter:errorlog]
-    use = egg:repoze.errorlog#errorlog
-    path = /__error_log__
-    keep = 50
-    ignore = 
-        paste.httpexceptions:HTTPUnauthorized
-        paste.httpexceptions:HTTPNotFound
-        paste.httpexceptions:HTTPFound
-    
-    [pipeline:main]
-    pipeline =
-        retry
-        egg:repoze.tm#tm
-        egg:repoze.vhm#vhm_xheaders
-        errorlog
-        zope2
-
-    [server:main]
-    use = egg:Paste#http
-    host = 127.0.0.1
-    port = 8080
-    threadpool_workers = 1
-    threadpool_spawn_if_under = 1
 
+API
+---
+
+To check if there would be breaches when deleting one or more objects
+you can use the follwing code:
+
+.. code-block:: python
+
+    from plone import api
+    portal = api.portal.get()
+    view = api.content.get_view(
+        'delete_confirmation_info',
+        portal,
+        self.request)
+    breaches = view.get_breaches([obj1, obj2])
+
+`get_breaches` ignores breaches originating from any items that would also be
+deleted by deleting the items (and their chidlren if an item is a folder).
+
+Each breach in `breaches` is a dictionary with a `target` (a dict with some
+info on the object to be deleted) and a list of `sources`.
+Each source is again a dict with `uid`, `title`, `url` and `accessible`
+(a boolean telling you if the user can access that source).
+
+
+To check items for links in html-fields you can use the methods in
+``plone.app.linkintegrity.utils``:
+
+
+
+``utils.hasIncomingLinks(obj)``
+    Test if an object is linked to by other objects
+
+``utils.hasOutgoingLinks(obj)``
+    Test if an object links to other objects
+
+``utils.getIncomingLinks(obj)``
+    Return a generator of incoming relations
+
+``utils.getOutgoingLinks(obj)``
+    Return a generator of outgoing relations
+
+``utils.linkintegrity_enabled()``
+    Test if linkintegrity-feature is enables for users
diff --git a/plone/app/linkintegrity/NOTES.txt b/plone/app/linkintegrity/NOTES.txt
deleted file mode 100644
index 4e38daa..0000000
--- a/plone/app/linkintegrity/NOTES.txt
+++ /dev/null
@@ -1,235 +0,0 @@
-[ these notes are a bit outdated now as they were written looking at
-  revision 29942 and there have been quite a number of changes since;
-  however, they should still give some hints about the problems and
-  make it easier to follow the recent changes;  nevertheless i'll try
-  to update soon... ]
-
-
-The how and why of link integrity when deleting objects
-=======================================================
-
-Okay, so here are some notes and explanations about the code in the
-Plone 3.0 review bundle for PLIP 125 -- Ensuring link/reference
-integrity, for the use case "deleting an item".  I've first tried to
-write this in a rather serious-documentation-like way, but realized soon
-enough that this would take much too long, so here's my second take in a
-more email-like fashion...
-
-First of all, it is important to note that one goal of the PLIP is to
-try to create a preferably generic way of ensuring link integrity.
-While it would have been relatively easy to enhance plone by integrity
-checks in a number of important places where objects can get deleted
-by the user, i.e. most visibly in `folder_contents`, trying to cover
-all possible ways of deleting objects, even future ones, seemed if
-at all only possible using the zope3-style event system.  However,
-this had a number of implications on the code, making it potentially
-look a bit hacky at first sight.
-
-Furthermore, another goal was to be able to interrupt any request that
-would cause an integrity breach and possibly continue it (after asking
-the user), which add to that effect.  Therefore I'd like to explain what
-problems I encountered and how a tried to solve them one by one after
-which it's hopefully more clear why the code turned out like it did, or
-in some cases even needed to, imho.
-
-
-Events and special references
------------------------------
-
-According to the PLIP the bundle tries to ensure link integrity by
-using references indicating that a document or other content object is
-refering to an image or another page.  When an item is supposed to be
-removed by the user, those references are then used to check if the
-removal would cause a breach of link integrity.  Events are used both
-for setting up those references and also to invoke the check.  The
-former can be done using `IObjectModifiedEvent` whenever an object was
-saved and is relatively straight-forward.  However, invoking the check
-using events brought up some problems ultimatively preventing it.  There
-is still an event involved in the process, so the above statement is not
-wrong, but I'll get to that soon.
-
-Before I'd like to point out why although it seemed logical to subscribe
-to `IObjectWillBeRemovedEvent`, it wouldn't help much in this case.
-This is because any additional subscriber to `IObjectWillBeRemovedEvent`
-will be called after the legacy support for `manage_beforeDelete`
-has been handled (OFS/ObjectManager.py:374[1]).  This means that the
-subscriber used for checking the link integrity references is also only
-called after the object's `manage_beforeDelete`, which in turn calls
-`Referenceable.manage_beforeDelete` (Archetypes/BaseObject.py:201),
-where all references held by the object are removed before it is
-deleted itself.  So at the time the "checking" subscriber gets called
-the references representing the links to the object will already be
-removed.  At least, this is true when the subscriber is called for
-`OFS.interfaces.IItem`, that is the referred to object itself.
-
-Now it should be possible to use a subscriber set up for
-`IObjectWillBeRemovedEvent` on the references themselves, possibly even
-producing cleaner code, but I think there was some reason that I cannot
-recall right now :), but that made me opt for another approach instead.
-Ben Saller suggested to use `HoldingReferences` to automatically raise
-an exception when a referenced object is going to be removed.  However,
-`HoldingReferences` as such won't work, because they always raise an
-exception, which makes it impossible to successfully continue the
-request after the user has confirmed it.  But, using the same idea,
-the code introduces a new reference type, which instead of raising an
-exception will notify subscribers of a special event before its target
-is deleted, and that's also where the link integrity checks use events
-as mentioned above.  This way the references created on modification can
-be easily hooked up with the code creating confirmation page, but won't
-hurt (by raising uncaught exceptions) when link integrity should be
-disabled, for example.
-
-
-Events have no return value
----------------------------
-
-So with an event handler being called whenever an referred to object
-is supposed to be deleted, the handler "only" needs to take care of
-presenting the user with a confirmation form giving some information
-about which objects refer to the one to be removed and asking if it
-should still be deleted.  While this sounds easy, the fact that event
-subscribers support no return value (for obvious reasons) is a problem,
-because the subscriber itself cannot provide the confirmation form.  Not
-even setting up a redirection to the form is possible, because this
-would very likely remove the item before the redirection happens, in
-most cases anyway.
-
-The idea to work around this problem was to raise an exception whenever
-an referred to object was going to be removed and use Zope's error
-mechanism to provide the necessary form as a response to the otherwise
-uncaught exception.  To do this zope3-style an approach inspired by
-FiveException[2] was used:  ZPublisher's exception hook is extended by
-an attempt to look up an adapter for an exception and the request, or in
-other words, a view.  This is done by using sort of a monkey patch at
-the moment, but unlike with FiveException the function registered as the
-new exception hook is just a wrapper around the original one instead of
-a patched version, which would potentially need to be updated after new
-Zope releases.
-
-Obviously patching the exception hook like that is not a desirable
-long-term solution, but maybe a similar approach can be introduced into
-Zope's standard exception hook in the future as such a feature would
-be helpful in a number of places, imho.  Anyway, now it's possible to
-register a view for a given exception via zcml and use it to render a
-response whenever that exception is raised.  One immediate consequence
-was that rendering the view without a context turned out to be not
-very useful, since the page should look like a part of plone, after
-all.  This problem exists at all, since the view in question adapts an
-exception and a request, and not as usual an object and a request.  To
-be able to access the context and hereby the other parts of the plone
-site as well, the code uses the convention that an object representing
-the context is passed as the exception value.  This solves the problem,
-but leaves room for improvement, too, of course.
-
-
-Which exception?
-----------------
-
-The next problem was to find a suitable exception to raise in order to
-call the view containing the confirmation page.  Normally, a specially
-defined exception should have been used, but this proved to be tricky
-without changing code in several places of Plone, Archetypes and Zope.
-
-This is because the exception is raised from an event subscriber
-of the event called by the supposed to be deleted reference in its
-`beforeTargetDeleteInformSource` function, as described before.  This
-limits the choice of exceptions which can potentially be raised, because
-at this time the point of execution (or whatever you'd call that
-properly :)) is inside
-
-  a) the `try` block handling the removal of all references held
-     by an object that is to be removed itself
-     (Archetypes/Referenceable.py:262-274)
-
-  b) the `try` block in the event handler for legacy support of
-     `manage_beforeDelete` (OFS/subscribers.py:153-164)
-
-To have an exception propagate in order to be able to catch and respond
-to it using the view-based approach described before, a) wouldn't be
-problematic, since it only catches instances of `ReferenceException`.
-However, b) would log and ignore (in most conditions, at least) all
-exceptions but `OFS.ObjectManager.BeforeDeleteException` and, well,
-`ConflictError`, but this really shouldn't be raised.  So basically,
-without changing Zope's OFS module and potentially Archetypes as well,
-the only viable option left is `BeforeDeleteException`.
-
-On the other hand, hooking up `BeforeDeleteException` with the
-confirmation form can of course create some other problems, namely when
-a `BeforeDeleteException` is raised for another reason (and not caught
-elsewhere).  So the code should eventually be changed to use its own
-exception type, but for the time being it seemed more important to keep
-is a simple as possible and avoid too many changes in Zope, Archetypes
-etc.
-
-
-Interrupting and continuing a request
--------------------------------------
-
-The last thing I'd like to write about is how the current code
-interrupts and continues requests in order to be able to "pause" any
-action leading to a link integrity breach, presenting the user with a
-form asking for confirmation, and, depending on the answer, either go
-through with the original request or cancel it.
-
-Continuing a request admittedly sounds very hacky as such, but the idea
-of the PLIP was to try to implement a method of ensuring integrity
-independent of how objects are moved, renamed or deleted (unless I
-understood it wrong, of course :)).  So, to be able to do that in
-a generic fashion, the code cannot make any assumptions about the
-offending request, but should still "insert" the necessary confirmation
-step before it gets processed.
-
-The only possible solution I could think of was to try to "remember"
-the request and later on set it up and re-request it again.  While this
-really doesn't sound like a good idea at first, with the knowledge that
-Zope already supports retrying requests (via the `Retry` exception) and
-after looking at the corresponding code, it turned out to be not too bad
-at all as I can hopefully show in the remainder of this document.
-
-When a `Retry` exception is raised the current transaction is aborted,
-a new request object is built by calling its `retry` function
-(ZPublisher/Publish.py:159) and then published again.  A closer look at
-`retry` (ZPublisher/HTTPRequest.py:131) shows that apart from increasing
-the retry counter only the original request's `stdin` and `_orig_env`
-attributes are used to construct the new request instance.  But that
-also means that only those two attributes are relevant when trying to
-interrupt and continue any given request.
-
-This seems much cleaner than possibly trying to pickle the whole request
-instance or some other approach.  In fact, after saving those values
-accross the confirmation page by compressing and base64-encoding their
-pickled tuple and putting the resulting string in a hidden field, the
-original request can be continued or rather replayed by simply
-overwriting the corresponding attributes of the current request
-instance and raising a `Retry`.
-
-Of course this would normally lead to the same exception being raised,
-since the to be deleted object is still referenced by others, just like
-before.  Since the only two values making it into the new request are
-`stdin` and `_orig_env`, it becomes necessary to set some kind of marker
-in one of the two to indicate that the request was already interrupted
-and confirmed by the user.  The subscriber of the event triggered by the
-removal of the special Archetypes reference as described before can then
-check for this marker and simply not raise `BeforeDeleteException` again
-if it exists.  This results in the original request getting executed as
-it had never been interrupted in the first place.
-
-
-An excuse for hackyness :)
---------------------------
-
-While all the solutions to the problems described so far are very
-likely not the cleanest and best way in terms of code simplicity and
-maintainability, most of them were the only way to work around the
-limitations I've run into, or at least the cleanest possible way, imho.
-As mentioned before, some things could be better with more changes to
-Zope, Archetypes and/or Plone, but I was trying to find ways to avoid
-or minimize that in order to make the code more suitable as an add-on
-product to Plone.  Also, I've tried to clean up as much as possible and
-comment the trickier parts of the code, so that it hopefully stands a
-chance of being accepted for the 3.0 release... :)
-
-
-[1] all line numbers refer to Zope 2.10.0b1 and the Plone 3.0 review bundle
-[2] http://codespeak.net/svn/z3/FiveException/
-
diff --git a/plone/app/linkintegrity/TODO.txt b/plone/app/linkintegrity/TODO.txt
deleted file mode 100644
index 214a117..0000000
--- a/plone/app/linkintegrity/TODO.txt
+++ /dev/null
@@ -1,29 +0,0 @@
-to do for a first real version:
-- link integrity vs iterate
-- create method to re-create integrity refs for the whole site and
-  integrate that into migration and the control panel
-- what about ftp/dav?
-
-nice things to have later on:
-- use annotations in info adapter (info.py)
-- update implementation notes
-- it would be possible to cancel single removals while going through with
-  the others, but only if a potentially uncaught (by other code, i.e. third
-  party products) exception was raised on cancel;  atm it's unclear if this
-  would be desirable, though...
-- reintroduce objects names/path in portal message on cancel
-- add warnings about moved images/pages
-- factor out all archetypes related stuff using adapters etc (i.e. references)
-- possibly replace atreferences by something more generic (five.intid should do)
-- use pullparser.py instead of the newly written link-parser?
-
-Things done and/or discovered in PLIP 13260 (winebeersprint 2014, saily, do3cc)
-- restructured whole package
-- using at and dx folders to allow setup of different specific tests in each
-  folder.
-- converted all doctests into p.a.testing tests, which run now quite fast.
-- linkintegrity is a huge hack. we should think about a more cleaner and
-  generic approach to implement such checks.
-- currently we have one failing test on dexerity, which targets renaming
-  documents. it has a decorator allowfailure to not break whole setup, we might
-  need to fix that later.
diff --git a/plone/app/linkintegrity/__init__.py b/plone/app/linkintegrity/__init__.py
index f786609..dae354a 100644
--- a/plone/app/linkintegrity/__init__.py
+++ b/plone/app/linkintegrity/__init__.py
@@ -1,39 +1 @@
-try:
-    # this import not used except as a test for Zope 2.12+
-    from Products.Five.bbb import AcquisitionBBB
-    AcquisitionBBB      # make pyflakes happy
-    HAS_ZOPE_212 = True
-except ImportError:
-    HAS_ZOPE_212 = False
-
-import pkg_resources
-
-try:
-    pkg_resources.get_distribution('plone.app.multilingual')
-except pkg_resources.DistributionNotFound:
-    HAS_PAM = False
-else:
-    HAS_PAM = True
-
-try:
-    pkg_resources.get_distribution('Products.LinguaPlone')
-except pkg_resources.DistributionNotFound:
-    HAS_LINGUAPLONE = False
-else:
-    HAS_LINGUAPLONE = True
-
-
-def initialize(context):
-
-    # side effect import to patch the response's retry method
-    import monkey
-
-    # Install the wrapper around zpublisher_exception_hook.
-    monkey.installExceptionHook()
-
-    # Install the status code for linkintegritynotificationexception
-    monkey.installStatusCode()
-
-
-import monkey2
-monkey2  # pyflakes
+# -*- encoding: utf-8 -*-
diff --git a/plone/app/linkintegrity/at/__init__.py b/plone/app/linkintegrity/at/__init__.py
deleted file mode 100644
index e69de29..0000000
diff --git a/plone/app/linkintegrity/at/configure.zcml b/plone/app/linkintegrity/at/configure.zcml
deleted file mode 100644
index e0aa3fa..0000000
--- a/plone/app/linkintegrity/at/configure.zcml
+++ /dev/null
@@ -1,29 +0,0 @@
-<configure
-    xmlns="http://namespaces.zope.org/zope">
-
-    <subscriber
-        for="Products.Archetypes.interfaces.IBaseObject
-             OFS.interfaces.IObjectClonedEvent"
-        handler="..handlers.modifiedArchetype" />
-
-    <subscriber
-        for="Products.Archetypes.interfaces.IBaseObject
-             zope.lifecycleevent.interfaces.IObjectCreatedEvent"
-        handler="..handlers.modifiedArchetype" />
-
-    <subscriber
-        for="Products.Archetypes.interfaces.IBaseObject
-             zope.lifecycleevent.interfaces.IObjectModifiedEvent"
-        handler="..handlers.modifiedArchetype" />
-
-    <subscriber
-        for="Products.Archetypes.interfaces.IBaseObject
-             zope.lifecycleevent.interfaces.IObjectRemovedEvent"
-        handler="..handlers.referencedObjectRemoved" />
-
-    <subscriber
-        for="Products.Archetypes.interfaces.IReference
-             zope.lifecycleevent.interfaces.IObjectRemovedEvent"
-        handler="..handlers.referenceRemoved" />
-
-</configure>
diff --git a/plone/app/linkintegrity/browser/configure.zcml b/plone/app/linkintegrity/browser/configure.zcml
index 184d3c9..50a108b 100644
--- a/plone/app/linkintegrity/browser/configure.zcml
+++ b/plone/app/linkintegrity/browser/configure.zcml
@@ -3,6 +3,13 @@
     xmlns:browser="http://namespaces.zope.org/browser">
 
     <browser:page
+       for="*"
+       name="delete_confirmation_info"
+       class=".info.DeleteConfirmationInfo"
+       permission="zope2.Public"
+       />
+
+    <browser:page
         name="updateLinkIntegrityInformation"
         for="Products.CMFPlone.interfaces.IPloneSiteRoot"
         template="update.pt"
@@ -10,17 +17,5 @@
         permission="cmf.ManagePortal"
         />
 
-    <browser:page
-        name="index.html"
-        for="..interfaces.ILinkIntegrityNotificationException"
-        template="confirmation.pt"
-        class=".confirmation.RemoveConfirmationView"
-        permission="zope2.Public" />
-
-    <browser:page
-        name="removeConfirmationAction"
-        for="Products.CMFPlone.interfaces.IPloneSiteRoot"
-        class=".remove.RemoveReferencedObjectView"
-        permission="zope2.Public" />
 
 </configure>
diff --git a/plone/app/linkintegrity/browser/confirmation.pt b/plone/app/linkintegrity/browser/confirmation.pt
deleted file mode 100644
index 2a2ce30..0000000
--- a/plone/app/linkintegrity/browser/confirmation.pt
+++ /dev/null
@@ -1,102 +0,0 @@
-<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"
-      lang="en"
-      metal:use-macro="here/main_template/macros/master"
-      i18n:domain="plone">
-
-<head>
-    <metal:block fill-slot="top_slot"
-                 tal:define="dummy python:request.set('disable_border',1);
-                             disable_column_one python:request.set('disable_plone.leftcolumn',1);
-                             disable_column_two python:request.set('disable_plone.rightcolumn',1);" />
-</head>
-
-<body>
-
-<metal:main fill-slot="content">
-
-    <div class="portalMessage warning">
-        <strong i18n:translate="">Warning</strong>
-        <span tal:omit-tag="" i18n:translate="linkintegrity_warning">
-            One or more of the items you are attempting to delete may cause links
-            in your site to break.
-        </span>
-    </div>
-
-    <article id="content">
-        <h1 class="documentFirstHeading"
-            i18n:translate="linkintegrity_breaches_title">Potential link breakage</h1>
-
-        <div id="content-core">
-            <p i18n:translate="linkintegrity_instructions">
-                By deleting this item, you will break links that exist in the items listed
-                below. If this is indeed what you want to do, we recommend that you remove
-                these references first.
-            </p>
-
-            <form method="post" action="removeConfirmationAction"
-                  tal:attributes="action view/callbackURL">
-
-              <div>
-                  <article tal:repeat="breach view/integrityBreaches">
-
-                    <header>
-                      <a tal:attributes="href breach/url"
-                          tal:content="breach/title" />
-                    </header>
-                    <p>
-                        <span i18n:translate="linkintegrity_is_referenced">
-                            This <span i18n:name="portal_type" tal:content="breach/type_title" />
-                            is referenced by the following items:
-                        </span>
-                    </p>
-
-                        <ul>
-                          <li tal:repeat="src breach/sources">
-                            <tal:visible condition="python: view.isAccessible(src)">
-                              <a tal:attributes="href src/absolute_url" tal:content="src/Title" />
-                              [<a tal:attributes="href string:${src/absolute_url}/edit"
-                                i18n:translate="linkintegrity_edit_in_new_window"
-                                target="_blank">Edit in new window</a>]
-                            </tal:visible>
-                            <tal:private condition="python: not view.isAccessible(src)"
-                                         i18n:translate="linkintegrity_item_not_accessible">
-                              The item is not accessible.
-                            </tal:private>
-                          </li>
-                        </ul>
-
-                  </article>
-
-              <br />
-
-              <p i18n:translate="linkintegrity_delete_anyway">
-                  Would you like to delete it anyway?
-              </p>
-
-              <input type="hidden" name="original_request"
-                     tal:attributes="value view/originalRequest" />
-
-              <input type="hidden" name="confirmed_items"
-                     tal:attributes="value view/confirmedItems" />
-
-              <input type="hidden" name="cancel_url"
-                     tal:attributes="value view/cancelURL" />
-
-              <input class="destructive" type="submit" name="delete"
-                     value="Yes" i18n:attributes="value linkintegrity_yes" />
-
-              <input class="destructive" type="submit" name="delete_all"
-                     value="Yes to all" i18n:attributes="value linkintegrity_yes_to_all" />
-
-              <input class="standalone" type="submit" name="cancel"
-                     value="Cancel" i18n:attributes="value linkintegrity_cancel" />
-
-              </div>
-            </form>
-        </div>
-    </article>
-
-</metal:main>
-
-</body>
-</html>
diff --git a/plone/app/linkintegrity/browser/confirmation.py b/plone/app/linkintegrity/browser/confirmation.py
deleted file mode 100644
index 3dcef67..0000000
--- a/plone/app/linkintegrity/browser/confirmation.py
+++ /dev/null
@@ -1,84 +0,0 @@
-# -*- coding: utf-8 -*-
-from Acquisition import aq_inner
-from Products.Five import BrowserView
-from Products.CMFCore.utils import getToolByName, _checkPermission
-from Products.CMFCore.permissions import AccessContentsInformation
-from plone.app.linkintegrity.interfaces import ILinkIntegrityInfo
-from plone.app.linkintegrity.utils import encodeRequestData
-from zope.component import getMultiAdapter
-from zope.i18n import translate
-
-
-class RemoveConfirmationView(BrowserView):
-
-    def __init__(self, context, request):
-        # since this is a view adapting an exception and a request (instead
-        # of a regular content object and a request), the exception object
-        # was passed as the context;  therefore we need to construct a
-        # proper context in order to render the template in a sane manner;
-        # to do this we will assume that the desired context was passed as
-        # the first exception value...
-        self.exception = context
-        self.context, = context.args
-        self.request = request
-
-    @property
-    def portal_state(self):
-        return getMultiAdapter(
-            (self.context, self.request), name='plone_portal_state')
-
-    def originalRequest(self):
-        # in order to interrupt the current request with a confirmation
-        # question about removing the referred to object we need to save
-        # the original request to be able to possibly continue it later on,
-        # so we pickle and encode its body and environment...
-        self.request.stdin.seek(0)
-        body = self.request.stdin.read()
-        env = dict(self.request._orig_env)
-        for key in 'HTTP_AUTHORIZATION', 'HTTP_COOKIE':
-            if key in env:
-                del env[key]
-        return encodeRequestData((body, env))
-
-    def getPortalTypeTitle(self, obj):
-        # Get the portal type title of the object.
-        context = aq_inner(self.context)
-        portal_types = getToolByName(context, 'portal_types')
-        fti = portal_types.get(obj.portal_type)
-        if fti is not None:
-            type_title_msgid = fti.Title()
-        else:
-            type_title_msgid = obj.portal_type
-        type_title = translate(type_title_msgid, context=self.request)
-        return type_title
-
-    def integrityBreaches(self):
-        info = ILinkIntegrityInfo(self.request).getIntegrityBreaches()
-        byTitle = lambda a, b: cmp(
-            (a.Title(), a.getId()), (b.Title(), b.getId()))
-        breaches = []
-        for target, sources in info.items():
-            breaches.append({
-                'title': target.Title(),
-                'type': target.getPortalTypeName(),
-                'type_title': self.getPortalTypeTitle(target),
-                'url': target.absolute_url(),
-                'sources': sorted(sources, byTitle),
-            })
-        return sorted(breaches, lambda a, b: cmp(a['title'], b['title']))
-
-    def isAccessible(self, obj):
-        return _checkPermission(AccessContentsInformation, obj)
-
-    def confirmedItems(self):
-        info = ILinkIntegrityInfo(self.request)
-        targets = info.getIntegrityBreaches().keys()
-        return info.encodeConfirmedItems(additions=targets)
-
-    def callbackURL(self):
-        return '{0:s}/removeConfirmationAction'.format(
-            self.portal_state.navigation_root_url())
-
-    def cancelURL(self):
-        url = self.request.environ.get('HTTP_REFERER', None)
-        return url or self.portal_state.navigation_root_url()
diff --git a/plone/app/linkintegrity/browser/delete_confirmation_info.pt b/plone/app/linkintegrity/browser/delete_confirmation_info.pt
new file mode 100644
index 0000000..5acddd4
--- /dev/null
+++ b/plone/app/linkintegrity/browser/delete_confirmation_info.pt
@@ -0,0 +1,56 @@
+<article id="content"
+  xmlns="http://www.w3.org/1999/xhtml"
+  xml:lang="en"
+  lang="en"
+  tal:define="breaches python:view.breaches"
+  tal:condition="breaches"
+  i18n:domain="plone">
+    <h1 class="documentFirstHeading"
+        i18n:translate="linkintegrity_breaches_title">Potential link breakage</h1>
+
+    <div id="content-core">
+        <p i18n:translate="linkintegrity_instructions">
+            By deleting this item, you will break links that exist in the items listed
+            below. If this is indeed what you want to do, we recommend that you remove
+            these references first.
+        </p>
+
+        <div tal:define="token context/@@authenticator/token">
+            <article tal:repeat="breach breaches" class="breach-container">
+
+              <tal:target  tal:define="target breach/target">
+                <header><a href="target/url" tal:content="target/title" /></header>
+                <p>
+                    <span i18n:translate="linkintegrity_is_referenced">
+                        This <span i18n:name="portal_type" tal:content="target/type_title" />
+                        is referenced by the following items:
+                    </span>
+                </p>
+              </tal:target>
+
+              <ul>
+                <li tal:repeat="source python:breach['sources']" class="breach-item">
+                  <tal:visible condition="source/accessible">
+                    <a tal:attributes="href source/url" tal:content="source/title" />
+                    [<a tal:attributes="href string:${source/url}/edit?_authenticator=${token}"
+                      i18n:translate="linkintegrity_edit_in_new_window"
+                      target="_blank">Edit in new window</a>]
+                  </tal:visible>
+                  <tal:private condition="not: source/accessible"
+                               i18n:translate="linkintegrity_item_not_accessible">
+                    The item is not accessible.
+                  </tal:private>
+                </li>
+              </ul>
+
+            </article>
+
+        <br />
+
+        <p i18n:translate="linkintegrity_delete_anyway">
+            Would you like to delete it anyway?
+        </p>
+
+        </div>
+    </div>
+</article>
\ No newline at end of file
diff --git a/plone/app/linkintegrity/browser/info.py b/plone/app/linkintegrity/browser/info.py
new file mode 100644
index 0000000..0fb9b06
--- /dev/null
+++ b/plone/app/linkintegrity/browser/info.py
@@ -0,0 +1,155 @@
+# -*- coding: utf-8 -*-
+from Acquisition import aq_inner
+from OFS.interfaces import IFolder
+from Products.CMFCore.permissions import AccessContentsInformation
+from Products.CMFCore.utils import _checkPermission
+from Products.CMFCore.utils import getToolByName
+from Products.CMFPlone.interfaces.siteroot import IPloneSiteRoot
+from Products.Five import BrowserView
+from Products.Five.browser.pagetemplatefile import ViewPageTemplateFile
+from collections import defaultdict
+from plone.app.linkintegrity.utils import getIncomingLinks
+from plone.app.linkintegrity.utils import linkintegrity_enabled
+from plone.uuid.interfaces import IUUID
+from zope.i18n import translate
+
+
+class DeleteConfirmationInfo(BrowserView):
+
+    template = ViewPageTemplateFile('delete_confirmation_info.pt')
+
+    def __init__(self, context, request):
+        self.linkintegrity_enabled = linkintegrity_enabled()
+        self.context = context
+        self.request = request
+
+    def __call__(self, items=None):
+        if not self.linkintegrity_enabled:
+            return
+        if items is None:
+            if IPloneSiteRoot.providedBy(self.context):
+                # Checking the portal for breaches makes no sense.
+                return
+            else:
+                items = [self.context]
+        self.breaches = self.get_breaches(items)
+        return self.template()
+
+    def get_breaches(self, items=None):
+        """Return breaches for multiple items.
+
+        Breaches coming from objects in the list of items
+        or their children (if a object is a folder) will be ignored.
+        """
+        if items is None:
+
+            items = [self.context]
+        catalog = getToolByName(self.context, 'portal_catalog')
+        results = []
+        uids_to_ignore = []
+        for obj in items:
+            obj_path = '/'.join(obj.getPhysicalPath())
+            brains_to_delete = catalog(path={'query': obj_path})
+            # add the current items uid and all its childrens uids to the
+            # list of uids that are ignored
+            uids_to_ignore.extend([i.UID for i in brains_to_delete])
+            for breach in self.get_breaches_for_item(obj):
+                add_breach = False
+                for source in breach['sources']:
+                    # Only add the breach if one the sources is not in the
+                    # list of items that are to be deleted.
+                    if source['uid'] not in uids_to_ignore:
+                        add_breach = True
+                if add_breach:
+                    results.append(breach)
+
+        # Cleanup: Some breaches where added before it was known
+        # that their source will be deleted too.
+        for result in results:
+            for source in result['sources']:
+                if source['uid'] in uids_to_ignore:
+                    # Drop sources that are also being deleted
+                    result['sources'].remove(source)
+                    if not result['sources']:
+                        # Remove the breach is there are no more sources
+                        # This check is necessary since there can be multiple
+                        # sources for a breach
+                        results.remove(result)
+        return results
+
+    def get_breaches_for_item(self, obj=None):
+        """Get breaches for one object and its children.
+
+        Breaches coming from the children of a folder are ignored by default.
+        """
+        if obj is None:
+            obj = self.context
+        results = []
+        catalog = getToolByName(obj, 'portal_catalog')
+        obj_path = '/'.join(obj.getPhysicalPath())
+
+        breaches = self.check_object(obj)
+        if breaches:
+            results.append(breaches)
+
+        if IFolder.providedBy(obj):
+            brains = catalog(path={'query': obj_path})
+            for brain in brains:
+                child = brain.getObject()
+                if child == obj:
+                    continue
+                breaches = self.check_object(obj=child, excluded_path=obj_path)
+                if breaches:
+                    results.append(breaches)
+        self.breaches = results
+        return results
+
+    def check_object(self, obj, excluded_path=None):
+        """Check one object for breaches.
+
+        Breaches originating from excluded_path are ignored.
+        """
+        breaches = defaultdict(list)
+        direct_links = getIncomingLinks(obj)
+        has_breaches = False
+        for direct_link in direct_links:
+            source_path = direct_link.from_path
+            if not source_path:
+                # link is broken
+                continue
+            if excluded_path and source_path.startswith(excluded_path):
+                # source is in excluded_path
+                continue
+            source = direct_link.from_object
+            breaches['sources'].append({
+                'uid': IUUID(source),
+                'title': source.Title(),
+                'url': source.absolute_url(),
+                'accessible': self.is_accessible(source),
+            })
+            has_breaches = True
+        if has_breaches:
+            breaches['target'] = {
+                'uid': IUUID(obj),
+                'title': obj.Title(),
+                'url': obj.absolute_url(),
+                'portal_type': obj.portal_type,
+                'type_title': self.get_portal_type_title(obj),
+            }
+        if has_breaches:
+            return breaches
+
+    def get_portal_type_title(self, obj):
+        """Get the portal type title of the object."""
+        context = aq_inner(self.context)
+        portal_types = getToolByName(context, 'portal_types')
+        fti = portal_types.get(obj.portal_type)
+        if fti is not None:
+            type_title_msgid = fti.Title()
+        else:
+            type_title_msgid = obj.portal_type
+        type_title = translate(type_title_msgid, context=self.request)
+        return type_title
+
+    def is_accessible(self, obj):
+        return _checkPermission(AccessContentsInformation, obj)
diff --git a/plone/app/linkintegrity/browser/remove.py b/plone/app/linkintegrity/browser/remove.py
deleted file mode 100644
index b0e61b7..0000000
--- a/plone/app/linkintegrity/browser/remove.py
+++ /dev/null
@@ -1,62 +0,0 @@
-# -*- coding: utf-8 -*-
-from Acquisition import aq_inner
-from base64 import b64encode
-from StringIO import StringIO
-from ZPublisher.Publish import Retry
-
-from Products.CMFPlone import PloneMessageFactory as _
-from Products.Five import BrowserView
-from Products.statusmessages.interfaces import IStatusMessage
-
-from plone.app.linkintegrity.interfaces import ILinkIntegrityInfo
-from plone.app.linkintegrity.utils import decodeRequestData
-
-
-class RemoveReferencedObjectView(BrowserView):
-
-    def __init__(self, context, request):
-        self.context = context
-        self.request = request
-
-    def __call__(self):
-        # this view is intended to provide an action called by the
-        # confirmation form;  all it does is prepare the request for
-        # the retry exception and raise it...
-        request = aq_inner(self.request)
-        clicked = request.form.has_key
-        if clicked('delete') or clicked('delete_all'):
-            # the user choose to actually delete the referred to object,
-            # so we reconstruct the original request which we interrupted
-            # before, store the so far confirmed items and retry it...
-            body, env = decodeRequestData(request.get('original_request'))
-
-            marker = ILinkIntegrityInfo(request).getEnvMarker()
-            if clicked('delete_all'):
-                env[marker] = 'all'
-            else:
-                env[marker] = request.get('confirmed_items')
-            auth = request._authUserPW()
-            if auth is not None:
-                authtoken = b64encode('%s:%s' % auth)
-                env['HTTP_AUTHORIZATION'] = 'Basic %s' % authtoken
-            env['HTTP_COOKIE'] = request.get('HTTP_COOKIE', '')
-
-            # Update the original environment with the new one. In a WSGI
-            # context, we want to update the dict, not overwrite it, because
-            # we actually want to modify the WSGI environ. We also need to
-            # make sure we don't touch keys that are not strings
-            request._orig_env.update(env)
-
-            # Set the stdin for the request
-            new_stdin = StringIO(body)
-            if 'wsgi.input' in request._orig_env:
-                request._orig_env['wsgi.input'] = new_stdin
-            setattr(request, 'stdin', new_stdin)
-
-            raise Retry
-        else:
-            # the user choose to cancel the removal, in which case we
-            # redirect back to the original HTTP_REFERER url...
-            msg = _(u'Removal cancelled.')
-            IStatusMessage(request).addStatusMessage(msg, type='info')
-            request.RESPONSE.redirect(request.get('cancel_url'))
diff --git a/plone/app/linkintegrity/browser/update.pt b/plone/app/linkintegrity/browser/update.pt
index 16da1b8..8a2d48b 100644
--- a/plone/app/linkintegrity/browser/update.pt
+++ b/plone/app/linkintegrity/browser/update.pt
@@ -18,7 +18,7 @@
     <div id="content-core">
         <p i18n:translate="linkintegrity_update_instructions">
             Clicking the below button will cause link integrity information to be
-            updated.  This might take a while, especially for bigger sites...
+            updated. This might take a while, especially for bigger sites...
         </p>
 
         <form method="post" action="updateLinkIntegrityInformation"
diff --git a/plone/app/linkintegrity/browser/update.py b/plone/app/linkintegrity/browser/update.py
index fbc5a84..e9b98a2 100644
--- a/plone/app/linkintegrity/browser/update.py
+++ b/plone/app/linkintegrity/browser/update.py
@@ -5,30 +5,55 @@
 from Products.CMFPlone import PloneMessageFactory as _
 from Products.Five import BrowserView
 from Products.statusmessages.interfaces import IStatusMessage
-
+from datetime import datetime
+from datetime import timedelta
 from plone.app.linkintegrity.handlers import modifiedArchetype
 from plone.app.linkintegrity.handlers import modifiedDexterity
-from plone.app.linkintegrity import HAS_LINGUAPLONE
-from plone.app.linkintegrity import HAS_PAM
-from plone.app.referenceablebehavior.referenceable import IReferenceable
 from plone.dexterity.interfaces import IDexterityContent
+from zExceptions import NotFound
+import logging
+import pkg_resources
+
+# Is there a multilingual addon?
+try:
+    pkg_resources.get_distribution('Products.LinguaPlone')
+except pkg_resources.DistributionNotFound:
+    HAS_MULTILINGUAL = False
+else:
+    HAS_MULTILINGUAL = True
+
+if not HAS_MULTILINGUAL:
+    try:
+        pkg_resources.get_distribution('plone.app.multilingual')
+    except pkg_resources.DistributionNotFound:
+        HAS_MULTILINGUAL = False
+    else:
+        HAS_MULTILINGUAL = True
+
+logger = logging.getLogger(__name__)
 
 
 class UpdateView(BrowserView):
+    """Iterate over all catalogued items and update linkintegrity-information.
+    """
 
     def __call__(self):
         context = aq_inner(self.context)
         request = aq_inner(self.request)
         clicked = request.form.has_key
         if clicked('update') or clicked('delete_all'):
+            starttime = datetime.now()
             count = self.update()
+            duration = timedelta(seconds=(datetime.now() - starttime).seconds)
             msg = _(
                 u'linkintegrity_update_info',
                 default=u'Link integrity information updated for ${count} ' +
-                        u'item(s).',
-                mapping={'count': count},
+                        u'items in ${time} seconds.',
+                mapping={'count': count, 'time': str(duration)},
             )
             IStatusMessage(request).add(msg, type='info')
+            msg = 'Updated {} items in {} seconds'.format(count, str(duration))
+            logger.info(msg)
             request.RESPONSE.redirect(getToolByName(context, 'portal_url')())
         elif clicked('cancel'):
             msg = _(u'Update cancelled.')
@@ -40,18 +65,27 @@ def __call__(self):
     def update(self):
         catalog = getToolByName(self.context, 'portal_catalog')
         count = 0
-        kwargs = {}
-
-        if HAS_LINGUAPLONE or HAS_PAM:
-            kwargs['Language'] = 'all'
+        query = {}
+        if HAS_MULTILINGUAL and 'Language' in catalog.indexes():
+            query['Language'] = 'all'
 
-        for brain in catalog(**kwargs):
-            obj = brain.getObject()
+        for brain in catalog(query):
+            try:
+                obj = brain.getObject()
+            except (AttributeError, NotFound, KeyError):
+                msg = "Catalog inconsistency: {} not found!"
+                logger.error(msg.format(brain.getPath()), exc_info=1)
+                continue
+            method = None
             if IBaseObject.providedBy(obj):
-                modifiedArchetype(obj, 'dummy event parameter')
-                count += 1
+                method = modifiedArchetype
             elif IDexterityContent.providedBy(obj):
-                if IReferenceable.providedBy(obj):
-                    modifiedDexterity(obj, 'dummy event parameter')
-                count += 1
+                method = modifiedDexterity
+            if method:
+                try:
+                    method(obj, 'dummy event parameter')
+                    count += 1
+                except Exception:
+                    msg = "Error updating linkintegrity-info for {}."
+                    logger.error(msg.format(obj.absolute_url()), exc_info=1)
         return count
diff --git a/plone/app/linkintegrity/configure.zcml b/plone/app/linkintegrity/configure.zcml
index e905ca1..db653d8 100644
--- a/plone/app/linkintegrity/configure.zcml
+++ b/plone/app/linkintegrity/configure.zcml
@@ -1,30 +1,55 @@
 <configure
     xmlns="http://namespaces.zope.org/zope"
     xmlns:browser="http://namespaces.zope.org/browser"
-    xmlns:five="http://namespaces.zope.org/five"
+    xmlns:genericsetup="http://namespaces.zope.org/genericsetup"
     xmlns:zcml="http://namespaces.zope.org/zcml">
 
     <includeDependencies package="." />
 
-    <five:registerPackage package="." initialize=".initialize" />
-
     <include package="Products.CMFCore" file="permissions.zcml" />
 
-    <adapter
-        for="zope.publisher.interfaces.browser.IBrowserRequest"
-        provides=".interfaces.ILinkIntegrityInfo"
-        factory=".info.LinkIntegrityInfo" />
-
-    <class class="OFS.Image.Image">
-        <implements interface=".interfaces.IOFSImage" />
-    </class>
-
     <include package=".browser" />
 
-    <include package=".at"
-             zcml:condition="installed Products.Archetypes" />
-
-    <include package=".dx"
-             zcml:condition="installed plone.dexterity" />
+    <configure zcml:condition="installed Products.Archetypes">
+      <subscriber
+          for="Products.Archetypes.interfaces.IBaseObject
+               OFS.interfaces.IObjectClonedEvent"
+          handler=".handlers.modifiedArchetype" />
+
+      <subscriber
+          for="Products.Archetypes.interfaces.IBaseObject
+               zope.lifecycleevent.interfaces.IObjectCreatedEvent"
+          handler=".handlers.modifiedArchetype" />
+
+      <subscriber
+          for="Products.Archetypes.interfaces.IBaseObject
+               zope.lifecycleevent.interfaces.IObjectModifiedEvent"
+          handler=".handlers.modifiedArchetype" />
+    </configure>
+
+    <configure zcml:condition="installed plone.dexterity">
+      <subscriber
+          for="plone.app.relationfield.interfaces.IDexterityHasRelations
+               zope.lifecycleevent.interfaces.IObjectCopiedEvent"
+          handler=".handlers.modifiedDexterity" />
+
+      <subscriber
+          for="plone.app.relationfield.interfaces.IDexterityHasRelations
+               zope.lifecycleevent.interfaces.IObjectAddedEvent"
+          handler=".handlers.modifiedDexterity" />
+
+      <subscriber
+          for="plone.app.relationfield.interfaces.IDexterityHasRelations
+               zope.lifecycleevent.interfaces.IObjectModifiedEvent"
+          handler=".handlers.modifiedDexterity" />
+    </configure>
+
+    <genericsetup:registerProfile
+        name="default"
+        title="plone.app.linkintegrity"
+        directory="profiles/default"
+        description="Installs the plone.app.linkintegrity add-on."
+        provides="Products.GenericSetup.interfaces.EXTENSION"
+        />
 
 </configure>
diff --git a/plone/app/linkintegrity/dx/__init__.py b/plone/app/linkintegrity/dx/__init__.py
deleted file mode 100644
index e69de29..0000000
diff --git a/plone/app/linkintegrity/dx/configure.zcml b/plone/app/linkintegrity/dx/configure.zcml
deleted file mode 100644
index b95e09b..0000000
--- a/plone/app/linkintegrity/dx/configure.zcml
+++ /dev/null
@@ -1,26 +0,0 @@
-<configure
-    xmlns="http://namespaces.zope.org/zope">
-
-    <include package="plone.app.referenceablebehavior" />
-
-    <subscriber
-        for="plone.app.referenceablebehavior.referenceable.IReferenceable
-             zope.lifecycleevent.interfaces.IObjectCopiedEvent"
-        handler="..handlers.modifiedDexterity" />
-
-    <subscriber
-        for="plone.app.referenceablebehavior.referenceable.IReferenceable
-             zope.lifecycleevent.interfaces.IObjectCreatedEvent"
-        handler="..handlers.modifiedDexterity" />
-
-    <subscriber
-        for="plone.app.referenceablebehavior.referenceable.IReferenceable
-             zope.lifecycleevent.interfaces.IObjectModifiedEvent"
-        handler="..handlers.modifiedDexterity" />
-
-    <subscriber
-        for="plone.app.referenceablebehavior.referenceable.IReferenceable
-             zope.lifecycleevent.interfaces.IObjectRemovedEvent"
-        handler="..handlers.referencedObjectRemoved" />
-
-</configure>
diff --git a/plone/app/linkintegrity/exceptions.py b/plone/app/linkintegrity/exceptions.py
deleted file mode 100644
index 30f26a7..0000000
--- a/plone/app/linkintegrity/exceptions.py
+++ /dev/null
@@ -1,14 +0,0 @@
-from zope.interface import implements
-from interfaces import ILinkIntegrityNotificationException
-from OFS.ObjectManager import BeforeDeleteException
-
-
-class LinkIntegrityNotificationException(BeforeDeleteException):
-    """ an exception indicating a prevented link integrity breach """
-    implements(ILinkIntegrityNotificationException)
-
-    def __str__(self):
-        args = self.args
-        if args and isinstance(args, tuple):
-            return repr(args[0])
-        return super(LinkIntegrityNotificationException, self).__str__()
diff --git a/plone/app/linkintegrity/handlers.py b/plone/app/linkintegrity/handlers.py
index 47b4a4d..70b67f3 100644
--- a/plone/app/linkintegrity/handlers.py
+++ b/plone/app/linkintegrity/handlers.py
@@ -3,57 +3,30 @@
 from Acquisition import aq_parent
 from Products.Archetypes.Field import TextField
 from Products.Archetypes.interfaces import IBaseObject
-from Products.Archetypes.interfaces import IReference
-from Products.Archetypes.interfaces import IReferenceable
 from Products.CMFCore.utils import getToolByName
-from OFS.interfaces import IItem
+from Products.CMFPlone.interfaces import IPloneSiteRoot
 from ZODB.POSException import ConflictError
-from plone.app.linkintegrity.exceptions \
-    import LinkIntegrityNotificationException
-from plone.app.linkintegrity.interfaces import ILinkIntegrityInfo, IOFSImage
 from plone.app.linkintegrity.parser import extractLinks
-from plone.app.linkintegrity.references import updateReferences
+from plone.app.textfield import RichText
+from plone.app.uuid.utils import uuidToObject
+from plone.dexterity.interfaces import IDexterityContent
+from plone.dexterity.interfaces import IDexterityFTI
+from plone.dexterity.utils import getAdditionalSchemata
+from urllib import unquote
+from urlparse import urlsplit
+from z3c.relationfield import RelationValue
+from z3c.relationfield.event import _setRelation
 from zExceptions import NotFound
+from zc.relation.interfaces import ICatalog
 from zope.component import getUtility
-from zope.schema import getFieldsInOrder
-from zope.component.hooks import getSite
+from zope.component.interfaces import ComponentLookupError
+from zope.intid.interfaces import IIntIds
+from zope.keyreference.interfaces import NotYet
 from zope.publisher.interfaces import NotFound as ztkNotFound
-from urllib import unquote
-from urlparse import urlsplit
-
-# To support various Plone versions, we need to support various UUID resolvers
-# This follows Kupu, TinyMCE and plone.app.uuid methods, in a similar manner to
-# plone.outputfilters.browser.resolveuid
-try:
-    from plone.app.uuid.utils import uuidToObject
-except ImportError:
-    def uuidToObject(uuid):
-        catalog = getToolByName(getSite(), 'portal_catalog', None)
-        res = catalog and catalog.unrestrictedSearchResults(UID=uuid)
-        if res and len(res) == 1:
-            return res[0].getObject()
-
-# We try to import dexterity related modules, or modules used just if
-# dexterity is around
-try:
-    from plone.app.textfield import RichText
-    from plone.dexterity.interfaces import IDexterityFTI
-    from plone.dexterity.utils import getAdditionalSchemata
-    HAS_DEXTERITY = True
-except ImportError:
-    HAS_DEXTERITY = False
-
-
-def _resolveUID(uid):
-    res = uuidToObject(uid)
-    if res is not None:
-        return res
-    kupu_hook = getattr(getSite(), 'kupu_resolveuid_hook', None)
-    if kupu_hook is not None:
-        return kupu_hook(uid)
-    return None
-
+from zope.schema import getFieldsInOrder
+import logging
 
+logger = logging.getLogger(__name__)
 referencedRelationship = 'isReferencing'
 
 
@@ -74,7 +47,7 @@ def findObject(base, path):
     # on a view or skinscript to do this for us.
     if 'resolveuid' in components:
         uid = components[components.index('resolveuid') + 1]
-        obj = _resolveUID(uid)
+        obj = uuidToObject(uid)
         if obj:
             return obj, path
 
@@ -91,7 +64,9 @@ def findObject(base, path):
         except (AttributeError, KeyError,
                 NotFound, ztkNotFound, UnicodeEncodeError):
             return None, None
-        if not IItem.providedBy(child):
+        if not IDexterityContent.providedBy(child) and \
+                not IBaseObject.providedBy(child) and \
+                not IPloneSiteRoot.providedBy(child):
             break
         obj = child
         components.pop(0)
@@ -100,6 +75,7 @@ def findObject(base, path):
 
 def getObjectsFromLinks(base, links):
     """ determine actual objects refered to by given links """
+    intids = getUtility(IIntIds)
     objects = set()
     url = base.absolute_url()
     scheme, host, path, query, frag = urlsplit(url)
@@ -112,30 +88,16 @@ def getObjectsFromLinks(base, links):
                 path = path.encode('utf-8')
 
             obj, extra = findObject(base, path)
-            if obj:
-                if IOFSImage.providedBy(obj):
-                    # use atimage object for scaled images
-                    obj = aq_parent(obj)
-                if not IReferenceable.providedBy(obj):
-                    try:
-                        obj = IReferenceable(obj)
-                    except:
-                        continue
-                objects.add(obj)
+            if obj and not IPloneSiteRoot.providedBy(obj):
+                objid = intids.getId(obj)
+                relation = RelationValue(objid)
+                objects.add(relation)
     return objects
 
 
 def modifiedArchetype(obj, event):
     """ an archetype based object was modified """
-    pu = getToolByName(obj, 'portal_url', None)
-    if pu is None:
-        # `getObjectFromLinks` is not possible without access
-        # to `portal_url`
-        return
-    rc = getToolByName(obj, 'reference_catalog', None)
-    if rc is None:
-        # `updateReferences` is not possible without access
-        # to `reference_catalog`
+    if not check_linkintegrity_dependencies(obj):
         return
     refs = set()
     for field in obj.Schema().fields():
@@ -150,109 +112,68 @@ def modifiedArchetype(obj, event):
                 value = field.get(obj)
             links = extractLinks(value, encoding)
             refs |= getObjectsFromLinks(obj, links)
-    updateReferences(obj, referencedRelationship, refs)
+    updateReferences(obj, refs)
 
 
 def modifiedDexterity(obj, event):
     """ a dexterity based object was modified """
-    pu = getToolByName(obj, 'portal_url', None)
-    if pu is None:
-        # `getObjectFromLinks` is not possible without access
-        # to `portal_url`
-        return
-    rc = getToolByName(obj, 'reference_catalog', None)
-    if rc is None:
-        # `updateReferences` is not possible without access
-        # to `reference_catalog`
+    if not check_linkintegrity_dependencies(obj):
         return
-
     fti = getUtility(IDexterityFTI, name=obj.portal_type)
     schema = fti.lookupSchema()
     additional_schema = getAdditionalSchemata(context=obj,
                                               portal_type=obj.portal_type)
-
     schemas = [i for i in additional_schema] + [schema]
-
     refs = set()
-
     for schema in schemas:
         for name, field in getFieldsInOrder(schema):
             if isinstance(field, RichText):
                 # Only check for "RichText" ?
                 value = getattr(schema(obj), name)
-                if not value:
+                if not value or not getattr(value, 'raw', None):
                     continue
                 links = extractLinks(value.raw)
                 refs |= getObjectsFromLinks(obj, links)
-
-    updateReferences(IReferenceable(obj), referencedRelationship, refs)
-
-
-def referenceRemoved(obj, event):
-    """ store information about the removed link integrity reference """
-    assert IReference.providedBy(obj)
-    assert obj is event.object          # just making sure...
-    if not obj.relationship == referencedRelationship:
-        return                          # skip for other removed references
-    # if the object the event was fired on doesn't have a `REQUEST` attribute
-    # we can safely assume no direct user action was involved and therefore
-    # never raise a link integrity exception...
-    request = aq_get(obj, 'REQUEST', None)
-    if not request:
-        return
-    storage = ILinkIntegrityInfo(request)
-    source = obj.getSourceObject()
-    if not IBaseObject.providedBy(source) and hasattr(source, 'context'):
-        source = source.context
-    target = obj.getTargetObject()
-    if not IBaseObject.providedBy(target) and hasattr(target, 'context'):
-        target = target.context
-    if source is not None and target is not None:
-        storage.addBreach(source, target)
+    updateReferences(obj, refs)
 
 
-def referencedObjectRemoved(obj, event):
-    """ check if the removal was already confirmed or redirect to the form """
-    # if the object the event was fired on doesn't have a `REQUEST` attribute
-    # we can safely assume no direct user action was involved and therefore
-    # never raise a link integrity exception...
-    request = aq_get(obj, 'REQUEST', None)
-    if not request:
-        return
-    info = ILinkIntegrityInfo(request)
-    # first we check if link integrity checking was enabled
-    if not info.integrityCheckingEnabled():
-        return
-
-    # since the event gets called for every subobject before it's
-    # called for the item deleted directly via _delObject (event.object)
-    # itself, but we do not want to present the user with a confirmation
-    # form for every (referred) subobject, so we remember and skip them...
-    info.addDeletedItem(obj)
-    if obj is not event.object:
-        return
+def updateReferences(obj, refs):
+    """Renew all linkintegritry-references.
 
-    # if the number of expected events has been stored to help us prevent
-    # multiple forms (i.e. in folder_delete), we wait for the next event
-    # if we know there will be another...
-    if info.moreEventsToExpect():
-        return
-
-    # at this point all subobjects have been removed already, so all
-    # link integrity breaches caused by that have been collected as well;
-    # if there aren't any (after things have been cleaned up),
-    # we keep lurking in the shadows...
-    if not info.getIntegrityBreaches():
-        return
-
-    # if the user has confirmed to remove the currently handled item in a
-    # previous confirmation form we won't need it anymore this time around...
-    if info.isConfirmedItem(obj):
-        return
-
-    # otherwise we raise an exception and pass the object that is supposed
-    # to be removed as the exception value so we can use it as the context
-    # for the view triggered by the exception;  this is needed since the
-    # view is an adapter for the exception and a request, so it gets the
-    # exception object as the context, which is not very useful...
-    raise LinkIntegrityNotificationException(obj)
+    Search the zc.relation catalog for linkintegritry-references for this obj.
+    Drop them all and set the new ones.
+    TODO: Might be improved by not changing anything if the links are the same.
+    """
+    intids = getUtility(IIntIds)
+    try:
+        int_id = intids.getId(obj)
+    except KeyError:
+        # In some cases a object is not yet registered by the intid catalog
+        try:
+            int_id = intids.register(obj)
+        except NotYet:
+            return
+    catalog = getUtility(ICatalog)
+    # unpack the rels before deleting
+    old_rels = [i for i in catalog.findRelations(
+        {'from_id': int_id,
+         'from_attribute': referencedRelationship})]
+    for old_rel in old_rels:
+        catalog.unindex(old_rel)
+    for ref in refs:
+        _setRelation(obj, referencedRelationship, ref)
+
+
+def check_linkintegrity_dependencies(obj):
+    if not getToolByName(obj, 'portal_url', None):
+        # `getObjectFromLinks` is not possible without access
+        # to `portal_url`
+        return False
+    try:
+        getUtility(IIntIds)
+        getUtility(ICatalog)
+    except ComponentLookupError:
+        # Linkintegrity not possible without zope.intid-
+        # and zc.relation-catalog
+        return False
+    return True
diff --git a/plone/app/linkintegrity/httpresponse.patch b/plone/app/linkintegrity/httpresponse.patch
deleted file mode 100644
index 26bc807..0000000
--- a/plone/app/linkintegrity/httpresponse.patch
+++ /dev/null
@@ -1,37 +0,0 @@
-This patch changes the original implementation of HTTPResponse'
-retry() function so that the response instance is reused
-instead of replaced with a new one (after a Retry exception was
-raised).  This fixes a bug in zopedoctests' http() function
-(Testing/ZopeTestCase/zopedoctest/functional.py:113): the doctest code
-assumes that the HTTPResponse instance passed to publish_module() (line
-177) is used to handle to complete request, so it can be used to get the
-status, headers etc later on (lines 183-186).  Normally this is okay,
-but raising a Retry will create a new response instance, which will then
-hold that data (relevant for evaluating the doctest) while the original
-(passed in) instance is still empty.  So to fix this (quickly) retry()
-now cleans up and returns itself...
-
---- ZPublisher/HTTPResponse.py~	2006-05-30 07:08:18.000000000 +0200
-+++ ZPublisher/HTTPResponse.py	2006-09-12 19:51:52.000000000 +0200
-@@ -182,19 +182,20 @@
- 
-     def retry(self):
-         """Return a response object to be used in a retry attempt
-         """
- 
-         # This implementation is a bit lame, because it assumes that
-         # only stdout stderr were passed to the constructor. OTOH, I
-         # think that that's all that is ever passed.
- 
--        return self.__class__(stdout=self.stdout, stderr=self.stderr)
-+        self.__init__(stdout=self.stdout, stderr=self.stderr)
-+        return self
- 
-     _shutdown_flag = None
-     def _requestShutdown(self, exitCode=0):
-         """Request that the server shut down with exitCode after fulfilling
-            the current request."""
-         import ZServer
-         ZServer.exit_code = exitCode
-         self._shutdown_flag = 1
- 
diff --git a/plone/app/linkintegrity/info.py b/plone/app/linkintegrity/info.py
deleted file mode 100644
index f48423d..0000000
--- a/plone/app/linkintegrity/info.py
+++ /dev/null
@@ -1,142 +0,0 @@
-from plone.app.linkintegrity.interfaces import ILinkIntegrityInfo
-from zope.interface import implements
-from zope.component import queryUtility
-from Acquisition import aq_base
-from Products.CMFCore.interfaces import IPropertiesTool
-from zope.component import getUtility
-from plone.registry.interfaces import IRegistry
-
-try:
-    from plone.uuid.interfaces import IUUID
-    IUUID       # make pyflakes happy
-except ImportError:
-    # Archetypes-only fallback for Plone < 4.1
-    def IUUID(obj, default=None):
-        if hasattr(aq_base(obj), 'UID'):
-            return obj.UID()
-        else:
-            return default
-try:
-    from Products.CMFPlone.interfaces import IEditingSchema
-    IS_PLONE5 = True
-except ImportError:
-    IS_PLONE5 = False
-
-
-class LinkIntegrityInfo(object):
-    """ adapter for browserrequests to temporarily store information
-        related to link integrity in the request object """
-    implements(ILinkIntegrityInfo)
-
-    attribute = marker = 'link_integrity_info'
-
-    def __init__(self, context):
-        self.context = context      # the context is the request
-
-    def integrityCheckingEnabled(self):
-        """ determine if link integrity checking for the site is enabled """
-        # Plone 5 uses p.a.registry to store the enable_link_integrity setting.
-        if IS_PLONE5:
-            registry = getUtility(IRegistry)
-            settings = registry.forInterface(IEditingSchema, prefix='plone')
-            return settings.enable_link_integrity_checks
-        # Plone version < 5 store the enable_link_integrity setting in the
-        # site_properties.
-        ptool = queryUtility(IPropertiesTool)
-        enabled = False
-        if ptool is not None:
-            props = getattr(ptool, 'site_properties', None)
-            if props is not None:
-                enabled = props.getProperty(
-                    'enable_link_integrity_checks', False)
-        return enabled
-
-    def getIntegrityInfo(self):
-        """ return stored information regarding link integrity """
-        return getattr(self.context, self.attribute, {})
-
-    def setIntegrityInfo(self, info):
-        """ store information regarding link integrity """
-        setattr(self.context, self.attribute, info)
-
-    def addBreach(self, source, target):
-        """ convenience helper; see interface """
-        breaches = self.getIntegrityInfo().get('breaches', {})
-        breaches.setdefault(target, set()).add(source)
-        self.setIntegrityBreaches(breaches)
-
-    def getIntegrityBreaches(self):
-        """
-        return stored information regarding link integrity breaches.
-        The information are in the form of a dictionary, they keys are the
-        target objects relations that will be broken after a delete, the value
-        is a list of source objects pointing to the target.
-        """
-        uuids_to_delete = [IUUID(obj, None) for obj in self.getDeletedItems()]
-        uuids_to_delete = set(filter(None, uuids_to_delete))    # filter `None`
-        breaches = dict(self.getIntegrityInfo().get('breaches', {}))
-        # Do an in-place filtering of breaches, any source of a breach that
-        # is to be removed anyway does not constitute a breach
-        for target, sources in breaches.items():
-            for source in list(sources):
-                if IUUID(source) in uuids_to_delete:
-                    sources.remove(source)
-        # After the cleanup, there can be breaches to targets that have no
-        # sources left. Also, targets where we confirm the link break are not
-        # breaches any more, so we remove them too.
-        for target, sources in breaches.items():
-            if not sources or self.isConfirmedItem(target):
-                del breaches[target]
-        return breaches
-
-    def setIntegrityBreaches(self, breaches):
-        """ store information regarding link integrity breaches """
-        info = self.getIntegrityInfo()
-        info['breaches'] = breaches
-        self.setIntegrityInfo(info)     # unnecessary, but sticking to the api
-
-    def getDeletedItems(self):
-        """ return information about all items deleted during the request """
-        return self.getIntegrityInfo().get('deleted', set())
-
-    def addDeletedItem(self, item):
-        """ remember an item deleted during the request """
-        info = self.getIntegrityInfo()
-        info.setdefault('deleted', set()).add(item)
-        self.setIntegrityInfo(info)     # unnecessary, but sticking to the api
-
-    def getEnvMarker(self):
-        """ return the marker string used to pass the already confirmed
-            items across the retry exception """
-        return self.marker
-
-    def confirmedItems(self):
-        """ return internal list of confirmed items """
-        confirmed = self.context.environ.get(self.marker, [])
-        if confirmed == 'all':
-            confirmed = ['all']
-        elif confirmed:
-            s = confirmed.decode('base64')
-            # split colon-delimited list of 8-byte oids
-            confirmed = [s[i * 9:i * 9 + 8] for i in range(len(s) / 9 + 1)]
-        return confirmed
-
-    def isConfirmedItem(self, obj):
-        """ indicate if the removal of the given object was confirmed """
-        confirmed = self.confirmedItems()
-        return obj._p_oid in confirmed or 'all' in confirmed
-
-    def encodeConfirmedItems(self, additions):
-        """ return the list of previously confirmed (for removeal) items,
-            optionally adding the given items, encoded for usage in a form """
-        confirmed = self.confirmedItems()
-        for obj in additions:
-            confirmed.append(obj._p_oid)
-        return ":".join(confirmed).encode('base64')
-
-    def moreEventsToExpect(self):
-        attr = 'link_integrity_events_counter'
-        counter = getattr(self.context, attr, 0) + 1    # nr of events so far
-        setattr(self.context, attr, counter)            # save for next time
-        expected = self.context.get('link_integrity_events_to_expect', 0)
-        return counter < expected
diff --git a/plone/app/linkintegrity/interfaces.py b/plone/app/linkintegrity/interfaces.py
deleted file mode 100644
index 401850f..0000000
--- a/plone/app/linkintegrity/interfaces.py
+++ /dev/null
@@ -1,45 +0,0 @@
-from zope.interface import Interface
-
-
-class ILinkIntegrityNotificationException(Interface):
-    """ an exception indicating a prevented link integrity breach """
-
-
-class ILinkIntegrityTool(Interface):
-    """ interface of link integrity tool """
-
-
-class ILinkIntegrityInfo(Interface):
-    """ a place to store information about link integrity, i.e. breaches;
-        the storage is assumed to be unique per browser request """
-
-    def addBreach(source, target):
-        """ add information about an integrity breach, i.e. an indicator
-            that `source` object somehow references `target` """
-
-    def getIntegrityBreaches():
-        """ return stored information regarding link integrity breaches """
-
-    def setIntegrityBreaches(breaches):
-        """ store information regarding link integrity breaches """
-
-    def getDeletedItems():
-        """ return information about all items deleted during the request """
-
-    def addDeletedItem(item):
-        """ remember an item deleted during the request """
-
-    def getEnvMarker():
-        """ return the marker string used to pass the already confirmed
-            items across the retry exception """
-
-    def isConfirmedItem(obj):
-        """ indicate if the removal of the given object was confirmed """
-
-    def encodeConfirmedItems(additions):
-        """ return the list of previously confirmed (for removeal) items,
-            optionally adding the given items, encoded for usage in a form """
-
-
-class IOFSImage(Interface):
-    """ interface for OFS.Image.Image """
diff --git a/plone/app/linkintegrity/monkey.py b/plone/app/linkintegrity/monkey.py
deleted file mode 100644
index ccc2df7..0000000
--- a/plone/app/linkintegrity/monkey.py
+++ /dev/null
@@ -1,56 +0,0 @@
-# the following code is "stolen" from (or maybe it was inspired by? :))
-# FiveException (http://codespeak.net/svn/z3/FiveException)
-
-from Zope2.App.startup import zpublisher_exception_hook
-from ZPublisher.Publish import Retry
-from ZPublisher.Publish import get_module_info
-
-
-def zpublisher_exception_hook_wrapper(published, REQUEST, t, v, traceback):
-    """ wrapper around the zope2 zpublisher's error hook """
-    try:
-        # if we got a retry exception, we just propagate it instead of
-        # trying to log it (like FiveException does)
-        if t is Retry:
-            v.reraise()
-        return zpublisher_exception_hook(published, REQUEST, t, v, traceback)
-    finally:
-        traceback = None
-
-
-def proxy_get_module_info(*args, **kwargs):
-    results = list(get_module_info(*args, **kwargs))
-    if results[5] is zpublisher_exception_hook:
-        results[5] = zpublisher_exception_hook_wrapper
-    return tuple(results)
-
-
-def installExceptionHook():
-    import ZPublisher.Publish
-    ZPublisher.Publish.get_module_info = proxy_get_module_info
-
-
-def installStatusCode():
-    from ZPublisher import HTTPResponse
-    HTTPResponse.status_codes['linkintegritynotificationexception'] = 200
-
-
-def retry(self):
-    """ re-initialize a response object to be used in a retry attempt """
-    # this implementation changes the original one so that the response
-    # instance is reused instead of replaced with a new one (after a Retry
-    # exception was raised);  this fixes a bug in zopedoctests' http()
-    # function (Testing/ZopeTestCase/zopedoctest/functional.py:113);
-    # the doctest code assumes that the HTTPResponse instance passed to
-    # publish_module() (line 177) is used to handle to complete request, so
-    # it can be used to get the status, headers etc later on (lines 183-186);
-    # normally this is okay, but raising a Retry will create a new response
-    # instance, which will then hold that data (relevant for evaluating the
-    # doctest) while the original (passed in) instance is still empty...
-    #
-    # so to fix this (quickly) retry() now cleans up and returns itself:
-    self.__init__(stdout=self.stdout, stderr=self.stderr)
-    return self
-
-from ZPublisher.HTTPResponse import HTTPResponse
-HTTPResponse.retry = retry
diff --git a/plone/app/linkintegrity/monkey2.py b/plone/app/linkintegrity/monkey2.py
deleted file mode 100644
index a8eca65..0000000
--- a/plone/app/linkintegrity/monkey2.py
+++ /dev/null
@@ -1,21 +0,0 @@
-
-import OFS.ObjectManager
-
-original = OFS.ObjectManager.ObjectManager.manage_delObjects
-# FIXME: Plone needs an api in core
-# Rationale for thix patch:
-# Linkintegrity needs to know how many things get deleted. There is no
-# event for that and plone does not use its own delete method, just the
-# plain zope method. So far, linkintegrity modified Script (Python) objects
-# to store the information, but we want to get rid of this. Then the only
-# way to add this information is by patching the canonical delete method
-# which is manage_delObjects
-
-def manage_delObjects(self, ids=None, REQUEST=None):
-    """Checking for docstrings as a security constraint is a very clever idea
-    """
-    if REQUEST is not None and not isinstance(ids, basestring):
-        REQUEST.set('link_integrity_events_to_expect', len(ids))
-    return original(self, ids, REQUEST)
-
-OFS.ObjectManager.ObjectManager.manage_delObjects = manage_delObjects
diff --git a/plone/app/linkintegrity/profiles/default/metadata.xml b/plone/app/linkintegrity/profiles/default/metadata.xml
new file mode 100644
index 0000000..3d93a8e
--- /dev/null
+++ b/plone/app/linkintegrity/profiles/default/metadata.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0"?>
+<metadata>
+  <version>1000</version>
+  <dependencies>
+    <dependency>profile-plone.app.intid:default</dependency>
+    <dependency>profile-plone.app.relationfield:default</dependency>
+  </dependencies>
+</metadata>
diff --git a/plone/app/linkintegrity/profiles/default/ploneapplinkintegrity_default.txt b/plone/app/linkintegrity/profiles/default/ploneapplinkintegrity_default.txt
new file mode 100644
index 0000000..e69de29
diff --git a/plone/app/linkintegrity/references.py b/plone/app/linkintegrity/references.py
deleted file mode 100644
index 24c54a5..0000000
--- a/plone/app/linkintegrity/references.py
+++ /dev/null
@@ -1,79 +0,0 @@
-# helpers related to reference handling
-#
-# the following functions can prove helpful outside of `p.a.linkintegrity`,
-# but they should really be integrated into `Archetypes` before anybody
-# starts using them.  so for now they are provided as a convenience for
-# the `plone.app.referenceintegrity` package, but other than that please
-# bear in mind the gently reminder that...
-#
-#	NOBODY ELSE SHOULD IMPORT FROM HERE!!!
-#
-# you have been warned! :)
-
-from OFS.interfaces import IItem
-from Products.Archetypes.exceptions import ReferenceException
-from Products.Archetypes.interfaces import IBaseObject
-from Products.CMFCore.utils import getToolByName
-from ZODB.POSException import ConflictError
-from logging import getLogger
-
-
-def updateReferences(obj, relationship, newrefs):
-
-    # This for sure looks ugly, but is necessary to maintian AT compatibility
-    # newrefs are wrapped objects, but getRefreences returns the real objects
-    # to generate a difference, we must do the difference with the objects
-    # the adapters wrapped. This is what real_newrefs is about
-    # next, when adding references, we have to provide the wrapped object
-    # again, so we create a mapping, newref_r_a_mapping to get the
-    # wrapped object.
-
-    real_newrefs = set()
-    newref_r_a_mapping = {}
-    for newref in newrefs:
-        # Checking for IItem is a hack to check wether this reference
-        # is an adapter or a real object. Real Objects from AT are IItem
-        if not IItem.providedBy(newref):
-            real_newrefs.add(newref.context)
-            newref_r_a_mapping[newref.context] = newref
-        else:
-            real_newrefs.add(newref)
-
-    existing = set(obj.getReferences(relationship=relationship))
-
-    for ref in real_newrefs.difference(existing):   # add new references and...
-        try:
-            obj.addReference(newref_r_a_mapping.get(ref, ref), 
-                             relationship=relationship)
-        except (ReferenceException, AttributeError):
-            pass
-    for ref in existing.difference(real_newrefs):   # removed leftovers
-        try:
-            obj.deleteReference(newref_r_a_mapping.get(ref, ref),
-                                relationship=relationship)
-        except ReferenceException:
-            removeDanglingReference(obj, relationship)
-
-
-def removeDanglingReference(obj, relationship):
-    # try to get rid of the dangling reference, but let's not
-    # have this attempt to clean up break things otherwise...
-    # iow, the `try..except` is there, because internal methods
-    # of the reference catalog are being used directly here.  any
-    # changes regarding these shouldn't break things over here,
-    # though...
-    try:
-        if not IBaseObject.providedBy(obj) and hasattr(obj, 'context'):
-            refcat = getToolByName(obj.context, 'reference_catalog')
-        else:
-            refcat = getToolByName(obj, 'reference_catalog')
-        uid, dummy = refcat._uidFor(obj)
-        brains = refcat._queryFor(uid, None, relationship=relationship)
-        objs = refcat._resolveBrains(brains)
-        for obj in objs:
-            refcat._deleteReference(obj)
-    except ConflictError:
-        raise
-    except:
-        getLogger(__name__).warning('dangling "linkintegrity" '
-            'reference to %r could not be removed.', obj)
diff --git a/plone/app/linkintegrity/testing.py b/plone/app/linkintegrity/testing.py
index 227491e..75506a8 100644
--- a/plone/app/linkintegrity/testing.py
+++ b/plone/app/linkintegrity/testing.py
@@ -11,7 +11,6 @@
 from plone.app.testing import TEST_USER_ID
 from plone.app.testing import TEST_USER_NAME
 from plone.app.testing import TEST_USER_PASSWORD
-from plone.app.testing import applyProfile
 from plone.app.testing import layers
 from plone.app.testing import login
 from plone.app.testing import ploneSite
@@ -56,7 +55,6 @@ def setUpMembers(self, portal):
 
     def setUpContent(self):
         import plone.app.linkintegrity
-
         xmlconfig.file('configure.zcml', plone.app.linkintegrity,
                        context=self['configurationContext'])
 
@@ -112,27 +110,8 @@ class LinkIntegrityDXLayer(LinkIntegrityLayer):
         PLONE_APP_CONTENTTYPES_FIXTURE,
         PLONE_APP_LINKINTEGRITY_FIXTURE,
     )
-    types_providing_referencable_behavior = set([
-        'Folder',
-        'Image',
-        'File',
-        'Document',
-    ])
 
     def setUp(self):
-        with ploneSite() as portal:
-            ttool = getToolByName(portal, 'portal_types')
-            for type_info in self.types_providing_referencable_behavior:
-                ttool.getTypeInfo(type_info).behaviors += (
-                    'plone.app.relationfield.behavior.IRelatedItems',
-                    'plone.app.referenceablebehavior.referenceable.IReferenceable',  # noqa
-                )
-
-            # FIXME: we need uid_catalog and referencer_catalog to keep
-            #        plone.app.referencebehavior working. So load Archetypes
-            #        profile to install those tools before we continue
-            applyProfile(portal, 'Products.Archetypes:Archetypes')
-
         self.setUpContent()
 
     def setUpContent(self):
diff --git a/plone/app/linkintegrity/tests/test_circular.py b/plone/app/linkintegrity/tests/test_circular.py
index c3c7f59..2005843 100644
--- a/plone/app/linkintegrity/tests/test_circular.py
+++ b/plone/app/linkintegrity/tests/test_circular.py
@@ -1,62 +1,85 @@
 # -*- coding: utf-8 -*-
-from Products.Archetypes.interfaces import IReferenceable
-from plone.app.linkintegrity import exceptions
-from plone.app.linkintegrity import testing
+from plone.app.linkintegrity.testing import create
 from plone.app.linkintegrity.tests.base import ATBaseTestCase
 from plone.app.linkintegrity.tests.base import DXBaseTestCase
-
-import transaction
+from plone.app.linkintegrity.utils import hasIncomingLinks
+from plone.app.linkintegrity.utils import getOutgoingLinks
+from plone.app.linkintegrity.browser.info import DeleteConfirmationInfo
 
 
 class CircularReferencesTestCase:
 
-    def test_circular_reference_deletion(self):
+    def test_circular_reference_manages_relations(self):
         doc1 = self.portal['doc1']
         doc2 = self.portal['doc2']
         doc3 = self.portal['doc3']
+        self.assertFalse(hasIncomingLinks(doc1))
+        self.assertFalse(hasIncomingLinks(doc2))
+        self.assertFalse(hasIncomingLinks(doc3))
         self._set_text(doc1, '<a href="doc2">doc2</a>')
         self._set_text(doc2, '<a href="doc3">doc3</a>')
         self._set_text(doc3, '<a href="doc1">doc1</a>')
-        self.assertRaises(
-            exceptions.LinkIntegrityNotificationException,
-            self.portal.manage_delObjects, ['doc1'], self.request
-        )
-        transaction.abort()
-
-        self.portal.manage_delObjects(
-            ['doc1', 'doc2', 'doc3'], self.request)
-        self.assertNotIn('doc1', self.portal)
-        self.assertNotIn('doc2', self.portal)
-        self.assertNotIn('doc3', self.portal)
+        self.assertTrue(hasIncomingLinks(doc1))
+        self.assertTrue(hasIncomingLinks(doc2))
+        self.assertTrue(hasIncomingLinks(doc3))
 
     def test_circular_reference_subfolder_deletion(self):
         doc1 = self.portal.doc1
         doc2 = self.portal.doc2
+        doc3 = self.portal.doc3
         doc4 = self.portal.folder1.doc4
+        folder1 = self.portal.folder1
 
-        # This tests the behaviour when removing three object
-        # referencing each other in a circle.  This situation cannot be
-        # resolved completely, since the removal events are fired
-        # separately.  However, the circle gets "broken up" when
-        # confirming the removal of the first object, and no further
-        # confirmation form are necessary:
+        # This tests the behaviour when removing objects
+        # referencing each other in a circle.
         self._set_text(doc1, '<a href="doc2">documents...</a>')
-        self._set_text(doc2, '<a href="folder1/doc4">linking...</a>')
+        self._set_text(doc2, '<a href="doc3">go round...</a>')
+        self._set_text(doc3, '<a href="folder1/doc4">and round.</a>')
         self._set_text(doc4, '<a href="../doc1">in circles.</a>')
-        self.assertEqual(IReferenceable(doc1).getReferences(), [doc2, ])
-        self.assertEqual(IReferenceable(doc2).getReferences(), [doc4, ])
-        self.assertEqual(IReferenceable(doc4).getReferences(), [doc1, ])
 
-        self.assertRaises(exceptions.LinkIntegrityNotificationException,
-            self.portal.manage_delObjects, ['doc1', 'doc2', ], self.request)
-        transaction.abort()
+        self.assertEqual([r.to_object for r in getOutgoingLinks(doc1)], [doc2])
+        self.assertEqual([r.to_object for r in getOutgoingLinks(doc2)], [doc3])
+        self.assertEqual([r.to_object for r in getOutgoingLinks(doc3)], [doc4])
+        self.assertEqual([r.to_object for r in getOutgoingLinks(doc4)], [doc1])
+
+        view = DeleteConfirmationInfo(self.portal, self.request)
+        self.assertEqual(len(view.get_breaches([folder1])), 1)
+        self.assertEqual(len(view.get_breaches([doc1, doc2, doc3, folder1])), 0)
+        self.assertEqual(len(view.get_breaches([doc2, folder1])), 2)
+
+    def test_internal_breaches_are_dropped(self):
+        folder1 = self.portal.folder1
+        create(folder1, 'Document', id='doc5', title='Test Page 5')
+        doc1 = self.portal.doc1
+        doc4 = self.portal.folder1.doc4
+        doc5 = self.portal.folder1.doc5
+        self._set_text(doc1, '<a href="folder1">f1</a>')
+        self._set_text(doc4, '<a href="doc5">d5</a><a href="../doc1">d1</a>')
+        self._set_text(doc5, '<a href="../folder1">f1</a>')
 
-        self.portal.manage_delObjects(
-            ['doc1', 'doc2', 'folder1', ], self.request)
+        doc4_breaches = set([r.to_object for r in getOutgoingLinks(doc4)])
+        # the order of breaches is non-deterministic
+        self.assertEqual(set([doc1, doc5]), doc4_breaches)
+        self.assertEqual(
+            [r.to_object for r in getOutgoingLinks(doc5)], [folder1])
+        self.assertEqual(
+            [r.to_object for r in getOutgoingLinks(doc1)], [folder1])
+        view = DeleteConfirmationInfo(self.portal, self.request)
+        self.assertEqual(len(view.get_breaches([doc4])), 0)
+        self.assertEqual(len(view.get_breaches([doc5])), 1)
+        self.assertEqual(len(view.get_breaches([doc4, doc5])), 0)
+        self.assertEqual(len(view.get_breaches([folder1])), 1)
+        self.assertEqual(len(view.get_breaches([doc1])), 1)
+        self.assertEqual(len(view.get_breaches([doc1, folder1])), 0)
 
-        self.assertNotIn('doc1', self.portal)
-        self.assertNotIn('doc2', self.portal)
-        self.assertNotIn('folder1', self.portal)
+        view = folder1.restrictedTraverse('delete_confirmation')
+        self.assertIn('Potential link breakage', view())
+        view = folder1.restrictedTraverse('delete_confirmation_info')
+        self.assertIn('Potential link breakage', view())
+        view = doc4.restrictedTraverse('delete_confirmation')
+        self.assertNotIn('Potential link breakage', view())
+        view = doc4.restrictedTraverse('delete_confirmation_info')
+        self.assertNotIn('Potential link breakage', view())
 
 
 class CircularReferencesDXTestCase(DXBaseTestCase, CircularReferencesTestCase):
diff --git a/plone/app/linkintegrity/tests/test_doctests.py b/plone/app/linkintegrity/tests/test_doctests.py
deleted file mode 100644
index fb0f635..0000000
--- a/plone/app/linkintegrity/tests/test_doctests.py
+++ /dev/null
@@ -1,43 +0,0 @@
-# -*- coding:utf-8 -*-
-from plone.testing import layered
-from plone.app.linkintegrity import testing
-
-import doctest
-import os
-import re
-import unittest2
-
-OPTIONFLAGS = (doctest.REPORT_ONLY_FIRST_FAILURE |
-               doctest.ELLIPSIS |
-               doctest.NORMALIZE_WHITESPACE)
-
-pattern = re.compile('^test.*\.(txt|rst)$')
-
-
-def test_suite():
-    tests = []
-    for layer in (testing.PLONE_APP_LINKINTEGRITY_AT_FUNCTIONAL_TESTING,
-                  testing.PLONE_APP_LINKINTEGRITY_DX_FUNCTIONAL_TESTING):
-
-        test_directory = layer.__bases__[-1].directory
-        path = os.path.join(os.path.dirname(testing.__file__),
-                            test_directory, 'tests')
-
-        # Skip non-existing directories
-        if not os.path.isdir(path):
-            continue
-
-        for name in os.listdir(path):
-            if pattern.search(name):
-                tests.append(
-                    layered(
-                        doctest.DocFileSuite(
-                            '{0:s}/tests/{1:s}'.format(test_directory, name),
-                            package='plone.app.linkintegrity',
-                            optionflags=OPTIONFLAGS,
-                        ),
-                        layer=layer
-                    )
-                )
-
-    return unittest2.TestSuite(tests)
diff --git a/plone/app/linkintegrity/tests/test_functional.py b/plone/app/linkintegrity/tests/test_functional.py
index 04259a0..a1fbf36 100644
--- a/plone/app/linkintegrity/tests/test_functional.py
+++ b/plone/app/linkintegrity/tests/test_functional.py
@@ -1,9 +1,13 @@
 # -*- coding: utf-8 -*-
-from Products.Archetypes.interfaces import IReferenceable
 from Products.CMFPlone.interfaces import IEditingSchema
 
+from zc.relation.interfaces import ICatalog
 from plone.app.linkintegrity import testing
-from plone.app.linkintegrity import exceptions
+from plone.app.linkintegrity.utils import getIncomingLinks
+# from plone.app.linkintegrity.utils import hasIncomingLinks
+from plone.app.linkintegrity.utils import getOutgoingLinks
+from plone.app.linkintegrity.utils import hasOutgoingLinks
+
 from plone.app.linkintegrity.tests.base import ATBaseTestCase
 from plone.app.linkintegrity.tests.base import DXBaseTestCase
 from plone.app.testing import TEST_USER_NAME
@@ -12,37 +16,21 @@
 from plone.registry.interfaces import IRegistry
 from zope.component import getUtility
 
-
 import transaction
+import unittest2 as unittest
 
 
 class ReferenceTestCase:
 
-    def test_file_reference_throws_exception(self):
-        """This tests the behaviour when removing a referenced file."""
-
-        doc1 = self.portal.doc1
-        file2 = testing.create(self.portal, 'File',
-                               id='file2', file=testing.GIF)
-
-        self._set_text(doc1, '<a href="file2">A File</a>')
-        self.assertEqual(IReferenceable(doc1).getReferences(), [file2])
-        self.assertIn('file2', self.portal.objectIds())
-
-        token = self._get_token(file2)
-        self.request['_authenticator'] = token
-
-        # Throws exception which actually should abort transaction
-        view = file2.restrictedTraverse('@@object_delete')
-        self.assertRaises(exceptions.LinkIntegrityNotificationException, view)
-
+    @unittest.skip('Re-enable after https://github.com/plone/plone.app.content/issues/38')  # noqa
     def test_file_reference_linkintegrity_page_is_shown(self):
         doc1 = self.portal.doc1
         file2 = testing.create(self.portal, 'File',
                                id='file2', file=testing.GIF)
 
+        self.assertFalse(hasOutgoingLinks(doc1))
         self._set_text(doc1, '<a href="file2">A File</a>')
-        self.assertEqual(IReferenceable(doc1).getReferences(), [file2])
+        self.assertTrue(hasOutgoingLinks(doc1))
         self.assertIn('file2', self.portal.objectIds())
 
         token = self._get_token(file2)
@@ -56,7 +44,7 @@ def test_file_reference_linkintegrity_page_is_shown(self):
             'Authorization',
             'Basic {0:s}:{1:s}'.format(TEST_USER_NAME, TEST_USER_PASSWORD))
 
-        delete_url = '{0:s}/object_delete?_authenticator={1:s}'.format(
+        delete_url = '{0:s}/delete_confirmation?_authenticator={1:s}'.format(
             file2.absolute_url(), token)
 
         # Try to remove but cancel
@@ -64,21 +52,23 @@ def test_file_reference_linkintegrity_page_is_shown(self):
 
         # Validate text
         self.assertIn('Potential link breakage', self.browser.contents)
-        self.assertIn('removeConfirmationAction', self.browser.contents)
         self.assertIn('<a href="http://nohost/plone/doc1">Test Page 1</a>',
                       self.browser.contents)
         self.assertIn('Would you like to delete it anyway?',
                       self.browser.contents)
 
         # Click cancel button, item should stay in place
-        self.browser.getControl(name='cancel').click()
-        self.assertEqual(self.browser.url, self.portal.absolute_url())
+        # FIXME! This fails in Archetypes because the redirect
+        # plone.app.content.browser.actions.DeleteConfirmationForm.handle_cancel
+        # is broken for AT-content.
+        self.browser.getControl(name='form.buttons.Cancel').click()
+        self.assertEqual(self.browser.url, file2.absolute_url() + '/view')
         self.assertIn('Removal cancelled.', self.browser.contents)
         self.assertIn('file2', self.portal.objectIds())
 
         # Try to remove and confirm
         self.browser.open(delete_url)
-        self.browser.getControl(name='delete').click()
+        self.browser.getControl(name='form.buttons.Delete').click()
         self.assertNotIn('file2', self.portal.objectIds())
 
     def test_unreferenced_removal(self):
@@ -104,7 +94,8 @@ def test_renaming_referenced_item(self):
         # renamed (see the related bug report in #6608).  First we need
         # to create the necessary links:
         self._set_text(doc1, '<a href="doc2">doc2</a>')
-        self.assertEqual(IReferenceable(doc2).getBackReferences(), [doc1])
+        self.assertEqual(
+            [i.from_object for i in getIncomingLinks(doc2)], [doc1])
 
         # Make changes visible to testbrowseropen
         transaction.commit()
@@ -121,20 +112,20 @@ def test_renaming_referenced_item(self):
 
         self.assertNotIn('doc1', self.portal.objectIds())
         self.assertIn('nuname', self.portal.objectIds())
-        self.assertEqual(IReferenceable(doc2).getBackReferences(), [doc1])
+        self.assertIn(doc1, [i.from_object for i in getIncomingLinks(doc2)])
 
         # We simply use a browser to try to delete a content item.
         self.browser.open(doc2.absolute_url())
         self.browser.getLink('Delete').click()
         self.assertIn(
             'Do you really want to delete this item?', self.browser.contents)
-        self.browser.getControl(name='form.buttons.Delete').click()
         self.assertIn('nuname', self.portal.objectIds())
-
         # Link breakabe page should be shown
         self.assertIn('Potential link breakage', self.browser.contents)
         self.assertIn('<a href="http://nohost/plone/nuname">Test Page 1</a>',
                       self.browser.contents)
+        self.browser.getControl(name='form.buttons.Delete').click()
+        self.assertNotIn('doc2', self.portal.objectIds())
 
     def test_removal_in_subfolder(self):
         doc1 = self.portal.doc1
@@ -155,14 +146,14 @@ def test_removal_in_subfolder(self):
         # throw.
         self.browser.handleErrors = True
 
-        self.browser.open('{0:s}/object_delete?_authenticator={1:s}'.format(
+        self.browser.open('{0:s}/delete_confirmation?_authenticator={1:s}'.format(
             folder1.absolute_url(), self._get_token(folder1)))
         self.assertIn('Potential link breakage', self.browser.contents)
         self.assertIn('<a href="http://nohost/plone/doc1">Test Page 1</a>',
                       self.browser.contents)
         self.assertIn('<a href="http://nohost/plone/doc2">Test Page 2</a>',
                       self.browser.contents)
-        self.browser.getControl(name='delete').click()
+        self.browser.getControl(name='form.buttons.Delete').click()
         self.assertNotIn('folder1', self.portal.objectIds())
 
     def test_removal_with_cookie_auth(self):
@@ -194,12 +185,12 @@ def test_removal_with_cookie_auth(self):
 
         # This should lead us back to the "folder contents" listing,
         # where we try to delete the referenced document.
-        browser.open('{0:s}/object_delete?_authenticator={1:s}'.format(
+        browser.open('{0:s}/delete_confirmation?_authenticator={1:s}'.format(
             doc2.absolute_url(), self._get_token(doc2)))
         self.assertIn('Potential link breakage', browser.contents)
         self.assertIn('<a href="http://nohost/plone/doc1">Test Page 1</a>',
                       browser.contents)
-        browser.getControl(name='delete').click()
+        browser.getControl(name='form.buttons.Delete').click()
         self.assertNotIn('doc2', self.portal.objectIds())
 
     def test_linkintegrity_on_off_switch(self):
@@ -216,7 +207,7 @@ def test_linkintegrity_on_off_switch(self):
         # the exception we intentionally throw.
         self.browser.handleErrors = True
 
-        self.browser.open('{0:s}/object_delete?_authenticator={1:s}'.format(
+        self.browser.open('{0:s}/delete_confirmation?_authenticator={1:s}'.format(
             doc2.absolute_url(), self._get_token(doc2)))
         self.assertIn('Potential link breakage', self.browser.contents)
         self.assertIn('<a href="http://nohost/plone/doc1">Test Page 1</a>',
@@ -229,9 +220,7 @@ def test_linkintegrity_on_off_switch(self):
         settings.enable_link_integrity_checks = False
         transaction.commit()
         self.browser.reload()
-        self.assertEqual(self.browser.url, self.portal.absolute_url())
-        self.assertIn('Test Page 2 has been deleted.', self.browser.contents)
-        self.assertNotIn('doc2', self.portal.objectIds())
+        self.assertNotIn('Potential link breakage', self.browser.contents)
 
     def test_update(self):
         doc1 = self.portal.doc1
@@ -242,13 +231,16 @@ def test_update(self):
         # i.e. after migrating from a previous version.
         self._set_text(doc1, '<a href="doc2">a document</a>')
         self._set_text(doc2, '<a href="folder1/doc4">a document</a>')
-        IReferenceable(doc1).deleteReferences(relationship='isReferencing')
-        IReferenceable(doc2).deleteReferences(relationship='isReferencing')
+
+        catalog = getUtility(ICatalog)
+        rels = [i for i in catalog.findRelations()]
+        for rel in rels:
+            catalog.unindex(rel)
 
         # Just to make sure, we check that there are no references from or to
         # these documents at this point:
-        self.assertEqual(IReferenceable(doc1).getReferences(), [])
-        self.assertEqual(IReferenceable(doc2).getReferences(), [])
+        self.assertEqual([i.to_object for i in getOutgoingLinks(doc1)], [])
+        self.assertEqual([i.to_object for i in getOutgoingLinks(doc2)], [])
 
         # An update of link integrity information for all content is triggered
         # by browsing a specific url:
@@ -261,8 +253,8 @@ def test_update(self):
 
         # Now the linking documents should hold the correct link integrity
         # references:
-        self.assertEqual(IReferenceable(doc1).getReferences(), [doc2, ])
-        self.assertEqual(IReferenceable(doc2).getReferences(), [doc4, ])
+        self.assertEqual([i.to_object for i in getOutgoingLinks(doc1)], [doc2, ])
+        self.assertEqual([i.to_object for i in getOutgoingLinks(doc2)], [doc4, ])
 
     def test_references_on_cloned_objects(self):
         doc1 = self.portal.doc1
@@ -289,7 +281,7 @@ def test_references_on_cloned_objects(self):
 
         # Now we can continue and "click" the "delete" action. The confirmation
         # page should list both documents:
-        self.browser.open('{0:s}/object_delete?_authenticator={1:s}'.format(
+        self.browser.open('{0:s}/delete_confirmation?_authenticator={1:s}'.format(
             doc2.absolute_url(), self._get_token(doc2)))
         self.assertIn(
             'is referenced by the following items:', self.browser.contents)
@@ -317,7 +309,8 @@ def test_files_with_spaces_removal(self):
         self._set_text(doc1, '<a href="some spaces.doc">a document</a>')
 
         # The document should now have a reference to the file:
-        self.assertEqual(IReferenceable(doc1).getReferences(), [spaces1])
+        self.assertEqual(
+            [i.to_object for i in getOutgoingLinks(doc1)], [spaces1])
         transaction.commit()
 
         # Then we use a browser to try to delete the referenced file.
@@ -325,24 +318,25 @@ def test_files_with_spaces_removal(self):
         # from choking on the exception we intentionally throw.
         self.browser.handleErrors = True
 
-        self.browser.open('{0:s}/object_delete?_authenticator={1:s}'.format(
+        self.browser.open('{0:s}/delete_confirmation?_authenticator={1:s}'.format(
             spaces1.absolute_url(), self._get_token(spaces1)))
         self.assertIn('Potential link breakage', self.browser.contents)
         self.assertIn(
             '<a href="http://nohost/plone/doc1">Test Page 1</a>',
             self.browser.contents
         )
-        self.browser.getControl(name='delete').click()
+        self.browser.getControl(name='form.buttons.Delete').click()
         self.assertNotIn('some spaces.doc', self.portal.objectIds())
 
     def test_removal_via_zmi(self):
+        """Delete via ZMI is no longer protedted!"""
         doc1 = self.portal.doc1
         doc2 = self.portal.doc2
 
         # This tests ensuring link integrity when removing an object via
         # the ZMI.
         self._set_text(doc1, '<a href="doc2">a document</a>')
-        self.assertEqual(IReferenceable(doc1).getReferences(), [doc2])
+        self.assertEqual([i.to_object for i in getOutgoingLinks(doc1)], [doc2])
 
         transaction.commit()
         # Then we use a browser to try to delete the referenced
@@ -356,15 +350,6 @@ def test_removal_via_zmi(self):
             .getControl(value='doc2').selected = True
 
         self.browser.getControl('Delete').click()
-        self.assertIn('Potential link breakage', self.browser.contents)
-        self.assertIn(
-            '<a href="http://nohost/plone/doc1">Test Page 1</a>',
-            self.browser.contents
-        )
-
-        # After we have acknowledged the breach in link integrity the
-        # document should have been deleted:
-        self.browser.getControl(name='delete').click()
         self.assertNotIn('doc2', self.portal.objectIds())
 
 
diff --git a/plone/app/linkintegrity/tests/test_imagescales.py b/plone/app/linkintegrity/tests/test_imagescales.py
index b1f9110..85b7610 100644
--- a/plone/app/linkintegrity/tests/test_imagescales.py
+++ b/plone/app/linkintegrity/tests/test_imagescales.py
@@ -1,7 +1,8 @@
 # -*- coding: utf-8 -*-
-from Products.Archetypes.interfaces import IReferenceable
 from plone.app.linkintegrity.tests.base import ATBaseTestCase
 from plone.app.linkintegrity.tests.base import DXBaseTestCase
+from plone.app.linkintegrity.utils import getOutgoingLinks
+from plone.app.linkintegrity.utils import getIncomingLinks
 from plone.uuid.interfaces import IUUID
 
 
@@ -17,10 +18,10 @@ def test_image_tag_reference_creation(self):
         # should create references between those objects on save.
         self._set_text(doc1, img1.restrictedTraverse('@@images').tag())
 
-        self.assertEqual(IReferenceable(doc1).getReferences(), [img1])
-        self.assertEqual(IReferenceable(doc1).getBackReferences(), [])
-        self.assertEqual(IReferenceable(img1).getReferences(), [])
-        self.assertEqual(IReferenceable(img1).getBackReferences(), [doc1])
+        self.assertEqual([r.to_object for r in getOutgoingLinks(doc1)], [img1, ])
+        self.assertEqual([r.to_object for r in getIncomingLinks(doc1)], [])
+        self.assertEqual([r.to_object for r in getOutgoingLinks(img1)], [])
+        self.assertEqual([r.from_object for r in getIncomingLinks(img1)], [doc1])
 
     def test_image_scale_reference_creation(self):
         doc1 = self.portal.doc1
@@ -29,8 +30,8 @@ def test_image_scale_reference_creation(self):
         # Linking image scales should also work:
         self._set_text(
             doc1, '<a href="image1/@@images/image_thumb">an image</a>')
-        self.assertEqual(IReferenceable(doc1).getReferences(), [img1])
-        self.assertEqual(IReferenceable(img1).getBackReferences(), [doc1])
+        self.assertEqual([r.to_object for r in getOutgoingLinks(doc1)], [img1, ])
+        self.assertEqual([r.from_object for r in getIncomingLinks(img1)], [doc1, ])
 
     def test_image_resolveuid_reference_creation(self):
         doc1 = self.portal.doc1
@@ -39,9 +40,8 @@ def test_image_resolveuid_reference_creation(self):
         # Linking via the "resolveuid/UID" method should also work:
         self._set_text(doc1, '<a href="resolveuid/{0:s}">an image</a>'.format(
             IUUID(img1)))
-
-        self.assertEqual(IReferenceable(doc1).getReferences(), [img1])
-        self.assertEqual(IReferenceable(img1).getBackReferences(), [doc1])
+        self.assertEqual([r.to_object for r in getOutgoingLinks(doc1)], [img1, ])
+        self.assertEqual([r.from_object for r in getIncomingLinks(img1)], [doc1, ])
 
 
 class ImageReferenceDXTestCase(DXBaseTestCase, ImageReferenceTestCase):
diff --git a/plone/app/linkintegrity/tests/test_info.py b/plone/app/linkintegrity/tests/test_info.py
deleted file mode 100644
index a53680a..0000000
--- a/plone/app/linkintegrity/tests/test_info.py
+++ /dev/null
@@ -1,18 +0,0 @@
-# -*- coding: utf-8 -*-
-import unittest
-
-
-class TestLinkIntegrityInfo(unittest.TestCase):
-
-    def test_confirmedItems_decodes_oids_with_colons(self):
-        oid1 = '\x00' * 8
-        oid2 = ':' * 8
-        info = ('%s:%s' % (oid1, oid2)).encode('base64')
-
-        class DummyContext(object):
-            environ = {'link_integrity_info': info}
-
-        from plone.app.linkintegrity.info import LinkIntegrityInfo
-        info = LinkIntegrityInfo(DummyContext())
-        confirmed = info.confirmedItems()
-        self.assertEqual(2, len(confirmed))
diff --git a/plone/app/linkintegrity/tests/test_references.py b/plone/app/linkintegrity/tests/test_references.py
index 7f53a57..7299d70 100644
--- a/plone/app/linkintegrity/tests/test_references.py
+++ b/plone/app/linkintegrity/tests/test_references.py
@@ -1,28 +1,25 @@
 # -*- coding: utf-8 -*-
-from Products.Archetypes.interfaces import IReferenceable
 from plone.app.linkintegrity import testing
-from plone.app.testing import logout
-from plone.app.testing import login
-from plone.app.linkintegrity import exceptions
 from plone.app.linkintegrity.parser import extractLinks
 from plone.app.linkintegrity.tests.base import ATBaseTestCase
 from plone.app.linkintegrity.tests.base import DXBaseTestCase
+from plone.app.linkintegrity.utils import hasIncomingLinks
+from plone.app.linkintegrity.utils import hasOutgoingLinks
+from plone.app.linkintegrity.utils import getIncomingLinks
+from plone.app.linkintegrity.utils import getOutgoingLinks
+from plone.app.testing import login
+from plone.app.testing import logout
+from plone.app.testing import TEST_USER_NAME
+from zope.lifecycleevent import modified
 
 
 class ReferenceGenerationTestCase:
 
-    def test_notification_exception(self):
-        self._set_text(self.portal['doc3'], '<a href="doc1">doc1</a>')
-        self.assertRaises(
-            exceptions.LinkIntegrityNotificationException,
-            self.portal.manage_delObjects, ['doc1'])
-
     def test_is_linked(self):
-        from Products.CMFPlone.utils import isLinked
         img1 = self.portal['image1']
         doc1 = self.portal['doc1']
         self._set_text(doc1, '<img src="image1"></img>')
-        self.assertTrue(isLinked(img1))
+        self.assertTrue(hasIncomingLinks(img1))
 
     def test_referal_to_private_files(self):
         # This tests the behaviour of the link integrity code when a to
@@ -50,12 +47,32 @@ def test_referal_to_private_files(self):
         self.assertTrue(checkPermission('View', img))
         self.assertTrue(checkPermission('Access contents information', img))
 
-        token = self._get_token(img)
-        self.request['_authenticator'] = token
+        # The warning is shown.
+        self.assertTrue(hasOutgoingLinks(doc))
+        view = img.restrictedTraverse('delete_confirmation')
+        results = view()
+        self.assertIn('Potential link breakage', results)
+        self.assertIn('The item is not accessible.', results)
 
-        # Throws exception
-        view = img.restrictedTraverse('@@object_delete')
-        self.assertRaises(exceptions.LinkIntegrityNotificationException, view)
+        # delete linked item and check if the source still has the relation
+
+        # TODO: There is a permission-problem. Deleting the relation
+        # When deleting the linked obj the relation is deleted by
+        # z3c.relationfield.event.breakRelations. That also fires
+        # ObjectModifiedEvent on the linked obj even though the user might not
+        # have the permission to edit that obj.
+        # Here plone.app.versioningbehavior.subscribers.create_version_on_save
+        # for the linked object is triggerted and results in
+        # Unauthorized: You are not allowed to access 'save' in this context
+
+        # self.portal.manage_delObjects(img.id)
+        self.portal._delObject(img.id, suppress_events=True)
+
+        logout()
+        login(self.portal, TEST_USER_NAME)
+        modified(doc)
+        self.assertFalse(hasOutgoingLinks(doc))
+        # doc now has a broken link and no relation :-(
 
     def test_link_extraction_easy(self):
         doc1 = self.portal.doc1
@@ -84,39 +101,34 @@ def test_broken_references(self):
         doc1a = testing.create(self.portal, 'Document', id='doc1a')
         doc1 = self.portal.doc1
 
-        self.assertEqual(len(IReferenceable(doc1).getReferences()), 0)
+        self.assertEqual(len(list(getOutgoingLinks(doc1))), 0)
         self._set_text(doc1, '<a href="doc1a">Doc 1a</a>')
-        self.assertEqual(len(IReferenceable(doc1).getReferences()), 1)
-        self.assertEqual(IReferenceable(doc1).getReferences()[0].id,
-                         self.portal.doc1a.id)
+        self.assertEqual(len(list(getOutgoingLinks(doc1))), 1)
+        self.assertEqual([l.to_object for l in getOutgoingLinks(doc1)],
+                         [self.portal.doc1a])
 
         # Now delete the target item, suppress events and test again,
-        # the reference should be broken now.
+        # the reference should be gone now.
         self.portal._delObject(doc1a.id, suppress_events=True)
-        self.assertEqual(IReferenceable(doc1).getReferences(), [None])
-
-        # If we now try to update the linking document again in order to
-        # remove the link, things used to break raising a
-        # ``ReferenceException``.  This should be handled more
-        # gracefully now:
-        self._set_text(doc1, 'foo!')
-        self.assertEqual(IReferenceable(doc1).getReferences(), [])
+        self.assertEqual([l.to_object for l in getOutgoingLinks(doc1)], [None])
 
     def test_relative_upwards_link_generates_matching_reference(self):
         doc1 = self.portal.doc1
         doc3 = self.portal.folder1.doc3
         self._set_text(doc3, '<a href="../doc1">go!</a>')
-        self.assertEqual(IReferenceable(doc3).getReferences(), [doc1])
+        self.assertEqual(len(list(getOutgoingLinks(doc1))), 0)
+        self.assertEqual([l.to_object for l in getOutgoingLinks(doc3)],
+                         [doc1])
 
     def test_unicode_links(self):
         doc1 = self.portal.doc1
 
-        # This tests checks that isLinked can now be used safely as it
+        # This tests checks that hasIncomingLinks can now be used safely as it
         # eventually plays well with transaction machinery.
         # Add bad link, should not raise exception and there should not
         # be any references added.
         self._set_text(doc1, unicode('<a href="?foo=bar&baz=bam">bug</a>', 'utf-8'))
-        self.assertEqual(IReferenceable(doc1).getReferences(), [])
+        self.assertEqual([l for l in getOutgoingLinks(doc1)], [])
 
     def test_reference_orthogonality(self):
         doc = self.portal.doc1
@@ -124,10 +136,10 @@ def test_reference_orthogonality(self):
         tag = img.restrictedTraverse('@@images').tag()
 
         # This tests the behavior when other references already exist.
-        self.assertEqual(IReferenceable(doc).getReferences(), [])
-        self.assertEqual(IReferenceable(doc).getBackReferences(), [])
-        self.assertEqual(IReferenceable(img).getReferences(), [])
-        self.assertEqual(IReferenceable(img).getBackReferences(), [])
+        self.assertEqual([l for l in getOutgoingLinks(doc)], [])
+        self.assertEqual([l for l in getIncomingLinks(doc)], [])
+        self.assertEqual([l for l in getOutgoingLinks(img)], [])
+        self.assertEqual([l for l in getOutgoingLinks(img)], [])
 
         # Then establish a reference between the document and image as
         # a related item:
@@ -138,9 +150,7 @@ def test_reference_orthogonality(self):
         # which should trigger the creation of a link integrity reference:
         self._set_text(doc, tag)
 
-        from plone.app.linkintegrity.handlers import referencedRelationship
-        self.assertEqual(IReferenceable(doc).getReferences(
-            relationship=referencedRelationship), [img, ])
+        self.assertEqual([l.to_object for l in getOutgoingLinks(doc)], [img])
 
         # And the related item reference remains in place:
         self.assertEqual(self._get_related_items(doc), [img, ])
@@ -149,8 +159,7 @@ def test_reference_orthogonality(self):
         # link to the image, which should trigger the removal of the
         # link integrity reference:
         self._set_text(doc, 'where did my link go?')
-        self.assertEqual(IReferenceable(doc).getReferences(
-            relationship=referencedRelationship), [])
+        self.assertEqual([l.to_object for l in getOutgoingLinks(doc)], [])
 
         # And again the related item reference remains in place:
         self.assertEqual(self._get_related_items(doc), [img, ])
diff --git a/plone/app/linkintegrity/tests/test_upgrade.py b/plone/app/linkintegrity/tests/test_upgrade.py
new file mode 100644
index 0000000..28cad29
--- /dev/null
+++ b/plone/app/linkintegrity/tests/test_upgrade.py
@@ -0,0 +1,22 @@
+# -*- coding: utf-8 -*-
+from Products.Archetypes.interfaces import IReferenceable
+from plone.app.linkintegrity.handlers import referencedRelationship
+from plone.app.linkintegrity.tests.base import ATBaseTestCase
+from plone.app.linkintegrity.upgrades import migrate_linkintegrity_relations
+from plone.app.linkintegrity.utils import hasIncomingLinks
+
+
+class ReferenceMigrationATTestCase(ATBaseTestCase):
+    """Reference migration testcase for at content types"""
+
+    def test_upgrade(self):
+        doc3 = self.portal['doc3']
+        doc1 = self.portal['doc1']
+        self.assertTrue(IReferenceable.providedBy(doc3))
+        doc3.setText('<a href="doc1">doc1</a>', mimetype='text/html')
+        doc3.addReference(doc1, relationship=referencedRelationship)
+        self.assertFalse(hasIncomingLinks(doc1))
+        self.assertFalse(hasIncomingLinks(doc3))
+        migrate_linkintegrity_relations(self.portal)
+        self.assertTrue(hasIncomingLinks(doc1))
+        self.assertFalse(hasIncomingLinks(doc3))
diff --git a/plone/app/linkintegrity/upgrades.py b/plone/app/linkintegrity/upgrades.py
new file mode 100644
index 0000000..20375ae
--- /dev/null
+++ b/plone/app/linkintegrity/upgrades.py
@@ -0,0 +1,26 @@
+# -*- coding: utf-8 -*-
+from Products.CMFCore.utils import getToolByName
+from Products.Archetypes.config import REFERENCE_CATALOG
+from plone.app.linkintegrity.handlers import referencedRelationship
+from plone.app.uuid.utils import uuidToObject
+from zope.lifecycleevent import modified
+
+
+def migrate_linkintegrity_relations(context):
+    """Migrate linkintegrity-relation from reference_catalog to zc.relation"""
+    reference_catalog = getToolByName(context, REFERENCE_CATALOG, None)
+    if reference_catalog is not None:
+        for brain in reference_catalog():
+            # only handle linkintegrity-relations ('relatesTo')
+            if brain.relationship != referencedRelationship:
+                continue
+            source_obj = uuidToObject(brain.sourceUID)
+            target_obj = uuidToObject(brain.targetUID)
+            # Delete old reference
+            reference_catalog.deleteReference(
+                source_obj, target_obj, relationship=referencedRelationship)
+
+            # Trigger the recreation of linkintegrity-relation in
+            # the relation_catalog (zc.relation)
+            modified(source_obj)
+            modified(target_obj)
diff --git a/plone/app/linkintegrity/utils.py b/plone/app/linkintegrity/utils.py
index 73ab6fb..789d9c0 100644
--- a/plone/app/linkintegrity/utils.py
+++ b/plone/app/linkintegrity/utils.py
@@ -1,52 +1,65 @@
-from zExceptions import BadRequest
-from base64 import b64encode, b64decode
-from zlib import compress, decompressobj
-
-
-def decompress(data, maxsize=262144):
-
-    dec = decompressobj()
-    data = dec.decompress(data, maxsize)
-    if dec.unconsumed_tail:
-        raise BadRequest
-    del dec
-
-    return data
-
-
-def encodeStrings(strings):
-    """ compress and encode a list of strings into a single string """
-    def _encode(strings):
-        for string in strings:
-            yield '%d:%s' % (len(string), string)
-    return b64encode(compress(''.join(_encode(strings))))
-
-
-def decodeStrings(data):
-    """ decode and uncompress a string as a generator """
-    data = decompress(b64decode(data))
-    while data:
-        pos = data.find(':')
-        end = pos + int(data[:pos]) + 1
-        yield data[pos + 1:end]
-        data = data[end:]
-
-
-def encodeRequestData((body, env)):
-    """ encode the relevant request data, i.e. body and env """
-    def _iterdata():
-        yield body
-        for key, val in env.iteritems():
-            if isinstance(key, basestring) and isinstance(val, basestring):
-                yield str(key)
-                yield str(val)
-    return encodeStrings(_iterdata())
-
-
-def decodeRequestData(data):
-    """ decode the relevant request data, i.e. body and env """
-    def _pertwo():
-        while True:
-            yield data.next(), data.next()
-    data = decodeStrings(data)
-    return data.next(), dict(_pertwo())
+# -*- coding: utf-8 -*-
+from Products.CMFPlone.interfaces import IEditingSchema
+from plone.app.linkintegrity.handlers import referencedRelationship
+from plone.registry.interfaces import IRegistry
+from zc.relation.interfaces import ICatalog
+from zope.component import getUtility
+from zope.intid.interfaces import IIntIds
+
+
+def getIncomingLinks(obj=None, intid=None):
+    """Return a generator of incoming relations created using
+    plone.app.linkintegrity (Links in Richtext-Fields).
+    """
+    catalog = getUtility(ICatalog)
+    if intid is not None:
+        return catalog.findRelations({
+            'to_id': intid,
+            'from_attribute': referencedRelationship})
+    else:
+        intids = getUtility(IIntIds)
+        return catalog.findRelations({
+            'to_id': intids.getId(obj),
+            'from_attribute': referencedRelationship})
+
+
+def hasIncomingLinks(obj=None, intid=None):
+    """Test if an object is linked to by other objects using
+    plone.app.linkintegrity (Links in Richtext-Fields).
+
+    Way to give bool without loading generator into list
+    """
+    for i in getIncomingLinks(obj=obj, intid=intid):
+        return True
+    return False
+
+
+def getOutgoingLinks(obj=None, intid=None):
+    """Return a generator of outgoing relations created using
+    plone.app.linkintegrity (Links in Richtext-Fields).
+    """
+    catalog = getUtility(ICatalog)
+    if intid is not None:
+        return catalog.findRelations({
+            'from_id': intid,
+            'from_attribute': referencedRelationship})
+    else:
+        intids = getUtility(IIntIds)
+        return catalog.findRelations({
+            'from_id': intids.getId(obj),
+            'from_attribute': referencedRelationship})
+
+
+def hasOutgoingLinks(obj=None, intid=None):
+    """Test if an object links to other objects using plone.app.linkintegrity
+    (Links in Richtext-Fields).
+    """
+    for i in getOutgoingLinks(obj=obj, intid=intid):
+        return True
+    return False
+
+
+def linkintegrity_enabled():
+    reg = getUtility(IRegistry)
+    editing_settings = reg.forInterface(IEditingSchema, prefix='plone')
+    return editing_settings.enable_link_integrity_checks
diff --git a/setup.py b/setup.py
index 7e1b778..5d406b9 100644
--- a/setup.py
+++ b/setup.py
@@ -1,6 +1,6 @@
 from setuptools import setup, find_packages
 
-version = '2.1.3.dev0'
+version = '3.0.dev0'
 
 setup(name='plone.app.linkintegrity',
       version=version,
@@ -31,7 +31,8 @@
       include_package_data=True,
       install_requires=[
           'setuptools',
-          'plone.app.referenceablebehavior',  # Requires Products.Archetypes
+          'plone.app.intid',
+          'plone.app.relationfield',
       ],
       extras_require={
           'test': [


