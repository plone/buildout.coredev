Repository: plone.app.linkintegrity


Branch: refs/heads/master
Date: 2019-05-24T11:29:38+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.app.linkintegrity/commit/5c9472848ed193f4d19a02ea37c5396bdd3f1c73

add regression-test for https://github.com/plone/Products.CMFPlone/issues/2866

Files changed:
A plone/app/linkintegrity/tests/test_copy_paste.py

b'diff --git a/plone/app/linkintegrity/tests/test_copy_paste.py b/plone/app/linkintegrity/tests/test_copy_paste.py\nnew file mode 100644\nindex 0000000..9dd20b4\n--- /dev/null\n+++ b/plone/app/linkintegrity/tests/test_copy_paste.py\n@@ -0,0 +1,47 @@\n+# -*- coding: utf-8 -*-\n+from plone.app.linkintegrity.testing import PLONE_APP_LINKINTEGRITY_DX_INTEGRATION_TESTING  # noqa: E501\n+from plone.app.testing import setRoles\n+from plone.app.testing import TEST_USER_ID\n+from plone.app.textfield import RichTextValue\n+from zope.lifecycleevent import modified\n+\n+import unittest\n+\n+\n+class TestCopyPaste(unittest.TestCase):\n+\n+    layer = PLONE_APP_LINKINTEGRITY_DX_INTEGRATION_TESTING\n+\n+    def setUp(self):\n+        self.portal = self.layer[\'portal\']\n+        self.request = self.layer[\'request\']\n+        setRoles(self.portal, TEST_USER_ID, [\'Manager\'])\n+\n+    def test_copy_paste(self):\n+        """Test that https://github.com/plone/Products.CMFPlone/issues/2866\n+        is fixed. Setting relations during copy&paste failed in Zope 4.\n+        """\n+        self.portal.invokeFactory(\'Image\', \'image\', title=u\'Image\')\n+        self.portal.invokeFactory(\'Document\', \'document\', title=u\'Document\')\n+        document = self.portal[\'document\']\n+        image = self.portal[\'image\']\n+        text = RichTextValue(\n+            \'<p><img src="{portal}/resolveuid/{uid}/@@images/image/large" class="image-inline" data-linktype="image" data-scale="large" data-val="{uid}" data-mce-src="{portal}/resolveuid/{uid}/@@images/image/large" data-mce-selected="1"></p>\'.format(\n+                portal=u\'..\',\n+                uid=image.UID()),\n+            \'text/html\', \'text/x-html-safe\')\n+        document.text = text\n+        modified(document)\n+        self.portal.invokeFactory(\'Folder\', \'folder\', title=u\'Folder\')\n+        target = self.portal[\'folder\']\n+\n+        copied = self.portal.manage_copyObjects(\'document\')\n+        target.manage_pasteObjects(copied)\n+        self.assertTrue(target[\'document\'])\n+        # check that linkintegrity-relations exists for both items:\n+        info = image.restrictedTraverse(\'@@delete_confirmation_info\')\n+        breaches = info.get_breaches()\n+        self.assertEqual(len(breaches[0][\'sources\']), 2)\n+        uids_objs = [i.UID() for i in [target[\'document\'], document]]\n+        uids_rels = [i[\'uid\'] for i in breaches[0][\'sources\']]\n+        self.assertEqual(set(uids_objs), set(uids_rels))\n'

Repository: plone.app.linkintegrity


Branch: refs/heads/master
Date: 2019-05-24T11:31:20+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.app.linkintegrity/commit/15d26da442462ab9a80c7a7c1941f125780056d4

add changenote

Files changed:
A news/71.bugfix

b'diff --git a/news/71.bugfix b/news/71.bugfix\nnew file mode 100644\nindex 0000000..0f20903\n--- /dev/null\n+++ b/news/71.bugfix\n@@ -0,0 +1,2 @@\n+Add regression-test for broken copy&paste. See https://github.com/plone/Products.CMFPlone/issues/2866\n+[pbauer]\n\\ No newline at end of file\n'

Repository: plone.app.linkintegrity


Branch: refs/heads/master
Date: 2024-06-12T13:50:04-04:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.app.linkintegrity/commit/5687a8c00e747174fb4ed5f4f6cc92d9a45c0577

Merge branch 'master' into add_regression_test

Files changed:
A .editorconfig
A .flake8
A .github/workflows/meta.yml
A .meta.toml
A .pre-commit-config.yaml
A plone/app/linkintegrity/tests/test_info.py
A plone/app/linkintegrity/tests/utils.py
A tox.ini
M .gitignore
M CHANGES.rst
M README.rst
M plone/__init__.py
M plone/app/__init__.py
M plone/app/linkintegrity/__init__.py
M plone/app/linkintegrity/browser/__init__.py
M plone/app/linkintegrity/browser/configure.zcml
M plone/app/linkintegrity/browser/delete_confirmation_info.pt
M plone/app/linkintegrity/browser/info.py
M plone/app/linkintegrity/browser/update.pt
M plone/app/linkintegrity/browser/update.py
M plone/app/linkintegrity/configure.zcml
M plone/app/linkintegrity/exceptions.py
M plone/app/linkintegrity/handlers.py
M plone/app/linkintegrity/interfaces.py
M plone/app/linkintegrity/parser.py
M plone/app/linkintegrity/profiles/default/metadata.xml
M plone/app/linkintegrity/retriever.py
M plone/app/linkintegrity/testing.py
M plone/app/linkintegrity/tests/__init__.py
M plone/app/linkintegrity/tests/test_circular.py
M plone/app/linkintegrity/tests/test_functional.py
M plone/app/linkintegrity/tests/test_handlers.py
M plone/app/linkintegrity/tests/test_imagescales.py
M plone/app/linkintegrity/tests/test_references.py
M plone/app/linkintegrity/utils.py
M pyproject.toml
M setup.py
D plone/app/linkintegrity/compat.py
D plone/app/linkintegrity/tests/base.py
D plone/app/linkintegrity/tests/test_upgrade.py
D plone/app/linkintegrity/upgrades.py
D setup.cfg

b'diff --git a/.editorconfig b/.editorconfig\nnew file mode 100644\nindex 0000000..fa698fb\n--- /dev/null\n+++ b/.editorconfig\n@@ -0,0 +1,54 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/main/config/default\n+# See the inline comments on how to expand/tweak this configuration file\n+#\n+# EditorConfig Configuration file, for more details see:\n+# http://EditorConfig.org\n+# EditorConfig is a convention description, that could be interpreted\n+# by multiple editors to enforce common coding conventions for specific\n+# file types\n+\n+# top-most EditorConfig file:\n+# Will ignore other EditorConfig files in Home directory or upper tree level.\n+root = true\n+\n+\n+[*]  # For All Files\n+# Unix-style newlines with a newline ending every file\n+end_of_line = lf\n+insert_final_newline = true\n+trim_trailing_whitespace = true\n+# Set default charset\n+charset = utf-8\n+# Indent style default\n+indent_style = space\n+# Max Line Length - a hard line wrap, should be disabled\n+max_line_length = off\n+\n+[*.{py,cfg,ini}]\n+# 4 space indentation\n+indent_size = 4\n+\n+[*.{yml,zpt,pt,dtml,zcml,html,xml}]\n+# 2 space indentation\n+indent_size = 2\n+\n+[*.{json,jsonl,js,jsx,ts,tsx,css,less,scss}]  # Frontend development\n+# 2 space indentation\n+indent_size = 2\n+max_line_length = 80\n+\n+[{Makefile,.gitmodules}]\n+# Tab indentation (no size specified, but view as 4 spaces)\n+indent_style = tab\n+indent_size = unset\n+tab_width = unset\n+\n+\n+##\n+# Add extra configuration options in .meta.toml:\n+#  [editorconfig]\n+#  extra_lines = """\n+#  _your own configuration lines_\n+#  """\n+##\ndiff --git a/.flake8 b/.flake8\nnew file mode 100644\nindex 0000000..38918f4\n--- /dev/null\n+++ b/.flake8\n@@ -0,0 +1,22 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/main/config/default\n+# See the inline comments on how to expand/tweak this configuration file\n+[flake8]\n+doctests = 1\n+ignore =\n+    # black takes care of line length\n+    E501,\n+    # black takes care of where to break lines\n+    W503,\n+    # black takes care of spaces within slicing (list[:])\n+    E203,\n+    # black takes care of spaces after commas\n+    E231,\n+\n+##\n+# Add extra configuration options in .meta.toml:\n+#  [flake8]\n+#  extra_lines = """\n+#  _your own configuration lines_\n+#  """\n+##\ndiff --git a/.github/workflows/meta.yml b/.github/workflows/meta.yml\nnew file mode 100644\nindex 0000000..b8edec0\n--- /dev/null\n+++ b/.github/workflows/meta.yml\n@@ -0,0 +1,68 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/main/config/default\n+# See the inline comments on how to expand/tweak this configuration file\n+name: Meta\n+on:\n+  push:\n+    branches:\n+      - master\n+      - main\n+  pull_request:\n+    branches:\n+      - master\n+      - main\n+  workflow_dispatch:\n+\n+##\n+# To set environment variables for all jobs, add in .meta.toml:\n+# [github]\n+# env = """\n+#     debug: 1\n+#     image-name: \'org/image\'\n+#     image-tag: \'latest\'\n+# """\n+##\n+\n+jobs:\n+  qa:\n+    uses: plone/meta/.github/workflows/qa.yml@main\n+  test:\n+    uses: plone/meta/.github/workflows/test.yml@main\n+  coverage:\n+    uses: plone/meta/.github/workflows/coverage.yml@main\n+  dependencies:\n+    uses: plone/meta/.github/workflows/dependencies.yml@main\n+  release_ready:\n+    uses: plone/meta/.github/workflows/release_ready.yml@main\n+  circular:\n+    uses: plone/meta/.github/workflows/circular.yml@main\n+\n+##\n+# To modify the list of default jobs being created add in .meta.toml:\n+# [github]\n+# jobs = [\n+#    "qa",\n+#    "test",\n+#    "coverage",\n+#    "dependencies",\n+#    "release_ready",\n+#    "circular",\n+#    ]\n+##\n+\n+##\n+# To request that some OS level dependencies get installed\n+# when running tests/coverage jobs, add in .meta.toml:\n+# [github]\n+# os_dependencies = "git libxml2 libxslt"\n+##\n+\n+\n+##\n+# Specify additional jobs in .meta.toml:\n+#  [github]\n+#  extra_lines = """\n+#  another:\n+#    uses: org/repo/.github/workflows/file.yml@main\n+#  """\n+##\ndiff --git a/.gitignore b/.gitignore\nindex d25714f..486392f 100644\n--- a/.gitignore\n+++ b/.gitignore\n@@ -1,3 +1,56 @@\n-*~\n+# Generated from:\n+# https://github.com/plone/meta/tree/main/config/default\n+# See the inline comments on how to expand/tweak this configuration file\n+# python related\n+*.egg-info\n *.pyc\n-*egg-info\n+*.pyo\n+\n+# translation related\n+*.mo\n+\n+# tools related\n+build/\n+.coverage\n+.*project\n+coverage.xml\n+dist/\n+docs/_build\n+__pycache__/\n+.tox\n+.vscode/\n+node_modules/\n+\n+# venv / buildout related\n+bin/\n+develop-eggs/\n+eggs/\n+.eggs/\n+etc/\n+.installed.cfg\n+include/\n+lib/\n+lib64\n+.mr.developer.cfg\n+parts/\n+pyvenv.cfg\n+var/\n+local.cfg\n+\n+# mxdev\n+/instance/\n+/.make-sentinels/\n+/*-mxdev.txt\n+/reports/\n+/sources/\n+/venv/\n+.installed.txt\n+\n+\n+##\n+# Add extra configuration options in .meta.toml:\n+#  [gitignore]\n+#  extra_lines = """\n+#  _your own configuration lines_\n+#  """\n+##\ndiff --git a/.meta.toml b/.meta.toml\nnew file mode 100644\nindex 0000000..d4b79f8\n--- /dev/null\n+++ b/.meta.toml\n@@ -0,0 +1,6 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/main/config/default\n+# See the inline comments on how to expand/tweak this configuration file\n+[meta]\n+template = "default"\n+commit-id = "6e36bcc4"\ndiff --git a/.pre-commit-config.yaml b/.pre-commit-config.yaml\nnew file mode 100644\nindex 0000000..f857b48\n--- /dev/null\n+++ b/.pre-commit-config.yaml\n@@ -0,0 +1,94 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/main/config/default\n+# See the inline comments on how to expand/tweak this configuration file\n+ci:\n+    autofix_prs: false\n+    autoupdate_schedule: monthly\n+\n+repos:\n+-   repo: https://github.com/asottile/pyupgrade\n+    rev: v3.15.0\n+    hooks:\n+    -   id: pyupgrade\n+        args: [--py38-plus]\n+-   repo: https://github.com/pycqa/isort\n+    rev: 5.13.2\n+    hooks:\n+    -   id: isort\n+-   repo: https://github.com/psf/black\n+    rev: 24.1.1\n+    hooks:\n+    -   id: black\n+-   repo: https://github.com/collective/zpretty\n+    rev: 3.1.0\n+    hooks:\n+    -   id: zpretty\n+\n+##\n+# Add extra configuration options in .meta.toml:\n+#  [pre_commit]\n+#  zpretty_extra_lines = """\n+#  _your own configuration lines_\n+#  """\n+##\n+-   repo: https://github.com/PyCQA/flake8\n+    rev: 7.0.0\n+    hooks:\n+    -   id: flake8\n+\n+##\n+# Add extra configuration options in .meta.toml:\n+#  [pre_commit]\n+#  flake8_extra_lines = """\n+#  _your own configuration lines_\n+#  """\n+##\n+-   repo: https://github.com/codespell-project/codespell\n+    rev: v2.2.6\n+    hooks:\n+    -   id: codespell\n+        additional_dependencies:\n+          - tomli\n+\n+##\n+# Add extra configuration options in .meta.toml:\n+#  [pre_commit]\n+#  codespell_extra_lines = """\n+#  _your own configuration lines_\n+#  """\n+##\n+-   repo: https://github.com/mgedmin/check-manifest\n+    rev: "0.49"\n+    hooks:\n+    -   id: check-manifest\n+-   repo: https://github.com/regebro/pyroma\n+    rev: "4.2"\n+    hooks:\n+    -   id: pyroma\n+-   repo: https://github.com/mgedmin/check-python-versions\n+    rev: "0.22.0"\n+    hooks:\n+    -   id: check-python-versions\n+        args: [\'--only\', \'setup.py,pyproject.toml\']\n+-   repo: https://github.com/collective/i18ndude\n+    rev: "6.1.0"\n+    hooks:\n+    -   id: i18ndude\n+\n+\n+##\n+# Add extra configuration options in .meta.toml:\n+#  [pre_commit]\n+#  i18ndude_extra_lines = """\n+#  _your own configuration lines_\n+#  """\n+##\n+\n+\n+##\n+# Add extra configuration options in .meta.toml:\n+#  [pre_commit]\n+#  extra_lines = """\n+#  _your own configuration lines_\n+#  """\n+##\ndiff --git a/CHANGES.rst b/CHANGES.rst\nindex 82c0e7e..09e7829 100644\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -8,6 +8,189 @@ Changelog\n \n .. towncrier release notes start\n \n+4.0.5 (2024-05-30)\n+------------------\n+\n+Bug fixes:\n+\n+\n+- Fix potential issue calculating breaches with objects sharing the same prefix\n+  [pgrunewald] (#97)\n+\n+\n+4.0.4 (2024-05-06)\n+------------------\n+\n+Bug fixes:\n+\n+\n+- Improve performance for calculating breaches.\n+  [pgrunewald] (#100)\n+- Fix breaches reporting for documents with multiple links.\n+  [pgrunewald] (#102)\n+\n+\n+4.0.3 (2023-09-29)\n+------------------\n+\n+Bug fixes:\n+\n+\n+- Report sources once per breach in delete_confirmation_info.\n+  [jaroel] (#95)\n+\n+\n+4.0.2 (2023-08-31)\n+------------------\n+\n+Bug fixes:\n+\n+\n+- Remove outgoing \'isReferencing\' RelationValues from catalog on deleting content item.\n+  [ksuess] (#93)\n+\n+\n+Internal:\n+\n+\n+- Update configuration files.\n+  [plone devs] (7723aeaf)\n+\n+\n+4.0.1 (2023-04-14)\n+------------------\n+\n+Internal:\n+\n+\n+- Update configuration files.\n+  [plone devs] (5623f8b3)\n+\n+\n+4.0.0 (2023-03-13)\n+------------------\n+\n+Breaking changes:\n+\n+\n+- Drop compatibility for Plone 5.2.  Support Plone 6 only.\n+  [maurits] (#60)\n+\n+\n+Bug fixes:\n+\n+\n+- Fixed test layer setup.\n+  Created content was bleeding into layers from other packages.\n+  [maurits] (#846)\n+\n+\n+3.6.1 (2022-04-28)\n+------------------\n+\n+Bug fixes:\n+\n+\n+- Test fix: only load plone.app.contenttypes migration layer on Python 2.\n+  [maurits] (#641)\n+\n+\n+3.6.0 (2022-02-23)\n+------------------\n+\n+New features:\n+\n+\n+- Track link integrity of referenced PDFs and other site objects in IFRAME SRC references. (#84)\n+\n+\n+3.5.0 (2021-12-29)\n+------------------\n+\n+New features:\n+\n+\n+- Track integrity of video and audio files in HTML source tags. (#77)\n+\n+\n+3.4.1 (2021-03-02)\n+------------------\n+\n+Bug fixes:\n+\n+\n+- Use base64.decodebytes instead of decodestring when possible.\n+  Fixes Python 3.9 compatibility in the tests.\n+  [maurits] (#81)\n+\n+\n+3.4.0 (2021-02-23)\n+------------------\n+\n+New features:\n+\n+\n+- Drop Plone 5.1 support, due to possible incompatibility with older plone.app.uuid.\n+  [maurits] (#79)\n+\n+\n+Bug fixes:\n+\n+\n+- Fix Unauthorized exception when you edit a page that links to another page that you are not allowed to see.\n+  Fixes `issue 79 <https://github.com/plone/plone.app.linkintegrity/issues/79>`_.\n+  [maurits] (#79)\n+\n+\n+3.3.14 (2020-09-07)\n+-------------------\n+\n+Bug fixes:\n+\n+\n+- Fixed deprecation warning for ComponentLookupError.\n+  [maurits] (#3130)\n+\n+\n+3.3.13 (2020-04-20)\n+-------------------\n+\n+Bug fixes:\n+\n+\n+- Minor packaging updates. (#1)\n+\n+\n+3.3.12 (2019-10-12)\n+-------------------\n+\n+Bug fixes:\n+\n+\n+- Explicitly load zcml of dependencies, instead of using ``includeDependencies``.\n+  [maurits] (#2952)\n+\n+\n+3.3.11 (2019-06-27)\n+-------------------\n+\n+Bug fixes:\n+\n+\n+- Add missing i18n:translate calls\n+  [erral] (#73)\n+\n+\n+3.3.10 (2019-06-19)\n+-------------------\n+\n+Bug fixes:\n+\n+\n+- Accept to have a broken object w/o aq_parent in test.\n+  [jensens] (#72)\n+\n+\n 3.3.9 (2019-05-01)\n ------------------\n \n@@ -414,7 +597,7 @@ New:\n   for fields which have been added via schema extension.\n   [malthe]\n \n-- Support resolveuid/UID references explicitely, by parsing and resolving\n+- Support resolveuid/UID references explicitly, by parsing and resolving\n   these ourselves instead of relying on a view or script (which doesn\'t work).\n   This fixes linkintegrity for sites with link-by-uid turned on.\n   This closes https://dev.plone.org/ticket/12104\ndiff --git a/README.rst b/README.rst\nindex 4d66a03..12f3178 100644\n--- a/README.rst\n+++ b/README.rst\n@@ -56,16 +56,16 @@ Customization\n \n On object created, added, modified events the ``modifiedContent`` handler\n is called. This handler adapts an ``IRetriever`` object if found.\n-The package comes with two general adapters for Dexterity and Archetypes.\n+The package comes with one general adapter for Dexterity content.\n You can easily write custom adapters implementing the ``IRetriever``\n-interface for your contenttype. Look at the ``retriever`` module in this\n+interface for your content type. Look at the ``retriever`` module in this\n package for examples.\n \n API\n ---\n \n To check if there would be breaches when deleting one or more objects\n-you can use the follwing code:\n+you can use the following code:\n \n .. code-block:: python\n \n@@ -78,7 +78,7 @@ you can use the follwing code:\n     breaches = view.get_breaches([obj1, obj2])\n \n `get_breaches` ignores breaches originating from any items that would also be\n-deleted by deleting the items (and their chidlren if an item is a folder).\n+deleted by deleting the items (and their children if an item is a folder).\n \n Each breach in `breaches` is a dictionary with a `target` (a dict with some\n info on the object to be deleted) and a list of `sources`.\ndiff --git a/plone/__init__.py b/plone/__init__.py\nindex 68c04af..5284146 100644\n--- a/plone/__init__.py\n+++ b/plone/__init__.py\n@@ -1,2 +1 @@\n-# -*- coding: utf-8 -*-\n-__import__(\'pkg_resources\').declare_namespace(__name__)\n+__import__("pkg_resources").declare_namespace(__name__)\ndiff --git a/plone/app/__init__.py b/plone/app/__init__.py\nindex 68c04af..5284146 100644\n--- a/plone/app/__init__.py\n+++ b/plone/app/__init__.py\n@@ -1,2 +1 @@\n-# -*- coding: utf-8 -*-\n-__import__(\'pkg_resources\').declare_namespace(__name__)\n+__import__("pkg_resources").declare_namespace(__name__)\ndiff --git a/plone/app/linkintegrity/__init__.py b/plone/app/linkintegrity/__init__.py\nindex 40a96af..e69de29 100644\n--- a/plone/app/linkintegrity/__init__.py\n+++ b/plone/app/linkintegrity/__init__.py\n@@ -1 +0,0 @@\n-# -*- coding: utf-8 -*-\ndiff --git a/plone/app/linkintegrity/browser/__init__.py b/plone/app/linkintegrity/browser/__init__.py\nindex 40a96af..e69de29 100644\n--- a/plone/app/linkintegrity/browser/__init__.py\n+++ b/plone/app/linkintegrity/browser/__init__.py\n@@ -1 +0,0 @@\n-# -*- coding: utf-8 -*-\ndiff --git a/plone/app/linkintegrity/browser/configure.zcml b/plone/app/linkintegrity/browser/configure.zcml\nindex 77c5b30..7931e09 100644\n--- a/plone/app/linkintegrity/browser/configure.zcml\n+++ b/plone/app/linkintegrity/browser/configure.zcml\n@@ -1,20 +1,21 @@\n <configure\n     xmlns="http://namespaces.zope.org/zope"\n-    xmlns:browser="http://namespaces.zope.org/browser">\n+    xmlns:browser="http://namespaces.zope.org/browser"\n+    >\n \n   <browser:page\n-       for="*"\n-       name="delete_confirmation_info"\n-       class=".info.DeleteConfirmationInfo"\n-       permission="zope2.Public"\n-       />\n+      name="delete_confirmation_info"\n+      for="*"\n+      class=".info.DeleteConfirmationInfo"\n+      permission="zope2.Public"\n+      />\n \n   <browser:page\n-        name="updateLinkIntegrityInformation"\n-        for="Products.CMFPlone.interfaces.IPloneSiteRoot"\n-        template="update.pt"\n-        class=".update.UpdateView"\n-        permission="cmf.ManagePortal"\n-        />\n+      name="updateLinkIntegrityInformation"\n+      for="plone.base.interfaces.IPloneSiteRoot"\n+      class=".update.UpdateView"\n+      template="update.pt"\n+      permission="cmf.ManagePortal"\n+      />\n \n </configure>\ndiff --git a/plone/app/linkintegrity/browser/delete_confirmation_info.pt b/plone/app/linkintegrity/browser/delete_confirmation_info.pt\nindex d2263f5..0b938c0 100644\n--- a/plone/app/linkintegrity/browser/delete_confirmation_info.pt\n+++ b/plone/app/linkintegrity/browser/delete_confirmation_info.pt\n@@ -1,86 +1,135 @@\n-<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"\n-    xmlns:tal="http://xml.zope.org/namespaces/tal"\n-    xmlns:metal="http://xml.zope.org/namespaces/metal"\n-    xmlns:i18n="http://xml.zope.org/namespaces/i18n"\n-    lang="en"\n-    i18n:domain="plone"\n-    tal:omit-tag="">\n-<body tal:omit-tag="" tal:define="breaches python:view.breaches">\n+<html xmlns="http://www.w3.org/1999/xhtml"\n+      xmlns:i18n="http://xml.zope.org/namespaces/i18n"\n+      xmlns:metal="http://xml.zope.org/namespaces/metal"\n+      xmlns:tal="http://xml.zope.org/namespaces/tal"\n+      lang="en"\n+      xml:lang="en"\n+      tal:omit-tag=""\n+      i18n:domain="plone"\n+>\n+  <body tal:define="\n+          breaches python:view.breaches;\n+        "\n+        tal:omit-tag=""\n+  >\n \n-  <h2 tal:condition="breaches" i18n:translate="linkintegrity_breaches_title">Potential link breakage</h2>\n+    <h2 tal:condition="breaches"\n+        i18n:translate="linkintegrity_breaches_title"\n+    >Potential link breakage</h2>\n \n-  <div id="content-core">\n+    <div id="content-core">\n \n-    <p tal:condition="breaches" i18n:translate="linkintegrity_instructions">\n+      <p tal:condition="breaches"\n+         i18n:translate="linkintegrity_instructions"\n+      >\n       By deleting this item, you will break links that exist in the items listed\n       below. If this is indeed what you want to do, we recommend that you remove\n       these references first.\n-    </p>\n+      </p>\n \n-    <div tal:define="token context/@@authenticator/token">\n-      <article tal:repeat="breach breaches" class="breach-container">\n+      <div tal:define="\n+             token context/@@authenticator/token;\n+           ">\n+        <article class="breach-container"\n+                 tal:repeat="breach breaches"\n+        >\n \n-        <tal:target  tal:define="target breach/target">\n-          <header><a href="${target/url}" tal:content="target/title" /></header>\n-          <p>\n-            <span i18n:translate="linkintegrity_is_referenced">\n-              This <span i18n:name="portal_type" tal:content="target/type_title" />\n+          <tal:target tal:define="\n+                        target breach/target;\n+                      ">\n+            <header><a href="${target/url}"\n+                 tal:content="target/title"\n+              ></a></header>\n+            <p>\n+              <span i18n:translate="linkintegrity_is_referenced">\n+              This\n+                <span tal:content="target/type_title"\n+                      i18n:name="portal_type"\n+                ></span>\n               is referenced by the following items:\n-            </span>\n-          </p>\n-        </tal:target>\n+              </span>\n+            </p>\n+          </tal:target>\n \n-        <ul>\n-          <li tal:repeat="source python:breach[\'sources\']" class="breach-item">\n-            <tal:visible condition="source/accessible">\n-              <a tal:attributes="href source/url" tal:content="source/title" />\n-              [<a\n-                  tal:attributes="href string:${source/url}/edit?_authenticator=${token}"\n-                  i18n:translate="linkintegrity_edit_in_new_window"\n-                  target="_blank">Edit in new window</a>]\n-            </tal:visible>\n-            <tal:private\n-                condition="not: source/accessible"\n-                i18n:translate="linkintegrity_item_not_accessible">\n+          <ul>\n+            <li class="breach-item"\n+                tal:repeat="source python:breach[\'sources\']"\n+            >\n+              <tal:visible condition="source/accessible">\n+                <a tal:content="source/title"\n+                   tal:attributes="\n+                     href source/url;\n+                   "\n+                ></a>\n+                [<a target="_blank"\n+                   tal:attributes="\n+                     href string:${source/url}/edit?_authenticator=${token};\n+                   "\n+                   i18n:translate="linkintegrity_edit_in_new_window"\n+                >Edit in new window</a>]\n+              </tal:visible>\n+              <tal:private condition="not: source/accessible"\n+                           i18n:translate="linkintegrity_item_not_accessible"\n+              >\n               The item is not accessible.\n-            </tal:private>\n-          </li>\n-        </ul>\n+              </tal:private>\n+            </li>\n+          </ul>\n \n-      </article>\n+        </article>\n \n-      <div tal:define="breach_count view/breach_count" tal:condition="breach_count">\n+        <div tal:define="\n+               breach_count view/breach_count;\n+             "\n+             tal:condition="breach_count"\n+        >\n \n-        <h2 i18n:translate="deleting_overview" >Deleting overview</h2>\n-        <p>\n-          <span tal:define="refs python:len(breach_count)"\n-              i18n:translate="selected_folders_with_content">\n-            Number of selected, non-empty folders: <strong><span tal:replace="refs" i18n:name="refs" /></strong>\n-          </span>\n-        </p>\n-        <ul>\n-          <li tal:repeat="content python:breach_count">\n-            <span i18n:translate="deleting_contents"> Following content within\n-              <strong><span tal:replace="content" i18n:name="content" /></strong>  will also be deleted:\n-            </span><br/>\n-            <ul>\n-              <li tal:define="objects view/objects"\n-                  tal:repeat="item python:range(3) ">\n-                <span tal:replace="python: breach_count[content][item]" /> <span tal:replace="python: objects[item]" />\n-              </li>\n-            </ul>\n-          </li>\n-        </ul>\n+          <h2 i18n:translate="deleting_overview">Deleting overview</h2>\n+          <p>\n+            <span tal:define="\n+                    refs python:len(breach_count);\n+                  "\n+                  i18n:translate="selected_folders_with_content"\n+            >\n+            Number of selected, non-empty folders:\n+              <strong><span tal:replace="refs"\n+                      i18n:name="refs"\n+                ></span></strong>\n+            </span>\n+          </p>\n+          <ul>\n+            <li tal:repeat="content python:breach_count">\n+              <span i18n:translate="deleting_contents">\n+                 Following content within\n+                <strong><span tal:replace="content"\n+                        i18n:name="content"\n+                  ></span></strong>\n+                  will also be deleted:\n+              </span><br />\n+              <ul>\n+                <li tal:define="\n+                      objects view/objects;\n+                    "\n+                    tal:repeat="item python:range(3) "\n+                >\n+                  <span tal:replace="python: breach_count[content][item]"></span>\n+                  <span tal:replace="python: objects[item]"></span>\n+                </li>\n+              </ul>\n+            </li>\n+          </ul>\n \n-      </div>\n+        </div>\n \n-      <p tal:condition="breaches" i18n:translate="linkintegrity_delete_anyway">\n+        <p tal:condition="breaches"\n+           i18n:translate="linkintegrity_delete_anyway"\n+        >\n         Would you like to delete it anyway?\n-      </p>\n+        </p>\n \n-    </div>\n+      </div>\n \n-  </div>\n+    </div>\n \n-</body>\n+  </body>\n </html>\ndiff --git a/plone/app/linkintegrity/browser/info.py b/plone/app/linkintegrity/browser/info.py\nindex 2921efa..41d7e35 100644\n--- a/plone/app/linkintegrity/browser/info.py\n+++ b/plone/app/linkintegrity/browser/info.py\n@@ -1,26 +1,26 @@\n-# -*- coding: utf-8 -*-\n from Acquisition import aq_inner\n from OFS.interfaces import IFolder\n from plone.app.linkintegrity.utils import getIncomingLinks\n from plone.app.linkintegrity.utils import linkintegrity_enabled\n+from plone.base import PloneMessageFactory as _\n+from plone.base.interfaces import IPloneSiteRoot\n from plone.uuid.interfaces import IUUID\n from Products.CMFCore.permissions import AccessContentsInformation\n from Products.CMFCore.utils import _checkPermission\n from Products.CMFCore.utils import getToolByName\n-from Products.CMFPlone import PloneMessageFactory as _\n-from Products.CMFPlone.interfaces.siteroot import IPloneSiteRoot\n from Products.Five import BrowserView\n from Products.Five.browser.pagetemplatefile import ViewPageTemplateFile\n from zope.i18n import translate\n+\n import logging\n+import warnings\n \n \n logger = logging.getLogger(__name__)\n \n \n class DeleteConfirmationInfo(BrowserView):\n-\n-    template = ViewPageTemplateFile(\'delete_confirmation_info.pt\')\n+    template = ViewPageTemplateFile("delete_confirmation_info.pt")\n     breach_count = {}\n \n     def __init__(self, context, request):\n@@ -48,67 +48,56 @@ def get_breaches(self, items=None):\n         """\n         if items is None:\n             items = [self.context]\n-        catalog = getToolByName(self.context, \'portal_catalog\')\n+        catalog = getToolByName(self.context, "portal_catalog")\n         results = []\n-        uids_to_ignore = []\n-        uids_visited = set()\n+        uids_to_ignore = set()\n         self.breach_count = {}\n+        path2obj = dict()\n+        path2brains = dict()\n+\n+        # build various helper structures\n         for obj in items:\n-            obj_path = \'/\'.join(obj.getPhysicalPath())\n-            brains_to_delete = catalog(path={\'query\': obj_path})\n-            # add the current items uid and all its childrens uids to the\n+            obj_path = "/".join(obj.getPhysicalPath())\n+            path2obj[obj_path] = obj\n+            path2brains[obj_path] = brains_to_delete = catalog(path={"query": obj_path})\n+            # add the current items uid and all its children\'s uids to the\n             # list of uids that are ignored\n-            uids_to_ignore.extend([i.UID for i in brains_to_delete])\n+            uids_to_ignore.update([i.UID for i in brains_to_delete])\n+\n+        excluded_paths = set(path2obj.keys())\n+\n+        # determine breaches\n+        for obj_path, obj in path2obj.items():\n+            brains_to_delete = path2brains[obj_path]\n             for brain_to_delete in brains_to_delete:\n                 try:\n                     obj_to_delete = brain_to_delete.getObject()  # noqa\n                 except (AttributeError, KeyError):\n                     logger.exception(\n-                        \'No object found for %s! Skipping\', brain_to_delete)\n+                        "No object found for %s! Skipping", brain_to_delete\n+                    )\n                     continue\n-                for breach in self.get_breaches_for_item(obj):\n-                    add_breach = False\n-                    for source in breach[\'sources\']:\n+                # look into potential breach\n+                breach = self.check_object(\n+                    obj=obj_to_delete, excluded_paths=excluded_paths\n+                )\n+                if breach:\n+                    for source in breach["sources"]:\n                         # Only add the breach if one the sources is not in the\n                         # list of items that are to be deleted.\n-                        if source[\'uid\'] not in uids_to_ignore and \\\n-                           source[\'uid\'] not in uids_visited:\n-                            add_breach = True\n-                            uids_visited.add(source[\'uid\'])\n+                        if source["uid"] not in uids_to_ignore:\n+                            results.append(breach)\n                             break\n-                    if add_breach:\n-                        results.append(breach)\n+\n             if IFolder.providedBy(obj):\n-                count = len(catalog(\n-                    path={\'query\': obj_path}\n-                ))\n-                count_dirs = len(catalog(\n-                    path={\'query\': obj_path},\n-                    is_folderish=True\n-                ))\n-                count_public = len(catalog(\n-                    path={\'query\': obj_path},\n-                    review_state=\'published\'\n-                ))\n+                count = len(catalog(path={"query": obj_path}))\n+                count_dirs = len(catalog(path={"query": obj_path}, is_folderish=True))\n+                count_public = len(\n+                    catalog(path={"query": obj_path}, review_state="published")\n+                )\n                 if count:\n-                    self.breach_count[obj_path] = [\n-                        count,\n-                        count_dirs,\n-                        count_public\n-                    ]\n-\n-        # Cleanup: Some breaches where added before it was known\n-        # that their source will be deleted too.\n-        for result in results:\n-            for source in result[\'sources\']:\n-                if source[\'uid\'] in uids_to_ignore:\n-                    # Drop sources that are also being deleted\n-                    result[\'sources\'].remove(source)\n-                    if not result[\'sources\']:\n-                        # Remove the breach is there are no more sources\n-                        # This check is necessary since there can be multiple\n-                        # sources for a breach\n-                        results.remove(result)\n+                    self.breach_count[obj_path] = [count, count_dirs, count_public]\n+\n         return results\n \n     def get_breaches_for_item(self, obj=None):\n@@ -116,35 +105,27 @@ def get_breaches_for_item(self, obj=None):\n \n         Breaches coming from the children of a folder are ignored by default.\n         """\n-        if obj is None:\n-            obj = self.context\n-        results = []\n-        catalog = getToolByName(obj, \'portal_catalog\')\n-        obj_path = \'/\'.join(obj.getPhysicalPath())\n-\n-        breaches = self.check_object(obj)\n-        if breaches:\n-            results.append(breaches)\n-\n-        if IFolder.providedBy(obj):\n-            brains = catalog(path={\'query\': obj_path})\n-            for brain in brains:\n-                try:\n-                    child = brain.getObject()\n-                except (AttributeError, KeyError):\n-                    continue\n-                if child == obj:\n-                    continue\n-                breaches = self.check_object(obj=child, excluded_path=obj_path)\n-                if breaches:\n-                    results.append(breaches)\n-        self.breaches = results\n-        return results\n-\n-    def check_object(self, obj, excluded_path=None):\n+        # BBB: No direct usage is known, but keep this for backwards compatibility.\n+        # Sooner or later, we should use only one method.\n+        warnings.warn(\n+            """Using `get_breaches_for_item` is deprecated. Use `get_breaches`\n+                      instead.""",\n+            DeprecationWarning,\n+        )\n+        if obj is not None:\n+            obj = [obj]\n+        return self.get_breaches(obj)\n+\n+    def check_object(self, obj, excluded_path=None, excluded_paths=None):\n         """Check one object for breaches.\n-        Breaches originating from excluded_path are ignored.\n+        Breaches originating from excluded_paths are ignored.\n         """\n+        # BBB: Support old and new parameters likewise\n+        if excluded_paths is None:\n+            excluded_paths = set()\n+        if excluded_path:\n+            excluded_paths.add(excluded_path)\n+\n         breaches = {}\n         direct_links = getIncomingLinks(obj, from_attribute=None)\n         has_breaches = False\n@@ -153,34 +134,41 @@ def check_object(self, obj, excluded_path=None):\n             if not source_path:\n                 # link is broken\n                 continue\n-            if excluded_path and source_path.startswith(excluded_path):\n+            if any(\n+                [\n+                    source_path == excluded_path\n+                    or source_path.startswith(excluded_path + "/")\n+                    for excluded_path in excluded_paths\n+                ]\n+            ):\n                 # source is in excluded_path\n                 continue\n             source = direct_link.from_object\n-            if not breaches.get(\'sources\'):\n-                breaches[\'sources\'] = []\n-            breaches[\'sources\'].append({\n-                \'uid\': IUUID(source),\n-                \'title\': source.Title(),\n-                \'url\': source.absolute_url(),\n-                \'accessible\': self.is_accessible(source),\n-            })\n+            if not breaches.get("sources"):\n+                breaches["sources"] = []\n+            breaches["sources"].append(\n+                {\n+                    "uid": IUUID(source),\n+                    "title": source.Title(),\n+                    "url": source.absolute_url(),\n+                    "accessible": self.is_accessible(source),\n+                }\n+            )\n             has_breaches = True\n         if has_breaches:\n-            breaches[\'target\'] = {\n-                \'uid\': IUUID(obj),\n-                \'title\': obj.Title(),\n-                \'url\': obj.absolute_url(),\n-                \'portal_type\': obj.portal_type,\n-                \'type_title\': self.get_portal_type_title(obj),\n+            breaches["target"] = {\n+                "uid": IUUID(obj),\n+                "title": obj.Title(),\n+                "url": obj.absolute_url(),\n+                "portal_type": obj.portal_type,\n+                "type_title": self.get_portal_type_title(obj),\n             }\n             return breaches\n \n     def get_portal_type_title(self, obj):\n-        """Get the portal type title of the object.\n-        """\n+        """Get the portal type title of the object."""\n         context = aq_inner(self.context)\n-        portal_types = getToolByName(context, \'portal_types\')\n+        portal_types = getToolByName(context, "portal_types")\n         fti = portal_types.get(obj.portal_type)\n         if fti is not None:\n             type_title_msgid = fti.Title()\n@@ -193,4 +181,4 @@ def is_accessible(self, obj):\n         return _checkPermission(AccessContentsInformation, obj)\n \n     def objects(self):\n-        return [_(\'Objects in all\'), _(\'Folders\'), _(\'Published objects\')]\n+        return [_("Objects in all"), _("Folders"), _("Published objects")]\ndiff --git a/plone/app/linkintegrity/browser/update.pt b/plone/app/linkintegrity/browser/update.pt\nindex 483d6a2..f099245 100644\n--- a/plone/app/linkintegrity/browser/update.pt\n+++ b/plone/app/linkintegrity/browser/update.pt\n@@ -1,39 +1,58 @@\n-<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"\n-    xmlns:tal="http://xml.zope.org/namespaces/tal"\n-    xmlns:metal="http://xml.zope.org/namespaces/metal"\n-    xmlns:i18n="http://xml.zope.org/namespaces/i18n"\n-    lang="en"\n-    metal:use-macro="here/main_template/macros/master"\n-    i18n:domain="plone"\n-    tal:omit-tag="">\n-\n-<head>\n-  <metal:block\n-      fill-slot="top_slot"\n-      tal:define="dummy python:request.set(\'disable_border\',1)" />\n-</head>\n-\n-<body>\n-<metal:main fill-slot="main">\n-\n-  <h1 class="documentFirstHeading"\n-      i18n:translate="linkintegrity_update_title">Update link integrity information</h1>\n-\n-  <div id="content-core">\n-\n-    <p i18n:translate="linkintegrity_update_instructions">\n+<html xmlns="http://www.w3.org/1999/xhtml"\n+      xmlns:i18n="http://xml.zope.org/namespaces/i18n"\n+      xmlns:metal="http://xml.zope.org/namespaces/metal"\n+      xmlns:tal="http://xml.zope.org/namespaces/tal"\n+      lang="en"\n+      metal:use-macro="here/main_template/macros/master"\n+      xml:lang="en"\n+      tal:omit-tag=""\n+      i18n:domain="plone"\n+>\n+\n+  <head>\n+    <metal:block fill-slot="top_slot"\n+                 tal:define="\n+                   dummy python:request.set(\'disable_border\',1);\n+                 "\n+    />\n+  </head>\n+\n+  <body>\n+    <metal:main fill-slot="main">\n+\n+      <h1 class="documentFirstHeading"\n+          i18n:translate="linkintegrity_update_title"\n+      >Update link integrity information</h1>\n+\n+      <div id="content-core">\n+\n+        <p i18n:translate="linkintegrity_update_instructions">\n       Clicking the below button will cause link integrity information to be\n       updated. This might take a while, especially for bigger sites...\n-    </p>\n-\n-    <form method="post" action="updateLinkIntegrityInformation"\n-        tal:attributes="action request/URL">\n-      <input class="destructive" type="submit" name="update" value="Update" />\n-      <input class="standalone" type="submit" name="cancel" value="Cancel" />\n-    </form>\n-\n-  </div>\n-\n-</metal:main>\n-</body>\n+        </p>\n+\n+        <form action="updateLinkIntegrityInformation"\n+              method="post"\n+              tal:attributes="\n+                action request/URL;\n+              "\n+        >\n+          <input class="destructive"\n+                 name="update"\n+                 type="submit"\n+                 value="Update"\n+                 i18n:attributes="value"\n+          />\n+          <input class="standalone"\n+                 name="cancel"\n+                 type="submit"\n+                 value="Cancel"\n+                 i18n:attributes="value"\n+          />\n+        </form>\n+\n+      </div>\n+\n+    </metal:main>\n+  </body>\n </html>\ndiff --git a/plone/app/linkintegrity/browser/update.py b/plone/app/linkintegrity/browser/update.py\nindex 1141f61..4f51eb4 100644\n--- a/plone/app/linkintegrity/browser/update.py\n+++ b/plone/app/linkintegrity/browser/update.py\n@@ -1,66 +1,66 @@\n-# -*- coding: utf-8 -*-\n from Acquisition import aq_inner\n from datetime import datetime\n from datetime import timedelta\n from plone.app.linkintegrity.handlers import modifiedContent\n+from plone.base import PloneMessageFactory as _\n from Products.CMFCore.utils import getToolByName\n-from Products.CMFPlone import PloneMessageFactory as _\n from Products.Five import BrowserView\n from Products.statusmessages.interfaces import IStatusMessage\n from transaction import savepoint\n from zExceptions import NotFound\n \n import logging\n+\n+\n logger = logging.getLogger(__name__)\n \n \n class UpdateView(BrowserView):\n-    """Iterate over all catalogued items and update linkintegrity-information.\n-    """\n+    """Iterate over all catalogued items and update linkintegrity-information."""\n \n     def __call__(self):\n         context = aq_inner(self.context)\n         request = aq_inner(self.request)\n-        if \'update\' in request.form or \'delete_all\' in request.form:\n+        if "update" in request.form or "delete_all" in request.form:\n             starttime = datetime.now()\n             count = self.update()\n             duration = timedelta(seconds=(datetime.now() - starttime).seconds)\n             msg = _(\n-                u\'linkintegrity_update_info\',\n-                default=u\'Link integrity information updated for ${count} \' +\n-                        u\'items in ${time} seconds.\',\n-                mapping={\'count\': count, \'time\': str(duration)},\n+                "linkintegrity_update_info",\n+                default="Link integrity information updated for ${count} "\n+                + "items in ${time} seconds.",\n+                mapping={"count": count, "time": str(duration)},\n             )\n-            IStatusMessage(request).add(msg, type=\'info\')\n-            msg = \'Updated {0} items in {1} seconds\'.format(\n+            IStatusMessage(request).add(msg, type="info")\n+            msg = "Updated {} items in {} seconds".format(\n                 count,\n                 str(duration),\n             )\n             logger.info(msg)\n-            request.RESPONSE.redirect(getToolByName(context, \'portal_url\')())\n-        elif \'cancel\' in request.form:\n-            msg = _(u\'Update cancelled.\')\n-            IStatusMessage(request).add(msg, type=\'info\')\n-            request.RESPONSE.redirect(getToolByName(context, \'portal_url\')())\n+            request.RESPONSE.redirect(getToolByName(context, "portal_url")())\n+        elif "cancel" in request.form:\n+            msg = _("Update cancelled.")\n+            IStatusMessage(request).add(msg, type="info")\n+            request.RESPONSE.redirect(getToolByName(context, "portal_url")())\n         else:\n             return self.index()\n \n     def update(self):\n-        catalog = getToolByName(self.context, \'portal_catalog\')\n+        catalog = getToolByName(self.context, "portal_catalog")\n         count = 0\n \n         for brain in catalog():\n             try:\n                 obj = brain.getObject()\n             except (AttributeError, NotFound, KeyError):\n-                msg = \'Catalog inconsistency: {0} not found!\'\n+                msg = "Catalog inconsistency: {0} not found!"\n                 logger.error(msg.format(brain.getPath()), exc_info=1)\n                 continue\n             try:\n-                modifiedContent(obj, \'dummy event parameter\')\n+                modifiedContent(obj, "dummy event parameter")\n                 count += 1\n             except Exception:\n-                msg = \'Error updating linkintegrity-info for {0}.\'\n+                msg = "Error updating linkintegrity-info for {0}."\n                 logger.error(msg.format(obj.absolute_url()), exc_info=1)\n             if count % 1000 == 0:\n                 savepoint(optimistic=True)\ndiff --git a/plone/app/linkintegrity/compat.py b/plone/app/linkintegrity/compat.py\ndeleted file mode 100644\nindex 4dbe0d3..0000000\n--- a/plone/app/linkintegrity/compat.py\n+++ /dev/null\n@@ -1,14 +0,0 @@\n-# -*- coding: utf-8 -*-\n-# If Archetypes is not installed, define dummy objects\n-# to replace Archetypes imports.\n-try:\n-    from Products.Archetypes.interfaces import IBaseObject\n-    from Products.Archetypes.Field import TextField\n-except ImportError:\n-    from zope.interface import Interface\n-\n-    class IBaseObject(Interface):\n-        pass\n-\n-    class TextField(object):\n-        pass\ndiff --git a/plone/app/linkintegrity/configure.zcml b/plone/app/linkintegrity/configure.zcml\nindex cee6697..e3fa781 100644\n--- a/plone/app/linkintegrity/configure.zcml\n+++ b/plone/app/linkintegrity/configure.zcml\n@@ -2,56 +2,51 @@\n     xmlns="http://namespaces.zope.org/zope"\n     xmlns:browser="http://namespaces.zope.org/browser"\n     xmlns:genericsetup="http://namespaces.zope.org/genericsetup"\n-    xmlns:zcml="http://namespaces.zope.org/zcml">\n+    >\n \n-  <includeDependencies package="." />\n-  <include package="Products.CMFCore" file="permissions.zcml" />\n+  <include package="plone.app.intid" />\n+  <include package="plone.app.relationfield" />\n+  <include\n+      package="Products.CMFCore"\n+      file="permissions.zcml"\n+      />\n \n   <include package=".browser" />\n \n-  <adapter factory=".retriever.ATGeneral" />\n   <adapter factory=".retriever.DXGeneral" />\n \n-  <configure zcml:condition="installed Products.Archetypes">\n-    <subscriber\n-        for="Products.Archetypes.interfaces.IBaseObject\n-             OFS.interfaces.IObjectClonedEvent"\n-        handler=".handlers.modifiedContent" />\n-\n-    <subscriber\n-        for="Products.Archetypes.interfaces.IBaseObject\n-             zope.lifecycleevent.interfaces.IObjectCreatedEvent"\n-        handler=".handlers.modifiedContent" />\n-\n-    <subscriber\n-        for="Products.Archetypes.interfaces.IBaseObject\n-             zope.lifecycleevent.interfaces.IObjectModifiedEvent"\n-        handler=".handlers.modifiedContent" />\n-  </configure>\n-\n-  <configure zcml:condition="installed plone.dexterity">\n-    <subscriber\n-        for="plone.app.relationfield.interfaces.IDexterityHasRelations\n-             zope.lifecycleevent.interfaces.IObjectCopiedEvent"\n-        handler=".handlers.modifiedContent" />\n-\n-    <subscriber\n-        for="plone.app.relationfield.interfaces.IDexterityHasRelations\n-             zope.lifecycleevent.interfaces.IObjectAddedEvent"\n-        handler=".handlers.modifiedContent" />\n-\n-    <subscriber\n-        for="plone.app.relationfield.interfaces.IDexterityHasRelations\n-             zope.lifecycleevent.interfaces.IObjectModifiedEvent"\n-        handler=".handlers.modifiedContent" />\n-  </configure>\n+  <subscriber\n+      for="plone.app.relationfield.interfaces.IDexterityHasRelations\n+           zope.lifecycleevent.interfaces.IObjectCopiedEvent"\n+      handler=".handlers.modifiedContent"\n+      />\n+\n+  <subscriber\n+      for="plone.app.relationfield.interfaces.IDexterityHasRelations\n+           zope.lifecycleevent.interfaces.IObjectAddedEvent"\n+      handler=".handlers.modifiedContent"\n+      />\n+\n+  <subscriber\n+      for="plone.app.relationfield.interfaces.IDexterityHasRelations\n+           zope.lifecycleevent.interfaces.IObjectModifiedEvent"\n+      handler=".handlers.modifiedContent"\n+      />\n+\n+  <!-- Not zope.lifecycleevent.interfaces.IObjectRemovedEvent!\n+    That\'s too late to grep the intId. -->\n+  <subscriber\n+      for="plone.app.relationfield.interfaces.IDexterityHasRelations\n+           OFS.interfaces.IObjectWillBeRemovedEvent"\n+      handler=".handlers.removedContent"\n+      />\n \n   <genericsetup:registerProfile\n       name="default"\n       title="plone.app.linkintegrity"\n-      directory="profiles/default"\n       description="Installs the plone.app.linkintegrity add-on."\n       provides="Products.GenericSetup.interfaces.EXTENSION"\n+      directory="profiles/default"\n       />\n \n </configure>\ndiff --git a/plone/app/linkintegrity/exceptions.py b/plone/app/linkintegrity/exceptions.py\nindex a0cf407..41afee0 100644\n--- a/plone/app/linkintegrity/exceptions.py\n+++ b/plone/app/linkintegrity/exceptions.py\n@@ -1,21 +1,18 @@\n-# -*- coding: utf-8 -*-\n from OFS.ObjectManager import BeforeDeleteException\n from zope.interface import implementer\n from zope.interface import Interface\n \n \n class ILinkIntegrityNotificationException(Interface):\n-    """An exception indicating a prevented link integrity breach.\n-    """\n+    """An exception indicating a prevented link integrity breach."""\n \n \n @implementer(ILinkIntegrityNotificationException)\n class LinkIntegrityNotificationException(BeforeDeleteException):\n-    """An exception indicating a prevented link integrity breach.\n-    """\n+    """An exception indicating a prevented link integrity breach."""\n \n     def __str__(self):\n         args = self.args\n         if args and isinstance(args, tuple):\n             return repr(args[0])\n-        return super(LinkIntegrityNotificationException, self).__str__()\n+        return super().__str__()\ndiff --git a/plone/app/linkintegrity/handlers.py b/plone/app/linkintegrity/handlers.py\nindex 80771b0..29c02de 100644\n--- a/plone/app/linkintegrity/handlers.py\n+++ b/plone/app/linkintegrity/handlers.py\n@@ -1,54 +1,60 @@\n-# -*- coding: utf-8 -*-\n-from .compat import IBaseObject\n from Acquisition import aq_get\n from Acquisition import aq_parent\n from plone.app.linkintegrity.interfaces import IRetriever\n from plone.app.linkintegrity.utils import ensure_intid\n from plone.app.linkintegrity.utils import referencedRelationship\n-from plone.app.uuid.utils import uuidToObject\n+from plone.app.uuid.utils import uuidToCatalogBrain\n+from plone.base.interfaces import IEditingSchema\n+from plone.base.interfaces import IPloneSiteRoot\n from plone.dexterity.interfaces import IDexterityContent\n from plone.registry.interfaces import IRegistry\n from Products.CMFCore.utils import getToolByName\n-from Products.CMFPlone.interfaces import IEditingSchema\n-from Products.CMFPlone.interfaces import IPloneSiteRoot\n-from six.moves.urllib.parse import unquote\n-from six.moves.urllib.parse import urlsplit\n+from urllib.parse import unquote\n+from urllib.parse import urlsplit\n from z3c.relationfield import RelationValue\n from z3c.relationfield.event import _setRelation\n from zc.relation.interfaces import ICatalog\n from zExceptions import NotFound\n from ZODB.POSException import ConflictError\n from zope.component import getUtility\n-from zope.component.interfaces import ComponentLookupError\n+from zope.interface.interfaces import ComponentLookupError\n from zope.intid.interfaces import IIntIds\n from zope.publisher.interfaces import NotFound as ztkNotFound\n \n import logging\n-import six\n+\n \n logger = logging.getLogger(__name__)\n \n \n def findObject(base, path):\n-    """ traverse to given path and find the upmost object """\n-    if path.startswith(\'/\'):\n+    """traverse to given path and find the upmost object"""\n+    if path.startswith("/"):\n         # Make an absolute path relative to the portal root\n-        obj = getToolByName(base, \'portal_url\').getPortalObject()\n-        portal_path = obj.absolute_url_path() + \'/\'\n+        obj = getToolByName(base, "portal_url").getPortalObject()\n+        portal_path = obj.absolute_url_path() + "/"\n         if path.startswith(portal_path):\n-            path = path[len(portal_path):]\n+            path = path[len(portal_path) :]\n     else:\n-        obj = aq_parent(base)   # relative urls start at the parent...\n+        obj = aq_parent(base)  # relative urls start at the parent...\n \n-    components = path.split(\'/\')\n+    components = path.split("/")\n \n-    # Support resolveuid/UID paths explicitely, without relying\n+    # Support resolveuid/UID paths explicitly, without relying\n     # on a view or skinscript to do this for us.\n-    if \'resolveuid\' in components:\n-        uid = components[components.index(\'resolveuid\') + 1]\n-        obj = uuidToObject(uid)\n-        if obj:\n-            return obj, path\n+    if "resolveuid" in components:\n+        uid = components[components.index("resolveuid") + 1]\n+        # This may be a link to a page that once was published but not anymore,\n+        # or the current editor does not have View permission.\n+        # In that case uuidToObject(uid) could fail with Unauthorized.\n+        brain = uuidToCatalogBrain(uid)\n+        if brain is not None:\n+            # Note: _unrestrictedGetObject starts with an underscore,\n+            # but it is documented in ZCatalog.interfaces,\n+            # so should be safe to rely on.\n+            obj = brain._unrestrictedGetObject()\n+            if obj:\n+                return obj, path\n \n     while components:\n         child_id = unquote(components[0])\n@@ -56,24 +62,26 @@ def findObject(base, path):\n             try:\n                 child = obj.unrestrictedTraverse(child_id)\n             except AttributeError:\n-                request = aq_get(obj, \'REQUEST\')\n+                request = aq_get(obj, "REQUEST")\n                 child = request.traverseName(obj, child_id)\n         except ConflictError:\n             raise\n-        except (AttributeError, KeyError,\n-                NotFound, ztkNotFound, UnicodeEncodeError):\n+        except (AttributeError, KeyError, NotFound, ztkNotFound, UnicodeEncodeError):\n             return None, None\n-        if not IDexterityContent.providedBy(child) and \\\n-                not IBaseObject.providedBy(child) and \\\n-                not IPloneSiteRoot.providedBy(child):\n+        if not IDexterityContent.providedBy(child) and not IPloneSiteRoot.providedBy(\n+            child\n+        ):\n             break\n         obj = child\n         components.pop(0)\n-    return obj, \'/\'.join(components)\n+    return obj, "/".join(components)\n \n \n def getObjectsFromLinks(base, links):\n-    """ determine actual objects refered to by given links """\n+    """Determine actual objects referred to by given links.\n+\n+    return set of RelationValue\n+    """\n     intids = getUtility(IIntIds)\n     objects = set()\n     url = base.absolute_url()\n@@ -82,10 +90,6 @@ def getObjectsFromLinks(base, links):\n         s, h, path, q, f = urlsplit(link)\n         # relative or local url\n         if (not s and not h) or (s == scheme and h == host):\n-            # Paths should always be strings\n-            if six.PY2 and isinstance(path, six.text_type):\n-                path = path.encode(\'utf-8\')\n-\n             obj, extra = findObject(base, path)\n             if obj and not IPloneSiteRoot.providedBy(obj):\n                 objid = ensure_intid(obj, intids)\n@@ -110,6 +114,24 @@ def modifiedContent(obj, event):\n         updateReferences(obj, refs)\n \n \n+def removedContent(obj, event):\n+    if not check_linkintegrity_dependencies(obj):\n+        return\n+\n+    intids = getUtility(IIntIds)\n+    try:\n+        int_id = intids.getId(obj)\n+    except KeyError:\n+        return\n+\n+    catalog = getUtility(ICatalog)\n+    rels = catalog.findRelations(\n+        {"from_id": int_id, "from_attribute": referencedRelationship}\n+    )\n+    for rel in list(rels):\n+        catalog.unindex(rel)\n+\n+\n # BBB\n modifiedArchetype = modifiedContent\n modifiedDexterity = modifiedContent\n@@ -127,9 +149,12 @@ def updateReferences(obj, refs):\n         return\n     catalog = getUtility(ICatalog)\n     # unpack the rels before deleting\n-    old_rels = [i for i in catalog.findRelations(\n-        {\'from_id\': int_id,\n-         \'from_attribute\': referencedRelationship})]\n+    old_rels = [\n+        i\n+        for i in catalog.findRelations(\n+            {"from_id": int_id, "from_attribute": referencedRelationship}\n+        )\n+    ]\n     for old_rel in old_rels:\n         catalog.unindex(old_rel)\n     for ref in refs:\n@@ -139,12 +164,12 @@ def updateReferences(obj, refs):\n def check_linkintegrity_dependencies(obj):\n     try:\n         reg = getUtility(IRegistry)\n-        editing_settings = reg.forInterface(IEditingSchema, prefix=\'plone\')\n+        editing_settings = reg.forInterface(IEditingSchema, prefix="plone")\n     except (ComponentLookupError, KeyError):\n         return False\n     if not editing_settings.enable_link_integrity_checks:\n         return False\n-    if not getToolByName(obj, \'portal_url\', None):\n+    if not getToolByName(obj, "portal_url", None):\n         # `getObjectFromLinks` is not possible without access\n         # to `portal_url`\n         return False\ndiff --git a/plone/app/linkintegrity/interfaces.py b/plone/app/linkintegrity/interfaces.py\nindex e7ee638..44287b0 100644\n--- a/plone/app/linkintegrity/interfaces.py\n+++ b/plone/app/linkintegrity/interfaces.py\n@@ -1,10 +1,8 @@\n-# -*- coding: utf-8 -*-\n from zope.interface import Interface\n \n \n class IRetriever(Interface):\n-    """A retriever for links in a content type.\n-    """\n+    """A retriever for links in a content type."""\n \n     def retrieveLinks():\n-        """ retrieve links """\n+        """retrieve links"""\ndiff --git a/plone/app/linkintegrity/parser.py b/plone/app/linkintegrity/parser.py\nindex 2a756c4..55d97d6 100644\n--- a/plone/app/linkintegrity/parser.py\n+++ b/plone/app/linkintegrity/parser.py\n@@ -1,49 +1,59 @@\n-# -*- coding: utf-8 -*-\n-from six.moves.html_parser import HTMLParser\n-\n-try:\n-    from html.parser import HTMLParseError\n-except ImportError as e:\n-    # HTMLParseError is removed in Python 3.5. Since it can never be\n-    # thrown in 3.5, we can just define our own class as a placeholder.\n-    class HTMLParseError(Exception):\n-        pass\n+from html.parser import HTMLParser\n+\n+\n+TAG_ATTRS_TO_TRACK = {\n+    # The humble hyperlink.\n+    "a": ["href"],\n+    # The image.\n+    "img": ["src", "srcset"],\n+    # Used within img/picture/audio/video tags\n+    # to embed various sources of media.\n+    "source": ["src", "srcset"],\n+    # Embeds audio recordings.\n+    "audio": ["src"],\n+    # Embeds videos.\n+    "video": ["src"],\n+    # Used to embed PDFs.\n+    "iframe": ["src"],\n+}\n \n \n class LinkParser(HTMLParser):\n-    """A simple html parser for link and image urls.\n-    """\n+    """A simple html parser for link and image urls."""\n \n     def __init__(self):\n         HTMLParser.__init__(self)\n         self.links = []\n \n     def getLinks(self):\n-        """Return all links found during parsing.\n-        """\n+        """Return all links found during parsing."""\n         return tuple(self.links)\n \n     def handle_starttag(self, tag, attrs):\n-        """Override the method to remember all links.\n-        """\n-        if tag == \'a\':\n-            self.links.extend(search_attr(\'href\', attrs))\n-        if tag == \'img\':\n-            self.links.extend(search_attr(\'src\', attrs))\n+        """Override the method to remember all links."""\n+        for at in TAG_ATTRS_TO_TRACK.get(tag.lower(), []):\n+            self.links.extend(search_attr(at, attrs))\n+\n+\n+def links_in_srcset(attrval):\n+    # SRCSET is split by commas, and each line\'s first\n+    # element is the URL in question.\n+    # Yes, this means that spaces in such a link must be\n+    # encoded with %20 or +.  That is what the written\n+    # standard implies.\n+    return [src.strip().split()[0] for src in attrval.split(",")]\n \n \n def search_attr(name, attrs):\n-    """Search named attribute in a list of attributes.\n-    """\n+    """Search named attribute in a list of attributes."""\n     for attr, value in attrs:\n         if attr == name:\n-            return [value]\n+            return links_in_srcset(value) if name == "srcset" else [value]\n     return []\n \n \n-def extractLinks(data, encoding=\'utf-8\'):\n-    """Parse the given html and return all links.\n-    """\n+def extractLinks(data, encoding="utf-8"):\n+    """Parse the given html and return all links."""\n     if not data:\n         return []\n     parser = LinkParser()\n@@ -54,7 +64,7 @@ def extractLinks(data, encoding=\'utf-8\'):\n         parser = LinkParser()\n         parser.feed(data.decode(encoding))\n         parser.close()\n-    except (HTMLParseError, TypeError):\n+    except TypeError:\n         pass\n \n     return parser.getLinks()\ndiff --git a/plone/app/linkintegrity/profiles/default/metadata.xml b/plone/app/linkintegrity/profiles/default/metadata.xml\nindex 3d93a8e..ffe02eb 100644\n--- a/plone/app/linkintegrity/profiles/default/metadata.xml\n+++ b/plone/app/linkintegrity/profiles/default/metadata.xml\n@@ -1,4 +1,4 @@\n-<?xml version="1.0"?>\n+<?xml version="1.0" encoding="utf-8"?>\n <metadata>\n   <version>1000</version>\n   <dependencies>\ndiff --git a/plone/app/linkintegrity/retriever.py b/plone/app/linkintegrity/retriever.py\nindex 7768e11..81c6d7d 100644\n--- a/plone/app/linkintegrity/retriever.py\n+++ b/plone/app/linkintegrity/retriever.py\n@@ -1,8 +1,6 @@\n-# -*- coding: utf-8 -*-\n """Link Integrity - link retriever methods.\n """\n-from .compat import IBaseObject\n-from .compat import TextField\n+\n from plone.app.linkintegrity.interfaces import IRetriever\n from plone.app.linkintegrity.parser import extractLinks\n from plone.app.textfield import RichText\n@@ -15,56 +13,28 @@\n from zope.schema import getFieldsInOrder\n \n \n-@implementer(IRetriever)\n-@adapter(IBaseObject)\n-class ATGeneral(object):\n-    """General retriever for AT that extracts URLs from (rich) text fields.\n-    """\n-\n-    def __init__(self, context):\n-        self.context = context\n-\n-    def retrieveLinks(self):\n-        """Finds all links from the object and return them.\n-        """\n-        links = set()\n-        for field in self.context.Schema().fields():\n-            if isinstance(field, TextField):\n-                accessor = field.getAccessor(self.context)\n-                encoding = field.getRaw(self.context, raw=1).original_encoding\n-                if accessor is not None:\n-                    value = accessor()\n-                else:\n-                    # Fields that have been added via schema extension do\n-                    # not have an accessor method.\n-                    value = field.get(self.context)\n-                links |= set(extractLinks(value, encoding))\n-        return links\n-\n-\n @implementer(IRetriever)\n @adapter(IDexterityContent)\n-class DXGeneral(object):\n-    """General retriever for DX that extracts URLs from (rich) text fields.\n-    """\n+class DXGeneral:\n+    """General retriever for DX that extracts URLs from (rich) text fields."""\n \n     def __init__(self, context):\n         self.context = context\n \n     def retrieveLinks(self):\n-        """Finds all links from the object and return them.\n-        """\n+        """Finds all links from the object and return them."""\n         fti = getUtility(IDexterityFTI, name=self.context.portal_type)\n         schema = fti.lookupSchema()\n         additional_schema = getAdditionalSchemata(\n-            context=self.context, portal_type=self.context.portal_type)\n+            context=self.context, portal_type=self.context.portal_type\n+        )\n         schemas = [i for i in additional_schema] + [schema]\n         links = set()\n         for schema in schemas:\n             for name, field in getFieldsInOrder(schema):\n                 if isinstance(field, RichText):\n                     value = getattr(schema(self.context), name)\n-                    if not value or not getattr(value, \'raw\', None):\n+                    if not value or not getattr(value, "raw", None):\n                         continue\n                     links |= set(extractLinks(value.raw))\n         return links\ndiff --git a/plone/app/linkintegrity/testing.py b/plone/app/linkintegrity/testing.py\nindex bd1cd96..518541b 100644\n--- a/plone/app/linkintegrity/testing.py\n+++ b/plone/app/linkintegrity/testing.py\n@@ -1,27 +1,23 @@\n-# -*- coding: utf-8 -*-\n-from base64 import decodestring\n-from plone.app.contenttypes.testing import PLONE_APP_CONTENTTYPES_FIXTURE\n-from plone.app.contenttypes.testing import PLONE_APP_CONTENTTYPES_MIGRATION_FIXTURE  # noqa\n+from base64 import decodebytes\n from plone.app.testing import layers\n from plone.app.testing import login\n from plone.app.testing import PLONE_FIXTURE\n-from plone.app.testing import ploneSite\n+from plone.app.testing import PloneSandboxLayer\n from plone.app.testing import setRoles\n from plone.app.testing import TEST_USER_ID\n from plone.app.testing import TEST_USER_NAME\n from plone.app.testing import TEST_USER_PASSWORD\n from plone.namedfile.file import NamedImage\n-from plone.testing import z2\n from Products.CMFCore.utils import getToolByName\n from zope.configuration import xmlconfig\n \n-import six\n+import io\n \n \n-B64_DATA = b\'R0lGODlhAQABAIAAAAUEBAAAACwAAAAAAQABAAACAkQBADs=\'\n-GIF = six.BytesIO(decodestring(B64_DATA))\n-GIF.filename = \'sample.gif\'\n-GIF.contentType = \'image/gif\'\n+B64_DATA = b"R0lGODlhAQABAIAAAAUEBAAAACwAAAAAAQABAAACAkQBADs="\n+GIF = io.BytesIO(decodebytes(B64_DATA))\n+GIF.filename = "sample.gif"\n+GIF.contentType = "image/gif"\n GIF._width = 1\n GIF._height = 1\n \n@@ -30,134 +26,65 @@ def create(container, type_name, **kwargs):\n     """A easy helper method to create some content since we do not have\n     plone.api in core.\n     """\n-\n     new_id = container.invokeFactory(type_name, **kwargs)\n     content = container[new_id]\n-\n-    # Archetypes specific code was taken from ``plone.api``\n-    # Switch when api has been merged into core.\n-    if six.PY2:\n-        from Products.Archetypes.interfaces import IBaseObject\n-        if IBaseObject.providedBy(content):\n-            content.processForm()\n-\n     return content\n \n \n-class LinkIntegrityLayer(z2.Layer):\n-    """Base Layer for AT and Dexterity testing.\n-    """\n-\n-    defaultBases = (PLONE_FIXTURE, )\n+class LinkIntegrityLayer(PloneSandboxLayer):\n+    """Base Layer for Dexterity testing."""\n \n-    def setUpMembers(self, portal):\n-        pm = getToolByName(portal, \'portal_membership\')\n-        pm.addMember(\'editor\', TEST_USER_PASSWORD, [\'Editor\'], [])\n-        pm.addMember(\'member\', TEST_USER_PASSWORD, [\'Member\'], [])\n-        pm.addMember(\'authenticated\', TEST_USER_PASSWORD, [], [])\n+    defaultBases = (PLONE_FIXTURE,)\n \n-    def setUpContent(self):\n+    def setUpZope(self, app, configurationContext):\n         import plone.app.linkintegrity\n-        xmlconfig.file(\'configure.zcml\', plone.app.linkintegrity,\n-                       context=self[\'configurationContext\'])\n-\n-        with z2.zopeApp() as app:\n-            z2.installProduct(app, \'plone.app.linkintegrity\')\n-\n-        with ploneSite() as portal:\n-            setRoles(portal, TEST_USER_ID, [\'Manager\', ])\n-            login(portal, TEST_USER_NAME)\n-\n-            # Create sample documents\n-            type_data = dict(type_name=\'Document\')\n-            for i in range(1, 4):\n-                type_data[\'id\'] = \'doc{0:d}\'.format(i)\n-                type_data[\'title\'] = \'Test Page {0:d}\'.format(i)\n-                create(portal, **type_data)\n \n-            create(portal, \'File\', id=\'file1\', title=\'File 1\', file=GIF)\n-            create(portal, \'Folder\', id=\'folder1\', title=\'Folder 1\')\n-            subfolder = portal[\'folder1\']\n-            create(subfolder, \'Document\', id=\'doc4\', title=\'Test Page 4\')\n-\n-            self.setUpMembers(portal)\n-\n-    def tearDown(self):\n-        with z2.zopeApp() as app:\n-            z2.uninstallProduct(app, \'plone.app.linkintegrity\')\n+        xmlconfig.file(\n+            "configure.zcml", plone.app.linkintegrity, context=configurationContext\n+        )\n+\n+    def setUpPloneSite(self, portal):\n+        setRoles(\n+            portal,\n+            TEST_USER_ID,\n+            [\n+                "Manager",\n+            ],\n+        )\n+        login(portal, TEST_USER_NAME)\n+\n+        # Create sample documents\n+        type_data = dict(type_name="Document")\n+        for i in range(1, 4):\n+            type_data["id"] = f"doc{i:d}"\n+            type_data["title"] = f"Test Page {i:d}"\n+            create(portal, **type_data)\n+\n+        create(portal, "File", id="file1", title="File 1", file=GIF)\n+        create(portal, "Folder", id="folder1", title="Folder 1")\n+        subfolder = portal["folder1"]\n+        create(subfolder, "Document", id="doc4", title="Test Page 4")\n+\n+        # setup members\n+        pm = getToolByName(portal, "portal_membership")\n+        pm.addMember("editor", TEST_USER_PASSWORD, ["Editor"], [])\n+        pm.addMember("member", TEST_USER_PASSWORD, ["Member"], [])\n+        pm.addMember("authenticated", TEST_USER_PASSWORD, [], [])\n+\n+        # Create an object that does not provide the behavior to live along\n+        create(portal, "News Item", id="news1", title="News 1")\n+\n+        # create a NamedImage\n+        portal.invokeFactory("Image", "image1")\n+        portal["image1"].image = NamedImage(GIF, "image/gif", "sample.gif")\n \n \n PLONE_APP_LINKINTEGRITY_FIXTURE = LinkIntegrityLayer()\n \n-\n-class LinkIntegrityATLayer(LinkIntegrityLayer):\n-    """Layer which targets testing with Archetypes and ATContentTypes.\n-    """\n-\n-    directory = \'at\'\n-    defaultBases = (\n-        PLONE_APP_CONTENTTYPES_MIGRATION_FIXTURE,\n-        PLONE_APP_LINKINTEGRITY_FIXTURE,\n-    )\n-\n-    def setUp(self):\n-        self.setUpContent()\n-\n-    def setUpContent(self):\n-        super(LinkIntegrityATLayer, self).setUpContent()\n-\n-        with ploneSite() as portal:\n-            create(portal, \'Image\', id=\'image1\', title=\'Image 1\', image=GIF)\n-\n-\n-PLONE_APP_LINKINTEGRITY_AT_FIXTURE = LinkIntegrityATLayer()\n-\n-\n-class LinkIntegrityDXLayer(LinkIntegrityLayer):\n-    """Layer which targets testing with Dexterity.\n-    """\n-\n-    directory = \'dx\'\n-    defaultBases = (\n-        PLONE_APP_CONTENTTYPES_FIXTURE,\n-        PLONE_APP_LINKINTEGRITY_FIXTURE,\n-    )\n-\n-    def setUp(self):\n-        self.setUpContent()\n-\n-    def setUpContent(self):\n-        super(LinkIntegrityDXLayer, self).setUpContent()\n-\n-        with ploneSite() as portal:\n-            # Create an object that does not provide the behavior to live along\n-            create(portal, \'News Item\', id=\'news1\', title=\'News 1\')\n-\n-            # create a DX NamedImage\n-            portal.invokeFactory(\'Image\', \'image1\')\n-            portal[\'image1\'].image = NamedImage(GIF, \'image/gif\',\n-                                                u\'sample.gif\')\n-\n-\n-PLONE_APP_LINKINTEGRITY_DX_FIXTURE = LinkIntegrityDXLayer()\n-\n-PLONE_APP_LINKINTEGRITY_DX_INTEGRATION_TESTING = layers.IntegrationTesting(\n-    bases=(PLONE_APP_LINKINTEGRITY_DX_FIXTURE, ),\n-    name=\'plone.app.linkintegrity:DX:Integration\'\n+PLONE_APP_LINKINTEGRITY_INTEGRATION_TESTING = layers.IntegrationTesting(\n+    bases=(PLONE_APP_LINKINTEGRITY_FIXTURE,), name="plone.app.linkintegrity:Integration"\n )\n \n-PLONE_APP_LINKINTEGRITY_DX_FUNCTIONAL_TESTING = layers.FunctionalTesting(\n-    bases=(PLONE_APP_LINKINTEGRITY_DX_FIXTURE, ),\n-    name=\'plone.app.linkintegrity:DX:Functional\'\n+PLONE_APP_LINKINTEGRITY_FUNCTIONAL_TESTING = layers.FunctionalTesting(\n+    bases=(PLONE_APP_LINKINTEGRITY_FIXTURE,), name="plone.app.linkintegrity:Functional"\n )\n-\n-if six.PY2:\n-    PLONE_APP_LINKINTEGRITY_AT_INTEGRATION_TESTING = layers.IntegrationTesting(\n-        bases=(PLONE_APP_LINKINTEGRITY_AT_FIXTURE, ),\n-        name=\'plone.app.linkintegrity:AT:Integration\'\n-    )\n-\n-    PLONE_APP_LINKINTEGRITY_AT_FUNCTIONAL_TESTING = layers.FunctionalTesting(\n-        bases=(PLONE_APP_LINKINTEGRITY_AT_FIXTURE, ),\n-        name=\'plone.app.linkintegrity:AT:Functional\'\n-    )\ndiff --git a/plone/app/linkintegrity/tests/__init__.py b/plone/app/linkintegrity/tests/__init__.py\nindex 336bbe1..dcdcd54 100644\n--- a/plone/app/linkintegrity/tests/__init__.py\n+++ b/plone/app/linkintegrity/tests/__init__.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n # tests package\n # to run all tests type \'.../bin/instance test -s plone.app.linkintegrity\'\n \n@@ -6,4 +5,4 @@\n import warnings\n \n \n-warnings.filterwarnings(\'ignore\', \'.*\', DeprecationWarning)\n+warnings.filterwarnings("ignore", ".*", DeprecationWarning)\ndiff --git a/plone/app/linkintegrity/tests/base.py b/plone/app/linkintegrity/tests/base.py\ndeleted file mode 100644\nindex 55e05f2..0000000\n--- a/plone/app/linkintegrity/tests/base.py\n+++ /dev/null\n@@ -1,87 +0,0 @@\n-# -*- coding: utf-8 -*-\n-from plone.app.linkintegrity import testing\n-from plone.app.relationfield.behavior import IRelatedItems\n-from plone.app.testing import setRoles\n-from plone.app.testing import TEST_USER_ID\n-from plone.app.testing import TEST_USER_NAME\n-from plone.app.testing import TEST_USER_PASSWORD\n-from plone.app.textfield import RichTextValue\n-from plone.testing.z2 import Browser\n-from z3c.form.interfaces import IFormLayer\n-from zope.component import getMultiAdapter\n-from zope.interface import alsoProvides\n-from zope.lifecycleevent import modified\n-\n-import six\n-import unittest\n-\n-\n-class BaseTestCase(unittest.TestCase):\n-\n-    def setUp(self):\n-        self.portal = self.layer[\'portal\']\n-        self.request = self.layer[\'request\']\n-        alsoProvides(self.request, IFormLayer)\n-\n-        # Get a testbrowser\n-        self.browser = Browser(self.layer[\'app\'])\n-        self.browser.handleErrors = False\n-        self.browser.addHeader(\'Referer\', self.portal.absolute_url())\n-        self.browser.addHeader(\n-            \'Authorization\',\n-            \'Basic {0:s}:{1:s}\'.format(TEST_USER_NAME, TEST_USER_PASSWORD))\n-\n-        # Do an initial page load to make sure the bundles get compiled\n-        # (which currently commits a transaction)\n-        # before we render exception views\n-        self.browser.open(self.portal.absolute_url())\n-\n-        setRoles(self.portal, TEST_USER_ID, [\'Manager\', ])\n-\n-    def _get_token(self, obj):\n-        return getMultiAdapter(\n-            (obj, self.request), name=\'authenticator\').token()\n-\n-\n-class DXBaseTestCase(BaseTestCase):\n-    """Base testcase for testing Dexterity content types"""\n-\n-    layer = testing.PLONE_APP_LINKINTEGRITY_DX_FUNCTIONAL_TESTING\n-\n-    def _set_text(self, obj, text):\n-        obj.text = RichTextValue(text)\n-        modified(obj)\n-\n-    def _get_text(self, obj):\n-        return obj.text.raw\n-\n-    def _set_related_items(self, obj, items):\n-        assert IRelatedItems.providedBy(obj)\n-        setattr(obj, \'relatedItems\', items)\n-        modified(obj)\n-\n-    def _get_related_items(self, obj):\n-        return obj.relatedItems\n-\n-\n-if six.PY2:\n-    class ATBaseTestCase(BaseTestCase):\n-        """Base testcase for testing Archetypes content types"""\n-\n-        layer = testing.PLONE_APP_LINKINTEGRITY_AT_FUNCTIONAL_TESTING\n-\n-        def _set_text(self, obj, text):\n-            obj.setText(text, mimetype=\'text/html\')\n-            modified(obj)\n-\n-        def _get_text(self, obj):\n-            # This is the equivalent to obj.text in dexterity. No transforms,\n-            # no rewritten relative urls\n-            return obj.getText(raw=1).raw\n-\n-        def _set_related_items(self, obj, items):\n-            obj.setRelatedItems(items)\n-            modified(obj)\n-\n-        def _get_related_items(self, obj):\n-            return obj.getRelatedItems()\ndiff --git a/plone/app/linkintegrity/tests/test_circular.py b/plone/app/linkintegrity/tests/test_circular.py\nindex 9f869e7..807cc67 100644\n--- a/plone/app/linkintegrity/tests/test_circular.py\n+++ b/plone/app/linkintegrity/tests/test_circular.py\n@@ -1,25 +1,38 @@\n-# -*- coding: utf-8 -*-\n+from plone.app.linkintegrity import testing\n from plone.app.linkintegrity.browser.info import DeleteConfirmationInfo\n from plone.app.linkintegrity.testing import create\n-from plone.app.linkintegrity.tests.base import DXBaseTestCase\n+from plone.app.linkintegrity.tests.utils import set_text\n from plone.app.linkintegrity.utils import getOutgoingLinks\n from plone.app.linkintegrity.utils import hasIncomingLinks\n+from plone.app.textfield import RichTextValue\n+from zope.lifecycleevent import modified\n \n-import six\n+import unittest\n \n \n-class CircularReferencesTestCase:\n+class CircularReferencesTestCase(unittest.TestCase):\n+    """Circular reference testcase"""\n+\n+    layer = testing.PLONE_APP_LINKINTEGRITY_INTEGRATION_TESTING\n+\n+    def setUp(self):\n+        self.portal = self.layer["portal"]\n+        self.request = self.layer["request"]\n+\n+    def _set_text(self, obj, text):\n+        obj.text = RichTextValue(text)\n+        modified(obj)\n \n     def test_circular_reference_manages_relations(self):\n-        doc1 = self.portal[\'doc1\']\n-        doc2 = self.portal[\'doc2\']\n-        doc3 = self.portal[\'doc3\']\n+        doc1 = self.portal["doc1"]\n+        doc2 = self.portal["doc2"]\n+        doc3 = self.portal["doc3"]\n         self.assertFalse(hasIncomingLinks(doc1))\n         self.assertFalse(hasIncomingLinks(doc2))\n         self.assertFalse(hasIncomingLinks(doc3))\n-        self._set_text(doc1, \'<a href="doc2">doc2</a>\')\n-        self._set_text(doc2, \'<a href="doc3">doc3</a>\')\n-        self._set_text(doc3, \'<a href="doc1">doc1</a>\')\n+        set_text(doc1, \'<a href="doc2">doc2</a>\')\n+        set_text(doc2, \'<a href="doc3">doc3</a>\')\n+        set_text(doc3, \'<a href="doc1">doc1</a>\')\n         self.assertTrue(hasIncomingLinks(doc1))\n         self.assertTrue(hasIncomingLinks(doc2))\n         self.assertTrue(hasIncomingLinks(doc3))\n@@ -33,10 +46,10 @@ def test_circular_reference_subfolder_deletion(self):\n \n         # This tests the behaviour when removing objects\n         # referencing each other in a circle.\n-        self._set_text(doc1, \'<a href="doc2">documents...</a>\')\n-        self._set_text(doc2, \'<a href="doc3">go round...</a>\')\n-        self._set_text(doc3, \'<a href="folder1/doc4">and round.</a>\')\n-        self._set_text(doc4, \'<a href="../doc1">in circles.</a>\')\n+        set_text(doc1, \'<a href="doc2">documents...</a>\')\n+        set_text(doc2, \'<a href="doc3">go round...</a>\')\n+        set_text(doc3, \'<a href="folder1/doc4">and round.</a>\')\n+        set_text(doc4, \'<a href="../doc1">in circles.</a>\')\n \n         self.assertEqual([r.to_object for r in getOutgoingLinks(doc1)], [doc2])\n         self.assertEqual([r.to_object for r in getOutgoingLinks(doc2)], [doc3])\n@@ -45,27 +58,24 @@ def test_circular_reference_subfolder_deletion(self):\n \n         view = DeleteConfirmationInfo(self.portal, self.request)\n         self.assertEqual(len(view.get_breaches([folder1])), 1)\n-        self.assertEqual(\n-            len(view.get_breaches([doc1, doc2, doc3, folder1])), 0)\n+        self.assertEqual(len(view.get_breaches([doc1, doc2, doc3, folder1])), 0)\n         self.assertEqual(len(view.get_breaches([doc2, folder1])), 2)\n \n     def test_internal_breaches_are_dropped(self):\n         folder1 = self.portal.folder1\n-        create(folder1, \'Document\', id=\'doc5\', title=\'Test Page 5\')\n+        create(folder1, "Document", id="doc5", title="Test Page 5")\n         doc1 = self.portal.doc1\n         doc4 = self.portal.folder1.doc4\n         doc5 = self.portal.folder1.doc5\n-        self._set_text(doc1, \'<a href="folder1">f1</a>\')\n-        self._set_text(doc4, \'<a href="doc5">d5</a><a href="../doc1">d1</a>\')\n-        self._set_text(doc5, \'<a href="../folder1">f1</a>\')\n+        set_text(doc1, \'<a href="folder1">f1</a>\')\n+        set_text(doc4, \'<a href="doc5">d5</a><a href="../doc1">d1</a>\')\n+        set_text(doc5, \'<a href="../folder1">f1</a>\')\n \n-        doc4_breaches = set([r.to_object for r in getOutgoingLinks(doc4)])\n+        doc4_breaches = {r.to_object for r in getOutgoingLinks(doc4)}\n         # the order of breaches is non-deterministic\n-        self.assertEqual(set([doc1, doc5]), doc4_breaches)\n-        self.assertEqual(\n-            [r.to_object for r in getOutgoingLinks(doc5)], [folder1])\n-        self.assertEqual(\n-            [r.to_object for r in getOutgoingLinks(doc1)], [folder1])\n+        self.assertEqual({doc1, doc5}, doc4_breaches)\n+        self.assertEqual([r.to_object for r in getOutgoingLinks(doc5)], [folder1])\n+        self.assertEqual([r.to_object for r in getOutgoingLinks(doc1)], [folder1])\n         view = DeleteConfirmationInfo(self.portal, self.request)\n         self.assertEqual(len(view.get_breaches([doc4])), 0)\n         self.assertEqual(len(view.get_breaches([doc5])), 1)\n@@ -74,20 +84,11 @@ def test_internal_breaches_are_dropped(self):\n         self.assertEqual(len(view.get_breaches([doc1])), 1)\n         self.assertEqual(len(view.get_breaches([doc1, folder1])), 0)\n \n-        view = folder1.restrictedTraverse(\'delete_confirmation\')\n-        self.assertIn(\'Potential link breakage\', view())\n-        view = folder1.restrictedTraverse(\'delete_confirmation_info\')\n-        self.assertIn(\'Potential link breakage\', view())\n-        view = doc4.restrictedTraverse(\'delete_confirmation\')\n-        self.assertNotIn(\'Potential link breakage\', view())\n-        view = doc4.restrictedTraverse(\'delete_confirmation_info\')\n-        self.assertNotIn(\'Potential link breakage\', view())\n-\n-\n-class CircularReferencesDXTestCase(DXBaseTestCase, CircularReferencesTestCase):\n-    """Circular reference testcase for dx content types"""\n-\n-if six.PY2:\n-    from plone.app.linkintegrity.tests.base import ATBaseTestCase\n-    class CircularReferencesATTestCase(ATBaseTestCase, CircularReferencesTestCase):\n-        """Circular reference testcase for dx content types"""\n+        view = folder1.restrictedTraverse("delete_confirmation")\n+        self.assertIn("Potential link breakage", view())\n+        view = folder1.restrictedTraverse("delete_confirmation_info")\n+        self.assertIn("Potential link breakage", view())\n+        view = doc4.restrictedTraverse("delete_confirmation")\n+        self.assertNotIn("Potential link breakage", view())\n+        view = doc4.restrictedTraverse("delete_confirmation_info")\n+        self.assertNotIn("Potential link breakage", view())\ndiff --git a/plone/app/linkintegrity/tests/test_functional.py b/plone/app/linkintegrity/tests/test_functional.py\nindex 2b68e7c..430b397 100644\n--- a/plone/app/linkintegrity/tests/test_functional.py\n+++ b/plone/app/linkintegrity/tests/test_functional.py\n@@ -1,73 +1,107 @@\n-# -*- coding: utf-8 -*-\n from plone.app.linkintegrity import testing\n-from plone.app.linkintegrity.tests.base import DXBaseTestCase\n-# from plone.app.linkintegrity.utils import hasIncomingLinks\n+from plone.app.linkintegrity.tests.utils import set_text\n from plone.app.linkintegrity.utils import getIncomingLinks\n from plone.app.linkintegrity.utils import getOutgoingLinks\n from plone.app.linkintegrity.utils import hasOutgoingLinks\n+from plone.app.testing import setRoles\n+from plone.app.testing import TEST_USER_ID\n from plone.app.testing import TEST_USER_NAME\n from plone.app.testing import TEST_USER_PASSWORD\n+from plone.base.interfaces import IEditingSchema\n from plone.registry.interfaces import IRegistry\n-from plone.testing.z2 import Browser\n-from Products.CMFPlone.interfaces import IEditingSchema\n+from plone.testing.zope import Browser\n from zc.relation.interfaces import ICatalog\n+from zope.component import getMultiAdapter\n from zope.component import getUtility\n \n-import six\n+import re\n import transaction\n import unittest\n \n \n-class ReferenceTestCase:\n+class FunctionalReferenceTestCase(unittest.TestCase):\n+    """functional reference testcase"""\n \n-    @unittest.skip(\'Re-enable after https://github.com/plone/plone.app.content/issues/38\')  # noqa\n+    layer = testing.PLONE_APP_LINKINTEGRITY_FUNCTIONAL_TESTING\n+\n+    def setUp(self):\n+        self.portal = self.layer["portal"]\n+        self.request = self.layer["request"]\n+        # alsoProvides(self.request, IFormLayer)\n+\n+        # Get a testbrowser\n+        self.browser = Browser(self.layer["app"])\n+        self.browser.handleErrors = False\n+        self.browser.addHeader("Referer", self.portal.absolute_url())\n+        self.browser.addHeader(\n+            "Authorization", f"Basic {TEST_USER_NAME:s}:{TEST_USER_PASSWORD:s}"\n+        )\n+\n+        # Do an initial page load to make sure the bundles get compiled\n+        # (which currently commits a transaction)\n+        # before we render exception views\n+        self.browser.open(self.portal.absolute_url())\n+\n+        setRoles(\n+            self.portal,\n+            TEST_USER_ID,\n+            [\n+                "Manager",\n+            ],\n+        )\n+\n+    def _get_token(self, obj):\n+        return getMultiAdapter((obj, self.request), name="authenticator").token()\n+\n+    @unittest.skip(\n+        "Re-enable after https://github.com/plone/plone.app.content/issues/38"\n+    )  # noqa\n     def test_file_reference_linkintegrity_page_is_shown(self):\n         doc1 = self.portal.doc1\n-        file2 = testing.create(self.portal, \'File\',\n-                               id=\'file2\', file=testing.GIF)\n+        file2 = testing.create(self.portal, "File", id="file2", file=testing.GIF)\n \n         self.assertFalse(hasOutgoingLinks(doc1))\n-        self._set_text(doc1, \'<a href="file2">A File</a>\')\n+        set_text(doc1, \'<a href="file2">A File</a>\')\n         self.assertTrue(hasOutgoingLinks(doc1))\n-        self.assertIn(\'file2\', self.portal.objectIds())\n+        self.assertIn("file2", self.portal.objectIds())\n \n         token = self._get_token(file2)\n-        self.request[\'_authenticator\'] = token\n+        self.request["_authenticator"] = token\n \n         # Make changes visible to test browser\n         transaction.commit()\n \n         self.browser.handleErrors = True\n         self.browser.addHeader(\n-            \'Authorization\',\n-            \'Basic {0:s}:{1:s}\'.format(TEST_USER_NAME, TEST_USER_PASSWORD))\n+            "Authorization", f"Basic {TEST_USER_NAME:s}:{TEST_USER_PASSWORD:s}"\n+        )\n \n-        delete_url = \'{0:s}/delete_confirmation?_authenticator={1:s}\'.format(\n-            file2.absolute_url(), token)\n+        delete_url = "{:s}/delete_confirmation?_authenticator={:s}".format(\n+            file2.absolute_url(), token\n+        )\n \n         # Try to remove but cancel\n         self.browser.open(delete_url)\n \n         # Validate text\n-        self.assertIn(\'Potential link breakage\', self.browser.contents)\n-        self.assertIn(\'<a href="http://nohost/plone/doc1">Test Page 1</a>\',\n-                      self.browser.contents)\n-        self.assertIn(\'Would you like to delete it anyway?\',\n-                      self.browser.contents)\n+        self.assertIn("Potential link breakage", self.browser.contents)\n+        self.assertIn(\n+            \'<a href="http://nohost/plone/doc1">Test Page 1</a>\', self.browser.contents\n+        )\n+        self.assertIn("Would you like to delete it anyway?", self.browser.contents)\n \n         # Click cancel button, item should stay in place\n-        # FIXME! This fails in Archetypes because the redirect\n-        # plone.app.content.browser.actions.DeleteConfirmationForm.handle_cancel\n-        # is broken for AT-content.\n-        self.browser.getControl(name=\'form.buttons.Cancel\').click()\n-        self.assertEqual(self.browser.url, file2.absolute_url() + \'/view\')\n-        self.assertIn(\'Removal cancelled.\', self.browser.contents)\n-        self.assertIn(\'file2\', self.portal.objectIds())\n+        # FIXME! This fails in Plone 6 with an internal server error,\n+        # but maybe no longer for the original reasons for which we skip this test.\n+        self.browser.getControl(name="form.buttons.Cancel").click()\n+        self.assertEqual(self.browser.url, file2.absolute_url() + "/view")\n+        self.assertIn("Removal cancelled.", self.browser.contents)\n+        self.assertIn("file2", self.portal.objectIds())\n \n         # Try to remove and confirm\n         self.browser.open(delete_url)\n-        self.browser.getControl(name=\'form.buttons.Delete\').click()\n-        self.assertNotIn(\'file2\', self.portal.objectIds())\n+        self.browser.getControl(name="form.buttons.Delete").click()\n+        self.assertNotIn("file2", self.portal.objectIds())\n \n     def test_unreferenced_removal(self):\n         # This tests against #6666 and #7784, simple removal of a not\n@@ -75,14 +109,13 @@ def test_unreferenced_removal(self):\n \n         # We simply use a browser to try to delete a content item.\n         self.browser.open(self.portal.doc1.absolute_url())\n-        self.browser.getLink(\'Delete\').click()\n-        self.assertIn(\n-            \'Do you really want to delete this item?\', self.browser.contents)\n-        self.browser.getControl(name=\'form.buttons.Delete\').click()\n+        self.browser.getLink("Delete").click()\n+        self.assertIn("Do you really want to delete this item?", self.browser.contents)\n+        self.browser.getControl(name="form.buttons.Delete").click()\n \n         # The resulting page should confirm the removal:\n-        self.assertIn(\'Test Page 1 has been deleted\', self.browser.contents)\n-        self.assertNotIn(\'doc1\', self.portal.objectIds())\n+        self.assertIn("Test Page 1 has been deleted", self.browser.contents)\n+        self.assertNotIn("doc1", self.portal.objectIds())\n \n     def test_renaming_referenced_item(self):\n         doc1 = self.portal.doc1\n@@ -91,39 +124,42 @@ def test_renaming_referenced_item(self):\n         # This tests makes sure items that are linked to can still be\n         # renamed (see the related bug report in #6608).  First we need\n         # to create the necessary links:\n-        self._set_text(doc1, \'<a href="doc2">doc2</a>\')\n-        self.assertEqual(\n-            [i.from_object for i in getIncomingLinks(doc2)], [doc1])\n+        set_text(doc1, \'<a href="doc2">doc2</a>\')\n+        self.assertEqual([i.from_object for i in getIncomingLinks(doc2)], [doc1])\n \n         # Make changes visible to testbrowseropen\n         transaction.commit()\n \n         # Then we use a browser to rename the referenced image:\n         self.browser.handleErrors = True\n-        self.browser.open(\'{0:s}/object_rename?_authenticator={1:s}\'.format(\n-            doc1.absolute_url(), self._get_token(doc1)))\n+        self.browser.open(\n+            "{:s}/object_rename?_authenticator={:s}".format(\n+                doc1.absolute_url(), self._get_token(doc1)\n+            )\n+        )\n \n-        self.browser.getControl(name=\'form.widgets.new_id\').value = \'nuname\'\n-        self.browser.getControl(name=\'form.buttons.Rename\').click()\n+        self.browser.getControl(name="form.widgets.new_id").value = "nuname"\n+        self.browser.getControl(name="form.buttons.Rename").click()\n         self.assertIn("Renamed \'doc1\' to \'nuname\'.", self.browser.contents)\n         transaction.commit()\n \n-        self.assertNotIn(\'doc1\', self.portal.objectIds())\n-        self.assertIn(\'nuname\', self.portal.objectIds())\n+        self.assertNotIn("doc1", self.portal.objectIds())\n+        self.assertIn("nuname", self.portal.objectIds())\n         self.assertIn(doc1, [i.from_object for i in getIncomingLinks(doc2)])\n \n         # We simply use a browser to try to delete a content item.\n         self.browser.open(doc2.absolute_url())\n-        self.browser.getLink(\'Delete\').click()\n-        self.assertIn(\n-            \'Do you really want to delete this item?\', self.browser.contents)\n-        self.assertIn(\'nuname\', self.portal.objectIds())\n+        self.browser.getLink("Delete").click()\n+        self.assertIn("Do you really want to delete this item?", self.browser.contents)\n+        self.assertIn("nuname", self.portal.objectIds())\n         # Link breakabe page should be shown\n-        self.assertIn(\'Potential link breakage\', self.browser.contents)\n-        self.assertIn(\'<a href="http://nohost/plone/nuname">Test Page 1</a>\',\n-                      self.browser.contents)\n-        self.browser.getControl(name=\'form.buttons.Delete\').click()\n-        self.assertNotIn(\'doc2\', self.portal.objectIds())\n+        self.assertIn("Potential link breakage", self.browser.contents)\n+        self.assertIn(\n+            \'<a href="http://nohost/plone/nuname">Test Page 1</a>\',\n+            self.browser.contents,\n+        )\n+        self.browser.getControl(name="form.buttons.Delete").click()\n+        self.assertNotIn("doc2", self.portal.objectIds())\n \n     def test_removal_in_subfolder(self):\n         doc1 = self.portal.doc1\n@@ -132,8 +168,8 @@ def test_removal_in_subfolder(self):\n \n         # This tests ensuring link integrity when removing an referenced\n         # object contained in a folder that is removed.\n-        self._set_text(doc1, \'<a href="folder1/doc4">a document</a>\')\n-        self._set_text(doc2, \'<a href="folder1/doc4">a document</a>\')\n+        set_text(doc1, \'<a href="folder1/doc4">a document</a>\')\n+        set_text(doc2, \'<a href="folder1/doc4">a document</a>\')\n \n         # Make changes visible to testbrowseropen\n         transaction.commit()\n@@ -145,17 +181,19 @@ def test_removal_in_subfolder(self):\n         self.browser.handleErrors = True\n \n         self.browser.open(\n-            \'{0:s}/delete_confirmation?_authenticator={1:s}\'.format(\n+            "{:s}/delete_confirmation?_authenticator={:s}".format(\n                 folder1.absolute_url(), self._get_token(folder1)\n             )\n         )\n-        self.assertIn(\'Potential link breakage\', self.browser.contents)\n-        self.assertIn(\'<a href="http://nohost/plone/doc1">Test Page 1</a>\',\n-                      self.browser.contents)\n-        self.assertIn(\'<a href="http://nohost/plone/doc2">Test Page 2</a>\',\n-                      self.browser.contents)\n-        self.browser.getControl(name=\'form.buttons.Delete\').click()\n-        self.assertNotIn(\'folder1\', self.portal.objectIds())\n+        self.assertIn("Potential link breakage", self.browser.contents)\n+        self.assertIn(\n+            \'<a href="http://nohost/plone/doc1">Test Page 1</a>\', self.browser.contents\n+        )\n+        self.assertIn(\n+            \'<a href="http://nohost/plone/doc2">Test Page 2</a>\', self.browser.contents\n+        )\n+        self.browser.getControl(name="form.buttons.Delete").click()\n+        self.assertNotIn("folder1", self.portal.objectIds())\n \n     def test_removal_with_cookie_auth(self):\n         doc1 = self.portal.doc1\n@@ -163,43 +201,45 @@ def test_removal_with_cookie_auth(self):\n \n         # This tests ensures link integrity working correctly without\n         # http basic authentication (see the bug report in #6607).\n-        self._set_text(doc1, \'<a href="doc2">doc2</a>\')\n+        set_text(doc1, \'<a href="doc2">doc2</a>\')\n         transaction.commit()\n \n-        browser = Browser(self.layer[\'app\'])\n+        browser = Browser(self.layer["app"])\n         browser.handleErrors = True\n-        browser.addHeader(\'Referer\', self.portal.absolute_url())\n-        browser.open(\n-            \'{0:s}/folder_contents\'.format(self.portal.absolute_url()))\n+        browser.addHeader("Referer", self.portal.absolute_url())\n+        browser.open(f"{self.portal.absolute_url():s}/folder_contents")\n \n         # At this point we shouldn\'t be able to look at the folder\n         # contents (as an anonymous user):\n-        self.assertIn(\'login?came_from\', browser.url)\n+        self.assertIn("login?came_from", browser.url)\n \n         # So we log in via the regular plone login form and additionally check\n         # that there is no \'authorization\' header set afterwards:\n-        browser.getControl(name=\'__ac_name\').value = TEST_USER_NAME\n-        browser.getControl(name=\'__ac_password\').value = TEST_USER_PASSWORD\n-        browser.getControl(\'Log in\').click()\n-        self.assertNotIn(\n-            \'authorization\', [h.lower() for h in browser.headers.keys()])\n+        browser.getControl(name="__ac_name").value = TEST_USER_NAME\n+        browser.getControl(name="__ac_password").value = TEST_USER_PASSWORD\n+        browser.getControl("Log in").click()\n+        self.assertNotIn("authorization", [h.lower() for h in browser.headers.keys()])\n \n         # This should lead us back to the "folder contents" listing,\n         # where we try to delete the referenced document.\n-        browser.open(\'{0:s}/delete_confirmation?_authenticator={1:s}\'.format(\n-            doc2.absolute_url(), self._get_token(doc2)))\n-        self.assertIn(\'Potential link breakage\', browser.contents)\n-        self.assertIn(\'<a href="http://nohost/plone/doc1">Test Page 1</a>\',\n-                      browser.contents)\n-        browser.getControl(name=\'form.buttons.Delete\').click()\n-        self.assertNotIn(\'doc2\', self.portal.objectIds())\n+        browser.open(\n+            "{:s}/delete_confirmation?_authenticator={:s}".format(\n+                doc2.absolute_url(), self._get_token(doc2)\n+            )\n+        )\n+        self.assertIn("Potential link breakage", browser.contents)\n+        self.assertIn(\n+            \'<a href="http://nohost/plone/doc1">Test Page 1</a>\', browser.contents\n+        )\n+        browser.getControl(name="form.buttons.Delete").click()\n+        self.assertNotIn("doc2", self.portal.objectIds())\n \n     def test_linkintegrity_on_off_switch(self):\n         doc1 = self.portal.doc1\n         doc2 = self.portal.doc2\n \n         # This tests switching link integrity checking on and off.\n-        self._set_text(doc1, \'<a href="doc2">a document</a>\')\n+        set_text(doc1, \'<a href="doc2">a document</a>\')\n         transaction.commit()\n \n         # This should lead us back to the "folder contents" listing,\n@@ -209,22 +249,23 @@ def test_linkintegrity_on_off_switch(self):\n         self.browser.handleErrors = True\n \n         self.browser.open(\n-            \'{0:s}/delete_confirmation?_authenticator={1:s}\'.format(\n+            "{:s}/delete_confirmation?_authenticator={:s}".format(\n                 doc2.absolute_url(), self._get_token(doc2)\n             )\n         )\n-        self.assertIn(\'Potential link breakage\', self.browser.contents)\n-        self.assertIn(\'<a href="http://nohost/plone/doc1">Test Page 1</a>\',\n-                      self.browser.contents)\n+        self.assertIn("Potential link breakage", self.browser.contents)\n+        self.assertIn(\n+            \'<a href="http://nohost/plone/doc1">Test Page 1</a>\', self.browser.contents\n+        )\n \n         # Now we turn the switch for link integrity checking off via the site\n         # properties and try again:\n         registry = getUtility(IRegistry)\n-        settings = registry.forInterface(IEditingSchema, prefix=\'plone\')\n+        settings = registry.forInterface(IEditingSchema, prefix="plone")\n         settings.enable_link_integrity_checks = False\n         transaction.commit()\n         self.browser.reload()\n-        self.assertNotIn(\'Potential link breakage\', self.browser.contents)\n+        self.assertNotIn("Potential link breakage", self.browser.contents)\n \n     def test_update(self):\n         doc1 = self.portal.doc1\n@@ -233,8 +274,8 @@ def test_update(self):\n \n         # This tests updating link integrity information for all site content,\n         # i.e. after migrating from a previous version.\n-        self._set_text(doc1, \'<a href="doc2">a document</a>\')\n-        self._set_text(doc2, \'<a href="folder1/doc4">a document</a>\')\n+        set_text(doc1, \'<a href="doc2">a document</a>\')\n+        set_text(doc2, \'<a href="folder1/doc4">a document</a>\')\n \n         catalog = getUtility(ICatalog)\n         rels = [i for i in catalog.findRelations()]\n@@ -249,21 +290,25 @@ def test_update(self):\n         # An update of link integrity information for all content is triggered\n         # by browsing a specific url:\n         transaction.commit()\n-        self.browser.open(\'{0:s}/updateLinkIntegrityInformation\'.format(\n-            self.portal.absolute_url()))\n-        self.browser.getControl(\'Update\').click()\n-        self.assertIn(\'Link integrity information updated for\',\n-                      self.browser.contents)\n+        self.browser.open(\n+            f"{self.portal.absolute_url():s}/updateLinkIntegrityInformation"\n+        )\n+        self.browser.getControl("Update").click()\n+        self.assertIn("Link integrity information updated for", self.browser.contents)\n \n         # Now the linking documents should hold the correct link integrity\n         # references:\n         self.assertEqual(\n             [i.to_object for i in getOutgoingLinks(doc1)],\n-            [doc2, ],\n+            [\n+                doc2,\n+            ],\n         )\n         self.assertEqual(\n             [i.to_object for i in getOutgoingLinks(doc2)],\n-            [doc4, ],\n+            [\n+                doc4,\n+            ],\n         )\n \n     def test_references_on_cloned_objects(self):\n@@ -272,16 +317,16 @@ def test_references_on_cloned_objects(self):\n \n         # This tests ensures that link integrity is correctly setup when\n         # cloning an object.\n-        self._set_text(doc1, \'<a href="doc2">a document</a>\')\n+        set_text(doc1, \'<a href="doc2">a document</a>\')\n \n         # Next we clone the document:\n         token = self._get_token(doc1)\n-        self.request[\'_authenticator\'] = token\n-        doc1.restrictedTraverse(\'object_copy\')()\n+        self.request["_authenticator"] = token\n+        doc1.restrictedTraverse("object_copy")()\n \n-        self.request[\'_authenticator\'] = token\n-        self.portal.restrictedTraverse(\'object_paste\')()\n-        self.assertIn(\'copy_of_doc1\', self.portal)\n+        self.request["_authenticator"] = token\n+        self.portal.restrictedTraverse("object_paste")()\n+        self.assertIn("copy_of_doc1", self.portal)\n         transaction.commit()\n \n         # Then we try to delete the document linked by the original document\n@@ -292,20 +337,17 @@ def test_references_on_cloned_objects(self):\n         # Now we can continue and "click" the "delete" action. The confirmation\n         # page should list both documents:\n         self.browser.open(\n-            \'{0:s}/delete_confirmation?_authenticator={1:s}\'.format(\n+            "{:s}/delete_confirmation?_authenticator={:s}".format(\n                 doc2.absolute_url(), self._get_token(doc2)\n             )\n         )\n+        self.assertIn("is referenced by the following items:", self.browser.contents)\n+        self.assertIn("Potential link breakage", self.browser.contents)\n         self.assertIn(\n-            \'is referenced by the following items:\', self.browser.contents)\n-        self.assertIn(\'Potential link breakage\', self.browser.contents)\n-        self.assertIn(\n-            \'<a href="http://nohost/plone/doc1">Test Page 1</a>\',\n-            self.browser.contents\n+            \'<a href="http://nohost/plone/doc1">Test Page 1</a>\', self.browser.contents\n         )\n         self.assertIn(\n-            \'<a href="http://nohost/plone/copy_of_doc1"\',\n-            self.browser.contents\n+            \'<a href="http://nohost/plone/copy_of_doc1"\', self.browser.contents\n         )\n \n     def test_files_with_spaces_removal(self):\n@@ -314,16 +356,16 @@ def test_files_with_spaces_removal(self):\n         # This tests the behaviour when removing a referenced file that has\n         # spaces in its id.  First we need to rename the existing file:\n         self.portal.invokeFactory(\n-            \'Document\', id=\'some spaces.doc\', title=\'A spaces doc\')\n+            "Document", id="some spaces.doc", title="A spaces doc"\n+        )\n \n-        self.assertIn(\'some spaces.doc\', self.portal.objectIds())\n-        spaces1 = self.portal[\'some spaces.doc\']\n+        self.assertIn("some spaces.doc", self.portal.objectIds())\n+        spaces1 = self.portal["some spaces.doc"]\n \n-        self._set_text(doc1, \'<a href="some spaces.doc">a document</a>\')\n+        set_text(doc1, \'<a href="some spaces.doc">a document</a>\')\n \n         # The document should now have a reference to the file:\n-        self.assertEqual(\n-            [i.to_object for i in getOutgoingLinks(doc1)], [spaces1])\n+        self.assertEqual([i.to_object for i in getOutgoingLinks(doc1)], [spaces1])\n         transaction.commit()\n \n         # Then we use a browser to try to delete the referenced file.\n@@ -332,17 +374,16 @@ def test_files_with_spaces_removal(self):\n         self.browser.handleErrors = True\n \n         self.browser.open(\n-            \'{0:s}/delete_confirmation?_authenticator={1:s}\'.format(\n+            "{:s}/delete_confirmation?_authenticator={:s}".format(\n                 spaces1.absolute_url(), self._get_token(spaces1)\n             )\n         )\n-        self.assertIn(\'Potential link breakage\', self.browser.contents)\n+        self.assertIn("Potential link breakage", self.browser.contents)\n         self.assertIn(\n-            \'<a href="http://nohost/plone/doc1">Test Page 1</a>\',\n-            self.browser.contents\n+            \'<a href="http://nohost/plone/doc1">Test Page 1</a>\', self.browser.contents\n         )\n-        self.browser.getControl(name=\'form.buttons.Delete\').click()\n-        self.assertNotIn(\'some spaces.doc\', self.portal.objectIds())\n+        self.browser.getControl(name="form.buttons.Delete").click()\n+        self.assertNotIn("some spaces.doc", self.portal.objectIds())\n \n     def test_removal_via_zmi(self):\n         """Delete via ZMI is no longer protedted!"""\n@@ -351,7 +392,7 @@ def test_removal_via_zmi(self):\n \n         # This tests ensuring link integrity when removing an object via\n         # the ZMI.\n-        self._set_text(doc1, \'<a href="doc2">a document</a>\')\n+        set_text(doc1, \'<a href="doc2">a document</a>\')\n         self.assertEqual([i.to_object for i in getOutgoingLinks(doc1)], [doc2])\n \n         transaction.commit()\n@@ -360,37 +401,22 @@ def test_removal_via_zmi(self):\n         # framework from choking on the exception we intentionally throw.\n         self.browser.handleErrors = True\n \n-        self.browser.open(\'http://nohost/plone/manage_main\')\n-        self.browser\\\n-            .getControl(name=\'ids:list\')\\\n-            .getControl(value=\'doc2\').selected = True\n+        self.browser.open("http://nohost/plone/manage_main")\n+        self.browser.getControl(name="ids:list").getControl(value="doc2").selected = (\n+            True\n+        )\n \n-        self.browser.getControl(\'Delete\').click()\n-        self.assertNotIn(\'doc2\', self.portal.objectIds())\n+        self.browser.getControl("Delete").click()\n+        self.assertNotIn("doc2", self.portal.objectIds())\n \n     def test_warn_about_content(self):\n         folder1 = self.portal.folder1\n         self.browser.open(\n-            \'{0:s}/delete_confirmation?_authenticator={1:s}\'.format(\n+            "{:s}/delete_confirmation?_authenticator={:s}".format(\n                 folder1.absolute_url(), self._get_token(folder1)\n             )\n         )\n-        self.assertIn(\'Number of selected\', self.browser.contents)\n-        self.assertIn(\'2 Objects in all\', self.browser.contents)\n-        self.assertIn(\'1 Folders\', self.browser.contents)\n-        self.assertIn(\'0 Published objects\', self.browser.contents)\n-\n-\n-class FunctionalReferenceDXTestCase(DXBaseTestCase, ReferenceTestCase):\n-    """Functional reference testcase for dx content types"""\n-\n-    layer = testing.PLONE_APP_LINKINTEGRITY_DX_FUNCTIONAL_TESTING\n-\n-\n-if six.PY2:\n-    from plone.app.linkintegrity.tests.base import ATBaseTestCase\n-\n-    class FunctionalReferenceATTestCase(ATBaseTestCase, ReferenceTestCase):\n-        """Functional reference testcase for dx content types"""\n-\n-        layer = testing.PLONE_APP_LINKINTEGRITY_AT_FUNCTIONAL_TESTING\n+        self.assertIn("Number of selected", self.browser.contents)\n+        self.assertTrue(re.search(r"2\\s+Objects in all", self.browser.contents))\n+        self.assertTrue(re.search(r"1\\s+Folders", self.browser.contents))\n+        self.assertTrue(re.search(r"0\\s+Published objects", self.browser.contents))\ndiff --git a/plone/app/linkintegrity/tests/test_handlers.py b/plone/app/linkintegrity/tests/test_handlers.py\nindex b4ec594..5b094ef 100644\n--- a/plone/app/linkintegrity/tests/test_handlers.py\n+++ b/plone/app/linkintegrity/tests/test_handlers.py\n@@ -1,42 +1,54 @@\n-# -*- coding: utf-8 -*-\n+from plone.app.linkintegrity import testing\n from plone.app.linkintegrity.handlers import findObject\n-from plone.app.linkintegrity.tests.base import DXBaseTestCase\n+from plone.app.linkintegrity.testing import create\n+from plone.app.testing import logout\n \n-import six\n+import unittest\n \n \n-class FindObjectTests:\n-    """ testing the handlers.findObject function """\n+class ReferenceGenerationTestCase(unittest.TestCase):\n+    """testing the handlers.findObject function"""\n+\n+    layer = testing.PLONE_APP_LINKINTEGRITY_INTEGRATION_TESTING\n+\n+    def setUp(self):\n+        self.portal = self.layer["portal"]\n \n     def test_relative_to_portal_root_1(self):\n-        obj, components = findObject(self.portal.doc1, \'/plone/doc2\')\n-        self.assertEqual(obj.absolute_url_path(), \'/plone/doc2\')\n-        self.assertEqual(components, \'\')\n+        obj, components = findObject(self.portal.doc1, "/plone/doc2")\n+        self.assertEqual(obj.absolute_url_path(), "/plone/doc2")\n+        self.assertEqual(components, "")\n \n     def test_relative_to_portal_root_2(self):\n         # Prevent regression.\n         # See https://github.com/plone/plone.app.linkintegrity/pull/17\n-        obj, components = findObject(self.portal.doc1, \'/doc2\')\n-        self.assertEqual(obj.absolute_url_path(), \'/plone/doc2\')\n-        self.assertEqual(components, \'\')\n+        obj, components = findObject(self.portal.doc1, "/doc2")\n+        self.assertEqual(obj.absolute_url_path(), "/plone/doc2")\n+        self.assertEqual(components, "")\n \n     def test_webserver_rewrites_portal_name(self):\n         # test the case where a webserver rewrites the portal name,\n         # e.g. for Apache:\n         # RewriteRule ^/wssitename(.*)$ http://localhost:8080/VirtualHostBase/http/my.domain.com:80/plonesitename/VirtualHostRoot/_vh_wssitename$1  # noqa\n-        self.portal.REQUEST.other[\'VirtualRootPhysicalPath\'] = (\'\', \'plone\')\n-        self.portal.REQUEST._script = [\'plone_foo\']\n-        obj, components = findObject(self.portal.doc1, \'/plone_foo/doc2\')\n-        self.assertEqual(obj.absolute_url_path(), \'/plone_foo/doc2\')\n-        self.assertEqual(obj.getPhysicalPath(), (\'\', \'plone\', \'doc2\'))\n-        self.assertEqual(components, \'\')\n-\n-\n-class ReferenceGenerationDXTestCase(DXBaseTestCase, FindObjectTests):\n-    """findObject testcase for dx content types"""\n-\n-if six.PY2:\n-    from plone.app.linkintegrity.tests.base import ATBaseTestCase\n-\n-    class ReferenceGenerationATTestCase(ATBaseTestCase, FindObjectTests):\n-        """findObject testcase for at content types"""\n+        self.portal.REQUEST.other["VirtualRootPhysicalPath"] = ("", "plone")\n+        self.portal.REQUEST._script = ["plone_foo"]\n+        obj, components = findObject(self.portal.doc1, "/plone_foo/doc2")\n+        self.assertEqual(obj.absolute_url_path(), "/plone_foo/doc2")\n+        self.assertEqual(obj.getPhysicalPath(), ("", "plone", "doc2"))\n+        self.assertEqual(components, "")\n+\n+    def test_uuid_link(self):\n+        # Test that objects can be found from uuid links.\n+        create(self.portal, "Document", id="target", title="Target")\n+        target = self.portal.target\n+        target_uid = target.UID()\n+        path = f"../resolveuid/{target_uid}"\n+\n+        # We logout.  This is to check that findObject also finds objects\n+        # that are not visible to the current user, like a private page.\n+        # See https://github.com/plone/plone.app.linkintegrity/issues/79\n+        logout()\n+\n+        obj, components = findObject(self.portal.doc1, path)\n+        self.assertEqual(obj.absolute_url_path(), "/plone/target")\n+        self.assertEqual(components, path)\ndiff --git a/plone/app/linkintegrity/tests/test_imagescales.py b/plone/app/linkintegrity/tests/test_imagescales.py\nindex b934934..3661478 100644\n--- a/plone/app/linkintegrity/tests/test_imagescales.py\n+++ b/plone/app/linkintegrity/tests/test_imagescales.py\n@@ -1,13 +1,19 @@\n-# -*- coding: utf-8 -*-\n-from plone.app.linkintegrity.tests.base import DXBaseTestCase\n+from plone.app.linkintegrity import testing\n+from plone.app.linkintegrity.tests.utils import set_text\n from plone.app.linkintegrity.utils import getIncomingLinks\n from plone.app.linkintegrity.utils import getOutgoingLinks\n from plone.uuid.interfaces import IUUID\n \n-import six\n+import unittest\n \n \n-class ImageReferenceTestCase:\n+class ImageReferenceTestCase(unittest.TestCase):\n+    """image reference testcase"""\n+\n+    layer = testing.PLONE_APP_LINKINTEGRITY_INTEGRATION_TESTING\n+\n+    def setUp(self):\n+        self.portal = self.layer["portal"]\n \n     def test_image_tag_reference_creation(self):\n         doc1 = self.portal.doc1\n@@ -17,11 +23,13 @@ def test_image_tag_reference_creation(self):\n         # ensuring link integrity. Any archetype-based content object\n         # which refers to other (local) objects by `<img>` or `<a>` tags\n         # should create references between those objects on save.\n-        self._set_text(doc1, img1.restrictedTraverse(\'@@images\').tag())\n+        set_text(doc1, img1.restrictedTraverse("@@images").tag())\n \n         self.assertEqual(\n             [r.to_object for r in getOutgoingLinks(doc1)],\n-            [img1, ],\n+            [\n+                img1,\n+            ],\n         )\n         self.assertEqual([r.to_object for r in getIncomingLinks(doc1)], [])\n         self.assertEqual([r.to_object for r in getOutgoingLinks(img1)], [])\n@@ -35,15 +43,18 @@ def test_image_scale_reference_creation(self):\n         img1 = self.portal.image1\n \n         # Linking image scales should also work:\n-        self._set_text(\n-            doc1, \'<a href="image1/@@images/image_thumb">an image</a>\')\n+        set_text(doc1, \'<a href="image1/@@images/image_thumb">an image</a>\')\n         self.assertEqual(\n             [r.to_object for r in getOutgoingLinks(doc1)],\n-            [img1, ],\n+            [\n+                img1,\n+            ],\n         )\n         self.assertEqual(\n             [r.from_object for r in getIncomingLinks(img1)],\n-            [doc1, ],\n+            [\n+                doc1,\n+            ],\n         )\n \n     def test_image_resolveuid_reference_creation(self):\n@@ -51,23 +62,16 @@ def test_image_resolveuid_reference_creation(self):\n         img1 = self.portal.image1\n \n         # Linking via the "resolveuid/UID" method should also work:\n-        self._set_text(doc1, \'<a href="resolveuid/{0:s}">an image</a>\'.format(\n-            IUUID(img1)))\n+        set_text(doc1, f\'<a href="resolveuid/{IUUID(img1):s}">an image</a>\')\n         self.assertEqual(\n             [r.to_object for r in getOutgoingLinks(doc1)],\n-            [img1, ],\n+            [\n+                img1,\n+            ],\n         )\n         self.assertEqual(\n             [r.from_object for r in getIncomingLinks(img1)],\n-            [doc1, ],\n+            [\n+                doc1,\n+            ],\n         )\n-\n-\n-class ImageReferenceDXTestCase(DXBaseTestCase, ImageReferenceTestCase):\n-    """Image reference testcase for dx content types"""\n-\n-if six.PY2:\n-    from plone.app.linkintegrity.tests.base import ATBaseTestCase\n-\n-    class ImageReferenceATTestCase(ATBaseTestCase, ImageReferenceTestCase):\n-        """Image reference testcase for dx content types"""\ndiff --git a/plone/app/linkintegrity/tests/test_info.py b/plone/app/linkintegrity/tests/test_info.py\nnew file mode 100644\nindex 0000000..2b51729\n--- /dev/null\n+++ b/plone/app/linkintegrity/tests/test_info.py\n@@ -0,0 +1,42 @@\n+from plone.app.linkintegrity import testing\n+from plone.app.linkintegrity.browser.info import DeleteConfirmationInfo\n+from plone.app.linkintegrity.tests.utils import set_text\n+\n+import unittest\n+\n+\n+class DeleteConfirmationInfoTestCase(unittest.TestCase):\n+    layer = testing.PLONE_APP_LINKINTEGRITY_INTEGRATION_TESTING\n+\n+    def setUp(self):\n+        self.portal = self.layer["portal"]\n+        self.request = self.layer["request"]\n+\n+    def test_get_breaches_shape(self):\n+        # Just here as a sanity check.\n+        folder1 = self.portal.folder1\n+        doc1 = self.portal.doc1\n+        set_text(doc1, \'<a href="folder1">f1</a>\')\n+        view = DeleteConfirmationInfo(self.portal, self.request)\n+        self.assertEqual(\n+            view.get_breaches([folder1]),\n+            [\n+                {\n+                    "target": {\n+                        "uid": folder1.UID(),\n+                        "title": "Folder 1",\n+                        "url": "http://nohost/plone/folder1",\n+                        "portal_type": "Folder",\n+                        "type_title": "Folder",\n+                    },\n+                    "sources": [\n+                        {\n+                            "uid": doc1.UID(),\n+                            "title": "Test Page 1",\n+                            "url": "http://nohost/plone/doc1",\n+                            "accessible": 1,\n+                        }\n+                    ],\n+                }\n+            ],\n+        )\ndiff --git a/plone/app/linkintegrity/tests/test_references.py b/plone/app/linkintegrity/tests/test_references.py\nindex f69e903..945b6cd 100644\n--- a/plone/app/linkintegrity/tests/test_references.py\n+++ b/plone/app/linkintegrity/tests/test_references.py\n@@ -1,11 +1,11 @@\n-# -*- coding: utf-8 -*-\n from plone.app.linkintegrity import testing\n from plone.app.linkintegrity.parser import extractLinks\n-from plone.app.linkintegrity.tests.base import DXBaseTestCase\n+from plone.app.linkintegrity.tests.utils import set_text\n from plone.app.linkintegrity.utils import getIncomingLinks\n from plone.app.linkintegrity.utils import getOutgoingLinks\n from plone.app.linkintegrity.utils import hasIncomingLinks\n from plone.app.linkintegrity.utils import hasOutgoingLinks\n+from plone.app.relationfield.behavior import IRelatedItems\n from plone.app.testing import login\n from plone.app.testing import logout\n from plone.app.testing import TEST_USER_NAME\n@@ -16,15 +16,29 @@\n from zope.intid.interfaces import IIntIds\n from zope.lifecycleevent import modified\n \n-import six\n+import unittest\n \n \n-class ReferenceGenerationTestCase:\n+class ReferenceGenerationTestCase(unittest.TestCase):\n+    """reference generation testcase"""\n+\n+    layer = testing.PLONE_APP_LINKINTEGRITY_INTEGRATION_TESTING\n+\n+    def setUp(self):\n+        self.portal = self.layer["portal"]\n+\n+    def _set_related_items(self, obj, items):\n+        assert IRelatedItems.providedBy(obj)\n+        setattr(obj, "relatedItems", items)\n+        modified(obj)\n+\n+    def _get_related_items(self, obj):\n+        return obj.relatedItems\n \n     def test_is_linked(self):\n-        img1 = self.portal[\'image1\']\n-        doc1 = self.portal[\'doc1\']\n-        self._set_text(doc1, \'<img src="image1"></img>\')\n+        img1 = self.portal["image1"]\n+        doc1 = self.portal["doc1"]\n+        set_text(doc1, \'<img src="image1"></img>\')\n         self.assertTrue(hasIncomingLinks(img1))\n \n     def test_referal_to_private_files(self):\n@@ -36,29 +50,30 @@ def test_referal_to_private_files(self):\n         # the link in question and set up the permissions accordingly.\n         doc = self.portal.doc1\n         img = self.portal.image1\n-        self._set_text(doc, \'<a href="image1">Image 1</a>\')\n-\n-        roles = (\'Member\', )\n-        self.portal.manage_permission(\'List folder contents\', roles=roles)\n-        self.portal.manage_permission(\'Delete objects\', roles=roles)\n-        doc.manage_permission(\'View\', roles=(\'Manager\',), acquire=0)\n-        doc.manage_permission(\'Access contents information\',\n-                              roles=(\'Manager\', ), acquire=0)\n+        set_text(doc, \'<a href="image1">Image 1</a>\')\n+\n+        roles = ("Member",)\n+        self.portal.manage_permission("List folder contents", roles=roles)\n+        self.portal.manage_permission("Delete objects", roles=roles)\n+        doc.manage_permission("View", roles=("Manager",), acquire=0)\n+        doc.manage_permission(\n+            "Access contents information", roles=("Manager",), acquire=0\n+        )\n \n         logout()\n-        login(self.portal, \'member\')\n+        login(self.portal, "member")\n         checkPermission = self.portal.portal_membership.checkPermission\n-        self.assertFalse(checkPermission(\'View\', doc))\n-        self.assertFalse(checkPermission(\'Access contents information\', doc))\n-        self.assertTrue(checkPermission(\'View\', img))\n-        self.assertTrue(checkPermission(\'Access contents information\', img))\n+        self.assertFalse(checkPermission("View", doc))\n+        self.assertFalse(checkPermission("Access contents information", doc))\n+        self.assertTrue(checkPermission("View", img))\n+        self.assertTrue(checkPermission("Access contents information", img))\n \n         # The warning is shown.\n         self.assertTrue(hasOutgoingLinks(doc))\n-        view = img.restrictedTraverse(\'delete_confirmation\')\n+        view = img.restrictedTraverse("delete_confirmation")\n         results = view()\n-        self.assertIn(\'Potential link breakage\', results)\n-        self.assertIn(\'The item is not accessible.\', results)\n+        self.assertIn("Potential link breakage", results)\n+        self.assertIn("The item is not accessible.", results)\n \n         # delete linked item and check if the source still has the relation\n \n@@ -82,49 +97,79 @@ def test_referal_to_private_files(self):\n \n     def test_link_extraction_easy(self):\n         doc1 = self.portal.doc1\n-        self._set_text(doc1, \'<a href="doc2">Doc 2</a>\')\n-        self.assertEqual(\n-            extractLinks(self._get_text(doc1)),\n-            (\'doc2\', )\n-        )\n+        set_text(doc1, \'<a href="doc2">Doc 2</a>\')\n+        self.assertEqual(extractLinks(doc1.text.raw), ("doc2",))\n \n     def test_link_extraction_more_complex(self):\n         doc2 = self.portal.doc2\n-        self._set_text(\n+        set_text(\n             doc2,\n-            \'<a href="doc1">Doc 2</a>\' +\n-            \'<a href="folder1/doc3"><img src="image1" /></a>\',\n+            \'<a href="doc1">Doc 2</a>\'\n+            + \'<a href="folder1/doc3"><img src="image1" /></a>\',\n         )\n         self.assertEqual(\n-            extractLinks(self._get_text(doc2)),\n-            (\'doc1\',\n-             \'folder1/doc3\',\n-             \'image1\')\n+            extractLinks(doc2.text.raw), ("doc1", "folder1/doc3", "image1")\n         )\n \n     def test_broken_references(self):\n         # create a temporary document to test with\n-        doc1a = testing.create(self.portal, \'Document\', id=\'doc1a\')\n+        doc1a = testing.create(self.portal, "Document", id="doc1a")\n         doc1 = self.portal.doc1\n \n         self.assertEqual(len(list(getOutgoingLinks(doc1))), 0)\n-        self._set_text(doc1, \'<a href="doc1a">Doc 1a</a>\')\n+        set_text(doc1, \'<a href="doc1a">Doc 1a</a>\')\n         self.assertEqual(len(list(getOutgoingLinks(doc1))), 1)\n-        self.assertEqual([l.to_object for l in getOutgoingLinks(doc1)],\n-                         [self.portal.doc1a])\n+        self.assertEqual(\n+            [link.to_object for link in getOutgoingLinks(doc1)], [self.portal.doc1a]\n+        )\n \n         # Now delete the target item, suppress events and test again,\n-        # the reference should be gone now.\n+        # The reference should be a ghost not in any folder anymore.\n+        # check if it has no acquisition parent!\n         self.portal._delObject(doc1a.id, suppress_events=True)\n-        self.assertEqual([l.to_object for l in getOutgoingLinks(doc1)], [None])\n+        objs = [link.to_object for link in getOutgoingLinks(doc1)]\n+        self.assertEqual(len(objs), 1)\n+        obj = objs[0]\n+        if obj is not None:\n+            # Plone with fixed five.intid\n+            # if object is None: all fine as well.\n+            self.assertEqual(obj.portal_type, "Document")\n+            _marker = dict()\n+            self.assertEqual(getattr(obj, "aq_parent", _marker), _marker)\n+\n+    def test_catalog_cleaned_up(self):\n+        doc1 = self.portal.doc1\n+        # Create a temporary document to test with.\n+        doc_temp = testing.create(self.portal, "Document", id="doc_temp")\n+\n+        self.assertEqual(len(list(getIncomingLinks(doc1))), 0)\n+        set_text(doc_temp, \'<a href="doc1">Doc 1</a>\')\n+        self.assertEqual(len(list(getIncomingLinks(doc1))), 1)\n+        self.assertEqual(\n+            [link.from_object for link in getIncomingLinks(doc1)],\n+            [self.portal.doc_temp],\n+        )\n+\n+        catalog = getUtility(ICatalog)\n+        rels = list(catalog.findRelations())\n+        self.assertEqual(len(rels), 1)\n+\n+        # Now delete the source item.\n+        self.portal._delObject(doc_temp.id)\n+\n+        # Test, if relation is removed from the relation catalog.\n+        catalog = getUtility(ICatalog)\n+        rels = list(catalog.findRelations())\n+        self.assertEqual(len(rels), 0)\n+\n+        self.assertEqual(len(list(getIncomingLinks(doc1))), 0)\n \n     def test_relative_upwards_link_generates_matching_reference(self):\n         doc1 = self.portal.doc1\n         doc3 = self.portal.folder1.doc3\n-        self._set_text(doc3, \'<a href="../doc1">go!</a>\')\n+        set_text(doc3, \'<a href="../doc1">go!</a>\')\n         self.assertEqual(len(list(getOutgoingLinks(doc1))), 0)\n-        self.assertEqual([l.to_object for l in getOutgoingLinks(doc3)],\n-                         [doc1])\n+        self.assertEqual([link.to_object for link in getOutgoingLinks(doc3)], [doc1])\n \n     def test_unicode_links(self):\n         doc1 = self.portal.doc1\n@@ -133,82 +178,140 @@ def test_unicode_links(self):\n         # eventually plays well with transaction machinery.\n         # Add bad link, should not raise exception and there should not\n         # be any references added.\n-        self._set_text(\n-            doc1,\n-            \'<a href="\xc3\xb6?foo=bar&baz=bam">bug</a>\')\n+        set_text(doc1, \'<a href="\xc3\xb6?foo=bar&baz=bam">bug</a>\')\n \n-        self.assertEqual([l for l in getOutgoingLinks(doc1)], [])\n+        self.assertEqual([link for link in getOutgoingLinks(doc1)], [])\n \n     def test_reference_orthogonality(self):\n         doc = self.portal.doc1\n         img = self.portal.image1\n-        tag = img.restrictedTraverse(\'@@images\').tag()\n+        tag = img.restrictedTraverse("@@images").tag()\n \n         # This tests the behavior when other references already exist.\n-        self.assertEqual([l for l in getOutgoingLinks(doc)], [])\n-        self.assertEqual([l for l in getIncomingLinks(doc)], [])\n-        self.assertEqual([l for l in getOutgoingLinks(img)], [])\n-        self.assertEqual([l for l in getOutgoingLinks(img)], [])\n+        self.assertEqual([link for link in getOutgoingLinks(doc)], [])\n+        self.assertEqual([link for link in getIncomingLinks(doc)], [])\n+        self.assertEqual([link for link in getOutgoingLinks(img)], [])\n+        self.assertEqual([link for link in getOutgoingLinks(img)], [])\n \n         # Then establish a reference between the document and image as\n         # a related item:\n-        self._set_related_items(doc, [img, ])\n-        self.assertEqual(self._get_related_items(doc), [img, ])\n+        self._set_related_items(\n+            doc,\n+            [\n+                img,\n+            ],\n+        )\n+        self.assertEqual(\n+            self._get_related_items(doc),\n+            [\n+                img,\n+            ],\n+        )\n \n         # Next edit the document body and insert a link to the image,\n         # which should trigger the creation of a link integrity reference:\n-        self._set_text(doc, tag)\n+        set_text(doc, tag)\n \n-        self.assertEqual([l.to_object for l in getOutgoingLinks(doc)], [img])\n+        self.assertEqual([link.to_object for link in getOutgoingLinks(doc)], [img])\n \n         # And the related item reference remains in place:\n-        self.assertEqual(self._get_related_items(doc), [img, ])\n+        self.assertEqual(\n+            self._get_related_items(doc),\n+            [\n+                img,\n+            ],\n+        )\n \n         # Finally, edit the document body again, this time removing the\n         # link to the image, which should trigger the removal of the\n         # link integrity reference:\n-        self._set_text(doc, \'where did my link go?\')\n-        self.assertEqual([l.to_object for l in getOutgoingLinks(doc)], [])\n+        set_text(doc, "where did my link go?")\n+        self.assertEqual([link.to_object for link in getOutgoingLinks(doc)], [])\n \n         # And again the related item reference remains in place:\n-        self.assertEqual(self._get_related_items(doc), [img, ])\n+        self.assertEqual(\n+            self._get_related_items(doc),\n+            [\n+                img,\n+            ],\n+        )\n \n     def test_delete_confirmation_for_any_reference(self):\n         """Test, if delete confirmation shows also a warning if items are\n         deleted, which are referenced by other items via a reference field.\n         """\n-        img1 = self.portal[\'image1\']\n-        doc1 = self.portal[\'doc1\']\n+        img1 = self.portal["image1"]\n+        doc1 = self.portal["doc1"]\n \n         intids_tool = getUtility(IIntIds)\n         to_id = intids_tool.getId(img1)\n         rel = RelationValue(to_id)\n-        _setRelation(doc1, \'related_image\', rel)\n+        _setRelation(doc1, "related_image", rel)\n \n         # Test, if relation is present in the relation catalog\n         catalog = getUtility(ICatalog)\n-        rels = list(catalog.findRelations({\'to_id\':  to_id}))\n+        rels = list(catalog.findRelations({"to_id": to_id}))\n         self.assertEqual(len(rels), 1)\n \n         # Test, if delete_confirmation_info shows also other relations than\n         # ``isReferencing``.\n-        info = img1.restrictedTraverse(\'@@delete_confirmation_info\')\n+        info = img1.restrictedTraverse("@@delete_confirmation_info")\n         breaches = info.get_breaches()\n         self.assertEqual(len(breaches), 1)\n-        self.assertEqual(len(info.get_breaches()[0][\'sources\']), 1)\n-\n+        self.assertEqual(len(info.get_breaches()[0]["sources"]), 1)\n \n-class ReferenceGenerationDXTestCase(\n-    DXBaseTestCase,\n-    ReferenceGenerationTestCase,\n-):\n-    """Reference generation testcase for dx content types"""\n+    def test_sources_with_multiple_links_can_appear_multiple_times(self):\n+        """Test, if delete confirmation shows one document as source twice\n+        if it links to two of our to-be-deleted documents.\n+        """\n+        from plone.app.linkintegrity.testing import create\n \n-if six.PY2:\n-    from plone.app.linkintegrity.tests.base import ATBaseTestCase\n+        doc1 = self.portal.doc1\n+        doc2 = self.portal.doc2\n+        # create a document and create links to two existing documents\n+        doc5 = create(self.portal, "Document", id="doc5", title="Test Page 5")\n+        set_text(doc5, \'<a href="doc1">d1</a><a href="doc2">d2</a>\')\n+\n+        doc5_breaches = {r.to_object for r in getOutgoingLinks(doc5)}\n+        # the order of breaches is non-deterministic\n+        self.assertEqual({doc1, doc2}, doc5_breaches)\n+        view = self.portal.restrictedTraverse("@@delete_confirmation_info")\n+        # deleting the two referenced document results in two reported breaches\n+        self.assertEqual(len(view.get_breaches([doc1, doc2])), 2)\n+\n+    def test_if_breaches_under_excluded_paths_are_ignored(self):\n+        """Test, if breaches are ignored under certain conditions."""\n+        folder_containing_doc4 = self.portal.folder1\n+        doc4 = self.portal.folder1.doc4\n+        doc1 = self.portal.doc1\n+        set_text(doc4, \'<a href="doc1">d1</a>\')\n+        # sanity check: deleting doc1 causes one breach\n+        doc4_breaches = {r.to_object for r in getOutgoingLinks(doc4)}\n+        self.assertEqual({doc1}, doc4_breaches)\n+        view = self.portal.restrictedTraverse("@@delete_confirmation_info")\n+        self.assertEqual(len(view.get_breaches([doc1])), 1)\n+        # now check for other ways, that should do not produce any breach:\n+        # a) we delete the document that links to doc1\n+        self.assertEqual(len(view.get_breaches([doc1, doc4])), 0)\n+        # b) we delete the folder, containing the document that links to doc1\n+        self.assertEqual(len(view.get_breaches([doc1, folder_containing_doc4])), 0)\n+\n+    def test_if_same_prefix_and_breaches_work(self):\n+        """Verify that the same prefix does not lead to acciddental ignored\n+        links / breaches.\n+        """\n+        from plone.app.linkintegrity.testing import create\n \n-    class ReferenceGenerationATTestCase(\n-        ATBaseTestCase,\n-        ReferenceGenerationTestCase,\n-    ):\n-        """Reference generation testcase for at content types"""\n+        doc1 = self.portal.doc1\n+        my_page = create(self.portal, "Document", id="my-page", title="My page")\n+        my_page2 = create(\n+            self.portal,\n+            "Document",\n+            id="my-page-being-linked",\n+            title="My Page Being Linked",\n+        )\n+        # Create a link, that might be overlooked since both page\' ids start\n+        # with the same string ("my-page").\n+        set_text(doc1, \'<a href="my-page-being-linked">.</a>\')\n+        view = self.portal.restrictedTraverse("@@delete_confirmation_info")\n+        self.assertEqual(len(view.get_breaches([my_page, my_page2])), 1)\ndiff --git a/plone/app/linkintegrity/tests/test_upgrade.py b/plone/app/linkintegrity/tests/test_upgrade.py\ndeleted file mode 100644\nindex c363339..0000000\n--- a/plone/app/linkintegrity/tests/test_upgrade.py\n+++ /dev/null\n@@ -1,37 +0,0 @@\n-# -*- coding: utf-8 -*-\n-from plone.app.linkintegrity.upgrades import migrate_linkintegrity_relations\n-from plone.app.linkintegrity.utils import hasIncomingLinks\n-from plone.app.linkintegrity.utils import referencedRelationship\n-try:\n-    from Products.Archetypes.interfaces import IReferenceable\n-    from plone.app.linkintegrity.tests.base import ATBaseTestCase\n-    HAS_AT = True\n-except ImportError:\n-    HAS_AT = False\n-import unittest\n-\n-\n-if HAS_AT:\n-    class ReferenceMigrationATTestCase(ATBaseTestCase):\n-        """Reference migration testcase for at content types"""\n-\n-        @unittest.skipUnless(\n-            HAS_AT, \'Archetypes are not installed. Skipping migration tests\')\n-        def test_upgrade(self):\n-            doc3 = self.portal[\'doc3\']\n-            doc1 = self.portal[\'doc1\']\n-            self.assertTrue(IReferenceable.providedBy(doc3))\n-            doc3.setText(\'<a href="doc1">doc1</a>\', mimetype=\'text/html\')\n-            doc3.addReference(doc1, relationship=referencedRelationship)\n-            self.assertFalse(hasIncomingLinks(doc1))\n-            self.assertFalse(hasIncomingLinks(doc3))\n-            migrate_linkintegrity_relations(self.portal)\n-            self.assertTrue(hasIncomingLinks(doc1))\n-            self.assertFalse(hasIncomingLinks(doc3))\n-\n-else:\n-\n-    class TestDummy(unittest.TestCase):\n-\n-        def test_dummy(self):\n-            pass\ndiff --git a/plone/app/linkintegrity/tests/utils.py b/plone/app/linkintegrity/tests/utils.py\nnew file mode 100644\nindex 0000000..895e85f\n--- /dev/null\n+++ b/plone/app/linkintegrity/tests/utils.py\n@@ -0,0 +1,7 @@\n+from plone.app.textfield import RichTextValue\n+from zope.lifecycleevent import modified\n+\n+\n+def set_text(obj, text):\n+    obj.text = RichTextValue(text)\n+    modified(obj)\ndiff --git a/plone/app/linkintegrity/upgrades.py b/plone/app/linkintegrity/upgrades.py\ndeleted file mode 100644\nindex a803180..0000000\n--- a/plone/app/linkintegrity/upgrades.py\n+++ /dev/null\n@@ -1,48 +0,0 @@\n-# -*- coding: utf-8 -*-\n-from plone.app.linkintegrity.utils import ensure_intid\n-from plone.app.linkintegrity.utils import referencedRelationship\n-from plone.app.uuid.utils import uuidToObject\n-try:\n-    from Products.Archetypes.config import REFERENCE_CATALOG\n-except ImportError:\n-    REFERENCE_CATALOG = "reference_catalog"\n-from Products.CMFCore.utils import getToolByName\n-from z3c.relationfield import RelationValue\n-from z3c.relationfield.event import _setRelation\n-from zope.component import getUtility\n-from zope.intid.interfaces import IIntIds\n-\n-import logging\n-log = logging.getLogger(__name__)\n-\n-\n-def migrate_linkintegrity_relations(context):\n-    """Migrate linkintegrity-relation from reference_catalog to zc.relation.\n-    """\n-    reference_catalog = getToolByName(context, REFERENCE_CATALOG, None)\n-    intids = getUtility(IIntIds)\n-    if reference_catalog is not None:\n-        # Only handle linkintegrity-relations (\'isReferencing\').\n-        # [:] copies the full result list to make sure\n-        # it won\'t change while we delete references below\n-        for brain in reference_catalog(relationship=referencedRelationship)[:]:\n-            try:\n-                source_obj = uuidToObject(brain.sourceUID)\n-                target_obj = uuidToObject(brain.targetUID)\n-            except AttributeError:\n-                source_obj = target_obj = None\n-            if source_obj is None or target_obj is None:\n-                # reference_catalog may be inconsistent\n-                log.info(\'Cannot delete relation since the relation_catalog is inconsistent.\')   # noqa: E501\n-                continue\n-            # Delete old reference\n-            reference_catalog.deleteReference(\n-                source_obj, target_obj, relationship=referencedRelationship)\n-\n-            # Trigger the recreation of linkintegrity-relation in\n-            # the relation_catalog (zc.relation)\n-            target_id = ensure_intid(target_obj, intids)\n-            if target_id is None:\n-                continue\n-            rel = RelationValue(target_id)\n-            _setRelation(source_obj, referencedRelationship, rel)\ndiff --git a/plone/app/linkintegrity/utils.py b/plone/app/linkintegrity/utils.py\nindex 226efac..5990bdd 100644\n--- a/plone/app/linkintegrity/utils.py\n+++ b/plone/app/linkintegrity/utils.py\n@@ -1,27 +1,23 @@\n-# -*- coding: utf-8 -*-\n+from plone.base.interfaces import IEditingSchema\n from plone.registry.interfaces import IRegistry\n-from Products.CMFPlone.interfaces import IEditingSchema\n from zc.relation.interfaces import ICatalog\n from zope.component import getUtility\n from zope.intid.interfaces import IIntIds\n from zope.keyreference.interfaces import NotYet\n \n-referencedRelationship = \'isReferencing\'\n \n+referencedRelationship = "isReferencing"\n \n-def getIncomingLinks(\n-    obj=None,\n-    intid=None,\n-    from_attribute=referencedRelationship\n-):\n+\n+def getIncomingLinks(obj=None, intid=None, from_attribute=referencedRelationship):\n     """Return a generator of incoming relations created using\n     plone.app.linkintegrity (Links in Richtext-Fields).\n     """\n     catalog = getUtility(ICatalog)\n     intid = intid if intid is not None else getUtility(IIntIds).getId(obj)\n-    query = {\'to_id\': intid}\n+    query = {"to_id": intid}\n     if from_attribute:\n-        query[\'from_attribute\'] = from_attribute\n+        query["from_attribute"] = from_attribute\n     return catalog.findRelations(query)\n \n \n@@ -36,19 +32,15 @@ def hasIncomingLinks(obj=None, intid=None):\n     return False\n \n \n-def getOutgoingLinks(\n-    obj=None,\n-    intid=None,\n-    from_attribute=referencedRelationship\n-):\n+def getOutgoingLinks(obj=None, intid=None, from_attribute=referencedRelationship):\n     """Return a generator of outgoing relations created using\n     plone.app.linkintegrity (Links in Richtext-Fields).\n     """\n     catalog = getUtility(ICatalog)\n     intid = intid if intid is not None else getUtility(IIntIds).getId(obj)\n-    query = {\'from_id\': intid}\n+    query = {"from_id": intid}\n     if from_attribute:\n-        query[\'from_attribute\'] = from_attribute\n+        query["from_attribute"] = from_attribute\n     return catalog.findRelations(query)\n \n \n@@ -63,7 +55,7 @@ def hasOutgoingLinks(obj=None, intid=None):\n \n def linkintegrity_enabled():\n     reg = getUtility(IRegistry)\n-    editing_settings = reg.forInterface(IEditingSchema, prefix=\'plone\')\n+    editing_settings = reg.forInterface(IEditingSchema, prefix="plone")\n     return editing_settings.enable_link_integrity_checks\n \n \ndiff --git a/pyproject.toml b/pyproject.toml\nindex 05b615d..f39d091 100644\n--- a/pyproject.toml\n+++ b/pyproject.toml\n@@ -1,6 +1,12 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/main/config/default\n+# See the inline comments on how to expand/tweak this configuration file\n+[build-system]\n+requires = ["setuptools>=68.2"]\n+\n [tool.towncrier]\n-filename = "CHANGES.rst"\n directory = "news/"\n+filename = "CHANGES.rst"\n title_format = "{version} ({project_date})"\n underlines = ["-", ""]\n \n@@ -18,3 +24,136 @@ showcontent = true\n directory = "bugfix"\n name = "Bug fixes:"\n showcontent = true\n+\n+[[tool.towncrier.type]]\n+directory = "internal"\n+name = "Internal:"\n+showcontent = true\n+\n+[[tool.towncrier.type]]\n+directory = "documentation"\n+name = "Documentation:"\n+showcontent = true\n+\n+[[tool.towncrier.type]]\n+directory = "tests"\n+name = "Tests"\n+showcontent = true\n+\n+##\n+# Add extra configuration options in .meta.toml:\n+#  [pyproject]\n+#  towncrier_extra_lines = """\n+#  extra_configuration\n+#  """\n+##\n+\n+[tool.isort]\n+profile = "plone"\n+\n+##\n+# Add extra configuration options in .meta.toml:\n+#  [pyproject]\n+#  isort_extra_lines = """\n+#  extra_configuration\n+#  """\n+##\n+\n+[tool.black]\n+target-version = ["py38"]\n+\n+##\n+# Add extra configuration options in .meta.toml:\n+#  [pyproject]\n+#  black_extra_lines = """\n+#  extra_configuration\n+#  """\n+##\n+\n+[tool.codespell]\n+ignore-words-list = "discreet,"\n+skip = "*.po,"\n+##\n+# Add extra configuration options in .meta.toml:\n+#  [pyproject]\n+#  codespell_ignores = "foo,bar"\n+#  codespell_skip = "*.po,*.map,package-lock.json"\n+##\n+\n+[tool.dependencychecker]\n+Zope = [\n+  # Zope own provided namespaces\n+  \'App\', \'OFS\', \'Products.Five\', \'Products.OFSP\', \'Products.PageTemplates\',\n+  \'Products.SiteAccess\', \'Shared\', \'Testing\', \'ZPublisher\', \'ZTUtils\',\n+  \'Zope2\', \'webdav\', \'zmi\',\n+  # ExtensionClass own provided namespaces\n+  \'ExtensionClass\', \'ComputedAttribute\', \'MethodObject\',\n+  # Zope dependencies\n+  \'AccessControl\', \'Acquisition\', \'AuthEncoding\', \'beautifulsoup4\', \'BTrees\',\n+  \'cffi\', \'Chameleon\', \'DateTime\', \'DocumentTemplate\',\n+  \'MultiMapping\', \'multipart\', \'PasteDeploy\', \'Persistence\', \'persistent\',\n+  \'pycparser\', \'python-gettext\', \'pytz\', \'RestrictedPython\', \'roman\',\n+  \'soupsieve\', \'transaction\', \'waitress\', \'WebOb\', \'WebTest\', \'WSGIProxy2\',\n+  \'z3c.pt\', \'zc.lockfile\', \'ZConfig\', \'zExceptions\', \'ZODB\', \'zodbpickle\',\n+  \'zope.annotation\', \'zope.browser\', \'zope.browsermenu\', \'zope.browserpage\',\n+  \'zope.browserresource\', \'zope.cachedescriptors\', \'zope.component\',\n+  \'zope.configuration\', \'zope.container\', \'zope.contentprovider\',\n+  \'zope.contenttype\', \'zope.datetime\', \'zope.deferredimport\',\n+  \'zope.deprecation\', \'zope.dottedname\', \'zope.event\', \'zope.exceptions\',\n+  \'zope.filerepresentation\', \'zope.globalrequest\', \'zope.hookable\',\n+  \'zope.i18n\', \'zope.i18nmessageid\', \'zope.interface\', \'zope.lifecycleevent\',\n+  \'zope.location\', \'zope.pagetemplate\', \'zope.processlifetime\', \'zope.proxy\',\n+  \'zope.ptresource\', \'zope.publisher\', \'zope.schema\', \'zope.security\',\n+  \'zope.sequencesort\', \'zope.site\', \'zope.size\', \'zope.structuredtext\',\n+  \'zope.tal\', \'zope.tales\', \'zope.testbrowser\', \'zope.testing\',\n+  \'zope.traversing\', \'zope.viewlet\'\n+]\n+\'Products.CMFCore\' = [\n+  \'docutils\', \'five.localsitemanager\', \'Missing\', \'Products.BTreeFolder2\',\n+  \'Products.GenericSetup\', \'Products.MailHost\', \'Products.PythonScripts\',\n+  \'Products.StandardCacheManagers\', \'Products.ZCatalog\', \'Record\',\n+  \'zope.sendmail\', \'Zope\'\n+]\n+\'plone.base\' = [\n+  \'plone.batching\', \'plone.registry\', \'plone.schema\',\'plone.z3cform\',\n+  \'Products.CMFCore\', \'Products.CMFDynamicViewFTI\',\n+]\n+python-dateutil = [\'dateutil\']\n+\n+##\n+# Add extra configuration options in .meta.toml:\n+#  [pyproject]\n+#  dependencies_ignores = "[\'zestreleaser.towncrier\']"\n+#  dependencies_mappings = [\n+#    "gitpython = [\'git\']",\n+#    "pygithub = [\'github\']",\n+#  ]\n+##\n+\n+[tool.check-manifest]\n+ignore = [\n+    ".editorconfig",\n+    ".meta.toml",\n+    ".pre-commit-config.yaml",\n+    "tox.ini",\n+    ".flake8",\n+    "mx.ini",\n+\n+]\n+##\n+# Add extra configuration options in .meta.toml:\n+#  [pyproject]\n+#  check_manifest_ignores = """\n+#      "*.map.js",\n+#      "*.pyc",\n+#  """\n+##\n+\n+\n+##\n+# Add extra configuration options in .meta.toml:\n+#  [pyproject]\n+#  extra_lines = """\n+#  _your own configuration lines_\n+#  """\n+##\ndiff --git a/setup.cfg b/setup.cfg\ndeleted file mode 100644\nindex c01f844..0000000\n--- a/setup.cfg\n+++ /dev/null\n@@ -1,5 +0,0 @@\n-[zest.releaser]\n-extra-message = [ci skip]\n-\n-[bdist_wheel]\n-universal = 1\ndiff --git a/setup.py b/setup.py\nindex d2ae99c..a13cb6b 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -1,61 +1,75 @@\n-# -*- coding: utf-8 -*-\n from setuptools import find_packages\n from setuptools import setup\n \n \n-version = \'3.3.10.dev0\'\n+version = "4.0.6.dev0"\n \n setup(\n-    name=\'plone.app.linkintegrity\',\n+    name="plone.app.linkintegrity",\n     version=version,\n-    description=\'Manage link integrity in Plone.\',\n-    long_description=\'\\n\\n\'.join([\n-        open("README.rst").read(),\n-        open(\'CHANGES.rst\').read(),\n-    ]),\n+    description="Manage link integrity in Plone.",\n+    long_description="\\n\\n".join(\n+        [\n+            open("README.rst").read(),\n+            open("CHANGES.rst").read(),\n+        ]\n+    ),\n     classifiers=[\n         "Development Status :: 5 - Production/Stable",\n         "Environment :: Web Environment",\n         "Framework :: Plone",\n-        "Framework :: Plone :: 5.1",\n-        "Framework :: Plone :: 5.2",\n-        "Framework :: Zope2",\n-        "Framework :: Zope :: 4",\n+        "Framework :: Plone :: 6.0",\n+        "Framework :: Plone :: Core",\n+        "Framework :: Zope :: 5",\n         "Intended Audience :: Other Audience",\n         "Intended Audience :: System Administrators",\n         "License :: OSI Approved :: GNU General Public License v2 (GPLv2)",\n         "Operating System :: OS Independent",\n         "Programming Language :: Python",\n-        "Programming Language :: Python :: 2.7",\n-        "Programming Language :: Python :: 3.6",\n-        "Programming Language :: Python :: 3.7",\n+        "Programming Language :: Python :: 3.8",\n+        "Programming Language :: Python :: 3.9",\n+        "Programming Language :: Python :: 3.10",\n+        "Programming Language :: Python :: 3.11",\n         "Topic :: Internet :: WWW/HTTP :: Site Management :: Link Checking",\n     ],\n-    keywords=\'link integrity plone\',\n-    author=\'Plone Foundation\',\n-    author_email=\'plone-developers@lists.sourceforge.net\',\n-    url=\'https://pypi.org/project/plone.app.linkintegrity\',\n-    license=\'GPL version 2\',\n+    keywords="link integrity plone",\n+    author="Plone Foundation",\n+    author_email="plone-developers@lists.sourceforge.net",\n+    url="https://github.com/plone/plone.app.linkintegrity",\n+    license="GPL version 2",\n     packages=find_packages(),\n-    namespace_packages=[\'plone\', \'plone.app\'],\n+    namespace_packages=["plone", "plone.app"],\n     include_package_data=True,\n+    python_requires=">=3.8",\n     install_requires=[\n-        \'setuptools\',\n-        \'six\',\n-        \'plone.app.intid\',\n-        \'plone.app.relationfield\',\n+        "setuptools",\n+        "plone.app.intid",\n+        "plone.app.relationfield",\n+        "plone.base",\n+        "plone.dexterity",\n+        "Products.GenericSetup",\n+        "Products.statusmessages",\n+        "plone.app.textfield",\n+        "plone.app.uuid",\n+        "plone.registry",\n+        "plone.uuid",\n+        "Zope",\n+        "z3c.relationfield",\n+        "zc.relation",\n+        "zope.intid",\n+        "zope.keyreference",\n     ],\n     extras_require={\n-        \'test\': [\n-            \'plone.app.testing\',\n-            \'plone.app.contenttypes\',\n-            \'plone.app.dexterity [relations]\',  # related items in dx 2.0\n+        "test": [\n+            "plone.app.testing",\n+            "plone.namedfile",\n+            "plone.testing",\n         ],\n     },\n-    platforms=\'Any\',\n+    platforms="Any",\n     zip_safe=False,\n-    entry_points=\'\'\'\n+    entry_points="""\n     [z3c.autoinclude.plugin]\n     target = plone\n-    \'\'\',\n+    """,\n )\ndiff --git a/tox.ini b/tox.ini\nnew file mode 100644\nindex 0000000..72790fa\n--- /dev/null\n+++ b/tox.ini\n@@ -0,0 +1,216 @@\n+# Generated from:\n+# https://github.com/plone/meta/tree/main/config/default\n+# See the inline comments on how to expand/tweak this configuration file\n+[tox]\n+# We need 4.4.0 for constrain_package_deps.\n+min_version = 4.4.0\n+envlist =\n+    lint\n+    test\n+    dependencies\n+\n+\n+##\n+# Add extra configuration options in .meta.toml:\n+#  [tox]\n+#  envlist_lines = """\n+#      my_other_environment\n+#  """\n+#  config_lines = """\n+#  my_extra_top_level_tox_configuration_lines\n+#  """\n+##\n+\n+[testenv]\n+skip_install = true\n+allowlist_externals =\n+    echo\n+    false\n+# Make sure typos like `tox -e formaat` are caught instead of silently doing nothing.\n+# See https://github.com/tox-dev/tox/issues/2858.\n+commands =\n+    echo "Unrecognized environment name {envname}"\n+    false\n+\n+##\n+# Add extra configuration options in .meta.toml:\n+#  [tox]\n+#  testenv_options = """\n+#  basepython = /usr/bin/python3.8\n+#  """\n+##\n+\n+[testenv:init]\n+description = Prepare environment\n+skip_install = true\n+commands =\n+    echo "Initial setup complete"\n+\n+\n+[testenv:format]\n+description = automatically reformat code\n+skip_install = true\n+deps =\n+    pre-commit\n+commands =\n+    pre-commit run -a pyupgrade\n+    pre-commit run -a isort\n+    pre-commit run -a black\n+    pre-commit run -a zpretty\n+\n+[testenv:lint]\n+description = run linters that will help improve the code style\n+skip_install = true\n+deps =\n+    pre-commit\n+commands =\n+    pre-commit run -a\n+\n+[testenv:dependencies]\n+description = check if the package defines all its dependencies\n+skip_install = true\n+deps =\n+    build\n+    z3c.dependencychecker==2.14.3\n+commands =\n+    python -m build --sdist\n+    dependencychecker\n+\n+[testenv:dependencies-graph]\n+description = generate a graph out of the dependencies of the package\n+skip_install = false\n+allowlist_externals =\n+    sh\n+deps =\n+    pipdeptree==2.5.1\n+    graphviz  # optional dependency of pipdeptree\n+commands =\n+    sh -c \'pipdeptree --exclude setuptools,wheel,pipdeptree,zope.interface,zope.component --graph-output svg > dependencies.svg\'\n+\n+[testenv:test]\n+description = run the distribution tests\n+use_develop = true\n+skip_install = false\n+constrain_package_deps = true\n+set_env =\n+    ROBOT_BROWSER=headlesschrome\n+\n+##\n+# Specify extra test environment variables in .meta.toml:\n+#  [tox]\n+#  test_environment_variables = """\n+#      PIP_EXTRA_INDEX_URL=https://my-pypi.my-server.com/\n+#  """\n+#\n+# Set constrain_package_deps .meta.toml:\n+#  [tox]\n+#  constrain_package_deps = "false"\n+##\n+deps =\n+    zope.testrunner\n+    -c https://dist.plone.org/release/6.0-dev/constraints.txt\n+    \n+##\n+# Specify additional deps in .meta.toml:\n+#  [tox]\n+#  test_deps_additional = "-esources/plonegovbr.portal_base[test]"\n+#\n+# Specify a custom constraints file in .meta.toml:\n+#  [tox]\n+#  constraints_file = "https://my-server.com/constraints.txt"\n+##\n+commands =\n+    zope-testrunner --all --test-path={toxinidir} -s plone.app.linkintegrity {posargs}\n+extras =\n+    test\n+\n+##\n+# Add extra configuration options in .meta.toml:\n+#  [tox]\n+#  test_extras = """\n+#      tests\n+#      widgets\n+#  """\n+##\n+\n+[testenv:coverage]\n+description = get a test coverage report\n+use_develop = true\n+skip_install = false\n+constrain_package_deps = true\n+set_env =\n+    ROBOT_BROWSER=headlesschrome\n+\n+##\n+# Specify extra test environment variables in .meta.toml:\n+#  [tox]\n+#  test_environment_variables = """\n+#      PIP_EXTRA_INDEX_URL=https://my-pypi.my-server.com/\n+#  """\n+##\n+deps =\n+    coverage\n+    zope.testrunner\n+    -c https://dist.plone.org/release/6.0-dev/constraints.txt\n+    \n+commands =\n+    coverage run --branch --source plone.app.linkintegrity {envbindir}/zope-testrunner --quiet --all --test-path={toxinidir} -s plone.app.linkintegrity {posargs}\n+    coverage report -m --format markdown\n+    coverage xml\n+extras =\n+    test\n+\n+\n+[testenv:release-check]\n+description = ensure that the distribution is ready to release\n+skip_install = true\n+deps =\n+    twine\n+    build\n+    towncrier\n+    -c https://dist.plone.org/release/6.0-dev/constraints.txt\n+    \n+commands =\n+    # fake version to not have to install the package\n+    # we build the change log as news entries might break\n+    # the README that is displayed on PyPI\n+    towncrier build --version=100.0.0 --yes\n+    python -m build --sdist\n+    twine check dist/*\n+\n+[testenv:circular]\n+description = ensure there are no cyclic dependencies\n+use_develop = true\n+skip_install = false\n+set_env =\n+\n+##\n+# Specify extra test environment variables in .meta.toml:\n+#  [tox]\n+#  test_environment_variables = """\n+#      PIP_EXTRA_INDEX_URL=https://my-pypi.my-server.com/\n+#  """\n+##\n+allowlist_externals =\n+    sh\n+deps =\n+    pipdeptree\n+    pipforester\n+    -c https://dist.plone.org/release/6.0-dev/constraints.txt\n+    \n+commands =\n+    # Generate the full dependency tree\n+    sh -c \'pipdeptree -j > forest.json\'\n+    # Generate a DOT graph with the circular dependencies, if any\n+    pipforester -i forest.json -o forest.dot --cycles\n+    # Report if there are any circular dependencies, i.e. error if there are any\n+    pipforester -i forest.json --check-cycles -o /dev/null\n+\n+\n+##\n+# Add extra configuration options in .meta.toml:\n+#  [tox]\n+#  extra_lines = """\n+#  _your own configuration lines_\n+#  """\n+##\n'

Repository: plone.app.linkintegrity


Branch: refs/heads/master
Date: 2024-06-12T13:50:47-04:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.app.linkintegrity/commit/37b1ee94d81230547eaebed364d41c1b63f937b2

Merge branch 'master' into add_regression_test

Files changed:
M .meta.toml
M .pre-commit-config.yaml
M pyproject.toml

b'diff --git a/.meta.toml b/.meta.toml\nindex d4b79f8..1fe6a71 100644\n--- a/.meta.toml\n+++ b/.meta.toml\n@@ -4,3 +4,6 @@\n [meta]\n template = "default"\n commit-id = "6e36bcc4"\n+\n+[pyproject]\n+codespell_ignores = "discreet,assertin"\n\\ No newline at end of file\ndiff --git a/.pre-commit-config.yaml b/.pre-commit-config.yaml\nindex f857b48..da56023 100644\n--- a/.pre-commit-config.yaml\n+++ b/.pre-commit-config.yaml\n@@ -7,7 +7,7 @@ ci:\n \n repos:\n -   repo: https://github.com/asottile/pyupgrade\n-    rev: v3.15.0\n+    rev: v3.15.2\n     hooks:\n     -   id: pyupgrade\n         args: [--py38-plus]\n@@ -16,7 +16,7 @@ repos:\n     hooks:\n     -   id: isort\n -   repo: https://github.com/psf/black\n-    rev: 24.1.1\n+    rev: 24.4.2\n     hooks:\n     -   id: black\n -   repo: https://github.com/collective/zpretty\n@@ -44,7 +44,7 @@ repos:\n #  """\n ##\n -   repo: https://github.com/codespell-project/codespell\n-    rev: v2.2.6\n+    rev: v2.3.0\n     hooks:\n     -   id: codespell\n         additional_dependencies:\n@@ -71,7 +71,7 @@ repos:\n     -   id: check-python-versions\n         args: [\'--only\', \'setup.py,pyproject.toml\']\n -   repo: https://github.com/collective/i18ndude\n-    rev: "6.1.0"\n+    rev: "6.2.0"\n     hooks:\n     -   id: i18ndude\n \ndiff --git a/pyproject.toml b/pyproject.toml\nindex f39d091..17116ec 100644\n--- a/pyproject.toml\n+++ b/pyproject.toml\n@@ -71,7 +71,7 @@ target-version = ["py38"]\n ##\n \n [tool.codespell]\n-ignore-words-list = "discreet,"\n+ignore-words-list = "discreet,assertin"\n skip = "*.po,"\n ##\n # Add extra configuration options in .meta.toml:\n'

Repository: plone.app.linkintegrity


Branch: refs/heads/master
Date: 2024-06-12T19:53:45+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.app.linkintegrity/commit/0638e608b24a59ffcb0594888da95c5d706ad507

precommit run -a

Files changed:
M plone/app/linkintegrity/tests/test_copy_paste.py

b'diff --git a/plone/app/linkintegrity/tests/test_copy_paste.py b/plone/app/linkintegrity/tests/test_copy_paste.py\nindex 9dd20b4..f3c6e62 100644\n--- a/plone/app/linkintegrity/tests/test_copy_paste.py\n+++ b/plone/app/linkintegrity/tests/test_copy_paste.py\n@@ -1,5 +1,6 @@\n-# -*- coding: utf-8 -*-\n-from plone.app.linkintegrity.testing import PLONE_APP_LINKINTEGRITY_DX_INTEGRATION_TESTING  # noqa: E501\n+from plone.app.linkintegrity.testing import (  # noqa: E501\n+    PLONE_APP_LINKINTEGRITY_DX_INTEGRATION_TESTING,\n+)\n from plone.app.testing import setRoles\n from plone.app.testing import TEST_USER_ID\n from plone.app.textfield import RichTextValue\n@@ -13,35 +14,37 @@ class TestCopyPaste(unittest.TestCase):\n     layer = PLONE_APP_LINKINTEGRITY_DX_INTEGRATION_TESTING\n \n     def setUp(self):\n-        self.portal = self.layer[\'portal\']\n-        self.request = self.layer[\'request\']\n-        setRoles(self.portal, TEST_USER_ID, [\'Manager\'])\n+        self.portal = self.layer["portal"]\n+        self.request = self.layer["request"]\n+        setRoles(self.portal, TEST_USER_ID, ["Manager"])\n \n     def test_copy_paste(self):\n         """Test that https://github.com/plone/Products.CMFPlone/issues/2866\n         is fixed. Setting relations during copy&paste failed in Zope 4.\n         """\n-        self.portal.invokeFactory(\'Image\', \'image\', title=u\'Image\')\n-        self.portal.invokeFactory(\'Document\', \'document\', title=u\'Document\')\n-        document = self.portal[\'document\']\n-        image = self.portal[\'image\']\n+        self.portal.invokeFactory("Image", "image", title="Image")\n+        self.portal.invokeFactory("Document", "document", title="Document")\n+        document = self.portal["document"]\n+        image = self.portal["image"]\n         text = RichTextValue(\n             \'<p><img src="{portal}/resolveuid/{uid}/@@images/image/large" class="image-inline" data-linktype="image" data-scale="large" data-val="{uid}" data-mce-src="{portal}/resolveuid/{uid}/@@images/image/large" data-mce-selected="1"></p>\'.format(\n-                portal=u\'..\',\n-                uid=image.UID()),\n-            \'text/html\', \'text/x-html-safe\')\n+                portal="..", uid=image.UID()\n+            ),\n+            "text/html",\n+            "text/x-html-safe",\n+        )\n         document.text = text\n         modified(document)\n-        self.portal.invokeFactory(\'Folder\', \'folder\', title=u\'Folder\')\n-        target = self.portal[\'folder\']\n+        self.portal.invokeFactory("Folder", "folder", title="Folder")\n+        target = self.portal["folder"]\n \n-        copied = self.portal.manage_copyObjects(\'document\')\n+        copied = self.portal.manage_copyObjects("document")\n         target.manage_pasteObjects(copied)\n-        self.assertTrue(target[\'document\'])\n+        self.assertTrue(target["document"])\n         # check that linkintegrity-relations exists for both items:\n-        info = image.restrictedTraverse(\'@@delete_confirmation_info\')\n+        info = image.restrictedTraverse("@@delete_confirmation_info")\n         breaches = info.get_breaches()\n-        self.assertEqual(len(breaches[0][\'sources\']), 2)\n-        uids_objs = [i.UID() for i in [target[\'document\'], document]]\n-        uids_rels = [i[\'uid\'] for i in breaches[0][\'sources\']]\n+        self.assertEqual(len(breaches[0]["sources"]), 2)\n+        uids_objs = [i.UID() for i in [target["document"], document]]\n+        uids_rels = [i["uid"] for i in breaches[0]["sources"]]\n         self.assertEqual(set(uids_objs), set(uids_rels))\n'

Repository: plone.app.linkintegrity


Branch: refs/heads/master
Date: 2024-06-12T19:56:50+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.app.linkintegrity/commit/d5c211435cb85d098a366022debb353d703a3499

fix import

Files changed:
M plone/app/linkintegrity/tests/test_copy_paste.py

b'diff --git a/plone/app/linkintegrity/tests/test_copy_paste.py b/plone/app/linkintegrity/tests/test_copy_paste.py\nindex f3c6e62..9706443 100644\n--- a/plone/app/linkintegrity/tests/test_copy_paste.py\n+++ b/plone/app/linkintegrity/tests/test_copy_paste.py\n@@ -1,6 +1,4 @@\n-from plone.app.linkintegrity.testing import (  # noqa: E501\n-    PLONE_APP_LINKINTEGRITY_DX_INTEGRATION_TESTING,\n-)\n+from plone.app.linkintegrity.testing import PLONE_APP_LINKINTEGRITY_INTEGRATION_TESTING\n from plone.app.testing import setRoles\n from plone.app.testing import TEST_USER_ID\n from plone.app.textfield import RichTextValue\n@@ -11,7 +9,7 @@\n \n class TestCopyPaste(unittest.TestCase):\n \n-    layer = PLONE_APP_LINKINTEGRITY_DX_INTEGRATION_TESTING\n+    layer = PLONE_APP_LINKINTEGRITY_INTEGRATION_TESTING\n \n     def setUp(self):\n         self.portal = self.layer["portal"]\n'

Repository: plone.app.linkintegrity


Branch: refs/heads/master
Date: 2024-06-12T13:59:08-04:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.app.linkintegrity/commit/73af526c6938e965d255d60195f08ad7b7ce82e9

Merge pull request #71 from plone/add_regression_test

add regression-test for broken copy&amp;paste

Files changed:
A news/71.bugfix
A plone/app/linkintegrity/tests/test_copy_paste.py

b'diff --git a/news/71.bugfix b/news/71.bugfix\nnew file mode 100644\nindex 0000000..0f20903\n--- /dev/null\n+++ b/news/71.bugfix\n@@ -0,0 +1,2 @@\n+Add regression-test for broken copy&paste. See https://github.com/plone/Products.CMFPlone/issues/2866\n+[pbauer]\n\\ No newline at end of file\ndiff --git a/plone/app/linkintegrity/tests/test_copy_paste.py b/plone/app/linkintegrity/tests/test_copy_paste.py\nnew file mode 100644\nindex 0000000..9706443\n--- /dev/null\n+++ b/plone/app/linkintegrity/tests/test_copy_paste.py\n@@ -0,0 +1,48 @@\n+from plone.app.linkintegrity.testing import PLONE_APP_LINKINTEGRITY_INTEGRATION_TESTING\n+from plone.app.testing import setRoles\n+from plone.app.testing import TEST_USER_ID\n+from plone.app.textfield import RichTextValue\n+from zope.lifecycleevent import modified\n+\n+import unittest\n+\n+\n+class TestCopyPaste(unittest.TestCase):\n+\n+    layer = PLONE_APP_LINKINTEGRITY_INTEGRATION_TESTING\n+\n+    def setUp(self):\n+        self.portal = self.layer["portal"]\n+        self.request = self.layer["request"]\n+        setRoles(self.portal, TEST_USER_ID, ["Manager"])\n+\n+    def test_copy_paste(self):\n+        """Test that https://github.com/plone/Products.CMFPlone/issues/2866\n+        is fixed. Setting relations during copy&paste failed in Zope 4.\n+        """\n+        self.portal.invokeFactory("Image", "image", title="Image")\n+        self.portal.invokeFactory("Document", "document", title="Document")\n+        document = self.portal["document"]\n+        image = self.portal["image"]\n+        text = RichTextValue(\n+            \'<p><img src="{portal}/resolveuid/{uid}/@@images/image/large" class="image-inline" data-linktype="image" data-scale="large" data-val="{uid}" data-mce-src="{portal}/resolveuid/{uid}/@@images/image/large" data-mce-selected="1"></p>\'.format(\n+                portal="..", uid=image.UID()\n+            ),\n+            "text/html",\n+            "text/x-html-safe",\n+        )\n+        document.text = text\n+        modified(document)\n+        self.portal.invokeFactory("Folder", "folder", title="Folder")\n+        target = self.portal["folder"]\n+\n+        copied = self.portal.manage_copyObjects("document")\n+        target.manage_pasteObjects(copied)\n+        self.assertTrue(target["document"])\n+        # check that linkintegrity-relations exists for both items:\n+        info = image.restrictedTraverse("@@delete_confirmation_info")\n+        breaches = info.get_breaches()\n+        self.assertEqual(len(breaches[0]["sources"]), 2)\n+        uids_objs = [i.UID() for i in [target["document"], document]]\n+        uids_rels = [i["uid"] for i in breaches[0]["sources"]]\n+        self.assertEqual(set(uids_objs), set(uids_rels))\n'

