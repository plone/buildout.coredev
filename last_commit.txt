Repository: plone.restapi


Branch: refs/heads/main
Date: 2024-06-12T15:59:17-07:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.restapi/commit/bbff5b890bb848f48688a0acecfeff6d33fdbf25

Make Teaser blocks dynamic (#1788)

* Allow teaser to be dynamic

* handle old blocks correctly

* better naming of variables

* Add changenote

* compile regex to save the planet

* Update src/plone/restapi/serializer/blocks.py

Co-authored-by: Jens W. Klein &lt;jk@kleinundpartner.at&gt;

* lint

* tests

* Update news/1788.feature

---------

Co-authored-by: Timo Stollenwerk &lt;tisto@users.noreply.github.com&gt;
Co-authored-by: Jens W. Klein &lt;jk@kleinundpartner.at&gt;
Co-authored-by: David Glick &lt;david@glicksoftware.com&gt;

Files changed:
A news/1788.feature
M src/plone/restapi/serializer/blocks.py
M src/plone/restapi/serializer/configure.zcml
M src/plone/restapi/tests/test_blocks_serializer.py

b'diff --git a/news/1788.feature b/news/1788.feature\nnew file mode 100644\nindex 000000000..b24523446\n--- /dev/null\n+++ b/news/1788.feature\n@@ -0,0 +1 @@\n+Added TeaserBlockSerializer which updates the contents of a teaser block from its target if the block has `"overwrite": false`. @pbauer, @davisagli\n\\ No newline at end of file\ndiff --git a/src/plone/restapi/serializer/blocks.py b/src/plone/restapi/serializer/blocks.py\nindex d36d0bc0e..da1c4a2e6 100644\n--- a/src/plone/restapi/serializer/blocks.py\n+++ b/src/plone/restapi/serializer/blocks.py\n@@ -1,3 +1,5 @@\n+from plone import api\n+from plone.app.uuid.utils import uuidToCatalogBrain\n from plone.restapi.bbb import IPloneSiteRoot\n from plone.restapi.behaviors import IBlocks\n from plone.restapi.blocks import visit_blocks, iter_block_transform_handlers\n@@ -6,17 +8,20 @@\n from plone.restapi.deserializer.blocks import transform_links\n from plone.restapi.interfaces import IBlockFieldSerializationTransformer\n from plone.restapi.interfaces import IFieldSerializer\n+from plone.restapi.interfaces import ISerializeToJsonSummary\n from plone.restapi.serializer.converters import json_compatible\n from plone.restapi.serializer.dxfields import DefaultFieldSerializer\n from plone.restapi.serializer.utils import resolve_uid, uid_to_url\n from plone.schema import IJSONField\n from zope.component import adapter\n+from zope.component import getMultiAdapter\n from zope.interface import implementer\n from zope.interface import Interface\n from zope.publisher.interfaces.browser import IBrowserRequest\n \n import copy\n import os\n+import re\n \n \n @adapter(IJSONField, IBlocks, Interface)\n@@ -193,3 +198,81 @@ class SlateTableBlockSerializer(SlateTableBlockSerializerBase):\n @adapter(IPloneSiteRoot, IBrowserRequest)\n class SlateTableBlockSerializerRoot(SlateTableBlockSerializerBase):\n     """Serializer for site root"""\n+\n+\n+class TeaserBlockSerializerBase:\n+    order = 0\n+    block_type = "teaser"\n+\n+    def __init__(self, context, request):\n+        self.context = context\n+        self.request = request\n+\n+    def __call__(self, block):\n+        return self._process_data(block)\n+\n+    def _process_data(self, data, field=None):\n+        value = data.get("href", "")\n+        if value:\n+            if "overwrite" not in data:\n+                # A block without this option is old and keeps the behavior\n+                # where data is not dynamically pulled from the href\n+                data["overwrite"] = True\n+                return data\n+\n+            if isinstance(value, str):\n+                url = value\n+                value = [{"@id": url}]\n+            else:\n+                url = value[0].get("@id", "")\n+            brain = url_to_brain(url)\n+            if brain is not None:\n+                serialized_brain = getMultiAdapter(\n+                    (brain, self.request), ISerializeToJsonSummary\n+                )()\n+\n+                if not data.get("overwrite"):\n+                    # Update fields at the top level of the block data\n+                    for key in ["title", "description", "head_title"]:\n+                        if key in serialized_brain:\n+                            data[key] = serialized_brain[key]\n+\n+                # We return the serialized brain.\n+                value[0].update(serialized_brain)\n+                data["href"] = value\n+            elif not url.startswith("http"):\n+                # Source not found; clear out derived fields\n+                data["href"] = []\n+        return data\n+\n+\n+@implementer(IBlockFieldSerializationTransformer)\n+@adapter(IBlocks, IBrowserRequest)\n+class TeaserBlockSerializer(TeaserBlockSerializerBase):\n+    """Serializer for content-types with IBlocks behavior"""\n+\n+\n+RESOLVE_UID_REGEXP = re.compile("resolveuid/([^/]+)")\n+\n+\n+@implementer(IBlockFieldSerializationTransformer)\n+@adapter(IPloneSiteRoot, IBrowserRequest)\n+class TeaserBlockSerializerRoot(TeaserBlockSerializerBase):\n+    """Serializer for site root"""\n+\n+\n+def url_to_brain(url):\n+    if not url:\n+        return\n+    brain = None\n+    if match := RESOLVE_UID_REGEXP.search(url):\n+        uid = match.group(1)\n+        brain = uuidToCatalogBrain(uid)\n+    else:\n+        # fallback in case the url wasn\'t converted to a UID\n+        catalog = api.portal.get_tool("portal_catalog")\n+        path = "/".join(api.portal.get().getPhysicalPath()) + url\n+        results = catalog.searchResults(path={"query": path, "depth": 0})\n+        if results:\n+            brain = results[0]\n+    return brain\ndiff --git a/src/plone/restapi/serializer/configure.zcml b/src/plone/restapi/serializer/configure.zcml\nindex c1117121a..0e84f64f4 100644\n--- a/src/plone/restapi/serializer/configure.zcml\n+++ b/src/plone/restapi/serializer/configure.zcml\n@@ -63,6 +63,14 @@\n       provides="plone.restapi.interfaces.IBlockFieldSerializationTransformer"\n       />\n \n+  <subscriber\n+      factory=".blocks.TeaserBlockSerializerRoot"\n+      provides="plone.restapi.interfaces.IBlockFieldSerializationTransformer"\n+      />\n+  <subscriber\n+      factory=".blocks.TeaserBlockSerializer"\n+      provides="plone.restapi.interfaces.IBlockFieldSerializationTransformer"\n+      />\n \n   <adapter factory=".converters.date_converter" />\n   <adapter factory=".converters.decimal_converter" />\ndiff --git a/src/plone/restapi/tests/test_blocks_serializer.py b/src/plone/restapi/tests/test_blocks_serializer.py\nindex 9005e2a40..a1c378ad8 100644\n--- a/src/plone/restapi/tests/test_blocks_serializer.py\n+++ b/src/plone/restapi/tests/test_blocks_serializer.py\n@@ -517,3 +517,97 @@ def test_image_scales_serializer_is_json_compatible(self):\n             blocks={"123": {"@type": "image", "url": f"../resolveuid/{image_uid}"}},\n         )\n         self.assertIs(type(res["123"]["image_scales"]), dict)\n+\n+    def test_teaser_block_serializer_dynamic(self):\n+        doc = self.portal["doc1"]\n+        doc_uid = doc.UID()\n+        resolve_uid_link = f"../resolveuid/{doc_uid}"\n+        value = self.serialize(\n+            context=self.portal.doc1,\n+            blocks={\n+                "1": {\n+                    "@type": "teaser",\n+                    "href": resolve_uid_link,\n+                    "overwrite": False,\n+                }\n+            },\n+        )\n+\n+        block = value["1"]\n+        self.assertEqual(block["title"], doc.title)\n+        self.assertEqual(block["description"], doc.description)\n+        href = block["href"][0]\n+        self.assertEqual(href["@id"], doc.absolute_url())\n+\n+    def test_teaser_block_serializer_dynamic_nested(self):\n+        doc = self.portal["doc1"]\n+        doc_uid = doc.UID()\n+        resolve_uid_link = f"../resolveuid/{doc_uid}"\n+        value = self.serialize(\n+            context=self.portal.doc1,\n+            blocks={\n+                "grid": {\n+                    "@type": "gridBlock",\n+                    "blocks": {\n+                        "1": {\n+                            "@type": "teaser",\n+                            "href": resolve_uid_link,\n+                            "overwrite": False,\n+                        },\n+                    },\n+                    "blocks_layout": {"items": ["1"]},\n+                }\n+            },\n+        )\n+\n+        block = value["grid"]["blocks"]["1"]\n+        self.assertEqual(block["title"], doc.title)\n+        self.assertEqual(block["description"], doc.description)\n+        href = block["href"][0]\n+        self.assertEqual(href["@id"], doc.absolute_url())\n+\n+    def test_teaser_block_serializer_with_overwrite(self):\n+        doc = self.portal["doc1"]\n+        doc_uid = doc.UID()\n+        resolve_uid_link = f"../resolveuid/{doc_uid}"\n+        value = self.serialize(\n+            context=self.portal.doc1,\n+            blocks={\n+                "1": {\n+                    "@type": "teaser",\n+                    "href": resolve_uid_link,\n+                    "overwrite": True,\n+                    "title": "Custom title",\n+                    "description": "Custom description",\n+                }\n+            },\n+        )\n+\n+        block = value["1"]\n+        self.assertEqual(block["title"], "Custom title")\n+        self.assertEqual(block["description"], "Custom description")\n+        href = block["href"][0]\n+        self.assertEqual(href["@id"], doc.absolute_url())\n+\n+    def test_teaser_block_serializer_legacy(self):\n+        # no "overwrite" key -> default to True\n+        doc = self.portal["doc1"]\n+        doc_uid = doc.UID()\n+        resolve_uid_link = f"../resolveuid/{doc_uid}"\n+        value = self.serialize(\n+            context=self.portal.doc1,\n+            blocks={\n+                "1": {\n+                    "@type": "teaser",\n+                    "href": [{"@id": resolve_uid_link}],\n+                    "title": "Custom title",\n+                    "description": "Custom description",\n+                }\n+            },\n+        )\n+\n+        block = value["1"]\n+        self.assertEqual(block["title"], "Custom title")\n+        self.assertEqual(block["description"], "Custom description")\n+        href = block["href"][0]\n+        self.assertEqual(href["@id"], doc.absolute_url())\n'

