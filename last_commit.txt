Repository: Products.CMFPlone


Branch: refs/heads/master
Date: 2024-05-16T21:13:39+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/Products.CMFPlone/commit/637e886ad7326a7871bb44929437179067636571

remove queryCatalog script.

Files changed:
A news/3960.bugfix
D Products/CMFPlone/skins/plone_scripts/queryCatalog.py

b'diff --git a/Products/CMFPlone/skins/plone_scripts/queryCatalog.py b/Products/CMFPlone/skins/plone_scripts/queryCatalog.py\ndeleted file mode 100644\nindex e00fdee9b7..0000000000\n--- a/Products/CMFPlone/skins/plone_scripts/queryCatalog.py\n+++ /dev/null\n@@ -1,128 +0,0 @@\n-## Script (Python) "queryCatalog"\n-##bind container=container\n-##bind context=context\n-##bind namespace=\n-##bind script=script\n-##bind subpath=traverse_subpath\n-##parameters=REQUEST=None,show_all=0,quote_logic=0,quote_logic_indexes=[\'SearchableText\',\'Description\',\'Title\'],use_types_blacklist=False,show_inactive=False,use_navigation_root=False\n-##title=wraps the portal_catalog with a rules qualified query\n-\n-from Products.CMFCore.utils import getToolByName\n-from Products.CMFPlone.browser.navtree import getNavigationRoot\n-from Products.ZCTextIndex.ParseTree import ParseError\n-from ZODB.POSException import ConflictError\n-\n-\n-results = []\n-catalog = context.portal_catalog\n-indexes = catalog.indexes()\n-query = {}\n-show_query = show_all\n-second_pass = {}\n-\n-if REQUEST is None:\n-    REQUEST = context.REQUEST\n-\n-multispace = "\\u3000"\n-\n-\n-def quotestring(s):\n-    return \'"%s"\' % s\n-\n-\n-def quotequery(s):\n-    if not s:\n-        return s\n-    try:\n-        terms = s.split()\n-    except ConflictError:\n-        raise\n-    except Exception:\n-        return s\n-    tokens = ("OR", "AND", "NOT")\n-    s_tokens = ("OR", "AND")\n-    check = (0, -1)\n-    for idx in check:\n-        if terms[idx].upper() in tokens:\n-            terms[idx] = quotestring(terms[idx])\n-    for idx in range(1, len(terms)):\n-        if terms[idx].upper() in s_tokens and terms[idx - 1].upper() in tokens:\n-            terms[idx] = quotestring(terms[idx])\n-    return " ".join(terms)\n-\n-\n-# We need to quote parentheses when searching text indices (we use\n-# quote_logic_indexes as the list of text indices)\n-def quote_bad_chars(s):\n-    bad_chars = ["(", ")"]\n-    for char in bad_chars:\n-        s = s.replace(char, quotestring(char))\n-    return s\n-\n-\n-def ensureFriendlyTypes(query):\n-    ploneUtils = getToolByName(context, "plone_utils")\n-    portal_type = query.get("portal_type", [])\n-    if not same_type(portal_type, []):\n-        portal_type = [portal_type]\n-    Type = query.get("Type", [])\n-    if not same_type(Type, []):\n-        Type = [Type]\n-    typesList = portal_type + Type\n-    if not typesList:\n-        friendlyTypes = ploneUtils.getUserFriendlyTypes(typesList)\n-        query["portal_type"] = friendlyTypes\n-\n-\n-def rootAtNavigationRoot(query):\n-    if "path" not in query:\n-        query["path"] = getNavigationRoot(context)\n-\n-\n-# Avoid creating a session implicitly.\n-for k in REQUEST.keys():\n-    if k in ("SESSION",):\n-        continue\n-    v = REQUEST.get(k)\n-    if v and k in indexes:\n-        if k in quote_logic_indexes:\n-            v = quote_bad_chars(v)\n-            if multispace in v:\n-                v = v.replace(multispace, " ")\n-            if quote_logic:\n-                v = quotequery(v)\n-        query[k] = v\n-        show_query = 1\n-    elif k.endswith("_usage"):\n-        key = k[:-6]\n-        param, value = v.split(":")\n-        second_pass[key] = {param: value}\n-    elif k in ("sort_on", "sort_order", "sort_limit"):\n-        if k == "sort_limit" and not same_type(v, 0):\n-            query[k] = int(v)\n-        else:\n-            query[k] = v\n-\n-for k in second_pass.keys():\n-    v = second_pass[k]\n-    qs = query.get(k)\n-    if qs is None:\n-        continue\n-    query[k] = q = {"query": qs}\n-    q.update(v)\n-\n-# doesn\'t normal call catalog unless some field has been queried\n-# against. if you want to call the catalog _regardless_ of whether\n-# any items were found, then you can pass show_all=1.\n-if show_query:\n-    try:\n-        if use_types_blacklist:\n-            ensureFriendlyTypes(query)\n-        if use_navigation_root:\n-            rootAtNavigationRoot(query)\n-        query["show_inactive"] = show_inactive\n-        results = catalog(**query)\n-    except ParseError:\n-        pass\n-\n-return results\ndiff --git a/news/3960.bugfix b/news/3960.bugfix\nnew file mode 100644\nindex 0000000000..a815a6eb58\n--- /dev/null\n+++ b/news/3960.bugfix\n@@ -0,0 +1 @@\n+Remove queryCatalog skins script. [@jensens]\n'

Repository: Products.CMFPlone


Branch: refs/heads/master
Date: 2024-05-17T10:57:03+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/Products.CMFPlone/commit/55705533a79abe29113b8f84558eacbf380f0219

rm getFolderContents and related tests for both

Files changed:
M Products/CMFPlone/browser/syndication/adapters.py
M Products/CMFPlone/browser/syndication/templates/search-rss.pt
M Products/CMFPlone/browser/syndication/views.py
M Products/CMFPlone/tests/testNavTree.py
M Products/CMFPlone/tests/testSecurity.py
M news/3960.bugfix
D Products/CMFPlone/skins/plone_scripts/getFolderContents.py
D Products/CMFPlone/tests/testQueryCatalog.py

b'diff --git a/Products/CMFPlone/browser/syndication/adapters.py b/Products/CMFPlone/browser/syndication/adapters.py\nindex 4d51bb1507..2a97b9d69d 100644\n--- a/Products/CMFPlone/browser/syndication/adapters.py\n+++ b/Products/CMFPlone/browser/syndication/adapters.py\n@@ -1,10 +1,13 @@\n from DateTime import DateTime\n from OFS.interfaces import IItem\n from plone.app.contenttypes.behaviors.leadimage import ILeadImageBehavior\n+from plone.base.batch import Batch\n+from plone.base.interfaces import IPloneSiteRoot\n from plone.base.interfaces.syndication import IFeed\n from plone.base.interfaces.syndication import IFeedItem\n from plone.base.interfaces.syndication import IFeedSettings\n from plone.base.interfaces.syndication import ISearchFeed\n+from plone.base.navigationroot import get_navigation_root_object\n from plone.dexterity.interfaces import IDexterityContent\n from plone.namedfile.interfaces import INamedField\n from plone.registry.interfaces import IRegistry\n@@ -154,21 +157,27 @@ def language(self):\n \n class CollectionFeed(FolderFeed):\n     def _brains(self):\n+        # call the collection query method as defined in\n+        # plone.app.contenttypes.interfaces.ICollection\n+        # usually implemented at plone.aapp.contenttypes.item.collection\n         return self.context.queryCatalog(batch=False)[: self.limit]\n \n \n @implementer(ISearchFeed)\n class SearchFeed(FolderFeed):\n     def _brains(self):\n-        max_items = self.limit\n         request = self.context.REQUEST\n+        navroot = get_navigation_root_object(self.context, IPloneSiteRoot(self.context))\n+        catalog = getToolByName(self.context, "portal_catalog")\n+        query = {\n+            "path": {"query": navroot.absolute_url_path(), "depth": 1},\n+            "sort_order": "reverse",\n+            "sort_on": request.get("sort_on", "effective"),\n+        }\n+        result = catalog(**query)\n         start = int(request.get("b_start", 0))\n-        end = int(request.get("b_end", start + max_items))\n-        request.set("sort_order", "reverse")\n-        request.set("sort_on", request.get("sort_on", "effective"))\n-        return self.context.queryCatalog(\n-            show_all=1, use_types_blacklist=True, use_navigation_root=True\n-        )[start:end]\n+        end = int(request.get("b_end", start + self.limit))\n+        return Batch(result, start, end)\n \n \n @adapter(IItem, IFeed)\ndiff --git a/Products/CMFPlone/browser/syndication/templates/search-rss.pt b/Products/CMFPlone/browser/syndication/templates/search-rss.pt\nindex 513e757697..cd21ca32ff 100644\n--- a/Products/CMFPlone/browser/syndication/templates/search-rss.pt\n+++ b/Products/CMFPlone/browser/syndication/templates/search-rss.pt\n@@ -8,11 +8,11 @@\n   xmlns:tal="http://xml.zope.org/namespaces/tal"\n   tal:define="syn context/@@syndication-util;">\n \n-<tal:synd tal:define="feed view/feed;\n+<tal:synd tal:define="feed python:view.feed();\n                       objects python: [i for i in feed.items];">\n <channel rdf:about="" tal:attributes="rdf:about request/URL">\n-  <title tal:content="context/pretty_title_or_id">The title</title>\n-  <link tal:content="context/portal_url">http://url.to.portal</link>\n+  <title tal:content="python:context.Title() or context.getId()">The title</title>\n+  <link tal:content="python:context.portal_url">http://url.to.portal</link>\n \n   <image tal:attributes="rdf:resource feed/logo" />\n \n@@ -29,7 +29,7 @@\n \n <tal:block repeat="item python: objects">\n   <item rdf:about="" tal:attributes="rdf:about item/link">\n-    <title tal:content="item/title">Title</title>\n+    <title tal:content="python:item.Title()">Title</title>\n     <link tal:content="item/link">Identifier</link>\n     <description tal:content="item/description">Description</description>\n     <content:encoded xmlns:content="http://purl.org/rss/1.0/modules/content/"\ndiff --git a/Products/CMFPlone/browser/syndication/views.py b/Products/CMFPlone/browser/syndication/views.py\nindex f165c80024..ee2a477469 100644\n--- a/Products/CMFPlone/browser/syndication/views.py\n+++ b/Products/CMFPlone/browser/syndication/views.py\n@@ -20,10 +20,10 @@ class FeedView(BrowserView):\n     content_type = "application/atom+xml"\n \n     def feed(self):\n-        f = queryAdapter(self.context, IFeed)\n-        if f is None:\n+        feed = queryAdapter(self.context, IFeed)\n+        if feed is None:\n             raise NotFound\n-        return f\n+        return feed\n \n     def __call__(self):\n         util = getMultiAdapter((self.context, self.request), name="syndication-util")\n@@ -40,10 +40,10 @@ def __call__(self):\n \n class SearchFeedView(FeedView):\n     def feed(self):\n-        f = queryAdapter(self.context, ISearchFeed)\n-        if f is None:\n+        feed = queryAdapter(self.context, ISearchFeed)\n+        if feed is None:\n             raise NotFound\n-        return f\n+        return feed\n \n     def __call__(self):\n         util = getMultiAdapter((self.context, self.request), name="syndication-util")\ndiff --git a/Products/CMFPlone/skins/plone_scripts/getFolderContents.py b/Products/CMFPlone/skins/plone_scripts/getFolderContents.py\ndeleted file mode 100644\nindex 01ce2b879b..0000000000\n--- a/Products/CMFPlone/skins/plone_scripts/getFolderContents.py\n+++ /dev/null\n@@ -1,61 +0,0 @@\n-## Script (Python) "getFolderContents"\n-##bind container=container\n-##bind context=context\n-##bind namespace=\n-##bind script=script\n-##bind subpath=traverse_subpath\n-##parameters=contentFilter=None,batch=False,b_size=100,full_objects=False\n-##title=wrapper method around to use catalog to get folder contents\n-\n-# NOTE: This script is obsolete, use the browser view\n-#       @@folderListing in plone.app.contentlisting\n-\n-from zExceptions import Forbidden\n-\n-\n-if container.REQUEST.get("PUBLISHED") is script:\n-    raise Forbidden("Script may not be published.")\n-\n-mtool = context.portal_membership\n-cur_path = "/".join(context.getPhysicalPath())\n-path = {}\n-\n-if not contentFilter:\n-    contentFilter = {}\n-else:\n-    contentFilter = dict(contentFilter)\n-\n-if not contentFilter.get("sort_on", None):\n-    contentFilter["sort_on"] = "getObjPositionInParent"\n-\n-if contentFilter.get("path", None) is None:\n-    path["query"] = cur_path\n-    path["depth"] = 1\n-    contentFilter["path"] = path\n-\n-show_inactive = mtool.checkPermission("Access inactive portal content", context)\n-\n-# Provide batching hints to the catalog\n-b_start = int(context.REQUEST.get("b_start", 0))\n-contentFilter["b_start"] = b_start\n-if batch:\n-    contentFilter["b_size"] = b_size\n-\n-# Evaluate in catalog context because some containers override queryCatalog\n-# with their own unrelated method (Topics)\n-contents = context.portal_catalog.queryCatalog(\n-    contentFilter,\n-    show_all=1,\n-    show_inactive=show_inactive,\n-)\n-\n-if full_objects:\n-    contents = [b.getObject() for b in contents]\n-\n-if batch:\n-    from Products.CMFPlone import Batch\n-\n-    batch = Batch(contents, b_size, b_start, orphan=0)\n-    return batch\n-\n-return contents\ndiff --git a/Products/CMFPlone/tests/testNavTree.py b/Products/CMFPlone/tests/testNavTree.py\nindex 40dc220684..bd6308028f 100644\n--- a/Products/CMFPlone/tests/testNavTree.py\n+++ b/Products/CMFPlone/tests/testNavTree.py\n@@ -48,8 +48,8 @@ def populateSite(self):\n         """\n         self.setRoles(["Manager"])\n \n-        for item in self.portal.getFolderContents():\n-            self.portal._delObject(item.getId)\n+        for cid in self.portal.contentIds():\n+            self.portal._delObject(cid)\n \n         self.portal.invokeFactory("Document", "doc1")\n         self.portal.invokeFactory("Document", "doc2")\ndiff --git a/Products/CMFPlone/tests/testQueryCatalog.py b/Products/CMFPlone/tests/testQueryCatalog.py\ndeleted file mode 100644\nindex 09fd22ccad..0000000000\n--- a/Products/CMFPlone/tests/testQueryCatalog.py\n+++ /dev/null\n@@ -1,266 +0,0 @@\n-# Test queryCatalog and plone search forms\n-from plone.app.textfield.value import RichTextValue\n-from plone.base.interfaces import INavigationSchema\n-from plone.base.interfaces import ISearchSchema\n-from plone.base.interfaces.syndication import ISiteSyndicationSettings\n-from plone.registry.interfaces import IRegistry\n-from Products.CMFPlone.tests import PloneTestCase\n-from Products.ZCTextIndex.ParseTree import ParseError\n-from zExceptions import NotFound\n-from zope.component import getMultiAdapter\n-from zope.component import getUtility\n-\n-\n-class TestQueryCatalog(PloneTestCase.PloneTestCase):\n-    """Test queryCatalog script.\n-\n-    Test function of queryCatalog script, **not** the\n-    functionality of the catalog itself. Therefore, we\'ll replace\n-    the actual call to the catalog to a dummy routine that just\n-    returns the catalog search dictionary so we can examine what\n-    would be searched.\n-    """\n-\n-    def dummyCatalog(self, REQUEST=None, **kw):\n-        return kw\n-\n-    def stripStuff(self, query_dict):\n-        # strip portal_types and show_inactive parameter which is\n-        # auto-set with types blacklisting. Useful to simplify test\n-        # assertions when we don\'t care\n-        if isinstance(query_dict, dict):\n-            for ignore in ["portal_type", "show_inactive"]:\n-                if ignore in query_dict:\n-                    del query_dict[ignore]\n-        return query_dict\n-\n-    def afterSetUp(self):\n-        self.portal.portal_catalog.__call__ = self.dummyCatalog\n-\n-    def testEmptyRequest(self):\n-        request = {}\n-        self.assertEqual(self.stripStuff(self.folder.queryCatalog(request)), [])\n-\n-    def testNonexistantIndex(self):\n-        request = {"foo": "bar"}\n-        self.assertEqual(self.stripStuff(self.folder.queryCatalog(request)), [])\n-\n-    def testRealIndex(self):\n-        request = {"SearchableText": "bar"}\n-        self.assertEqual(\n-            self.stripStuff(self.folder.queryCatalog(request)),\n-            {"SearchableText": "bar"},\n-        )\n-\n-    def testTwoIndexes(self):\n-        request = {"SearchableText": "bar", "foo": "bar"}\n-        self.assertEqual(\n-            self.stripStuff(self.folder.queryCatalog(request)),\n-            {"SearchableText": "bar"},\n-        )\n-\n-    def testRealIndexes(self):\n-        request = {"SearchableText": "bar", "Subject": "bar"}\n-        self.assertEqual(self.stripStuff(self.folder.queryCatalog(request)), request)\n-\n-    def testOnlySort(self):\n-        # if we only sort, we shouldn\'t actually call the catalog\n-        request = {"sort_on": "foozle"}\n-        self.assertEqual(self.stripStuff(self.folder.queryCatalog(request)), [])\n-        request = {"sort_order": "foozle", "sort_on": "foozle"}\n-        self.assertEqual(self.stripStuff(self.folder.queryCatalog(request)), [])\n-        request = {"sort_order": "foozle"}\n-        self.assertEqual(self.stripStuff(self.folder.queryCatalog(request)), [])\n-\n-    def testOnlyUsage(self):\n-        request = {"date_usage": "range:min"}\n-        self.assertEqual(self.stripStuff(self.folder.queryCatalog(request)), [])\n-\n-    def testRealWithUsage(self):\n-        request = {"modified": "2004-01-01", "modified_usage": "range:min"}\n-        expected = {"modified": {"query": "2004-01-01", "range": "min"}}\n-        self.assertEqual(self.stripStuff(self.folder.queryCatalog(request)), expected)\n-\n-    def testSortLimit(self):\n-        # the script ignored \'sort_limit\'; test to show it no longer does.\n-        request = {"SearchableText": "bar", "sort_on": "foozle", "sort_limit": 50}\n-        self.assertEqual(self.stripStuff(self.folder.queryCatalog(request)), request)\n-\n-    def testBlacklistedTypes(self):\n-        request = {"SearchableText": "a*"}\n-        registry = getUtility(IRegistry)\n-        search_settings = registry.forInterface(ISearchSchema, prefix="plone")\n-        search_settings.types_not_searched = ("Event",)\n-        qry = self.folder.queryCatalog(request, use_types_blacklist=True)\n-        self.assertTrue("Document" in qry["portal_type"])\n-        self.assertTrue("Event" not in qry["portal_type"])\n-\n-    def testNavigationRoot(self):\n-        request = {"SearchableText": "a*"}\n-        registry = getUtility(IRegistry)\n-        navigation_settings = registry.forInterface(INavigationSchema, prefix="plone")\n-        navigation_settings.root = "/"\n-        qry = self.folder.queryCatalog(request, use_navigation_root=True)\n-        self.assertEqual("/".join(self.portal.getPhysicalPath()), qry["path"])\n-        self.setRoles(("Manager",))\n-        self.portal.invokeFactory("Folder", "foo")\n-        navigation_settings.root = "/foo"\n-        qry = self.folder.queryCatalog(request, use_navigation_root=True)\n-        self.assertEqual("/".join(self.portal.foo.getPhysicalPath()), qry["path"])\n-\n-    def testNavigationRootDoesNotOverrideExplicitPath(self):\n-        request = {"SearchableText": "a*", "path": "/yyy/zzz"}\n-        self.setRoles(("Manager",))\n-        self.portal.invokeFactory("Folder", "foo")\n-        registry = getUtility(IRegistry)\n-        navigation_settings = registry.forInterface(INavigationSchema, prefix="plone")\n-        navigation_settings.root = "/"\n-        qry = self.folder.queryCatalog(request, use_navigation_root=True)\n-        self.assertEqual("/yyy/zzz", qry["path"])\n-\n-\n-class TestQueryCatalogQuoting(PloneTestCase.PloneTestCase):\n-    """Test logic quoting features queryCatalog script.\n-\n-    Test function of queryCatalog script, **not** the\n-    functionality of the catalog itself. Therefore, we\'ll replace\n-    the actual call to the catalog to a dummy routine that just\n-    returns the catalog search dictionary so we can examine what\n-    would be searched.\n-    """\n-\n-    def dummyCatalog(self, REQUEST=None, **kw):\n-        return kw\n-\n-    def stripStuff(self, query_dict):\n-        # strip portal_types and show_inactive parameter which is\n-        # auto-set with types blacklisting. Useful to simplify test\n-        # assertions when we don\'t care\n-        if isinstance(query_dict, dict):\n-            for ignore in ["portal_type", "show_inactive"]:\n-                if ignore in query_dict:\n-                    del query_dict[ignore]\n-        return query_dict\n-\n-    def afterSetUp(self):\n-        self.portal.portal_catalog.__call__ = self.dummyCatalog\n-\n-    def testQuotingNone(self):\n-        request = {"SearchableText": "Hello Joel"}\n-        expected = request\n-        self.assertEqual(\n-            self.stripStuff(self.folder.queryCatalog(request, quote_logic=1)), expected\n-        )\n-\n-    def testQuotingNotNeeded(self):\n-        request = {"SearchableText": "Hello or Joel"}\n-        expected = request\n-        self.assertEqual(\n-            self.stripStuff(self.folder.queryCatalog(request, quote_logic=1)), expected\n-        )\n-\n-    def testQuotingNotNeededWithNot(self):\n-        request = {"SearchableText": "Hello or not Joel"}\n-        expected = request\n-        self.assertEqual(\n-            self.stripStuff(self.folder.queryCatalog(request, quote_logic=1)), expected\n-        )\n-\n-    def testQuotingRequiredToEscape(self):\n-        request = {"SearchableText": "Hello Joel Or"}\n-        expected = {"SearchableText": \'Hello Joel "Or"\'}\n-        self.assertEqual(\n-            self.stripStuff(self.folder.queryCatalog(request, quote_logic=1)), expected\n-        )\n-\n-    def testQuotingRequiredToEscapeOptionOff(self):\n-        request = {"SearchableText": "Hello Joel Or"}\n-        expected = request\n-        self.assertEqual(self.stripStuff(self.folder.queryCatalog(request)), expected)\n-\n-    def testQuotingWithLeadingNot(self):\n-        request = {"SearchableText": "Not Hello Joel"}\n-        expected = request\n-        self.assertEqual(self.stripStuff(self.folder.queryCatalog(request)), expected)\n-\n-    def testEmptyItem(self):\n-        request = {"SearchableText": ""}\n-        # queryCatalog will return empty result without calling the catalog\n-        # tool\n-        expected = []\n-        self.assertEqual(self.stripStuff(self.folder.queryCatalog(request)), expected)\n-\n-    def testEmptyItemShowAll(self):\n-        request = {"SearchableText": ""}\n-        # Catalog gets a blank search, and returns the empty dict\n-        expected = {}\n-        self.assertEqual(\n-            self.stripStuff(self.folder.queryCatalog(request, show_all=1)), expected\n-        )\n-\n-    def testBadCharsAreQuoted(self):\n-        request = {"SearchableText": "context(1)"}\n-        # Catalog gets ( or ) in search and quotes them to avoid parse error\n-        expected = {"SearchableText": \'context"("1")"\'}\n-        self.assertEqual(self.stripStuff(self.folder.queryCatalog(request)), expected)\n-\n-\n-class TestQueryCatalogParseError(PloneTestCase.PloneTestCase):\n-    """Checks that the queryCatalog script returns an empty result set\n-    in case of ZCTextIndex ParseErrors.\n-\n-    This testcase uses the real catalog, not a stub.\n-    """\n-\n-    def afterSetUp(self):\n-        self.folder.invokeFactory(\n-            "Document", id="doc", text=RichTextValue("foo bar baz")\n-        )\n-\n-    def testSearchableText(self):\n-        request = {"SearchableText": "foo"}\n-        # We expect a non-empty result set\n-        self.assertTrue(self.portal.queryCatalog(request))\n-\n-    def testParseError(self):\n-        # ZCTextIndex raises ParseError\n-        self.assertRaises(ParseError, self.portal.portal_catalog, SearchableText="-foo")\n-\n-    def testQueryCatalogParseError(self):\n-        request = {"SearchableText": "-foo"}\n-        # ZCTextIndex raises ParseError which translates to empty result\n-        expected = []\n-        self.assertEqual(self.portal.queryCatalog(request), expected)\n-\n-    def testQueryCatalogParseError3050(self):\n-        # http://dev.plone.org/plone/ticket/3050\n-        request = {"SearchableText": "AND"}\n-        # ZCTextIndex raises ParseError which translates to empty result\n-        expected = []\n-        self.assertEqual(self.portal.queryCatalog(request), expected)\n-\n-\n-AddPortalTopics = "Add portal topics"\n-\n-\n-class TestSearchForms(PloneTestCase.PloneTestCase):\n-    """Render all forms related to queryCatalog"""\n-\n-    def testRenderSearchForm(self):\n-        searchView = getMultiAdapter((self.portal, self.app.REQUEST), name="search")\n-        searchView()\n-\n-    def testRenderSearchRSS(self):\n-        searchRssView = getMultiAdapter(\n-            (self.portal, self.app.REQUEST), name="search_rss"\n-        )\n-        searchRssView()\n-\n-    def testSearchGives404WhenDisabled(self):\n-        registry = getUtility(IRegistry)\n-        settings = registry.forInterface(ISiteSyndicationSettings)\n-        settings.search_rss_enabled = False\n-        searchRssView = getMultiAdapter(\n-            (self.portal, self.app.REQUEST), name="search_rss"\n-        )\n-        self.assertRaises(NotFound, searchRssView)\ndiff --git a/Products/CMFPlone/tests/testSecurity.py b/Products/CMFPlone/tests/testSecurity.py\nindex 2a895be962..62b8f4eae1 100644\n--- a/Products/CMFPlone/tests/testSecurity.py\n+++ b/Products/CMFPlone/tests/testSecurity.py\n@@ -124,10 +124,6 @@ def test_getMemberInfo(self):\n         res = self.publish("/plone/portal_membership/getMemberInfo?id=admin")\n         self.assertEqual(404, res.status)\n \n-    def test_queryCatalog(self):\n-        res = self.publish("/plone/news/aggregator/queryCatalog")\n-        self.assertEqual(404, res.status)\n-\n     def test_resolve_url(self):\n         res = self.publish("/plone/uid_catalog/resolve_url?path=/evil")\n         self.assertEqual(404, res.status)\n@@ -136,10 +132,6 @@ def test_atat_does_not_return_anything(self):\n         res = self.publish("/plone/@@")\n         self.assertEqual(404, res.status)\n \n-    def test_getFolderContents(self):\n-        res = self.publish("/plone/getFolderContents")\n-        self.assertEqual(403, res.status)\n-\n     def test_translate(self):\n         res = self.publish("/plone/translate?msgid=foo")\n         self.assertEqual(403, res.status)\ndiff --git a/news/3960.bugfix b/news/3960.bugfix\nindex a815a6eb58..b943c844f0 100644\n--- a/news/3960.bugfix\n+++ b/news/3960.bugfix\n@@ -1 +1 @@\n-Remove queryCatalog skins script. [@jensens]\n+Remove queryCatalog and getFolderContents skins script. [@jensens]\n'

Repository: Products.CMFPlone


Branch: refs/heads/master
Date: 2024-05-17T11:17:21+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/Products.CMFPlone/commit/e88c7ec8e5c60af1653f944eea6f6c7412d05f2f

better chnagelog

Files changed:
M news/3960.bugfix

b'diff --git a/news/3960.bugfix b/news/3960.bugfix\nindex b943c844f0..b1fe215568 100644\n--- a/news/3960.bugfix\n+++ b/news/3960.bugfix\n@@ -1 +1,3 @@\n-Remove queryCatalog and getFolderContents skins script. [@jensens]\n+Remove queryCatalog and getFolderContents skins script.\n+This includes a refactoring in the search RSS and updates to soe tests\n+[@jensens]\n'

Repository: Products.CMFPlone


Branch: refs/heads/master
Date: 2024-05-17T14:42:27+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/Products.CMFPlone/commit/7d6f1ed50b18a0d60a58038ab2c3ab190be59a29

Merge pull request #3960 from plone/rm-queryCatalog

Remove queryCatalog and getFolderContents skin scripts

Files changed:
A news/3960.bugfix
M Products/CMFPlone/browser/syndication/adapters.py
M Products/CMFPlone/browser/syndication/templates/search-rss.pt
M Products/CMFPlone/browser/syndication/views.py
M Products/CMFPlone/tests/testNavTree.py
M Products/CMFPlone/tests/testSecurity.py
D Products/CMFPlone/skins/plone_scripts/getFolderContents.py
D Products/CMFPlone/skins/plone_scripts/queryCatalog.py
D Products/CMFPlone/tests/testQueryCatalog.py

b'diff --git a/Products/CMFPlone/browser/syndication/adapters.py b/Products/CMFPlone/browser/syndication/adapters.py\nindex 4d51bb1507..2a97b9d69d 100644\n--- a/Products/CMFPlone/browser/syndication/adapters.py\n+++ b/Products/CMFPlone/browser/syndication/adapters.py\n@@ -1,10 +1,13 @@\n from DateTime import DateTime\n from OFS.interfaces import IItem\n from plone.app.contenttypes.behaviors.leadimage import ILeadImageBehavior\n+from plone.base.batch import Batch\n+from plone.base.interfaces import IPloneSiteRoot\n from plone.base.interfaces.syndication import IFeed\n from plone.base.interfaces.syndication import IFeedItem\n from plone.base.interfaces.syndication import IFeedSettings\n from plone.base.interfaces.syndication import ISearchFeed\n+from plone.base.navigationroot import get_navigation_root_object\n from plone.dexterity.interfaces import IDexterityContent\n from plone.namedfile.interfaces import INamedField\n from plone.registry.interfaces import IRegistry\n@@ -154,21 +157,27 @@ def language(self):\n \n class CollectionFeed(FolderFeed):\n     def _brains(self):\n+        # call the collection query method as defined in\n+        # plone.app.contenttypes.interfaces.ICollection\n+        # usually implemented at plone.aapp.contenttypes.item.collection\n         return self.context.queryCatalog(batch=False)[: self.limit]\n \n \n @implementer(ISearchFeed)\n class SearchFeed(FolderFeed):\n     def _brains(self):\n-        max_items = self.limit\n         request = self.context.REQUEST\n+        navroot = get_navigation_root_object(self.context, IPloneSiteRoot(self.context))\n+        catalog = getToolByName(self.context, "portal_catalog")\n+        query = {\n+            "path": {"query": navroot.absolute_url_path(), "depth": 1},\n+            "sort_order": "reverse",\n+            "sort_on": request.get("sort_on", "effective"),\n+        }\n+        result = catalog(**query)\n         start = int(request.get("b_start", 0))\n-        end = int(request.get("b_end", start + max_items))\n-        request.set("sort_order", "reverse")\n-        request.set("sort_on", request.get("sort_on", "effective"))\n-        return self.context.queryCatalog(\n-            show_all=1, use_types_blacklist=True, use_navigation_root=True\n-        )[start:end]\n+        end = int(request.get("b_end", start + self.limit))\n+        return Batch(result, start, end)\n \n \n @adapter(IItem, IFeed)\ndiff --git a/Products/CMFPlone/browser/syndication/templates/search-rss.pt b/Products/CMFPlone/browser/syndication/templates/search-rss.pt\nindex 513e757697..cd21ca32ff 100644\n--- a/Products/CMFPlone/browser/syndication/templates/search-rss.pt\n+++ b/Products/CMFPlone/browser/syndication/templates/search-rss.pt\n@@ -8,11 +8,11 @@\n   xmlns:tal="http://xml.zope.org/namespaces/tal"\n   tal:define="syn context/@@syndication-util;">\n \n-<tal:synd tal:define="feed view/feed;\n+<tal:synd tal:define="feed python:view.feed();\n                       objects python: [i for i in feed.items];">\n <channel rdf:about="" tal:attributes="rdf:about request/URL">\n-  <title tal:content="context/pretty_title_or_id">The title</title>\n-  <link tal:content="context/portal_url">http://url.to.portal</link>\n+  <title tal:content="python:context.Title() or context.getId()">The title</title>\n+  <link tal:content="python:context.portal_url">http://url.to.portal</link>\n \n   <image tal:attributes="rdf:resource feed/logo" />\n \n@@ -29,7 +29,7 @@\n \n <tal:block repeat="item python: objects">\n   <item rdf:about="" tal:attributes="rdf:about item/link">\n-    <title tal:content="item/title">Title</title>\n+    <title tal:content="python:item.Title()">Title</title>\n     <link tal:content="item/link">Identifier</link>\n     <description tal:content="item/description">Description</description>\n     <content:encoded xmlns:content="http://purl.org/rss/1.0/modules/content/"\ndiff --git a/Products/CMFPlone/browser/syndication/views.py b/Products/CMFPlone/browser/syndication/views.py\nindex f165c80024..ee2a477469 100644\n--- a/Products/CMFPlone/browser/syndication/views.py\n+++ b/Products/CMFPlone/browser/syndication/views.py\n@@ -20,10 +20,10 @@ class FeedView(BrowserView):\n     content_type = "application/atom+xml"\n \n     def feed(self):\n-        f = queryAdapter(self.context, IFeed)\n-        if f is None:\n+        feed = queryAdapter(self.context, IFeed)\n+        if feed is None:\n             raise NotFound\n-        return f\n+        return feed\n \n     def __call__(self):\n         util = getMultiAdapter((self.context, self.request), name="syndication-util")\n@@ -40,10 +40,10 @@ def __call__(self):\n \n class SearchFeedView(FeedView):\n     def feed(self):\n-        f = queryAdapter(self.context, ISearchFeed)\n-        if f is None:\n+        feed = queryAdapter(self.context, ISearchFeed)\n+        if feed is None:\n             raise NotFound\n-        return f\n+        return feed\n \n     def __call__(self):\n         util = getMultiAdapter((self.context, self.request), name="syndication-util")\ndiff --git a/Products/CMFPlone/skins/plone_scripts/getFolderContents.py b/Products/CMFPlone/skins/plone_scripts/getFolderContents.py\ndeleted file mode 100644\nindex 01ce2b879b..0000000000\n--- a/Products/CMFPlone/skins/plone_scripts/getFolderContents.py\n+++ /dev/null\n@@ -1,61 +0,0 @@\n-## Script (Python) "getFolderContents"\n-##bind container=container\n-##bind context=context\n-##bind namespace=\n-##bind script=script\n-##bind subpath=traverse_subpath\n-##parameters=contentFilter=None,batch=False,b_size=100,full_objects=False\n-##title=wrapper method around to use catalog to get folder contents\n-\n-# NOTE: This script is obsolete, use the browser view\n-#       @@folderListing in plone.app.contentlisting\n-\n-from zExceptions import Forbidden\n-\n-\n-if container.REQUEST.get("PUBLISHED") is script:\n-    raise Forbidden("Script may not be published.")\n-\n-mtool = context.portal_membership\n-cur_path = "/".join(context.getPhysicalPath())\n-path = {}\n-\n-if not contentFilter:\n-    contentFilter = {}\n-else:\n-    contentFilter = dict(contentFilter)\n-\n-if not contentFilter.get("sort_on", None):\n-    contentFilter["sort_on"] = "getObjPositionInParent"\n-\n-if contentFilter.get("path", None) is None:\n-    path["query"] = cur_path\n-    path["depth"] = 1\n-    contentFilter["path"] = path\n-\n-show_inactive = mtool.checkPermission("Access inactive portal content", context)\n-\n-# Provide batching hints to the catalog\n-b_start = int(context.REQUEST.get("b_start", 0))\n-contentFilter["b_start"] = b_start\n-if batch:\n-    contentFilter["b_size"] = b_size\n-\n-# Evaluate in catalog context because some containers override queryCatalog\n-# with their own unrelated method (Topics)\n-contents = context.portal_catalog.queryCatalog(\n-    contentFilter,\n-    show_all=1,\n-    show_inactive=show_inactive,\n-)\n-\n-if full_objects:\n-    contents = [b.getObject() for b in contents]\n-\n-if batch:\n-    from Products.CMFPlone import Batch\n-\n-    batch = Batch(contents, b_size, b_start, orphan=0)\n-    return batch\n-\n-return contents\ndiff --git a/Products/CMFPlone/skins/plone_scripts/queryCatalog.py b/Products/CMFPlone/skins/plone_scripts/queryCatalog.py\ndeleted file mode 100644\nindex e00fdee9b7..0000000000\n--- a/Products/CMFPlone/skins/plone_scripts/queryCatalog.py\n+++ /dev/null\n@@ -1,128 +0,0 @@\n-## Script (Python) "queryCatalog"\n-##bind container=container\n-##bind context=context\n-##bind namespace=\n-##bind script=script\n-##bind subpath=traverse_subpath\n-##parameters=REQUEST=None,show_all=0,quote_logic=0,quote_logic_indexes=[\'SearchableText\',\'Description\',\'Title\'],use_types_blacklist=False,show_inactive=False,use_navigation_root=False\n-##title=wraps the portal_catalog with a rules qualified query\n-\n-from Products.CMFCore.utils import getToolByName\n-from Products.CMFPlone.browser.navtree import getNavigationRoot\n-from Products.ZCTextIndex.ParseTree import ParseError\n-from ZODB.POSException import ConflictError\n-\n-\n-results = []\n-catalog = context.portal_catalog\n-indexes = catalog.indexes()\n-query = {}\n-show_query = show_all\n-second_pass = {}\n-\n-if REQUEST is None:\n-    REQUEST = context.REQUEST\n-\n-multispace = "\\u3000"\n-\n-\n-def quotestring(s):\n-    return \'"%s"\' % s\n-\n-\n-def quotequery(s):\n-    if not s:\n-        return s\n-    try:\n-        terms = s.split()\n-    except ConflictError:\n-        raise\n-    except Exception:\n-        return s\n-    tokens = ("OR", "AND", "NOT")\n-    s_tokens = ("OR", "AND")\n-    check = (0, -1)\n-    for idx in check:\n-        if terms[idx].upper() in tokens:\n-            terms[idx] = quotestring(terms[idx])\n-    for idx in range(1, len(terms)):\n-        if terms[idx].upper() in s_tokens and terms[idx - 1].upper() in tokens:\n-            terms[idx] = quotestring(terms[idx])\n-    return " ".join(terms)\n-\n-\n-# We need to quote parentheses when searching text indices (we use\n-# quote_logic_indexes as the list of text indices)\n-def quote_bad_chars(s):\n-    bad_chars = ["(", ")"]\n-    for char in bad_chars:\n-        s = s.replace(char, quotestring(char))\n-    return s\n-\n-\n-def ensureFriendlyTypes(query):\n-    ploneUtils = getToolByName(context, "plone_utils")\n-    portal_type = query.get("portal_type", [])\n-    if not same_type(portal_type, []):\n-        portal_type = [portal_type]\n-    Type = query.get("Type", [])\n-    if not same_type(Type, []):\n-        Type = [Type]\n-    typesList = portal_type + Type\n-    if not typesList:\n-        friendlyTypes = ploneUtils.getUserFriendlyTypes(typesList)\n-        query["portal_type"] = friendlyTypes\n-\n-\n-def rootAtNavigationRoot(query):\n-    if "path" not in query:\n-        query["path"] = getNavigationRoot(context)\n-\n-\n-# Avoid creating a session implicitly.\n-for k in REQUEST.keys():\n-    if k in ("SESSION",):\n-        continue\n-    v = REQUEST.get(k)\n-    if v and k in indexes:\n-        if k in quote_logic_indexes:\n-            v = quote_bad_chars(v)\n-            if multispace in v:\n-                v = v.replace(multispace, " ")\n-            if quote_logic:\n-                v = quotequery(v)\n-        query[k] = v\n-        show_query = 1\n-    elif k.endswith("_usage"):\n-        key = k[:-6]\n-        param, value = v.split(":")\n-        second_pass[key] = {param: value}\n-    elif k in ("sort_on", "sort_order", "sort_limit"):\n-        if k == "sort_limit" and not same_type(v, 0):\n-            query[k] = int(v)\n-        else:\n-            query[k] = v\n-\n-for k in second_pass.keys():\n-    v = second_pass[k]\n-    qs = query.get(k)\n-    if qs is None:\n-        continue\n-    query[k] = q = {"query": qs}\n-    q.update(v)\n-\n-# doesn\'t normal call catalog unless some field has been queried\n-# against. if you want to call the catalog _regardless_ of whether\n-# any items were found, then you can pass show_all=1.\n-if show_query:\n-    try:\n-        if use_types_blacklist:\n-            ensureFriendlyTypes(query)\n-        if use_navigation_root:\n-            rootAtNavigationRoot(query)\n-        query["show_inactive"] = show_inactive\n-        results = catalog(**query)\n-    except ParseError:\n-        pass\n-\n-return results\ndiff --git a/Products/CMFPlone/tests/testNavTree.py b/Products/CMFPlone/tests/testNavTree.py\nindex 40dc220684..bd6308028f 100644\n--- a/Products/CMFPlone/tests/testNavTree.py\n+++ b/Products/CMFPlone/tests/testNavTree.py\n@@ -48,8 +48,8 @@ def populateSite(self):\n         """\n         self.setRoles(["Manager"])\n \n-        for item in self.portal.getFolderContents():\n-            self.portal._delObject(item.getId)\n+        for cid in self.portal.contentIds():\n+            self.portal._delObject(cid)\n \n         self.portal.invokeFactory("Document", "doc1")\n         self.portal.invokeFactory("Document", "doc2")\ndiff --git a/Products/CMFPlone/tests/testQueryCatalog.py b/Products/CMFPlone/tests/testQueryCatalog.py\ndeleted file mode 100644\nindex 09fd22ccad..0000000000\n--- a/Products/CMFPlone/tests/testQueryCatalog.py\n+++ /dev/null\n@@ -1,266 +0,0 @@\n-# Test queryCatalog and plone search forms\n-from plone.app.textfield.value import RichTextValue\n-from plone.base.interfaces import INavigationSchema\n-from plone.base.interfaces import ISearchSchema\n-from plone.base.interfaces.syndication import ISiteSyndicationSettings\n-from plone.registry.interfaces import IRegistry\n-from Products.CMFPlone.tests import PloneTestCase\n-from Products.ZCTextIndex.ParseTree import ParseError\n-from zExceptions import NotFound\n-from zope.component import getMultiAdapter\n-from zope.component import getUtility\n-\n-\n-class TestQueryCatalog(PloneTestCase.PloneTestCase):\n-    """Test queryCatalog script.\n-\n-    Test function of queryCatalog script, **not** the\n-    functionality of the catalog itself. Therefore, we\'ll replace\n-    the actual call to the catalog to a dummy routine that just\n-    returns the catalog search dictionary so we can examine what\n-    would be searched.\n-    """\n-\n-    def dummyCatalog(self, REQUEST=None, **kw):\n-        return kw\n-\n-    def stripStuff(self, query_dict):\n-        # strip portal_types and show_inactive parameter which is\n-        # auto-set with types blacklisting. Useful to simplify test\n-        # assertions when we don\'t care\n-        if isinstance(query_dict, dict):\n-            for ignore in ["portal_type", "show_inactive"]:\n-                if ignore in query_dict:\n-                    del query_dict[ignore]\n-        return query_dict\n-\n-    def afterSetUp(self):\n-        self.portal.portal_catalog.__call__ = self.dummyCatalog\n-\n-    def testEmptyRequest(self):\n-        request = {}\n-        self.assertEqual(self.stripStuff(self.folder.queryCatalog(request)), [])\n-\n-    def testNonexistantIndex(self):\n-        request = {"foo": "bar"}\n-        self.assertEqual(self.stripStuff(self.folder.queryCatalog(request)), [])\n-\n-    def testRealIndex(self):\n-        request = {"SearchableText": "bar"}\n-        self.assertEqual(\n-            self.stripStuff(self.folder.queryCatalog(request)),\n-            {"SearchableText": "bar"},\n-        )\n-\n-    def testTwoIndexes(self):\n-        request = {"SearchableText": "bar", "foo": "bar"}\n-        self.assertEqual(\n-            self.stripStuff(self.folder.queryCatalog(request)),\n-            {"SearchableText": "bar"},\n-        )\n-\n-    def testRealIndexes(self):\n-        request = {"SearchableText": "bar", "Subject": "bar"}\n-        self.assertEqual(self.stripStuff(self.folder.queryCatalog(request)), request)\n-\n-    def testOnlySort(self):\n-        # if we only sort, we shouldn\'t actually call the catalog\n-        request = {"sort_on": "foozle"}\n-        self.assertEqual(self.stripStuff(self.folder.queryCatalog(request)), [])\n-        request = {"sort_order": "foozle", "sort_on": "foozle"}\n-        self.assertEqual(self.stripStuff(self.folder.queryCatalog(request)), [])\n-        request = {"sort_order": "foozle"}\n-        self.assertEqual(self.stripStuff(self.folder.queryCatalog(request)), [])\n-\n-    def testOnlyUsage(self):\n-        request = {"date_usage": "range:min"}\n-        self.assertEqual(self.stripStuff(self.folder.queryCatalog(request)), [])\n-\n-    def testRealWithUsage(self):\n-        request = {"modified": "2004-01-01", "modified_usage": "range:min"}\n-        expected = {"modified": {"query": "2004-01-01", "range": "min"}}\n-        self.assertEqual(self.stripStuff(self.folder.queryCatalog(request)), expected)\n-\n-    def testSortLimit(self):\n-        # the script ignored \'sort_limit\'; test to show it no longer does.\n-        request = {"SearchableText": "bar", "sort_on": "foozle", "sort_limit": 50}\n-        self.assertEqual(self.stripStuff(self.folder.queryCatalog(request)), request)\n-\n-    def testBlacklistedTypes(self):\n-        request = {"SearchableText": "a*"}\n-        registry = getUtility(IRegistry)\n-        search_settings = registry.forInterface(ISearchSchema, prefix="plone")\n-        search_settings.types_not_searched = ("Event",)\n-        qry = self.folder.queryCatalog(request, use_types_blacklist=True)\n-        self.assertTrue("Document" in qry["portal_type"])\n-        self.assertTrue("Event" not in qry["portal_type"])\n-\n-    def testNavigationRoot(self):\n-        request = {"SearchableText": "a*"}\n-        registry = getUtility(IRegistry)\n-        navigation_settings = registry.forInterface(INavigationSchema, prefix="plone")\n-        navigation_settings.root = "/"\n-        qry = self.folder.queryCatalog(request, use_navigation_root=True)\n-        self.assertEqual("/".join(self.portal.getPhysicalPath()), qry["path"])\n-        self.setRoles(("Manager",))\n-        self.portal.invokeFactory("Folder", "foo")\n-        navigation_settings.root = "/foo"\n-        qry = self.folder.queryCatalog(request, use_navigation_root=True)\n-        self.assertEqual("/".join(self.portal.foo.getPhysicalPath()), qry["path"])\n-\n-    def testNavigationRootDoesNotOverrideExplicitPath(self):\n-        request = {"SearchableText": "a*", "path": "/yyy/zzz"}\n-        self.setRoles(("Manager",))\n-        self.portal.invokeFactory("Folder", "foo")\n-        registry = getUtility(IRegistry)\n-        navigation_settings = registry.forInterface(INavigationSchema, prefix="plone")\n-        navigation_settings.root = "/"\n-        qry = self.folder.queryCatalog(request, use_navigation_root=True)\n-        self.assertEqual("/yyy/zzz", qry["path"])\n-\n-\n-class TestQueryCatalogQuoting(PloneTestCase.PloneTestCase):\n-    """Test logic quoting features queryCatalog script.\n-\n-    Test function of queryCatalog script, **not** the\n-    functionality of the catalog itself. Therefore, we\'ll replace\n-    the actual call to the catalog to a dummy routine that just\n-    returns the catalog search dictionary so we can examine what\n-    would be searched.\n-    """\n-\n-    def dummyCatalog(self, REQUEST=None, **kw):\n-        return kw\n-\n-    def stripStuff(self, query_dict):\n-        # strip portal_types and show_inactive parameter which is\n-        # auto-set with types blacklisting. Useful to simplify test\n-        # assertions when we don\'t care\n-        if isinstance(query_dict, dict):\n-            for ignore in ["portal_type", "show_inactive"]:\n-                if ignore in query_dict:\n-                    del query_dict[ignore]\n-        return query_dict\n-\n-    def afterSetUp(self):\n-        self.portal.portal_catalog.__call__ = self.dummyCatalog\n-\n-    def testQuotingNone(self):\n-        request = {"SearchableText": "Hello Joel"}\n-        expected = request\n-        self.assertEqual(\n-            self.stripStuff(self.folder.queryCatalog(request, quote_logic=1)), expected\n-        )\n-\n-    def testQuotingNotNeeded(self):\n-        request = {"SearchableText": "Hello or Joel"}\n-        expected = request\n-        self.assertEqual(\n-            self.stripStuff(self.folder.queryCatalog(request, quote_logic=1)), expected\n-        )\n-\n-    def testQuotingNotNeededWithNot(self):\n-        request = {"SearchableText": "Hello or not Joel"}\n-        expected = request\n-        self.assertEqual(\n-            self.stripStuff(self.folder.queryCatalog(request, quote_logic=1)), expected\n-        )\n-\n-    def testQuotingRequiredToEscape(self):\n-        request = {"SearchableText": "Hello Joel Or"}\n-        expected = {"SearchableText": \'Hello Joel "Or"\'}\n-        self.assertEqual(\n-            self.stripStuff(self.folder.queryCatalog(request, quote_logic=1)), expected\n-        )\n-\n-    def testQuotingRequiredToEscapeOptionOff(self):\n-        request = {"SearchableText": "Hello Joel Or"}\n-        expected = request\n-        self.assertEqual(self.stripStuff(self.folder.queryCatalog(request)), expected)\n-\n-    def testQuotingWithLeadingNot(self):\n-        request = {"SearchableText": "Not Hello Joel"}\n-        expected = request\n-        self.assertEqual(self.stripStuff(self.folder.queryCatalog(request)), expected)\n-\n-    def testEmptyItem(self):\n-        request = {"SearchableText": ""}\n-        # queryCatalog will return empty result without calling the catalog\n-        # tool\n-        expected = []\n-        self.assertEqual(self.stripStuff(self.folder.queryCatalog(request)), expected)\n-\n-    def testEmptyItemShowAll(self):\n-        request = {"SearchableText": ""}\n-        # Catalog gets a blank search, and returns the empty dict\n-        expected = {}\n-        self.assertEqual(\n-            self.stripStuff(self.folder.queryCatalog(request, show_all=1)), expected\n-        )\n-\n-    def testBadCharsAreQuoted(self):\n-        request = {"SearchableText": "context(1)"}\n-        # Catalog gets ( or ) in search and quotes them to avoid parse error\n-        expected = {"SearchableText": \'context"("1")"\'}\n-        self.assertEqual(self.stripStuff(self.folder.queryCatalog(request)), expected)\n-\n-\n-class TestQueryCatalogParseError(PloneTestCase.PloneTestCase):\n-    """Checks that the queryCatalog script returns an empty result set\n-    in case of ZCTextIndex ParseErrors.\n-\n-    This testcase uses the real catalog, not a stub.\n-    """\n-\n-    def afterSetUp(self):\n-        self.folder.invokeFactory(\n-            "Document", id="doc", text=RichTextValue("foo bar baz")\n-        )\n-\n-    def testSearchableText(self):\n-        request = {"SearchableText": "foo"}\n-        # We expect a non-empty result set\n-        self.assertTrue(self.portal.queryCatalog(request))\n-\n-    def testParseError(self):\n-        # ZCTextIndex raises ParseError\n-        self.assertRaises(ParseError, self.portal.portal_catalog, SearchableText="-foo")\n-\n-    def testQueryCatalogParseError(self):\n-        request = {"SearchableText": "-foo"}\n-        # ZCTextIndex raises ParseError which translates to empty result\n-        expected = []\n-        self.assertEqual(self.portal.queryCatalog(request), expected)\n-\n-    def testQueryCatalogParseError3050(self):\n-        # http://dev.plone.org/plone/ticket/3050\n-        request = {"SearchableText": "AND"}\n-        # ZCTextIndex raises ParseError which translates to empty result\n-        expected = []\n-        self.assertEqual(self.portal.queryCatalog(request), expected)\n-\n-\n-AddPortalTopics = "Add portal topics"\n-\n-\n-class TestSearchForms(PloneTestCase.PloneTestCase):\n-    """Render all forms related to queryCatalog"""\n-\n-    def testRenderSearchForm(self):\n-        searchView = getMultiAdapter((self.portal, self.app.REQUEST), name="search")\n-        searchView()\n-\n-    def testRenderSearchRSS(self):\n-        searchRssView = getMultiAdapter(\n-            (self.portal, self.app.REQUEST), name="search_rss"\n-        )\n-        searchRssView()\n-\n-    def testSearchGives404WhenDisabled(self):\n-        registry = getUtility(IRegistry)\n-        settings = registry.forInterface(ISiteSyndicationSettings)\n-        settings.search_rss_enabled = False\n-        searchRssView = getMultiAdapter(\n-            (self.portal, self.app.REQUEST), name="search_rss"\n-        )\n-        self.assertRaises(NotFound, searchRssView)\ndiff --git a/Products/CMFPlone/tests/testSecurity.py b/Products/CMFPlone/tests/testSecurity.py\nindex 2a895be962..62b8f4eae1 100644\n--- a/Products/CMFPlone/tests/testSecurity.py\n+++ b/Products/CMFPlone/tests/testSecurity.py\n@@ -124,10 +124,6 @@ def test_getMemberInfo(self):\n         res = self.publish("/plone/portal_membership/getMemberInfo?id=admin")\n         self.assertEqual(404, res.status)\n \n-    def test_queryCatalog(self):\n-        res = self.publish("/plone/news/aggregator/queryCatalog")\n-        self.assertEqual(404, res.status)\n-\n     def test_resolve_url(self):\n         res = self.publish("/plone/uid_catalog/resolve_url?path=/evil")\n         self.assertEqual(404, res.status)\n@@ -136,10 +132,6 @@ def test_atat_does_not_return_anything(self):\n         res = self.publish("/plone/@@")\n         self.assertEqual(404, res.status)\n \n-    def test_getFolderContents(self):\n-        res = self.publish("/plone/getFolderContents")\n-        self.assertEqual(403, res.status)\n-\n     def test_translate(self):\n         res = self.publish("/plone/translate?msgid=foo")\n         self.assertEqual(403, res.status)\ndiff --git a/news/3960.bugfix b/news/3960.bugfix\nnew file mode 100644\nindex 0000000000..b1fe215568\n--- /dev/null\n+++ b/news/3960.bugfix\n@@ -0,0 +1,3 @@\n+Remove queryCatalog and getFolderContents skins script.\n+This includes a refactoring in the search RSS and updates to soe tests\n+[@jensens]\n'

