Repository: plone.api


Branch: refs/heads/master
Date: 2021-02-26T11:26:06+01:00
Author: Johannes Raggam (thet) <thetetet@gmail.com>
Commit: https://github.com/plone/plone.api/commit/92a78755fe4966eb6ae73f6f7c8c8c2c9c77e4b9

Fix plone.api.content.find to respect object_provides "not" queries.

Fixes: #451

Files changed:
A news/452.bugfix
M src/plone/api/content.py
M src/plone/api/tests/test_content.py

b'diff --git a/news/452.bugfix b/news/452.bugfix\nnew file mode 100644\nindex 0000000..6e802e0\n--- /dev/null\n+++ b/news/452.bugfix\n@@ -0,0 +1,3 @@\n+Fix plone.api.content.find to respect object_provides "not" queries.\n+Fixes: #451\n+[thet]\ndiff --git a/src/plone/api/content.py b/src/plone/api/content.py\nindex a5706dc..7a47288 100644\n--- a/src/plone/api/content.py\n+++ b/src/plone/api/content.py\n@@ -594,18 +594,35 @@ def _parse_object_provides_query(query):\n         query for multiple values\n         (eg. `{\'query\': [Iface1, Iface2], \'operator\': \'or\'}`)\n     """\n-    operator = \'or\'\n     ifaces = query\n+    operator = \'or\'\n+    query_not = []\n+\n     if isinstance(query, dict):\n-        operator = query.get(\'operator\', operator)\n         ifaces = query.get(\'query\', [])\n-    elif not isinstance(query, (list, tuple)):\n-        ifaces = [query]\n+        operator = query.get(\'operator\', operator)\n+        query_not = query.get(\'not\', [])\n+        # KeywordIndex also supports "range",\n+        # but that\'s not useful for querying object_provides\n+\n+    if not isinstance(ifaces, (list, tuple)):\n+        ifaces = [ifaces]\n+    ifaces = [getattr(x, \'__identifier__\', x) for x in ifaces]\n+\n+    if not isinstance(query_not, (list, tuple)):\n+        query_not = [query_not]\n+    query_not = [getattr(x, \'__identifier__\', x) for x in query_not]\n+\n+    result = {}\n+\n+    if ifaces:\n+        result[\'query\'] = ifaces\n+        result[\'operator\'] = operator\n+\n+    if query_not:\n+        result[\'not\'] = query_not\n \n-    return {\n-        \'query\': [getattr(x, \'__identifier__\', x) for x in ifaces],\n-        \'operator\': operator,\n-    }\n+    return result\n \n \n def find(context=None, depth=None, **kwargs):\ndiff --git a/src/plone/api/tests/test_content.py b/src/plone/api/tests/test_content.py\nindex 795a8c2..f840d10 100644\n--- a/src/plone/api/tests/test_content.py\n+++ b/src/plone/api/tests/test_content.py\n@@ -6,6 +6,7 @@\n from OFS.event import ObjectWillBeMovedEvent\n from OFS.interfaces import IObjectWillBeMovedEvent\n from plone import api\n+from plone.api.content import _parse_object_provides_query\n from plone.api.content import NEW_LINKINTEGRITY\n from plone.api.tests.base import INTEGRATION_TESTING\n from plone.app.layout.navigation.interfaces import INavigationRoot\n@@ -1049,6 +1050,74 @@ def test_find_interface_dict(self):\n         )\n         self.assertEqual(len(brains), 1)\n \n+    def test_find_interface_dict__include_not_query(self):\n+        """Check if not query in object_provides is functional.\n+        """\n+\n+        brains_all = api.content.find(\n+            object_provides={\'query\': IContentish.__identifier__},\n+        )\n+\n+        alsoProvides(self.portal.events, INavigationRoot)\n+        self.portal.events.reindexObject(idxs=[\'object_provides\'])\n+\n+        brains = api.content.find(\n+            object_provides={\n+                \'query\': IContentish.__identifier__,\n+                \'not\': INavigationRoot.__identifier__\n+            },\n+        )\n+\n+        self.assertEqual(len(brains_all) - len(brains), 1)\n+\n+    def test_find_interface_dict__all_options(self):\n+        """ Check for all options in a object_provides query are correctly\n+        transformed.\n+        """\n+        parser = _parse_object_provides_query\n+\n+        self.assertDictEqual(\n+            parser({\'query\': IContentish}),\n+            {\'query\': [IContentish.__identifier__], \'operator\': \'or\'},\n+        )\n+\n+        self.assertDictEqual(\n+            parser(\n+                {\n+                    \'query\': [IContentish, INavigationRoot.__identifier__],\n+                    \'operator\': \'and\'\n+                }\n+            ),\n+            {\n+                \'query\': [IContentish.__identifier__, INavigationRoot.__identifier__],\n+                \'operator\': \'and\'\n+            },\n+        )\n+\n+        self.assertDictEqual(\n+            parser({\'not\': IContentish}),\n+            {\'not\': [IContentish.__identifier__]},\n+        )\n+\n+        self.assertDictEqual(\n+            parser({\'not\': [IContentish, INavigationRoot.__identifier__]}),\n+            {\'not\': [IContentish.__identifier__, INavigationRoot.__identifier__]},\n+        )\n+\n+        self.assertDictEqual(\n+            parser({\'not\': IContentish}),\n+            {\'not\': [IContentish.__identifier__]},\n+        )\n+\n+        self.assertDictEqual(\n+            parser({\'query\': IContentish, \'operator\': \'and\', \'not\': INavigationRoot}),\n+            {\n+                \'query\': [IContentish.__identifier__],\n+                \'operator\': \'and\',\n+                \'not\': [INavigationRoot.__identifier__],\n+            },\n+        )\n+\n     def test_find_dict(self):\n         # Pass arguments using dict\n         path = \'/\'.join(self.portal.about.getPhysicalPath())\n'

