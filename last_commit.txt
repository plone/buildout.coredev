Repository: plone.app.contenttypes


Branch: refs/heads/master
Date: 2021-01-29T09:24:30+01:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.app.contenttypes/commit/c83a8a71a75b8b3edf752471d3787cd62257e642

Migration link_items: migrate relatesTo AT relation to relatedItems DX relation.

Removed some commented-out code.
Fixed comment: the linkintegrity referencedRelationship is not 'relatesTo', but 'isReferencing'.

Files changed:
M plone/app/contenttypes/migration/utils.py

b'diff --git a/plone/app/contenttypes/migration/utils.py b/plone/app/contenttypes/migration/utils.py\nindex 1689eec4..5264efd8 100644\n--- a/plone/app/contenttypes/migration/utils.py\n+++ b/plone/app/contenttypes/migration/utils.py\n@@ -376,6 +376,10 @@ def link_items(  # noqa\n     This uses the field \'relatedItems\' and works for Archetypes and Dexterity.\n     By passing a fieldname and a relationship it can be used to create\n     arbitrary relations.\n+\n+    Note: for the relatedItems field, Products.ATContentTypes uses \'relatesTo\'\n+    and plone.app.contenttypes uses \'relatedItems\'.\n+    We switch between these two, based on the source object.\n     """\n     # relations from AT to DX and from DX to AT are only possible through\n     # the referenceable-behavior:\n@@ -387,19 +391,6 @@ def link_items(  # noqa\n         # Thou shalt not relate to yourself.\n         return\n \n-    # if fieldname != \'relatedItems\':\n-        # \'relatedItems\' is the default field for AT and DX\n-        # See plone.app.relationfield.behavior.IRelatedItems for DX and\n-        # Products.ATContentTypes.content.schemata.relatedItemsField for AT\n-        # They always use these relationships:\n-        # \'relatesTo\' (Archetpyes) and \'relatedItems\' (Dexterity)\n-        # Maybe be we should handle custom relations somewhat different?\n-\n-    if relationship in [\'relatesTo\', \'relatedItems\']:\n-        # These are the two default-relationships used by AT and DX\n-        # for the field \'relatedItems\' respectively.\n-        pass\n-\n     if IDexterityContent.providedBy(source_obj):\n         source_type = \'DX\'\n     else:\n@@ -411,7 +402,7 @@ def link_items(  # noqa\n         target_type = \'AT\'\n \n     if relationship == referencedRelationship:\n-        # \'relatesTo\' is the relationship for linkintegrity-relations.\n+        # \'isReferencing\' is the relationship for linkintegrity-relations.\n         # Linkintegrity-relations should automatically be (re)created by\n         # plone.app.linkintegrity.handlers.modifiedDexterity or\n         # plone.app.linkintegrity.handlers.modifiedArchetype\n@@ -425,6 +416,8 @@ def link_items(  # noqa\n         return\n \n     if source_type == \'AT\':\n+        if relationship == \'relatedItems\':\n+            relationship = \'relatesTo\'\n         # If there is any Archetypes-content there is also the\n         # reference_catalog. For a site without AT content this\n         # might not be there at all.\n@@ -480,6 +473,8 @@ def link_items(  # noqa\n         return\n \n     if source_type is \'DX\':\n+        if relationship == \'relatesTo\':\n+            relationship = \'relatedItems\'\n         if target_type is \'AT\' and not is_referenceable(source_obj):\n             logger.info(drop_msg % (\n                 source_obj.absolute_url(), target_obj.absolute_url()))\n'

Repository: plone.app.contenttypes


Branch: refs/heads/master
Date: 2021-01-29T09:24:30+01:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.app.contenttypes/commit/1e3bf565234c8be0b7730d70dd78d1e89de1fe93

Migration link_items: in DX check if relation field is list or item.

Check the schema.
I got an AttributeError when the previous code try to iterate over an attribute which was None.
New code is a combination between p.a.c and collective.relationhelpers.

Files changed:
M plone/app/contenttypes/migration/utils.py

b'diff --git a/plone/app/contenttypes/migration/utils.py b/plone/app/contenttypes/migration/utils.py\nindex 5264efd8..f0d86774 100644\n--- a/plone/app/contenttypes/migration/utils.py\n+++ b/plone/app/contenttypes/migration/utils.py\n@@ -15,6 +15,7 @@\n from plone.app.linkintegrity.handlers import modifiedDexterity\n from plone.app.linkintegrity.handlers import referencedRelationship\n from plone.app.uuid.utils import uuidToObject\n+from plone.dexterity.utils import iterSchemataForType\n from plone.contentrules.engine.interfaces import IRuleAssignmentManager\n from plone.contentrules.engine.interfaces import IRuleStorage\n from plone.dexterity.interfaces import IDexterityContent\n@@ -34,6 +35,9 @@\n from Products.GenericSetup.context import DirectoryImportContext\n from Products.GenericSetup.utils import importObjects\n from z3c.relationfield import RelationValue\n+from z3c.relationfield.schema import Relation\n+from z3c.relationfield.schema import RelationChoice\n+from z3c.relationfield.schema import RelationList\n from zc.relation.interfaces import ICatalog\n from zExceptions import NotFound\n from zope.annotation.interfaces import IAnnotations\n@@ -486,17 +490,39 @@ def link_items(  # noqa\n \n         intids = getUtility(IIntIds)\n         to_id = intids.getId(target_obj)\n-        existing_dx_relations = getattr(source_obj, fieldname, [])\n-        # purge broken relations\n-        existing_dx_relations = [\n-            i for i in existing_dx_relations if i.to_id is not None]\n-\n-        if to_id not in [i.to_id for i in existing_dx_relations]:\n-            existing_dx_relations.append(RelationValue(to_id))\n-            setattr(source_obj, fieldname, existing_dx_relations)\n+        # Before we set the fieldname attribute on the source object,\n+        # we need to know if this should be a list or a single item.\n+        # Might be None at the moment.\n+        # We check the field definition.\n+        fti = getUtility(IDexterityFTI, name=source_obj.portal_type)\n+        field = None\n+        for schema in iterSchemataForType(fti):\n+            field = schema.get(fieldname, None)\n+            if field is not None:\n+                break\n+        if isinstance(field, RelationList):\n+            existing_relations = getattr(source_obj, fieldname, [])\n+            if existing_relations is None:\n+                existing_relations = []\n+            else:\n+                # purge broken relations\n+                existing_relations = [\n+                    i for i in existing_relations if i.to_id is not None]\n+            if to_id not in [i.to_id for i in existing_relations]:\n+                existing_relations.append(RelationValue(to_id))\n+                setattr(source_obj, fieldname, existing_relations)\n+                modified(source_obj)\n+                return\n+            return\n+        elif isinstance(field, (Relation, RelationChoice)):\n+            setattr(source_obj, fieldname, RelationValue(to_id))\n             modified(source_obj)\n             return\n \n+        # We should never end up here!\n+        logger.warning(\'Ignoring unknown fieldname %s when restoring relation %s from %s to %s\',\n+            fieldname, relationship, source_obj.absolute_url(), target_obj.absolute_url())\n+\n \n def is_referenceable(obj):\n     """Find out if this object (AT or DX) is referenceable.\n'

Repository: plone.app.contenttypes


Branch: refs/heads/master
Date: 2021-01-29T09:24:30+01:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.app.contenttypes/commit/4eb341627f95669fa0ff0d1a75e308578fc44d7d

restore_references: accept relationship_fieldname_mapping argument.

This must be a dictionary with a relationship name as key and fieldname as value.
Otherwise we use the relationship name as fieldname.
Previously, we always used the relatedItems field.

By default we will also map the 'relatesTo' relation to the 'relatedItems' field.
This is needed for ATContentTypes.

Files changed:
M plone/app/contenttypes/migration/utils.py

b'diff --git a/plone/app/contenttypes/migration/utils.py b/plone/app/contenttypes/migration/utils.py\nindex f0d86774..e0577828 100644\n--- a/plone/app/contenttypes/migration/utils.py\n+++ b/plone/app/contenttypes/migration/utils.py\n@@ -335,12 +335,35 @@ def get_all_references(context):\n     return results\n \n \n-def restore_references(context):\n+def restore_references(context, relationship_fieldname_mapping=None):\n     """Recreate all references stored in an annotation on the context.\n \n     Iterate over the stored references and restore them all according to\n     the content-types framework.\n+\n+    Accepts an optional relationship_fieldname_mapping argument.\n+    This must be a dictionary with a relationship name as key and fieldname as value.\n+    For example:\n+    relationship_fieldname_mapping =  {\n+        \'advisory_contact\': \'contact\',\n+        \'study_contact\': \'contact\',\n+    }\n+    In this case, old Archetypes content types Advisory and Study both had a\n+    reference field \'contact\' to a content type Contact.\n+    This relationship was stored under different names for the two contenttypes.\n+    After migration to Dexterity, the above mapping makes sure the relation is still\n+    stored on the \'contact\' field in both cases.\n+    The attribute_name of the RelationValue will be the same as this fieldname,\n+    which is what happens by default when setting relations.\n+\n+    By default we will also map the \'relatesTo\' relation to the \'relatedItems\' field.\n+    This is needed for ATContentTypes.\n     """\n+    if relationship_fieldname_mapping is None:\n+        relationship_fieldname_mapping = {}\n+    if \'relatesTo\' not in relationship_fieldname_mapping:\n+        # ATContentTypes used this relation.\n+        relationship_fieldname_mapping[\'relatesTo\'] = \'relatedItems\'\n     key = \'ALL_REFERENCES\'\n     all_references = IAnnotations(context)[key]\n     logger.info(\'Restoring {0} relations.\'.format(\n@@ -352,7 +375,9 @@ def restore_references(context):\n         relationship = ref[\'relationship\']\n         if source_obj and target_obj:\n             relationship = ref[\'relationship\']\n-            link_items(context, source_obj, target_obj, relationship)\n+            # By default use the relationship as fieldname.  Fall back to the relationship.\n+            fieldname = relationship_fieldname_mapping.get(relationship, relationship)\n+            link_items(context, source_obj, target_obj, relationship, fieldname)\n         else:\n             logger.warn(\n                 \'Could not restore reference from uid \'\n'

Repository: plone.app.contenttypes


Branch: refs/heads/master
Date: 2021-01-29T09:24:30+01:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.app.contenttypes/commit/855801f3502eab06be228fb32b0b01981b922b4e

restore_references: start enumerate at one.

This avoids a confusing log message because '0 % 100' is also zero.
With four relations to restore, I saw this after the first relation was restored:

```
Restoring 4 relations.
Restoring relations: 0/4
```

Files changed:
M plone/app/contenttypes/migration/utils.py

b"diff --git a/plone/app/contenttypes/migration/utils.py b/plone/app/contenttypes/migration/utils.py\nindex e0577828..16cd92a3 100644\n--- a/plone/app/contenttypes/migration/utils.py\n+++ b/plone/app/contenttypes/migration/utils.py\n@@ -369,7 +369,7 @@ def restore_references(context, relationship_fieldname_mapping=None):\n     logger.info('Restoring {0} relations.'.format(\n         len(all_references))\n     )\n-    for index, ref in enumerate(all_references):\n+    for index, ref in enumerate(all_references, 1):\n         source_obj = uuidToObject(ref['from_uuid'])\n         target_obj = uuidToObject(ref['to_uuid'])\n         relationship = ref['relationship']\n"

Repository: plone.app.contenttypes


Branch: refs/heads/master
Date: 2021-01-29T09:24:30+01:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.app.contenttypes/commit/30b6d2c97d3af443cafe6b8b3bcebea470a3f888

Added news snippet for bunch of relation changes.

The biggest one fixes https://github.com/plone/plone.app.contenttypes/issues/510

Files changed:
A news/510.bugfix

b'diff --git a/news/510.bugfix b/news/510.bugfix\nnew file mode 100644\nindex 00000000..c987a4b1\n--- /dev/null\n+++ b/news/510.bugfix\n@@ -0,0 +1,9 @@\n+Various fixes for restoring references:\n+\n+- Migrate ``relatesTo`` AT relation to ``relatedItems`` DX relation.\n+- In DX check the schema to see if relation field is list or item.\n+  Taken over from `collective.relationhelpers <https://github.com/collective/collective.relationhelpers/>`_.\n+- ``restore_references``: accept ``relationship_fieldname_mapping`` argument.\n+  This must be a dictionary with a relationship name as key and fieldname as value, instead of always using ``relatedItems`` as fieldname.\n+\n+[maurits]\n'

