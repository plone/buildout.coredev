Repository: plone.app.contenttypes
Branch: refs/heads/master
Date: 2014-04-22T17:18:18+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.app.contenttypes/commit/5a86be18ef8026266573eac7ae3fd59537059405

add browser-view @@custom_migration

Files changed:
A plone/app/contenttypes/migration/custom_migration.pt
A plone/app/contenttypes/migration/custom_migration.py
M plone/app/contenttypes/migration/configure.zcml

diff --git a/plone/app/contenttypes/migration/configure.zcml b/plone/app/contenttypes/migration/configure.zcml
index e912337..d353ca9 100644
--- a/plone/app/contenttypes/migration/configure.zcml
+++ b/plone/app/contenttypes/migration/configure.zcml
@@ -59,6 +59,15 @@
     permission="cmf.ManagePortal"
     />
 
+  <browser:page
+    name="custom_migration"
+    for="Products.CMFPlone.interfaces.IPloneSiteRoot"
+    class=".custom_migration.CustomMigrationForm"
+    layer="..interfaces.IPloneAppContenttypesLayer"
+    permission="cmf.ManagePortal"
+    template="custom_migration.pt"
+    />
+
   <utility
       factory=".vocabularies.ATCTypesVocabulary"
       name="plone.app.contenttypes.migration.atctypes"
diff --git a/plone/app/contenttypes/migration/custom_migration.pt b/plone/app/contenttypes/migration/custom_migration.pt
new file mode 100644
index 0000000..dc34228
--- /dev/null
+++ b/plone/app/contenttypes/migration/custom_migration.pt
@@ -0,0 +1 @@
+<h1>TODO</h1>
diff --git a/plone/app/contenttypes/migration/custom_migration.py b/plone/app/contenttypes/migration/custom_migration.py
new file mode 100644
index 0000000..ca8bcd9
--- /dev/null
+++ b/plone/app/contenttypes/migration/custom_migration.py
@@ -0,0 +1,40 @@
+# -*- coding: UTF-8 -*-
+from Products.Five.browser import BrowserView
+from plone.dexterity.interfaces import IDexterityFTI
+from Products.CMFCore.utils import getToolByName
+from Products.Five.browser.pagetemplatefile import ViewPageTemplateFile
+
+
+class CustomMigrationForm(BrowserView):
+
+    template = ViewPageTemplateFile('custom_migration.pt')
+
+    def __call__(self):
+        return self.template()
+
+    def getATFTIs(self):
+        ''' return a list of all at-types with existing instances
+        (including default-types)  '''
+        pass
+
+    def getDXFTIs(self):
+        '''return the FTI's of all DX-Types (including default-types)
+        '''
+        results = []
+        portal = self.context
+        ttool = getToolByName(portal, 'portal_types')
+        for ti in ttool.listTypeInfo():
+            if IDexterityFTI.providedBy(ti):
+                results.append(ti)
+
+    def getFieldsForATType(self, typename):
+        pass
+
+    def getFieldsForDXType(self, typename):
+        pass
+
+    def getPossibleTargetField(self, fieldtype):
+        ''' a list of DX-field types'''
+
+    def isFolderish(self):
+        ''' decide which base-class we use for the migrator'''


Repository: plone.app.contenttypes
Branch: refs/heads/master
Date: 2014-04-22T20:14:41+02:00
Author: Gauthier Bastien (gbastien) <g.bastien@imio.be>
Commit: https://github.com/plone/plone.app.contenttypes/commit/b4eee833b49bc46e0cdbd720b9760d716c84c79d

Added base methods listing AT and DX content types, added default template for custom content types migration based on atct content type migration template

Files changed:
M plone/app/contenttypes/migration/custom_migration.pt
M plone/app/contenttypes/migration/custom_migration.py
D README.rst

diff --git a/README.rst b/README.rst
deleted file mode 120000
index cffceba..0000000
--- a/README.rst
+++ /dev/null
@@ -1 +0,0 @@
-docs/README.rst
\ No newline at end of file
diff --git a/plone/app/contenttypes/migration/custom_migration.pt b/plone/app/contenttypes/migration/custom_migration.pt
index dc34228..cfc4454 100644
--- a/plone/app/contenttypes/migration/custom_migration.pt
+++ b/plone/app/contenttypes/migration/custom_migration.pt
@@ -1 +1,66 @@
-<h1>TODO</h1>
+<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"
+      xmlns:tal="http://xml.zope.org/namespaces/tal"
+      xmlns:metal="http://xml.zope.org/namespaces/metal"
+      xmlns:i18n="http://xml.zope.org/namespaces/i18n"
+      lang="en"
+      metal:use-macro="context/main_template/macros/master"
+      i18n:domain="plone">
+
+<metal:block fill-slot="top_slot"
+    tal:define="dummy python:request.set('disable_border', 1);
+                disable_column_two python:request.set('disable_plone.rightcolumn', 1);
+                disable_column_two python:request.set('disable_plone.leftcolumn', 1);
+                portal_state context/@@plone_portal_state;
+                portal_url portal_state/portal_url">
+  <link rel="stylesheet" type="text/css" href="" media="screen" tal:attributes="href string:${portal_url}/++resource++pac_migrator.css">
+</metal:block>
+
+<body>
+
+<metal:custom_title fill-slot="content-title">
+  <h1 class="documentFirstHeading" i18n:translate="">Custom types migration control panel</h1>
+</metal:custom_title>
+<metal:custom_desc fill-slot="content-description">
+  <div class="documentDescription" i18n:translate="">Migrate custom Archetypes content types to any available Dexterity content types.</div>
+</metal:custom_desc>
+
+<metal:content-core fill-slot="content-core">
+<metal:block define-macro="content-core" tal:define="at_types view/getATFTIs">
+  <div class="important">
+    <h2 i18n:translate="">Important</h2>
+    <p i18n:translate="">Before migrating your content please read the <a href="https://github.com/plone/plone.app.contenttypes#migration">migration-section in the documentation of plone.app.contenttypes</a></p>
+
+
+    <h3>Migrating content that is translated with LinguaPlone</h3>
+    <p i18n:translate="">Since LinguaPlone does not support Dexterity you need to migrate from LinguaPlone to <a href="http://pypi.python.org/pypi/plone.app.multilingual">plone.app.multilingual</a>. The migration from Products.LinguaPlone to plone.app.multilingual should happen before the migration from Archetypes to plone.app.contenttypes. For details on the migration see the <a href="http://pypi.python.org/pypi/plone.app.multilingual#linguaplone-migration">documentation</a></p>
+    <h3 i18n:translate="">Note about how long it might take</h3>
+    <p i18n:translate="">Depending of the number of archetypes in your portal, it may take a <span class="strong">really</span> long time for the migration to be done.
+      Stay calm and be patient.</p>
+    </div>
+    <tal:block condition="at_types">
+        <div id="migration-options">
+          <h2 i18n:translate="">Migrate contents</h2>
+          <div i18n:translate=""
+            class="documentDescription">
+            <p>You can select which AT content type you want to migrate to an existing DX content type.</p>
+            <h3>AT content types</h3>
+            <tal:block repeat="at_type at_types">
+                <p tal:content="at_type/title">AT content type title</p>
+            </tal:block>
+            <h3>DX content types</h3>
+            <tal:block repeat="dx_type view/getDXFTIs">
+                <p tal:content="dx_type/title">DX content type title</p>
+            </tal:block>
+          </div>
+        </div>
+    </tal:block>
+  <tal:block condition="not:at_types">
+    <div class="important">
+      <h2 i18n:translate="">Warning</h2>
+      <p i18n:translate="" class="strong">No content to migrate.</p>
+  </tal:block>
+
+</metal:block>
+</metal:content-core>
+</body>
+</html>
diff --git a/plone/app/contenttypes/migration/custom_migration.py b/plone/app/contenttypes/migration/custom_migration.py
index ca8bcd9..f2c7f2c 100644
--- a/plone/app/contenttypes/migration/custom_migration.py
+++ b/plone/app/contenttypes/migration/custom_migration.py
@@ -13,19 +13,35 @@ def __call__(self):
         return self.template()
 
     def getATFTIs(self):
-        ''' return a list of all at-types with existing instances
-        (including default-types)  '''
-        pass
+        '''Returns a list of all AT types with existing instances (including default-types).'''
+        results = []
+        archetype_tool = getToolByName(self.context, 'archetype_tool', None)
+        # if we do not have archetype_tool, it means that we have no registered AT types
+        if not archetype_tool:
+            return results
+
+        typesTool = getToolByName(self.context, 'portal_types')
+        catalog = getToolByName(self.context, 'portal_catalog')
+        registeredTypeNames = [registered['name'] for registered in archetype_tool.listRegisteredTypes()]
+        for fti in typesTool.listTypeInfo():
+            ftiId = fti.getId()
+            if hasattr(fti, 'content_meta_type') and \
+               fti.content_meta_type in registeredTypeNames and \
+               catalog(portal_type=ftiId):
+                results.append({'id': ftiId,
+                                'title': fti.Title()})
+        return results
 
     def getDXFTIs(self):
-        '''return the FTI's of all DX-Types (including default-types)
-        '''
+        '''return the FTI's of all DX-Types (including default-types).'''
         results = []
         portal = self.context
         ttool = getToolByName(portal, 'portal_types')
-        for ti in ttool.listTypeInfo():
-            if IDexterityFTI.providedBy(ti):
-                results.append(ti)
+        for fti in ttool.listTypeInfo():
+            if IDexterityFTI.providedBy(fti):
+                results.append({'id': fti.getId(),
+                                'title': fti.Title()})
+        return results
 
     def getFieldsForATType(self, typename):
         pass


Repository: plone.app.contenttypes
Branch: refs/heads/master
Date: 2014-04-23T09:32:41+02:00
Author: Gauthier Bastien (gbastien) <g.bastien@imio.be>
Commit: https://github.com/plone/plone.app.contenttypes/commit/32af50554365f8b89e6ea08474fb125a6b2aaad6

Added method that list an AT content type fields

Files changed:
M plone/app/contenttypes/migration/custom_migration.pt
M plone/app/contenttypes/migration/custom_migration.py

diff --git a/plone/app/contenttypes/migration/custom_migration.pt b/plone/app/contenttypes/migration/custom_migration.pt
index cfc4454..58a3758 100644
--- a/plone/app/contenttypes/migration/custom_migration.pt
+++ b/plone/app/contenttypes/migration/custom_migration.pt
@@ -46,6 +46,10 @@
             <h3>AT content types</h3>
             <tal:block repeat="at_type at_types">
                 <p tal:content="at_type/title">AT content type title</p>
+                <p style="font-weight: bold;">Fields</p>
+                <tal:block repeat="field python: view.getFieldsForATType(at_type['id'])">
+                    <p tal:content="field/title">AT field</p>
+                </tal:block>
             </tal:block>
             <h3>DX content types</h3>
             <tal:block repeat="dx_type view/getDXFTIs">
diff --git a/plone/app/contenttypes/migration/custom_migration.py b/plone/app/contenttypes/migration/custom_migration.py
index f2c7f2c..7e5fcfc 100644
--- a/plone/app/contenttypes/migration/custom_migration.py
+++ b/plone/app/contenttypes/migration/custom_migration.py
@@ -4,6 +4,12 @@
 from Products.CMFCore.utils import getToolByName
 from Products.Five.browser.pagetemplatefile import ViewPageTemplateFile
 
+HAS_EXTENDER = True
+try:
+    from archetypes.schemaextender.extender import instanceSchemaFactory
+except ImportError:
+    HAS_EXTENDER = False
+
 
 class CustomMigrationForm(BrowserView):
 
@@ -33,7 +39,7 @@ def getATFTIs(self):
         return results
 
     def getDXFTIs(self):
-        '''return the FTI's of all DX-Types (including default-types).'''
+        '''Returns the FTI's of all DX-Types (including default-types).'''
         results = []
         portal = self.context
         ttool = getToolByName(portal, 'portal_types')
@@ -44,9 +50,30 @@ def getDXFTIs(self):
         return results
 
     def getFieldsForATType(self, typename):
-        pass
+        '''Returns schema fields (name and type) for the given typename.'''
+        results = []
+        typesTool = getToolByName(self.context, 'portal_types')
+        fti = typesTool.getTypeInfo(typename)
+        archetype_tool = getToolByName(self.context, 'archetype_tool', None)
+        if not fti or not archetype_tool:
+            return results
+        schema = None
+        # a schema instance is stored in the archetype_tool
+        for regType in archetype_tool.listRegisteredTypes():
+            if regType['meta_type'] == fti.content_meta_type:
+                if HAS_EXTENDER:
+                    schema = instanceSchemaFactory(regType['klass'])
+                else:
+                    schema = regType['schema']
+                break
+        if not schema:
+            return results
+        for field in schema.filterFields(isMetadata=False):
+            results.append({'id': field.getName(),
+                            'title': '%s (%s)' % (field.widget.label, field.widget.getName())})
+        return results
 
-    def getFieldsForDXType(self, typename):
+    def getFieldsForDXType(self, typename, exclude_metadata=True):
         pass
 
     def getPossibleTargetField(self, fieldtype):


Repository: plone.app.contenttypes
Branch: refs/heads/master
Date: 2014-04-23T17:32:02+02:00
Author: Gauthier Bastien (gbastien) <g.bastien@imio.be>
Commit: https://github.com/plone/plone.app.contenttypes/commit/b8dfce1e2817f2931cf450f1d3f623507b8648c1

Added method that list fields of a given DX type

Files changed:
M plone/app/contenttypes/migration/custom_migration.pt
M plone/app/contenttypes/migration/custom_migration.py

diff --git a/plone/app/contenttypes/migration/custom_migration.pt b/plone/app/contenttypes/migration/custom_migration.pt
index 58a3758..6791328 100644
--- a/plone/app/contenttypes/migration/custom_migration.pt
+++ b/plone/app/contenttypes/migration/custom_migration.pt
@@ -54,6 +54,10 @@
             <h3>DX content types</h3>
             <tal:block repeat="dx_type view/getDXFTIs">
                 <p tal:content="dx_type/title">DX content type title</p>
+                <p style="font-weight: bold;">Fields</p>
+                <tal:block repeat="field python: view.getFieldsForDXType(dx_type['id'])">
+                    <p tal:content="field/title">AT field</p>
+                </tal:block>
             </tal:block>
           </div>
         </div>
diff --git a/plone/app/contenttypes/migration/custom_migration.py b/plone/app/contenttypes/migration/custom_migration.py
index 7e5fcfc..e5aff7a 100644
--- a/plone/app/contenttypes/migration/custom_migration.py
+++ b/plone/app/contenttypes/migration/custom_migration.py
@@ -1,8 +1,11 @@
 # -*- coding: UTF-8 -*-
 from Products.Five.browser import BrowserView
 from plone.dexterity.interfaces import IDexterityFTI
+from plone.dexterity.utils import iterSchemataForType
 from Products.CMFCore.utils import getToolByName
 from Products.Five.browser.pagetemplatefile import ViewPageTemplateFile
+from Products.ATContentTypes.content.base import ATContentTypeSchema
+
 
 HAS_EXTENDER = True
 try:
@@ -14,6 +17,7 @@
 class CustomMigrationForm(BrowserView):
 
     template = ViewPageTemplateFile('custom_migration.pt')
+    metadata_fields = ATContentTypeSchema.keys()
 
     def __call__(self):
         return self.template()
@@ -50,7 +54,7 @@ def getDXFTIs(self):
         return results
 
     def getFieldsForATType(self, typename):
-        '''Returns schema fields (name and type) for the given typename.'''
+        '''Returns schema fields (name and type) for the given AT typename.'''
         results = []
         typesTool = getToolByName(self.context, 'portal_types')
         fti = typesTool.getTypeInfo(typename)
@@ -68,13 +72,28 @@ def getFieldsForATType(self, typename):
                 break
         if not schema:
             return results
-        for field in schema.filterFields(isMetadata=False):
-            results.append({'id': field.getName(),
-                            'title': '%s (%s)' % (field.widget.label, field.widget.getName())})
+        for field in schema.fields():
+            if not field.getName() in self.metadata_fields:
+                results.append({'id': field.getName(),
+                                'title': '%s (%s)' % (field.widget.label, field.widget.getName())})
         return results
 
-    def getFieldsForDXType(self, typename, exclude_metadata=True):
-        pass
+    def getFieldsForDXType(self, typename):
+        '''Returns schema fields (name and type) for the given DX typename.'''
+        results = []
+        typesTool = getToolByName(self.context, 'portal_types')
+        fti = typesTool.getTypeInfo(typename)
+        if not fti:
+            return results
+
+        for schemata in iterSchemataForType(typename):
+            for fieldName, field in schemata.namesAndDescriptions():
+                # ignore Dublin Core fields
+                if fieldName in self.metadata_fields:
+                    continue
+                results.append({'id': fieldName,
+                                'title': '%s (%s)' % (field.title, field.__class__.__name__)})
+        return results
 
     def getPossibleTargetField(self, fieldtype):
         ''' a list of DX-field types'''


Repository: plone.app.contenttypes
Branch: refs/heads/master
Date: 2014-04-23T17:43:10+02:00
Author: Gauthier Bastien (gbastien) <g.bastien@imio.be>
Commit: https://github.com/plone/plone.app.contenttypes/commit/bba69fda2d6cf303e15839082b292311e7702865

Display something closer of mockup

Files changed:
M plone/app/contenttypes/migration/custom_migration.pt

diff --git a/plone/app/contenttypes/migration/custom_migration.pt b/plone/app/contenttypes/migration/custom_migration.pt
index 6791328..28cdbf8 100644
--- a/plone/app/contenttypes/migration/custom_migration.pt
+++ b/plone/app/contenttypes/migration/custom_migration.pt
@@ -43,22 +43,25 @@
           <div i18n:translate=""
             class="documentDescription">
             <p>You can select which AT content type you want to migrate to an existing DX content type.</p>
-            <h3>AT content types</h3>
-            <tal:block repeat="at_type at_types">
-                <p tal:content="at_type/title">AT content type title</p>
-                <p style="font-weight: bold;">Fields</p>
-                <tal:block repeat="field python: view.getFieldsForATType(at_type['id'])">
-                    <p tal:content="field/title">AT field</p>
-                </tal:block>
-            </tal:block>
-            <h3>DX content types</h3>
-            <tal:block repeat="dx_type view/getDXFTIs">
-                <p tal:content="dx_type/title">DX content type title</p>
-                <p style="font-weight: bold;">Fields</p>
-                <tal:block repeat="field python: view.getFieldsForDXType(dx_type['id'])">
-                    <p tal:content="field/title">AT field</p>
-                </tal:block>
-            </tal:block>
+            <table>
+                <tr tal:repeat="at_type at_types">
+                    <td valign="top">
+                        <p tal:content="at_type/title" style="font-weight: bold;">AT content type title</p>
+                        <p tal:repeat="field python: view.getFieldsForATType(at_type['id'])" tal:content="field/title">Field name</p>
+                    </td>
+                    <td valign="top">
+                        <select>
+                            <option value="">Choose</option>
+                            <option tal:repeat="dx_type view/getDXFTIs"
+                                    tal:attributes="value dx_type/id"
+                                    tal:content="dx_type/title">DX type name</option>
+                        </select>
+                        <!--tal:block repeat="field python: view.getFieldsForDXType(dx_type['id'])">
+                            <p tal:content="field/title">AT field</p>
+                        </tal:block-->
+                    </td>
+                </tr>
+            </table>
           </div>
         </div>
     </tal:block>


Repository: plone.app.contenttypes
Branch: refs/heads/master
Date: 2014-04-24T14:57:42+02:00
Author: Andrea Cecchi (cekk) <andrea.cecchi85@gmail.com>
Commit: https://github.com/plone/plone.app.contenttypes/commit/fc9b41860860872be50798a80e160af8d53e131e

initial custom migrator implementation

Files changed:
A plone/app/contenttypes/tests/test_migration_custom.py
M plone/app/contenttypes/migration/migration.py

diff --git a/plone/app/contenttypes/migration/migration.py b/plone/app/contenttypes/migration/migration.py
index e330194..75af1ba 100644
--- a/plone/app/contenttypes/migration/migration.py
+++ b/plone/app/contenttypes/migration/migration.py
@@ -523,3 +523,147 @@ def migrate_events(portal):
     migrate(portal, DXOldEventMigrator)
     migrate(portal, EventMigrator)
     migrate(portal, DXEventMigrator)
+
+
+# def makeFolderMigrator(context, src_type, dst_type):
+#     """ generate a migrator for the given at-based folderish portal type """
+#     from Products.contentmigration.archetypes import InplaceATFolderMigrator
+
+#     class ATFolderMigrator(InplaceATFolderMigrator):
+#         src_portal_type = src_type
+#         dst_portal_type = dst_type
+
+#     return ATFolderMigrator
+
+
+# def makeContentMigrator(context, src_type, dst_type):
+#     """ generate a migrator for the given at-based portal type """
+#     from Products.contentmigration.archetypes import InplaceATItemMigrator
+
+#     class ATContentMigrator(InplaceATItemMigrator):
+#         src_portal_type = src_type
+#         dst_portal_type = dst_type
+
+#     return ATContentMigrator
+
+
+# def migrateContents(context, src_type, dst_type, query={}):
+#     from Products.contentmigration.walker import CustomQueryWalker
+#     #BBB: i can't find a better way to know if a given portal_type is folderish or not
+#     is_folderish = False
+#     temp_obj = context.restrictedTraverse('portal_factory/%s/tmp_id' % src_type)
+#     if temp_obj:
+#         plone_view = temp_obj.restrictedTraverse('@@plone')
+#         if plone_view.isStructuralFolder():
+#             is_folderish = True
+#     portal_types = context.portal_types
+#     src_infos = portal_types.getTypeInfo(src_type)
+#     dst_infos = portal_types.getTypeInfo(dst_type)
+#     if is_folderish:
+#         migrator = makeFolderMigrator(context,
+#                                      src_type,
+#                                      dst_type,)
+#     else:
+#         migrator = makeContentMigrator(context,
+#                                       src_type,
+#                                       dst_type,)
+#     if migrator:
+#         migrator.src_meta_type = src_infos.content_meta_type
+#         migrator.dst_meta_type = dst_infos.content_meta_type
+#         walker = CustomQueryWalker(context, migrator,
+#                                   src_portal_type=src_type,
+#                                   dst_portal_type=dst_type,
+#                                   query=query,
+#                                   use_savepoint=True)
+#         walker.go()
+#         walk_infos = {'error': walker.errors,
+#                       'msg': walker.getOutput().splitlines(),
+#                       'counter': walker.counter}
+#         return walk_infos
+
+
+def migrate_simplefield(src_obj, dst_obj, src_fieldname, dst_fieldname):
+    field = src_obj.getField(src_fieldname)
+    if not field:
+        return
+    val = field.get(src_obj)
+    setattr(dst_obj, dst_fieldname, val)
+
+
+def migrate_imagefield(src_obj, dst_obj, src_fieldname, dst_fieldname):
+    old_image = src_obj.getField(src_fieldname).get(src_obj)
+    if old_image == '':
+        return
+    filename = safe_unicode(old_image.filename)
+    old_image_data = old_image.data
+    if safe_hasattr(old_image_data, 'data'):
+        old_image_data = old_image_data.data
+    namedblobimage = NamedBlobImage(data=old_image_data,
+                                    filename=filename)
+    dst_obj.image = namedblobimage
+    caption_field = src_obj.getField('imageCaption', None)
+    if caption_field:
+        dst_obj.image_caption = safe_unicode(caption_field.get(src_obj))
+    logger.info("Migrating image %s" % filename)
+
+
+def migrate_filefield(src_obj, dst_obj, src_fieldname, dst_fieldname):
+    """
+    BBB to be tested
+    """
+    old_file = src_obj.getField(src_fieldname).get(src_obj)
+    if old_file == '':
+        return
+    filename = safe_unicode(old_file.filename)
+    old_file_data = old_file.data
+    if safe_hasattr(old_file_data, 'data'):
+        old_file_data = old_file_data.data
+    namedblobfile = NamedBlobFile(data=old_file_data,
+                                    filename=filename)
+    dst_obj.file = namedblobfile
+    logger.info("Migrating file %s" % filename)
+
+
+# def migrate_referencefield(src_obj, dst_obj, src_fieldname, dst_fieldname):
+#     # Relations UIDs:
+#     field = src_obj.getField(src_fieldname)
+#     if not field:
+#         return
+#     references = field.get(src_obj)
+#     if not hasattr(src_obj, "_%sOrder" % src_fieldname):
+#         referencesOrder = [item.UID() for item in references]
+#         setattr(src_obj, "_%sOrder" % src_fieldname, PersistentList(referencesOrder))
+
+#     # Backrefs Relations UIDs:
+#     reference_cat = getToolByName(src_obj, REFERENCE_CATALOG)
+#     backrefs = reference_cat.getBackReferences(src_obj,
+#                                                relationship="relatesTo")
+#     backref_objects = map(lambda x: x.getSourceObject(), backrefs)
+#     for obj in backref_objects:
+#         if obj.portal_type != dst_obj.src_portal_type:
+#             continue
+#         if not hasattr(obj, "_relUids"):
+#             relatedItems = obj.getRelatedItems()
+#             relatedItemsOrder = [item.UID() for item in relatedItems]
+#             obj._relatedItemsOrder = PersistentList(relatedItemsOrder)
+
+# def migrate_relatedItems(self):
+#     """ Store Archetype relations as target uids on the dexterity object
+#         for later restore. Backrelations are saved as well because all
+#         relation to deleted objects would be lost.
+#     """
+
+#     # Relations:
+#     relItems = self.old.getRelatedItems()
+#     relUids = [item.UID() for item in relItems]
+#     self.new._relatedItems = relUids
+
+#     # Backrefs:
+#     reference_catalog = getToolByName(self.old, REFERENCE_CATALOG)
+
+#     backrefs = [i.sourceUID for i in reference_catalog.getBackReferences(
+#         self.old, relationship="relatesTo")]
+#     self.new._backrefs = backrefs
+
+#     # Order:
+#     self.new._relatedItemsOrder = self.old._relatedItemsOrder
\ No newline at end of file
diff --git a/plone/app/contenttypes/tests/test_migration_custom.py b/plone/app/contenttypes/tests/test_migration_custom.py
new file mode 100644
index 0000000..acbc29f
--- /dev/null
+++ b/plone/app/contenttypes/tests/test_migration_custom.py
@@ -0,0 +1,101 @@
+# -*- coding: utf-8 -*-
+from Products.CMFCore.utils import getToolByName
+from five.intid.intid import IntIds
+from five.intid.site import addUtility
+from plone.app.contenttypes.testing import \
+    PLONE_APP_CONTENTTYPES_MIGRATION_TESTING
+from plone.app.contenttypes.testing import set_browserlayer
+from plone.app.testing import applyProfile
+from plone.app.testing import login
+from plone.event.interfaces import IEventAccessor
+from zope.annotation.interfaces import IAnnotations
+from zope.component import getMultiAdapter
+from zope.component import getSiteManager
+from zope.component import getUtility
+from zope.intid.interfaces import IIntIds
+from zope.schema.interfaces import IVocabularyFactory
+import os.path
+import time
+import unittest2 as unittest
+from plone.app.testing import TEST_USER_ID, setRoles
+from test_image import dummy_image
+from plone.app.contenttypes.migration.migration import migrate_imagefield, migrate_simplefield
+from plone.app.testing import applyProfile
+
+
+class MigrateFieldsTest(unittest.TestCase):
+
+    layer = PLONE_APP_CONTENTTYPES_MIGRATION_TESTING
+
+    def setUp(self):
+        self.portal = self.layer['portal']
+        self.request = self.layer['request']
+        setRoles(self.portal, TEST_USER_ID, ['Manager'])
+
+    def tearDown(self):
+        try:
+            applyProfile(self.portal, 'plone.app.contenttypes:uninstall')
+        except KeyError:
+            pass
+
+    def get_test_image_data(self):
+        test_image_path = os.path.join(os.path.dirname(__file__), 'image.png')
+        with open(test_image_path, 'rb') as test_image_file:
+            test_image_data = test_image_file.read()
+        return test_image_data
+
+    def get_test_file_data(self):
+        test_file_path = os.path.join(os.path.dirname(__file__), 'file.pdf')
+        with open(test_file_path, 'rb') as test_file:
+            test_file_data = test_file.read()
+        return test_file_data
+
+    def test_migrate_stringfield(self):
+        # create content
+        at_document_id = self.portal.invokeFactory('Document',
+                                                   'foo',
+                                                   title="Foo document")
+        # register p.a.contenttypes profile
+        applyProfile(self.portal, 'plone.app.contenttypes:default')
+        dx_document_id = self.portal.invokeFactory('Document',
+                                                   'bar',
+                                                   title="Bar document")
+        at_document = self.portal[at_document_id]
+        dx_document = self.portal[dx_document_id]
+        migrate_simplefield(at_document, dx_document, 'title', 'title')
+        self.assertEqual(dx_document.Title(), at_document.Title())
+
+    def test_migrate_listfield(self):
+        # create content
+        at_document_id = self.portal.invokeFactory('Document',
+                                                   'foo',
+                                                   title="Foo document",
+                                                   subject=['aaa', 'bbb'])
+        # register p.a.contenttypes profile
+        applyProfile(self.portal, 'plone.app.contenttypes:default')
+        dx_document_id = self.portal.invokeFactory('Document',
+                                                   'bar',
+                                                   title="Bar document")
+        at_document = self.portal[at_document_id]
+        dx_document = self.portal[dx_document_id]
+        migrate_simplefield(at_document, dx_document, 'subject', 'subject')
+        self.assertEqual(dx_document.Subject(), at_document.Subject())
+
+    def test_migrate_imagefield(self):
+        test_image_data = self.get_test_image_data()
+        at_newsitem_id = self.portal.invokeFactory('News Item',
+                                                'foo',
+                                                title="Foo news",
+                                                image=test_image_data)
+        # register p.a.contenttypes profile
+        applyProfile(self.portal, 'plone.app.contenttypes:default')
+        dx_newsitem_id = self.portal.invokeFactory('News Item',
+                                                'bar',
+                                                title="Bar news")
+        at_newsitem = self.portal[at_newsitem_id]
+        dx_newsitem = self.portal[dx_newsitem_id]
+        self.assertEqual(dx_newsitem.image, None)
+        migrate_imagefield(at_newsitem, dx_newsitem, 'image', 'image')
+        self.assertEqual(dx_newsitem.image.contentType, 'image/png')
+        self.assertEqual(dx_newsitem.image.data, test_image_data)
+


Repository: plone.app.contenttypes
Branch: refs/heads/master
Date: 2014-04-24T15:22:40+02:00
Author: Andrea Cecchi (cekk) <andrea.cecchi85@gmail.com>
Commit: https://github.com/plone/plone.app.contenttypes/commit/e28ab1341d361399a66ed79d3bcc03fb93d48ff1

initial implementation of custom migrator

Files changed:
M plone/app/contenttypes/migration/migration.py
M plone/app/contenttypes/tests/test_migration_custom.py

diff --git a/plone/app/contenttypes/migration/migration.py b/plone/app/contenttypes/migration/migration.py
index 75af1ba..6b25188 100644
--- a/plone/app/contenttypes/migration/migration.py
+++ b/plone/app/contenttypes/migration/migration.py
@@ -525,61 +525,55 @@ def migrate_events(portal):
     migrate(portal, DXEventMigrator)
 
 
-# def makeFolderMigrator(context, src_type, dst_type):
-#     """ generate a migrator for the given at-based folderish portal type """
-#     from Products.contentmigration.archetypes import InplaceATFolderMigrator
-
-#     class ATFolderMigrator(InplaceATFolderMigrator):
-#         src_portal_type = src_type
-#         dst_portal_type = dst_type
-
-#     return ATFolderMigrator
-
-
-# def makeContentMigrator(context, src_type, dst_type):
-#     """ generate a migrator for the given at-based portal type """
-#     from Products.contentmigration.archetypes import InplaceATItemMigrator
-
-#     class ATContentMigrator(InplaceATItemMigrator):
-#         src_portal_type = src_type
-#         dst_portal_type = dst_type
-
-#     return ATContentMigrator
-
-
-# def migrateContents(context, src_type, dst_type, query={}):
-#     from Products.contentmigration.walker import CustomQueryWalker
-#     #BBB: i can't find a better way to know if a given portal_type is folderish or not
-#     is_folderish = False
-#     temp_obj = context.restrictedTraverse('portal_factory/%s/tmp_id' % src_type)
-#     if temp_obj:
-#         plone_view = temp_obj.restrictedTraverse('@@plone')
-#         if plone_view.isStructuralFolder():
-#             is_folderish = True
-#     portal_types = context.portal_types
-#     src_infos = portal_types.getTypeInfo(src_type)
-#     dst_infos = portal_types.getTypeInfo(dst_type)
-#     if is_folderish:
-#         migrator = makeFolderMigrator(context,
-#                                      src_type,
-#                                      dst_type,)
-#     else:
-#         migrator = makeContentMigrator(context,
-#                                       src_type,
-#                                       dst_type,)
-#     if migrator:
-#         migrator.src_meta_type = src_infos.content_meta_type
-#         migrator.dst_meta_type = dst_infos.content_meta_type
-#         walker = CustomQueryWalker(context, migrator,
-#                                   src_portal_type=src_type,
-#                                   dst_portal_type=dst_type,
-#                                   query=query,
-#                                   use_savepoint=True)
-#         walker.go()
-#         walk_infos = {'error': walker.errors,
-#                       'msg': walker.getOutput().splitlines(),
-#                       'counter': walker.counter}
-#         return walk_infos
+def makeCustomFolderMigrator(context, src_type, dst_type, fields_mapping):
+    """ generate a migrator for the given at-based folderish portal type """
+
+    class CustomATFolderMigrator(ATCTFolderMigrator):
+        src_portal_type = src_type
+        dst_portal_type = dst_type
+
+    return CustomATFolderMigrator
+
+
+def makeCustomContentMigrator(context, src_type, dst_type, fields_mapping):
+    """ generate a migrator for the given at-based portal type """
+
+    class CustomATContentMigrator(ATCTContentMigrator):
+        src_portal_type = src_type
+        dst_portal_type = dst_type
+
+        def migrate_schema_fields(self):
+            # migrate the richtext
+            super(CustomATContentMigrator, self).migrate_schema_fields()
+
+    return CustomATContentMigrator
+
+
+def migrateCustomAT(context, fields_mapping):
+    #BBB: i can't find a better way to know if a given portal_type is folderish or not
+    is_folderish = False
+    temp_obj = context.restrictedTraverse('portal_factory/%s/tmp_id' % src_type)
+    if temp_obj:
+        plone_view = temp_obj.restrictedTraverse('@@plone')
+        if plone_view.isStructuralFolder():
+            is_folderish = True
+    portal_types = context.portal_types
+    src_infos = portal_types.getTypeInfo(src_type)
+    dst_infos = portal_types.getTypeInfo(dst_type)
+    if is_folderish:
+        migrator = makeCustomFolderMigrator(context,
+                                     src_type,
+                                     dst_type,
+                                     fields_mapping)
+    else:
+        migrator = makeCustomContentMigrator(context,
+                                      src_type,
+                                      dst_type,
+                                      fields_mapping)
+    if migrator:
+        migrator.src_meta_type = src_infos.content_meta_type
+        migrator.dst_meta_type = dst_infos.content_meta_type
+        migrate(context, migrator)
 
 
 def migrate_simplefield(src_obj, dst_obj, src_fieldname, dst_fieldname):
diff --git a/plone/app/contenttypes/tests/test_migration_custom.py b/plone/app/contenttypes/tests/test_migration_custom.py
index acbc29f..971eea8 100644
--- a/plone/app/contenttypes/tests/test_migration_custom.py
+++ b/plone/app/contenttypes/tests/test_migration_custom.py
@@ -99,3 +99,18 @@ def test_migrate_imagefield(self):
         self.assertEqual(dx_newsitem.image.contentType, 'image/png')
         self.assertEqual(dx_newsitem.image.data, test_image_data)
 
+
+class MigrateCustomATTest(unittest.TestCase):
+
+    layer = PLONE_APP_CONTENTTYPES_MIGRATION_TESTING
+
+    def setUp(self):
+        self.portal = self.layer['portal']
+        self.request = self.layer['request']
+        setRoles(self.portal, TEST_USER_ID, ['Manager'])
+
+    def tearDown(self):
+        try:
+            applyProfile(self.portal, 'plone.app.contenttypes:uninstall')
+        except KeyError:
+            pass


Repository: plone.app.contenttypes
Branch: refs/heads/master
Date: 2014-04-24T15:47:00+02:00
Author: Gauthier Bastien (gbastien) <g.bastien@imio.be>
Commit: https://github.com/plone/plone.app.contenttypes/commit/61abc95dd723391d4ea834f93f6b810c9a1b60ce

Call relevant method with hardcoded data for testing purpose

Files changed:
M plone/app/contenttypes/migration/configure.zcml
M plone/app/contenttypes/migration/custom_migration.pt
M plone/app/contenttypes/migration/custom_migration.py
M plone/app/contenttypes/migration/migration.py

diff --git a/plone/app/contenttypes/migration/configure.zcml b/plone/app/contenttypes/migration/configure.zcml
index d353ca9..1b267a2 100644
--- a/plone/app/contenttypes/migration/configure.zcml
+++ b/plone/app/contenttypes/migration/configure.zcml
@@ -68,6 +68,15 @@
     template="custom_migration.pt"
     />
 
+  <browser:page
+    name="display_dx_fields"
+    for="Products.CMFPlone.interfaces.IPloneSiteRoot"
+    class=".custom_migration.DisplayDXFields"
+    layer="..interfaces.IPloneAppContenttypesLayer"
+    permission="cmf.ManagePortal"
+    template="custom_migration_display_dx_fields.pt"
+    />
+
   <utility
       factory=".vocabularies.ATCTypesVocabulary"
       name="plone.app.contenttypes.migration.atctypes"
diff --git a/plone/app/contenttypes/migration/custom_migration.pt b/plone/app/contenttypes/migration/custom_migration.pt
index 28cdbf8..5e6b63e 100644
--- a/plone/app/contenttypes/migration/custom_migration.pt
+++ b/plone/app/contenttypes/migration/custom_migration.pt
@@ -37,6 +37,24 @@
     <p i18n:translate="">Depending of the number of archetypes in your portal, it may take a <span class="strong">really</span> long time for the migration to be done.
       Stay calm and be patient.</p>
     </div>
+    <script type="text/javascript">
+        // function that toggle an icon by calling the p_viewName view
+        function getDXFields(at_typename) {
+          $.ajax({
+            url: '@@display_dx_fields',
+            dataType: 'html',
+            data: {at_typename:at_typename},
+            cache: false,
+            success: function(data) {
+                var $div = $('#hook_at_fti_' + at_typename);
+                $div.empty();
+                $div.html(data);
+              },
+            error: function(jqXHR, textStatus, errorThrown) {
+              }
+            });
+        }
+    </script>
     <tal:block condition="at_types">
         <div id="migration-options">
           <h2 i18n:translate="">Migrate contents</h2>
@@ -50,15 +68,19 @@
                         <p tal:repeat="field python: view.getFieldsForATType(at_type['id'])" tal:content="field/title">Field name</p>
                     </td>
                     <td valign="top">
-                        <select>
-                            <option value="">Choose</option>
+                        <select tal:attributes="onChange string:javascript:getDXFields(at_typename='${at_type/id}');">
+                            <option value="" selected>Choose</option>
                             <option tal:repeat="dx_type view/getDXFTIs"
                                     tal:attributes="value dx_type/id"
                                     tal:content="dx_type/title">DX type name</option>
                         </select>
-                        <!--tal:block repeat="field python: view.getFieldsForDXType(dx_type['id'])">
-                            <p tal:content="field/title">AT field</p>
+                        <!--tal:block repeat='dx_type view/getDXFTIs'>
+                            <h3 tal:content="dx_type/title"></h3>
+                            <tal:block repeat="field python: view.getFieldsForDXType(dx_type['id'])">
+                                <p tal:content="field/id">AT field</p>
+                            </tal:block>
                         </tal:block-->
+                        <div id="hook_at_fti" tal:attributes="id string:hook_at_fti_${at_type/id}" />
                     </td>
                 </tr>
             </table>
diff --git a/plone/app/contenttypes/migration/custom_migration.py b/plone/app/contenttypes/migration/custom_migration.py
index e5aff7a..53aff1f 100644
--- a/plone/app/contenttypes/migration/custom_migration.py
+++ b/plone/app/contenttypes/migration/custom_migration.py
@@ -4,7 +4,8 @@
 from plone.dexterity.utils import iterSchemataForType
 from Products.CMFCore.utils import getToolByName
 from Products.Five.browser.pagetemplatefile import ViewPageTemplateFile
-from Products.ATContentTypes.content.base import ATContentTypeSchema
+from Products.ATContentTypes.content.schemata import ATContentTypeSchema
+from plone.app.contenttypes.migration.migration import migrateCustomAT
 
 
 HAS_EXTENDER = True
@@ -17,10 +18,27 @@
 class CustomMigrationForm(BrowserView):
 
     template = ViewPageTemplateFile('custom_migration.pt')
-    metadata_fields = ATContentTypeSchema.keys()
+    at_metadata_fields = ATContentTypeSchema.keys()
+    dx_metadata_fields = list(at_metadata_fields)
+    # some metadata names are different between AT and DX...
+    dx_metadata_fields.remove('allowDiscussion')
+    dx_metadata_fields.remove('excludeFromNav')
+    dx_metadata_fields.append('allow_discussion')
+    dx_metadata_fields.append('exclude_from_nav')
 
     def __call__(self):
-        return self.template()
+        # check that we can actually access this form, aka the current user has an advice to add or edit
+        form = self.request.form
+        cancelled = form.get('form.button.Cancel', False)
+        submitted = form.get('form.button.Save', False)
+        if submitted:
+            # proceed, call the migration methdd
+            self.apply()
+            msg = self.context.utranslate('Migration applied.', domain='plone.app.contenttypes')
+            self.context.plone_utils.addPortalMessage(msg)
+        elif cancelled:
+            self.request.response.redirect(form.get('form.HTTP_REFERER'))
+        return self.index()
 
     def getATFTIs(self):
         '''Returns a list of all AT types with existing instances (including default-types).'''
@@ -73,7 +91,7 @@ def getFieldsForATType(self, typename):
         if not schema:
             return results
         for field in schema.fields():
-            if not field.getName() in self.metadata_fields:
+            if not field.getName() in self.at_metadata_fields:
                 results.append({'id': field.getName(),
                                 'title': '%s (%s)' % (field.widget.label, field.widget.getName())})
         return results
@@ -89,7 +107,7 @@ def getFieldsForDXType(self, typename):
         for schemata in iterSchemataForType(typename):
             for fieldName, field in schemata.namesAndDescriptions():
                 # ignore Dublin Core fields
-                if fieldName in self.metadata_fields:
+                if fieldName in self.dx_metadata_fields:
                     continue
                 results.append({'id': fieldName,
                                 'title': '%s (%s)' % (field.title, field.__class__.__name__)})
@@ -100,3 +118,28 @@ def getPossibleTargetField(self, fieldtype):
 
     def isFolderish(self):
         ''' decide which base-class we use for the migrator'''
+
+    def apply(self):
+        '''
+        '''
+        # dictionnary structure is like :
+        # ({'AT_field_name': 'text',
+        #   'AT_field_type': 'RichText',
+        #   'DX_field_name': 'text',
+        #   'DX_field_type': 'TextLine', }), },
+        # }
+        data = ({'AT_field_name': 'text',
+                 'AT_field_type': 'RichText',
+                 'DX_field_name': 'text',
+                 'DX_field_type': 'TextLine', }, )
+        migrateCustomAT(fields_mapping=data, src_type='DocumentAT', dst_type='Document')
+
+
+class DisplayDXFields(BrowserView):
+
+    template = ViewPageTemplateFile('custom_migration_display_dx_fields.pt')
+
+    def __call__(self):
+        '''
+        '''
+        return self.index()
diff --git a/plone/app/contenttypes/migration/migration.py b/plone/app/contenttypes/migration/migration.py
index 6b25188..3e49baa 100644
--- a/plone/app/contenttypes/migration/migration.py
+++ b/plone/app/contenttypes/migration/migration.py
@@ -549,7 +549,7 @@ def migrate_schema_fields(self):
     return CustomATContentMigrator
 
 
-def migrateCustomAT(context, fields_mapping):
+def migrateCustomAT(context, fields_mapping, src_type, dst_type):
     #BBB: i can't find a better way to know if a given portal_type is folderish or not
     is_folderish = False
     temp_obj = context.restrictedTraverse('portal_factory/%s/tmp_id' % src_type)


Repository: plone.app.contenttypes
Branch: refs/heads/master
Date: 2014-04-24T17:53:22+02:00
Author: Gauthier Bastien (gbastien) <g.bastien@imio.be>
Commit: https://github.com/plone/plone.app.contenttypes/commit/0b64a1b277eb096345f244bcd3e402c536acbaab

Make test work with DocumentAT sample AT type

Files changed:
M plone/app/contenttypes/migration/custom_migration.pt
M plone/app/contenttypes/migration/custom_migration.py

diff --git a/plone/app/contenttypes/migration/custom_migration.pt b/plone/app/contenttypes/migration/custom_migration.pt
index 5e6b63e..74678fd 100644
--- a/plone/app/contenttypes/migration/custom_migration.pt
+++ b/plone/app/contenttypes/migration/custom_migration.pt
@@ -39,11 +39,12 @@
     </div>
     <script type="text/javascript">
         // function that toggle an icon by calling the p_viewName view
-        function getDXFields(at_typename) {
+        function getDXFields(at_typename, dx_typename) {
           $.ajax({
             url: '@@display_dx_fields',
             dataType: 'html',
-            data: {at_typename:at_typename},
+            data: {at_typename:at_typename,
+                   dx_typename: dx_typename},
             cache: false,
             success: function(data) {
                 var $div = $('#hook_at_fti_' + at_typename);
@@ -61,6 +62,8 @@
           <div i18n:translate=""
             class="documentDescription">
             <p>You can select which AT content type you want to migrate to an existing DX content type.</p>
+            <form id="migrateCustomATForm" method="post"
+                  tal:attributes="action python:context.absolute_url() + '/@@custom_migration'">
             <table>
                 <tr tal:repeat="at_type at_types">
                     <td valign="top">
@@ -68,8 +71,9 @@
                         <p tal:repeat="field python: view.getFieldsForATType(at_type['id'])" tal:content="field/title">Field name</p>
                     </td>
                     <td valign="top">
-                        <select tal:attributes="onChange string:javascript:getDXFields(at_typename='${at_type/id}');">
-                            <option value="" selected>Choose</option>
+                        <select tal:attributes="onChange string:javascript:getDXFields(at_typename='${at_type/id}', this.value);
+                                                name string:dx_select_${at_type/id};">
+                            <option value="" selected="selected">Do not migrate</option>
                             <option tal:repeat="dx_type view/getDXFTIs"
                                     tal:attributes="value dx_type/id"
                                     tal:content="dx_type/title">DX type name</option>
@@ -84,6 +88,12 @@
                     </td>
                 </tr>
             </table>
+            <div>
+              <br />
+              <input type="submit" name="form.button.Apply" class="context" value="Apply" i18n:attributes="value" i18n:domain="plone"/>&nbsp;
+              <input type="submit" name="form.button.Cancel" class="standalone" value="Cancel" i18n:attributes="value" i18n:domain="plone"/>
+            </div>
+            </form>
           </div>
         </div>
     </tal:block>
diff --git a/plone/app/contenttypes/migration/custom_migration.py b/plone/app/contenttypes/migration/custom_migration.py
index 53aff1f..ea28b2a 100644
--- a/plone/app/contenttypes/migration/custom_migration.py
+++ b/plone/app/contenttypes/migration/custom_migration.py
@@ -30,7 +30,7 @@ def __call__(self):
         # check that we can actually access this form, aka the current user has an advice to add or edit
         form = self.request.form
         cancelled = form.get('form.button.Cancel', False)
-        submitted = form.get('form.button.Save', False)
+        submitted = form.get('form.button.Apply', False)
         if submitted:
             # proceed, call the migration methdd
             self.apply()
@@ -132,13 +132,18 @@ def apply(self):
                  'AT_field_type': 'RichText',
                  'DX_field_name': 'text',
                  'DX_field_type': 'TextLine', }, )
-        migrateCustomAT(fields_mapping=data, src_type='DocumentAT', dst_type='Document')
+        migrateCustomAT(self.context, fields_mapping=data, src_type='DocumentAT', dst_type='Document')
 
 
-class DisplayDXFields(BrowserView):
+class DisplayDXFields(CustomMigrationForm):
 
     template = ViewPageTemplateFile('custom_migration_display_dx_fields.pt')
 
+    def __init__(self, context, request):
+        CustomMigrationForm.__init__(self, context, request)
+        self.at_typename = request.get('at_typename')
+        self.dx_typename = request.get('dx_typename')
+
     def __call__(self):
         '''
         '''


Repository: plone.app.contenttypes
Branch: refs/heads/master
Date: 2014-04-25T16:31:06+02:00
Author: Andrea Cecchi (cekk) <andrea.cecchi85@gmail.com>
Commit: https://github.com/plone/plone.app.contenttypes/commit/f9244b613385c4b17956ede1c006a638a9439a34

added more fieldmigrators and tested a custom migration

Files changed:
M plone/app/contenttypes/migration/migration.py
M plone/app/contenttypes/tests/test_migration_custom.py

diff --git a/plone/app/contenttypes/migration/migration.py b/plone/app/contenttypes/migration/migration.py
index 3e49baa..5a6b394 100644
--- a/plone/app/contenttypes/migration/migration.py
+++ b/plone/app/contenttypes/migration/migration.py
@@ -7,37 +7,107 @@
 module will only work if Products.contentmigration is installed so make sure
 you catch ImportErrors
 '''
-from Products.ATContentTypes.interfaces.interfaces import IATContentType
-from Products.Archetypes.config import REFERENCE_CATALOG
-from Products.CMFCore.utils import getToolByName
-from Products.CMFPlone.utils import safe_unicode, safe_hasattr
-from Products.contentmigration.basemigrator.migrator import CMFFolderMigrator
-from Products.contentmigration.basemigrator.migrator import CMFItemMigrator
-from Products.contentmigration.basemigrator.walker import CatalogWalker
 from persistent.list import PersistentList
 from plone.app.contenttypes.behaviors.collection import ICollection
+from plone.app.contenttypes.migration import datetime_fixer
 from plone.app.contenttypes.migration.dxmigration import DXEventMigrator
 from plone.app.contenttypes.migration.dxmigration import DXOldEventMigrator
-from plone.app.contenttypes.migration import datetime_fixer
 from plone.app.textfield.value import RichTextValue
 from plone.app.uuid.utils import uuidToObject
 from plone.dexterity.interfaces import IDexterityContent
 from plone.event.utils import default_timezone
 from plone.namedfile.file import NamedBlobFile
 from plone.namedfile.file import NamedBlobImage
+from Products.Archetypes.config import REFERENCE_CATALOG
+from Products.ATContentTypes.interfaces.interfaces import IATContentType
+from Products.CMFCore.utils import getToolByName
+from Products.CMFPlone.utils import safe_unicode, safe_hasattr
+from Products.contentmigration.basemigrator.migrator import CMFFolderMigrator
+from Products.contentmigration.basemigrator.migrator import CMFItemMigrator
+from Products.contentmigration.basemigrator.walker import CatalogWalker
 from z3c.relationfield import RelationValue
 from zope.component import adapter
 from zope.component import getAdapters
 from zope.component import getUtility
-from zope.interface import Interface
+from zope.component.hooks import getSite
 from zope.interface import implementer
+from zope.interface import Interface
 from zope.intid.interfaces import IIntIds
 
-
 import logging
 logger = logging.getLogger(__name__)
 
 
+def migrate_simplefield(src_obj, dst_obj, src_fieldname, dst_fieldname):
+    field = src_obj.getField(src_fieldname)
+    if field:
+        at_value = field.get(src_obj)
+    else:
+        at_value = getattr(src_obj, src_fieldname, None)
+        if at_value and hasattr(at_value, '__call__'):
+            at_value = at_value()
+    if at_value:
+        setattr(dst_obj, dst_fieldname, at_value)
+
+
+def migrate_textfield(src_obj, dst_obj, src_fieldname, dst_fieldname):
+    field = src_obj.getField(src_fieldname)
+    raw_text = ''
+    if field:
+        mime_type = field.getContentType(src_obj)
+        raw_text = safe_unicode(field.getRaw(src_obj))
+    else:
+        at_value = getattr(src_obj, src_fieldname, None)
+        if at_value:
+            mime_type = at_value.mimetype
+            raw_text = safe_unicode(at_value.raw)
+
+    if raw_text.strip() == '':
+            return
+    richtext = RichTextValue(raw=raw_text, mimeType=mime_type,
+                             outputMimeType='text/x-html-safe')
+    setattr(dst_obj, dst_fieldname, richtext)
+
+
+def migrate_imagefield(src_obj, dst_obj, src_fieldname, dst_fieldname):
+    old_image = src_obj.getField(src_fieldname).get(src_obj)
+    if old_image == '':
+        return
+    filename = safe_unicode(old_image.filename)
+    old_image_data = old_image.data
+    if safe_hasattr(old_image_data, 'data'):
+        old_image_data = old_image_data.data
+    namedblobimage = NamedBlobImage(data=old_image_data,
+                                    filename=filename)
+    dst_obj.image = namedblobimage
+    caption_field = src_obj.getField('imageCaption', None)
+    if caption_field:
+        dst_obj.image_caption = safe_unicode(caption_field.get(src_obj))
+    logger.info("Migrating image %s" % filename)
+
+
+def migrate_filefield(src_obj, dst_obj, src_fieldname, dst_fieldname):
+    """
+    BBB to be tested
+    """
+    old_file = src_obj.getField(src_fieldname).get(src_obj)
+    if old_file == '':
+        return
+    filename = safe_unicode(old_file.filename)
+    old_file_data = old_file.data
+    if safe_hasattr(old_file_data, 'data'):
+        old_file_data = old_file_data.data
+    namedblobfile = NamedBlobFile(data=old_file_data,
+                                    filename=filename)
+    dst_obj.file = namedblobfile
+    logger.info("Migrating file %s" % filename)
+
+
+FIELDS_MAPPING = {'TextField': migrate_textfield,
+                  'FileField': migrate_filefield,
+                  'ImageField': migrate_imagefield}
+
+
 def migrate(portal, migrator):
     """return a CatalogWalker instance in order
     to have its output after migration"""
@@ -532,6 +602,19 @@ class CustomATFolderMigrator(ATCTFolderMigrator):
         src_portal_type = src_type
         dst_portal_type = dst_type
 
+        def migrate_schema_fields(self):
+            for fields_dict in fields_mapping:
+                at_fieldname = fields_dict.get('AT_field_name')
+                at_fieldtype = fields_dict.get('AT_field_type')
+                dx_fieldname = fields_dict.get('DX_field_name')
+                migration_field_method = migrate_simplefield
+                if at_fieldtype in FIELDS_MAPPING:
+                    migration_field_method = FIELDS_MAPPING[at_fieldtype]
+                migration_field_method(self.old,
+                                       self.new,
+                                       at_fieldname,
+                                       dx_fieldname)
+
     return CustomATFolderMigrator
 
 
@@ -543,121 +626,46 @@ class CustomATContentMigrator(ATCTContentMigrator):
         dst_portal_type = dst_type
 
         def migrate_schema_fields(self):
-            # migrate the richtext
-            super(CustomATContentMigrator, self).migrate_schema_fields()
+            for fields_dict in fields_mapping:
+                at_fieldname = fields_dict.get('AT_field_name')
+                at_fieldtype = fields_dict.get('AT_field_type')
+                dx_fieldname = fields_dict.get('DX_field_name')
+                migration_field_method = migrate_simplefield
+                if at_fieldtype in FIELDS_MAPPING:
+                    migration_field_method = FIELDS_MAPPING[at_fieldtype]
+                migration_field_method(self.old,
+                                       self.new,
+                                       at_fieldname,
+                                       dx_fieldname)
 
     return CustomATContentMigrator
 
 
-def migrateCustomAT(context, fields_mapping, src_type, dst_type):
-    #BBB: i can't find a better way to know if a given portal_type is folderish or not
-    is_folderish = False
-    temp_obj = context.restrictedTraverse('portal_factory/%s/tmp_id' % src_type)
-    if temp_obj:
-        plone_view = temp_obj.restrictedTraverse('@@plone')
-        if plone_view.isStructuralFolder():
-            is_folderish = True
-    portal_types = context.portal_types
-    src_infos = portal_types.getTypeInfo(src_type)
-    dst_infos = portal_types.getTypeInfo(dst_type)
-    if is_folderish:
-        migrator = makeCustomFolderMigrator(context,
+def migrateCustomAT(fields_mapping, src_type, dst_type):
+    """
+    try to get types infos from archetype_tool, then set a migrator an pass it given values
+    """
+    portal = getSite()
+    archetype_tool = getToolByName(portal, 'archetype_tool', None)
+    src_type_infos = None
+    if archetype_tool:
+        for info in archetype_tool.listRegisteredTypes():
+            if info.get('portal_type') == src_type:
+                src_type_infos = info
+    if src_type_infos and src_type_infos.get('klass').isPrincipiaFolderish:
+        migrator = makeCustomFolderMigrator(portal,
                                      src_type,
                                      dst_type,
                                      fields_mapping)
     else:
-        migrator = makeCustomContentMigrator(context,
+        migrator = makeCustomContentMigrator(portal,
                                       src_type,
                                       dst_type,
                                       fields_mapping)
     if migrator:
-        migrator.src_meta_type = src_infos.content_meta_type
-        migrator.dst_meta_type = dst_infos.content_meta_type
-        migrate(context, migrator)
-
-
-def migrate_simplefield(src_obj, dst_obj, src_fieldname, dst_fieldname):
-    field = src_obj.getField(src_fieldname)
-    if not field:
-        return
-    val = field.get(src_obj)
-    setattr(dst_obj, dst_fieldname, val)
-
-
-def migrate_imagefield(src_obj, dst_obj, src_fieldname, dst_fieldname):
-    old_image = src_obj.getField(src_fieldname).get(src_obj)
-    if old_image == '':
-        return
-    filename = safe_unicode(old_image.filename)
-    old_image_data = old_image.data
-    if safe_hasattr(old_image_data, 'data'):
-        old_image_data = old_image_data.data
-    namedblobimage = NamedBlobImage(data=old_image_data,
-                                    filename=filename)
-    dst_obj.image = namedblobimage
-    caption_field = src_obj.getField('imageCaption', None)
-    if caption_field:
-        dst_obj.image_caption = safe_unicode(caption_field.get(src_obj))
-    logger.info("Migrating image %s" % filename)
-
-
-def migrate_filefield(src_obj, dst_obj, src_fieldname, dst_fieldname):
-    """
-    BBB to be tested
-    """
-    old_file = src_obj.getField(src_fieldname).get(src_obj)
-    if old_file == '':
-        return
-    filename = safe_unicode(old_file.filename)
-    old_file_data = old_file.data
-    if safe_hasattr(old_file_data, 'data'):
-        old_file_data = old_file_data.data
-    namedblobfile = NamedBlobFile(data=old_file_data,
-                                    filename=filename)
-    dst_obj.file = namedblobfile
-    logger.info("Migrating file %s" % filename)
-
-
-# def migrate_referencefield(src_obj, dst_obj, src_fieldname, dst_fieldname):
-#     # Relations UIDs:
-#     field = src_obj.getField(src_fieldname)
-#     if not field:
-#         return
-#     references = field.get(src_obj)
-#     if not hasattr(src_obj, "_%sOrder" % src_fieldname):
-#         referencesOrder = [item.UID() for item in references]
-#         setattr(src_obj, "_%sOrder" % src_fieldname, PersistentList(referencesOrder))
-
-#     # Backrefs Relations UIDs:
-#     reference_cat = getToolByName(src_obj, REFERENCE_CATALOG)
-#     backrefs = reference_cat.getBackReferences(src_obj,
-#                                                relationship="relatesTo")
-#     backref_objects = map(lambda x: x.getSourceObject(), backrefs)
-#     for obj in backref_objects:
-#         if obj.portal_type != dst_obj.src_portal_type:
-#             continue
-#         if not hasattr(obj, "_relUids"):
-#             relatedItems = obj.getRelatedItems()
-#             relatedItemsOrder = [item.UID() for item in relatedItems]
-#             obj._relatedItemsOrder = PersistentList(relatedItemsOrder)
-
-# def migrate_relatedItems(self):
-#     """ Store Archetype relations as target uids on the dexterity object
-#         for later restore. Backrelations are saved as well because all
-#         relation to deleted objects would be lost.
-#     """
-
-#     # Relations:
-#     relItems = self.old.getRelatedItems()
-#     relUids = [item.UID() for item in relItems]
-#     self.new._relatedItems = relUids
-
-#     # Backrefs:
-#     reference_catalog = getToolByName(self.old, REFERENCE_CATALOG)
-
-#     backrefs = [i.sourceUID for i in reference_catalog.getBackReferences(
-#         self.old, relationship="relatesTo")]
-#     self.new._backrefs = backrefs
-
-#     # Order:
-#     self.new._relatedItemsOrder = self.old._relatedItemsOrder
\ No newline at end of file
+        if src_type_infos:
+            migrator.src_meta_type = src_type_infos.get('meta_type')
+        else:
+            migrator.src_meta_type = src_type
+        migrator.dst_meta_type = ''
+        migrate(portal, migrator)
diff --git a/plone/app/contenttypes/tests/test_migration_custom.py b/plone/app/contenttypes/tests/test_migration_custom.py
index 971eea8..08746b1 100644
--- a/plone/app/contenttypes/tests/test_migration_custom.py
+++ b/plone/app/contenttypes/tests/test_migration_custom.py
@@ -1,26 +1,11 @@
 # -*- coding: utf-8 -*-
-from Products.CMFCore.utils import getToolByName
-from five.intid.intid import IntIds
-from five.intid.site import addUtility
 from plone.app.contenttypes.testing import \
     PLONE_APP_CONTENTTYPES_MIGRATION_TESTING
-from plone.app.contenttypes.testing import set_browserlayer
 from plone.app.testing import applyProfile
-from plone.app.testing import login
-from plone.event.interfaces import IEventAccessor
-from zope.annotation.interfaces import IAnnotations
-from zope.component import getMultiAdapter
-from zope.component import getSiteManager
-from zope.component import getUtility
-from zope.intid.interfaces import IIntIds
-from zope.schema.interfaces import IVocabularyFactory
 import os.path
-import time
 import unittest2 as unittest
 from plone.app.testing import TEST_USER_ID, setRoles
-from test_image import dummy_image
 from plone.app.contenttypes.migration.migration import migrate_imagefield, migrate_simplefield
-from plone.app.testing import applyProfile
 
 
 class MigrateFieldsTest(unittest.TestCase):
@@ -65,6 +50,23 @@ def test_migrate_stringfield(self):
         migrate_simplefield(at_document, dx_document, 'title', 'title')
         self.assertEqual(dx_document.Title(), at_document.Title())
 
+    def test_migrate_richtextfield(self):
+        # create content
+        at_document_id = self.portal.invokeFactory('Document',
+                                                   'foo',
+                                                   title="Foo document",
+                                                   text="Some foo html text")
+        # register p.a.contenttypes profile
+        applyProfile(self.portal, 'plone.app.contenttypes:default')
+        dx_document_id = self.portal.invokeFactory('Document',
+                                                   'bar',
+                                                   title="Bar document")
+        at_document = self.portal[at_document_id]
+        dx_document = self.portal[dx_document_id]
+        self.assertEqual(dx_document.text, None)
+        migrate_simplefield(at_document, dx_document, 'text', 'text')
+        self.assertEqual(dx_document.text, at_document.getText())
+
     def test_migrate_listfield(self):
         # create content
         at_document_id = self.portal.invokeFactory('Document',
@@ -114,3 +116,71 @@ def tearDown(self):
             applyProfile(self.portal, 'plone.app.contenttypes:uninstall')
         except KeyError:
             pass
+
+    def createCustomATDocument(self, id, parent=None):
+        from Products.Archetypes.atapi import StringField, TextField
+        from Products.ATContentTypes.interface import IATDocument
+        from archetypes.schemaextender.interfaces import ISchemaExtender
+        from archetypes.schemaextender.field import ExtensionField
+        from zope.component import getGlobalSiteManager
+        from zope.interface import implements
+
+        # create schema extension
+        class ExtensionTextField(ExtensionField, TextField):
+            """ derivative of text for extending schemas """
+
+        class ExtensionStringField(ExtensionField, StringField):
+            """ derivative of text for extending schemas """
+
+        class SchemaExtender(object):
+            implements(ISchemaExtender)
+            fields = [
+                ExtensionTextField('textExtended',
+                                   ),
+                ExtensionStringField('stringExtended',
+                                     ),
+            ]
+
+            def __init__(self, context):
+                self.context = context
+
+            def getFields(self):
+                return self.fields
+
+        # register adapter
+        gsm = getGlobalSiteManager()
+        gsm.registerAdapter(SchemaExtender, (IATDocument,), ISchemaExtender)
+
+        # create content
+        container = parent or self.portal
+        container.invokeFactory('Document', id,
+                                title="Foo document",
+                                stringExtended="foo text",
+                                textExtended='foo extended rich text')
+        at_document = container[id]
+
+        # unregister adapter assure test isolation
+        gsm.unregisterAdapter(required=[IATDocument], provided=ISchemaExtender)
+
+        return at_document
+
+    def test_migrate_extended_document(self):
+        from plone.app.contenttypes.migration.migration import\
+            migrateCustomAT
+        from plone.app.contenttypes.interfaces import INewsItem
+        at_document = self.createCustomATDocument('foo-document')
+        applyProfile(self.portal, 'plone.app.contenttypes:default')
+        fields_mapping = ({'AT_field_name': 'textExtended',
+                           'AT_field_type': 'TextField',
+                           'DX_field_name': 'text',
+                           'DX_field_type': 'TextField', },
+                           {'AT_field_name': 'stringExtended',
+                           'AT_field_type': 'StringField',
+                           'DX_field_name': 'title',
+                           'DX_field_type': 'StringField', },)
+        migrateCustomAT(fields_mapping, src_type='Document', dst_type='News Item')
+        dx_newsitem = self.portal['foo-document']
+        self.assertTrue(INewsItem.providedBy(dx_newsitem))
+        self.assertTrue(dx_newsitem is not at_document)
+        self.assertEquals(at_document.textExtended(), dx_newsitem.text.raw)
+        self.assertEquals(at_document.stringExtended, dx_newsitem.title)


Repository: plone.app.contenttypes
Branch: refs/heads/master
Date: 2014-04-25T17:19:05+02:00
Author: Gauthier Bastien (gbastien) <g.bastien@imio.be>
Commit: https://github.com/plone/plone.app.contenttypes/commit/9c095108826e34cd06934e33e3d1c04d839ef345

Build dict passed to migrateCustomAT

Files changed:
M plone/app/contenttypes/migration/custom_migration.pt
M plone/app/contenttypes/migration/custom_migration.py

diff --git a/plone/app/contenttypes/migration/custom_migration.pt b/plone/app/contenttypes/migration/custom_migration.pt
index 74678fd..36b6db0 100644
--- a/plone/app/contenttypes/migration/custom_migration.pt
+++ b/plone/app/contenttypes/migration/custom_migration.pt
@@ -68,7 +68,11 @@
                 <tr tal:repeat="at_type at_types">
                     <td valign="top">
                         <p tal:content="at_type/title" style="font-weight: bold;">AT content type title</p>
-                        <p tal:repeat="field python: view.getFieldsForATType(at_type['id'])" tal:content="field/title">Field name</p>
+                        <tal:block repeat="field python: view.getFieldsForATType(at_type['id'])">
+                            <p tal:content="field/title">Field name</p>
+                            <input type="hidden" tal:attributes="name string:${at_type/id}:list;
+                                                                 value string:${field/id};" />
+                        </tal:block>
                     </td>
                     <td valign="top">
                         <select tal:attributes="onChange string:javascript:getDXFields(at_typename='${at_type/id}', this.value);
@@ -90,7 +94,7 @@
             </table>
             <div>
               <br />
-              <input type="submit" name="form.button.Apply" class="context" value="Apply" i18n:attributes="value" i18n:domain="plone"/>&nbsp;
+              <input type="submit" name="form.button.Migrate" class="context" value="Migrate" i18n:attributes="value" i18n:domain="plone"/>&nbsp;
               <input type="submit" name="form.button.Cancel" class="standalone" value="Cancel" i18n:attributes="value" i18n:domain="plone"/>
             </div>
             </form>
diff --git a/plone/app/contenttypes/migration/custom_migration.py b/plone/app/contenttypes/migration/custom_migration.py
index ea28b2a..5977c32 100644
--- a/plone/app/contenttypes/migration/custom_migration.py
+++ b/plone/app/contenttypes/migration/custom_migration.py
@@ -1,4 +1,5 @@
 # -*- coding: UTF-8 -*-
+from zope.i18n import translate
 from Products.Five.browser import BrowserView
 from plone.dexterity.interfaces import IDexterityFTI
 from plone.dexterity.utils import iterSchemataForType
@@ -30,11 +31,12 @@ def __call__(self):
         # check that we can actually access this form, aka the current user has an advice to add or edit
         form = self.request.form
         cancelled = form.get('form.button.Cancel', False)
-        submitted = form.get('form.button.Apply', False)
+        submitted = form.get('form.button.Migrate', False)
         if submitted:
             # proceed, call the migration methdd
-            self.apply()
-            msg = self.context.utranslate('Migration applied.', domain='plone.app.contenttypes')
+            self.migrate()
+            msg = translate('Migration applied.',
+                            domain='plone.app.contenttypes')
             self.context.plone_utils.addPortalMessage(msg)
         elif cancelled:
             self.request.response.redirect(form.get('form.HTTP_REFERER'))
@@ -93,7 +95,8 @@ def getFieldsForATType(self, typename):
         for field in schema.fields():
             if not field.getName() in self.at_metadata_fields:
                 results.append({'id': field.getName(),
-                                'title': '%s (%s)' % (field.widget.label, field.widget.getName())})
+                                'title': '%s (%s)' % (field.widget.label, field.widget.getName()),
+                                'type': field.widget.getName()})
         return results
 
     def getFieldsForDXType(self, typename):
@@ -110,7 +113,8 @@ def getFieldsForDXType(self, typename):
                 if fieldName in self.dx_metadata_fields:
                     continue
                 results.append({'id': fieldName,
-                                'title': '%s (%s)' % (field.title, field.__class__.__name__)})
+                                'title': '%s (%s)' % (field.title, field.__class__.__name__),
+                                'type': field.__class__.__name__})
         return results
 
     def getPossibleTargetField(self, fieldtype):
@@ -119,20 +123,37 @@ def getPossibleTargetField(self, fieldtype):
     def isFolderish(self):
         ''' decide which base-class we use for the migrator'''
 
-    def apply(self):
-        '''
-        '''
-        # dictionnary structure is like :
-        # ({'AT_field_name': 'text',
-        #   'AT_field_type': 'RichText',
-        #   'DX_field_name': 'text',
-        #   'DX_field_type': 'TextLine', }), },
-        # }
-        data = ({'AT_field_name': 'text',
-                 'AT_field_type': 'RichText',
-                 'DX_field_name': 'text',
-                 'DX_field_type': 'TextLine', }, )
-        migrateCustomAT(self.context, fields_mapping=data, src_type='DocumentAT', dst_type='Document')
+    def migrate(self):
+        '''Build data from self.request.form, we will build something like :
+           {'MyATPortalType': {'MyDXPortalType': {'at_fielname1': 'dx_fieldname1', 'at_fieldname2': 'dx_fieldname2'}}}
+           Call the migrateCustomAT migrator for each AT content_type we choose to migrate.'''
+        data = {}
+        form = self.request.form
+        for k in self.request.form.keys():
+            if k.startswith('dx_select_'):
+                # we found select where we choose a DX type regarding an AT type
+                # the selelect name is like 'dx_select_MyATPortalType'
+                if not form[k]:
+                    # nothing selected in this select, continue
+                    continue
+                at_typename = k[10:]
+                dx_typename = form[k]
+                data[at_typename] = {dx_typename: {}}
+                # now handle fields mapping for found DX/AT type migration definition
+                # we have 2 keys we relevant mappings, first key is the AT typename
+                # second key is a particular key like 'dx_DXPortalType__for__MyATPortalType
+                dx_key = 'dx_%s__for__%s' % (dx_typename, at_typename)
+                for at_fieldname in form[at_typename]:
+                    data[at_typename][dx_typename][at_fieldname] = form[dx_key][form[at_typename].index(at_fieldname)]
+        for at_typename, dx_mappings in data.items():
+            for k, v in dx_mappings.items():
+                migrateCustomAT(self.context, fields_mapping=v, src_type=at_typename, dst_type=dx_typename)
+
+        #data = ({'AT_field_name': 'text',
+        #         'AT_field_type': 'RichText',
+        #         'DX_field_name': 'text',
+        #         'DX_field_type': 'TextLine', }, )
+        #migrateCustomAT(self.context, fields_mapping=data, src_type='DocumentAT', dst_type='Document')
 
 
 class DisplayDXFields(CustomMigrationForm):


Repository: plone.app.contenttypes
Branch: refs/heads/master
Date: 2014-04-25T17:23:38+02:00
Author: Gauthier Bastien (gbastien) <g.bastien@imio.be>
Commit: https://github.com/plone/plone.app.contenttypes/commit/a8b6cf6ad90f06deb7ce5696fbbf03df8f0ab44a

Merge branch 'issue133_custom_types_migration' of git://github.com/plone/plone.app.contenttypes into issue133_custom_types_migration

Files changed:
M plone/app/contenttypes/migration/migration.py
M plone/app/contenttypes/tests/test_migration_custom.py

diff --git a/plone/app/contenttypes/migration/migration.py b/plone/app/contenttypes/migration/migration.py
index 3e49baa..5a6b394 100644
--- a/plone/app/contenttypes/migration/migration.py
+++ b/plone/app/contenttypes/migration/migration.py
@@ -7,37 +7,107 @@
 module will only work if Products.contentmigration is installed so make sure
 you catch ImportErrors
 '''
-from Products.ATContentTypes.interfaces.interfaces import IATContentType
-from Products.Archetypes.config import REFERENCE_CATALOG
-from Products.CMFCore.utils import getToolByName
-from Products.CMFPlone.utils import safe_unicode, safe_hasattr
-from Products.contentmigration.basemigrator.migrator import CMFFolderMigrator
-from Products.contentmigration.basemigrator.migrator import CMFItemMigrator
-from Products.contentmigration.basemigrator.walker import CatalogWalker
 from persistent.list import PersistentList
 from plone.app.contenttypes.behaviors.collection import ICollection
+from plone.app.contenttypes.migration import datetime_fixer
 from plone.app.contenttypes.migration.dxmigration import DXEventMigrator
 from plone.app.contenttypes.migration.dxmigration import DXOldEventMigrator
-from plone.app.contenttypes.migration import datetime_fixer
 from plone.app.textfield.value import RichTextValue
 from plone.app.uuid.utils import uuidToObject
 from plone.dexterity.interfaces import IDexterityContent
 from plone.event.utils import default_timezone
 from plone.namedfile.file import NamedBlobFile
 from plone.namedfile.file import NamedBlobImage
+from Products.Archetypes.config import REFERENCE_CATALOG
+from Products.ATContentTypes.interfaces.interfaces import IATContentType
+from Products.CMFCore.utils import getToolByName
+from Products.CMFPlone.utils import safe_unicode, safe_hasattr
+from Products.contentmigration.basemigrator.migrator import CMFFolderMigrator
+from Products.contentmigration.basemigrator.migrator import CMFItemMigrator
+from Products.contentmigration.basemigrator.walker import CatalogWalker
 from z3c.relationfield import RelationValue
 from zope.component import adapter
 from zope.component import getAdapters
 from zope.component import getUtility
-from zope.interface import Interface
+from zope.component.hooks import getSite
 from zope.interface import implementer
+from zope.interface import Interface
 from zope.intid.interfaces import IIntIds
 
-
 import logging
 logger = logging.getLogger(__name__)
 
 
+def migrate_simplefield(src_obj, dst_obj, src_fieldname, dst_fieldname):
+    field = src_obj.getField(src_fieldname)
+    if field:
+        at_value = field.get(src_obj)
+    else:
+        at_value = getattr(src_obj, src_fieldname, None)
+        if at_value and hasattr(at_value, '__call__'):
+            at_value = at_value()
+    if at_value:
+        setattr(dst_obj, dst_fieldname, at_value)
+
+
+def migrate_textfield(src_obj, dst_obj, src_fieldname, dst_fieldname):
+    field = src_obj.getField(src_fieldname)
+    raw_text = ''
+    if field:
+        mime_type = field.getContentType(src_obj)
+        raw_text = safe_unicode(field.getRaw(src_obj))
+    else:
+        at_value = getattr(src_obj, src_fieldname, None)
+        if at_value:
+            mime_type = at_value.mimetype
+            raw_text = safe_unicode(at_value.raw)
+
+    if raw_text.strip() == '':
+            return
+    richtext = RichTextValue(raw=raw_text, mimeType=mime_type,
+                             outputMimeType='text/x-html-safe')
+    setattr(dst_obj, dst_fieldname, richtext)
+
+
+def migrate_imagefield(src_obj, dst_obj, src_fieldname, dst_fieldname):
+    old_image = src_obj.getField(src_fieldname).get(src_obj)
+    if old_image == '':
+        return
+    filename = safe_unicode(old_image.filename)
+    old_image_data = old_image.data
+    if safe_hasattr(old_image_data, 'data'):
+        old_image_data = old_image_data.data
+    namedblobimage = NamedBlobImage(data=old_image_data,
+                                    filename=filename)
+    dst_obj.image = namedblobimage
+    caption_field = src_obj.getField('imageCaption', None)
+    if caption_field:
+        dst_obj.image_caption = safe_unicode(caption_field.get(src_obj))
+    logger.info("Migrating image %s" % filename)
+
+
+def migrate_filefield(src_obj, dst_obj, src_fieldname, dst_fieldname):
+    """
+    BBB to be tested
+    """
+    old_file = src_obj.getField(src_fieldname).get(src_obj)
+    if old_file == '':
+        return
+    filename = safe_unicode(old_file.filename)
+    old_file_data = old_file.data
+    if safe_hasattr(old_file_data, 'data'):
+        old_file_data = old_file_data.data
+    namedblobfile = NamedBlobFile(data=old_file_data,
+                                    filename=filename)
+    dst_obj.file = namedblobfile
+    logger.info("Migrating file %s" % filename)
+
+
+FIELDS_MAPPING = {'TextField': migrate_textfield,
+                  'FileField': migrate_filefield,
+                  'ImageField': migrate_imagefield}
+
+
 def migrate(portal, migrator):
     """return a CatalogWalker instance in order
     to have its output after migration"""
@@ -532,6 +602,19 @@ class CustomATFolderMigrator(ATCTFolderMigrator):
         src_portal_type = src_type
         dst_portal_type = dst_type
 
+        def migrate_schema_fields(self):
+            for fields_dict in fields_mapping:
+                at_fieldname = fields_dict.get('AT_field_name')
+                at_fieldtype = fields_dict.get('AT_field_type')
+                dx_fieldname = fields_dict.get('DX_field_name')
+                migration_field_method = migrate_simplefield
+                if at_fieldtype in FIELDS_MAPPING:
+                    migration_field_method = FIELDS_MAPPING[at_fieldtype]
+                migration_field_method(self.old,
+                                       self.new,
+                                       at_fieldname,
+                                       dx_fieldname)
+
     return CustomATFolderMigrator
 
 
@@ -543,121 +626,46 @@ class CustomATContentMigrator(ATCTContentMigrator):
         dst_portal_type = dst_type
 
         def migrate_schema_fields(self):
-            # migrate the richtext
-            super(CustomATContentMigrator, self).migrate_schema_fields()
+            for fields_dict in fields_mapping:
+                at_fieldname = fields_dict.get('AT_field_name')
+                at_fieldtype = fields_dict.get('AT_field_type')
+                dx_fieldname = fields_dict.get('DX_field_name')
+                migration_field_method = migrate_simplefield
+                if at_fieldtype in FIELDS_MAPPING:
+                    migration_field_method = FIELDS_MAPPING[at_fieldtype]
+                migration_field_method(self.old,
+                                       self.new,
+                                       at_fieldname,
+                                       dx_fieldname)
 
     return CustomATContentMigrator
 
 
-def migrateCustomAT(context, fields_mapping, src_type, dst_type):
-    #BBB: i can't find a better way to know if a given portal_type is folderish or not
-    is_folderish = False
-    temp_obj = context.restrictedTraverse('portal_factory/%s/tmp_id' % src_type)
-    if temp_obj:
-        plone_view = temp_obj.restrictedTraverse('@@plone')
-        if plone_view.isStructuralFolder():
-            is_folderish = True
-    portal_types = context.portal_types
-    src_infos = portal_types.getTypeInfo(src_type)
-    dst_infos = portal_types.getTypeInfo(dst_type)
-    if is_folderish:
-        migrator = makeCustomFolderMigrator(context,
+def migrateCustomAT(fields_mapping, src_type, dst_type):
+    """
+    try to get types infos from archetype_tool, then set a migrator an pass it given values
+    """
+    portal = getSite()
+    archetype_tool = getToolByName(portal, 'archetype_tool', None)
+    src_type_infos = None
+    if archetype_tool:
+        for info in archetype_tool.listRegisteredTypes():
+            if info.get('portal_type') == src_type:
+                src_type_infos = info
+    if src_type_infos and src_type_infos.get('klass').isPrincipiaFolderish:
+        migrator = makeCustomFolderMigrator(portal,
                                      src_type,
                                      dst_type,
                                      fields_mapping)
     else:
-        migrator = makeCustomContentMigrator(context,
+        migrator = makeCustomContentMigrator(portal,
                                       src_type,
                                       dst_type,
                                       fields_mapping)
     if migrator:
-        migrator.src_meta_type = src_infos.content_meta_type
-        migrator.dst_meta_type = dst_infos.content_meta_type
-        migrate(context, migrator)
-
-
-def migrate_simplefield(src_obj, dst_obj, src_fieldname, dst_fieldname):
-    field = src_obj.getField(src_fieldname)
-    if not field:
-        return
-    val = field.get(src_obj)
-    setattr(dst_obj, dst_fieldname, val)
-
-
-def migrate_imagefield(src_obj, dst_obj, src_fieldname, dst_fieldname):
-    old_image = src_obj.getField(src_fieldname).get(src_obj)
-    if old_image == '':
-        return
-    filename = safe_unicode(old_image.filename)
-    old_image_data = old_image.data
-    if safe_hasattr(old_image_data, 'data'):
-        old_image_data = old_image_data.data
-    namedblobimage = NamedBlobImage(data=old_image_data,
-                                    filename=filename)
-    dst_obj.image = namedblobimage
-    caption_field = src_obj.getField('imageCaption', None)
-    if caption_field:
-        dst_obj.image_caption = safe_unicode(caption_field.get(src_obj))
-    logger.info("Migrating image %s" % filename)
-
-
-def migrate_filefield(src_obj, dst_obj, src_fieldname, dst_fieldname):
-    """
-    BBB to be tested
-    """
-    old_file = src_obj.getField(src_fieldname).get(src_obj)
-    if old_file == '':
-        return
-    filename = safe_unicode(old_file.filename)
-    old_file_data = old_file.data
-    if safe_hasattr(old_file_data, 'data'):
-        old_file_data = old_file_data.data
-    namedblobfile = NamedBlobFile(data=old_file_data,
-                                    filename=filename)
-    dst_obj.file = namedblobfile
-    logger.info("Migrating file %s" % filename)
-
-
-# def migrate_referencefield(src_obj, dst_obj, src_fieldname, dst_fieldname):
-#     # Relations UIDs:
-#     field = src_obj.getField(src_fieldname)
-#     if not field:
-#         return
-#     references = field.get(src_obj)
-#     if not hasattr(src_obj, "_%sOrder" % src_fieldname):
-#         referencesOrder = [item.UID() for item in references]
-#         setattr(src_obj, "_%sOrder" % src_fieldname, PersistentList(referencesOrder))
-
-#     # Backrefs Relations UIDs:
-#     reference_cat = getToolByName(src_obj, REFERENCE_CATALOG)
-#     backrefs = reference_cat.getBackReferences(src_obj,
-#                                                relationship="relatesTo")
-#     backref_objects = map(lambda x: x.getSourceObject(), backrefs)
-#     for obj in backref_objects:
-#         if obj.portal_type != dst_obj.src_portal_type:
-#             continue
-#         if not hasattr(obj, "_relUids"):
-#             relatedItems = obj.getRelatedItems()
-#             relatedItemsOrder = [item.UID() for item in relatedItems]
-#             obj._relatedItemsOrder = PersistentList(relatedItemsOrder)
-
-# def migrate_relatedItems(self):
-#     """ Store Archetype relations as target uids on the dexterity object
-#         for later restore. Backrelations are saved as well because all
-#         relation to deleted objects would be lost.
-#     """
-
-#     # Relations:
-#     relItems = self.old.getRelatedItems()
-#     relUids = [item.UID() for item in relItems]
-#     self.new._relatedItems = relUids
-
-#     # Backrefs:
-#     reference_catalog = getToolByName(self.old, REFERENCE_CATALOG)
-
-#     backrefs = [i.sourceUID for i in reference_catalog.getBackReferences(
-#         self.old, relationship="relatesTo")]
-#     self.new._backrefs = backrefs
-
-#     # Order:
-#     self.new._relatedItemsOrder = self.old._relatedItemsOrder
\ No newline at end of file
+        if src_type_infos:
+            migrator.src_meta_type = src_type_infos.get('meta_type')
+        else:
+            migrator.src_meta_type = src_type
+        migrator.dst_meta_type = ''
+        migrate(portal, migrator)
diff --git a/plone/app/contenttypes/tests/test_migration_custom.py b/plone/app/contenttypes/tests/test_migration_custom.py
index 971eea8..08746b1 100644
--- a/plone/app/contenttypes/tests/test_migration_custom.py
+++ b/plone/app/contenttypes/tests/test_migration_custom.py
@@ -1,26 +1,11 @@
 # -*- coding: utf-8 -*-
-from Products.CMFCore.utils import getToolByName
-from five.intid.intid import IntIds
-from five.intid.site import addUtility
 from plone.app.contenttypes.testing import \
     PLONE_APP_CONTENTTYPES_MIGRATION_TESTING
-from plone.app.contenttypes.testing import set_browserlayer
 from plone.app.testing import applyProfile
-from plone.app.testing import login
-from plone.event.interfaces import IEventAccessor
-from zope.annotation.interfaces import IAnnotations
-from zope.component import getMultiAdapter
-from zope.component import getSiteManager
-from zope.component import getUtility
-from zope.intid.interfaces import IIntIds
-from zope.schema.interfaces import IVocabularyFactory
 import os.path
-import time
 import unittest2 as unittest
 from plone.app.testing import TEST_USER_ID, setRoles
-from test_image import dummy_image
 from plone.app.contenttypes.migration.migration import migrate_imagefield, migrate_simplefield
-from plone.app.testing import applyProfile
 
 
 class MigrateFieldsTest(unittest.TestCase):
@@ -65,6 +50,23 @@ def test_migrate_stringfield(self):
         migrate_simplefield(at_document, dx_document, 'title', 'title')
         self.assertEqual(dx_document.Title(), at_document.Title())
 
+    def test_migrate_richtextfield(self):
+        # create content
+        at_document_id = self.portal.invokeFactory('Document',
+                                                   'foo',
+                                                   title="Foo document",
+                                                   text="Some foo html text")
+        # register p.a.contenttypes profile
+        applyProfile(self.portal, 'plone.app.contenttypes:default')
+        dx_document_id = self.portal.invokeFactory('Document',
+                                                   'bar',
+                                                   title="Bar document")
+        at_document = self.portal[at_document_id]
+        dx_document = self.portal[dx_document_id]
+        self.assertEqual(dx_document.text, None)
+        migrate_simplefield(at_document, dx_document, 'text', 'text')
+        self.assertEqual(dx_document.text, at_document.getText())
+
     def test_migrate_listfield(self):
         # create content
         at_document_id = self.portal.invokeFactory('Document',
@@ -114,3 +116,71 @@ def tearDown(self):
             applyProfile(self.portal, 'plone.app.contenttypes:uninstall')
         except KeyError:
             pass
+
+    def createCustomATDocument(self, id, parent=None):
+        from Products.Archetypes.atapi import StringField, TextField
+        from Products.ATContentTypes.interface import IATDocument
+        from archetypes.schemaextender.interfaces import ISchemaExtender
+        from archetypes.schemaextender.field import ExtensionField
+        from zope.component import getGlobalSiteManager
+        from zope.interface import implements
+
+        # create schema extension
+        class ExtensionTextField(ExtensionField, TextField):
+            """ derivative of text for extending schemas """
+
+        class ExtensionStringField(ExtensionField, StringField):
+            """ derivative of text for extending schemas """
+
+        class SchemaExtender(object):
+            implements(ISchemaExtender)
+            fields = [
+                ExtensionTextField('textExtended',
+                                   ),
+                ExtensionStringField('stringExtended',
+                                     ),
+            ]
+
+            def __init__(self, context):
+                self.context = context
+
+            def getFields(self):
+                return self.fields
+
+        # register adapter
+        gsm = getGlobalSiteManager()
+        gsm.registerAdapter(SchemaExtender, (IATDocument,), ISchemaExtender)
+
+        # create content
+        container = parent or self.portal
+        container.invokeFactory('Document', id,
+                                title="Foo document",
+                                stringExtended="foo text",
+                                textExtended='foo extended rich text')
+        at_document = container[id]
+
+        # unregister adapter assure test isolation
+        gsm.unregisterAdapter(required=[IATDocument], provided=ISchemaExtender)
+
+        return at_document
+
+    def test_migrate_extended_document(self):
+        from plone.app.contenttypes.migration.migration import\
+            migrateCustomAT
+        from plone.app.contenttypes.interfaces import INewsItem
+        at_document = self.createCustomATDocument('foo-document')
+        applyProfile(self.portal, 'plone.app.contenttypes:default')
+        fields_mapping = ({'AT_field_name': 'textExtended',
+                           'AT_field_type': 'TextField',
+                           'DX_field_name': 'text',
+                           'DX_field_type': 'TextField', },
+                           {'AT_field_name': 'stringExtended',
+                           'AT_field_type': 'StringField',
+                           'DX_field_name': 'title',
+                           'DX_field_type': 'StringField', },)
+        migrateCustomAT(fields_mapping, src_type='Document', dst_type='News Item')
+        dx_newsitem = self.portal['foo-document']
+        self.assertTrue(INewsItem.providedBy(dx_newsitem))
+        self.assertTrue(dx_newsitem is not at_document)
+        self.assertEquals(at_document.textExtended(), dx_newsitem.text.raw)
+        self.assertEquals(at_document.stringExtended, dx_newsitem.title)


Repository: plone.app.contenttypes
Branch: refs/heads/master
Date: 2014-04-25T18:00:43+02:00
Author: Andrea Cecchi (cekk) <andrea.cecchi85@gmail.com>
Commit: https://github.com/plone/plone.app.contenttypes/commit/7f615521b30f269dd24b30046c6f1dd3a2b265c5

fixed migrator

Files changed:
M plone/app/contenttypes/migration/migration.py
M plone/app/contenttypes/tests/test_migration_custom.py

diff --git a/plone/app/contenttypes/migration/migration.py b/plone/app/contenttypes/migration/migration.py
index 5a6b394..18d2de9 100644
--- a/plone/app/contenttypes/migration/migration.py
+++ b/plone/app/contenttypes/migration/migration.py
@@ -38,7 +38,7 @@
 logger = logging.getLogger(__name__)
 
 
-def migrate_simplefield(src_obj, dst_obj, src_fieldname, dst_fieldname):
+def migrate_simplefield(src_obj, dst_obj, src_fieldname, dst_fieldname, dst_fieldtype):
     field = src_obj.getField(src_fieldname)
     if field:
         at_value = field.get(src_obj)
@@ -50,7 +50,7 @@ def migrate_simplefield(src_obj, dst_obj, src_fieldname, dst_fieldname):
         setattr(dst_obj, dst_fieldname, at_value)
 
 
-def migrate_textfield(src_obj, dst_obj, src_fieldname, dst_fieldname):
+def migrate_textfield(src_obj, dst_obj, src_fieldname, dst_fieldname, dst_fieldtype):
     field = src_obj.getField(src_fieldname)
     raw_text = ''
     if field:
@@ -69,7 +69,7 @@ def migrate_textfield(src_obj, dst_obj, src_fieldname, dst_fieldname):
     setattr(dst_obj, dst_fieldname, richtext)
 
 
-def migrate_imagefield(src_obj, dst_obj, src_fieldname, dst_fieldname):
+def migrate_imagefield(src_obj, dst_obj, src_fieldname, dst_fieldname, dst_fieldtype):
     old_image = src_obj.getField(src_fieldname).get(src_obj)
     if old_image == '':
         return
@@ -86,7 +86,7 @@ def migrate_imagefield(src_obj, dst_obj, src_fieldname, dst_fieldname):
     logger.info("Migrating image %s" % filename)
 
 
-def migrate_filefield(src_obj, dst_obj, src_fieldname, dst_fieldname):
+def migrate_filefield(src_obj, dst_obj, src_fieldname, dst_fieldname, dst_fieldtype):
     """
     BBB to be tested
     """
@@ -595,33 +595,15 @@ def migrate_events(portal):
     migrate(portal, DXEventMigrator)
 
 
-def makeCustomFolderMigrator(context, src_type, dst_type, fields_mapping):
+def makeCustomATMigrator(context, src_type, dst_type, fields_mapping, is_folderish=False):
     """ generate a migrator for the given at-based folderish portal type """
 
-    class CustomATFolderMigrator(ATCTFolderMigrator):
-        src_portal_type = src_type
-        dst_portal_type = dst_type
-
-        def migrate_schema_fields(self):
-            for fields_dict in fields_mapping:
-                at_fieldname = fields_dict.get('AT_field_name')
-                at_fieldtype = fields_dict.get('AT_field_type')
-                dx_fieldname = fields_dict.get('DX_field_name')
-                migration_field_method = migrate_simplefield
-                if at_fieldtype in FIELDS_MAPPING:
-                    migration_field_method = FIELDS_MAPPING[at_fieldtype]
-                migration_field_method(self.old,
-                                       self.new,
-                                       at_fieldname,
-                                       dx_fieldname)
-
-    return CustomATFolderMigrator
+    base_class = ATCTContentMigrator
+    if is_folderish:
+        base_class = ATCTFolderMigrator
 
+    class CustomATMigrator(base_class):
 
-def makeCustomContentMigrator(context, src_type, dst_type, fields_mapping):
-    """ generate a migrator for the given at-based portal type """
-
-    class CustomATContentMigrator(ATCTContentMigrator):
         src_portal_type = src_type
         dst_portal_type = dst_type
 
@@ -630,15 +612,17 @@ def migrate_schema_fields(self):
                 at_fieldname = fields_dict.get('AT_field_name')
                 at_fieldtype = fields_dict.get('AT_field_type')
                 dx_fieldname = fields_dict.get('DX_field_name')
+                dx_fieldtype = fields_dict.get('DX_field_type')
                 migration_field_method = migrate_simplefield
                 if at_fieldtype in FIELDS_MAPPING:
                     migration_field_method = FIELDS_MAPPING[at_fieldtype]
-                migration_field_method(self.old,
-                                       self.new,
-                                       at_fieldname,
-                                       dx_fieldname)
+                migration_field_method(src_obj=self.old,
+                                       dst_obj=self.new,
+                                       src_fieldname=at_fieldname,
+                                       dst_fieldname=dx_fieldname,
+                                       dst_fieldtype=dx_fieldtype)
 
-    return CustomATContentMigrator
+    return CustomATMigrator
 
 
 def migrateCustomAT(fields_mapping, src_type, dst_type):
@@ -648,24 +632,18 @@ def migrateCustomAT(fields_mapping, src_type, dst_type):
     portal = getSite()
     archetype_tool = getToolByName(portal, 'archetype_tool', None)
     src_type_infos = None
-    if archetype_tool:
-        for info in archetype_tool.listRegisteredTypes():
-            if info.get('portal_type') == src_type:
-                src_type_infos = info
-    if src_type_infos and src_type_infos.get('klass').isPrincipiaFolderish:
-        migrator = makeCustomFolderMigrator(portal,
-                                     src_type,
-                                     dst_type,
-                                     fields_mapping)
-    else:
-        migrator = makeCustomContentMigrator(portal,
-                                      src_type,
-                                      dst_type,
-                                      fields_mapping)
+    if not archetype_tool:
+        return
+    for info in archetype_tool.listRegisteredTypes():
+        if info.get('portal_type') == src_type:
+            src_type_infos = info
+    is_folderish = src_type_infos.get('klass').isPrincipiaFolderish
+    migrator = makeCustomATMigrator(context=portal,
+                                 src_type=src_type,
+                                 dst_type=dst_type,
+                                 fields_mapping=fields_mapping,
+                                 is_folderish=is_folderish)
     if migrator:
-        if src_type_infos:
-            migrator.src_meta_type = src_type_infos.get('meta_type')
-        else:
-            migrator.src_meta_type = src_type
+        migrator.src_meta_type = src_type_infos.get('meta_type')
         migrator.dst_meta_type = ''
         migrate(portal, migrator)
diff --git a/plone/app/contenttypes/tests/test_migration_custom.py b/plone/app/contenttypes/tests/test_migration_custom.py
index 08746b1..4f26f79 100644
--- a/plone/app/contenttypes/tests/test_migration_custom.py
+++ b/plone/app/contenttypes/tests/test_migration_custom.py
@@ -47,7 +47,7 @@ def test_migrate_stringfield(self):
                                                    title="Bar document")
         at_document = self.portal[at_document_id]
         dx_document = self.portal[dx_document_id]
-        migrate_simplefield(at_document, dx_document, 'title', 'title')
+        migrate_simplefield(at_document, dx_document, 'title', 'title', '')
         self.assertEqual(dx_document.Title(), at_document.Title())
 
     def test_migrate_richtextfield(self):
@@ -64,7 +64,7 @@ def test_migrate_richtextfield(self):
         at_document = self.portal[at_document_id]
         dx_document = self.portal[dx_document_id]
         self.assertEqual(dx_document.text, None)
-        migrate_simplefield(at_document, dx_document, 'text', 'text')
+        migrate_simplefield(at_document, dx_document, 'text', 'text', '')
         self.assertEqual(dx_document.text, at_document.getText())
 
     def test_migrate_listfield(self):
@@ -80,7 +80,7 @@ def test_migrate_listfield(self):
                                                    title="Bar document")
         at_document = self.portal[at_document_id]
         dx_document = self.portal[dx_document_id]
-        migrate_simplefield(at_document, dx_document, 'subject', 'subject')
+        migrate_simplefield(at_document, dx_document, 'subject', 'subject', '')
         self.assertEqual(dx_document.Subject(), at_document.Subject())
 
     def test_migrate_imagefield(self):
@@ -97,7 +97,7 @@ def test_migrate_imagefield(self):
         at_newsitem = self.portal[at_newsitem_id]
         dx_newsitem = self.portal[dx_newsitem_id]
         self.assertEqual(dx_newsitem.image, None)
-        migrate_imagefield(at_newsitem, dx_newsitem, 'image', 'image')
+        migrate_imagefield(at_newsitem, dx_newsitem, 'image', 'image', '')
         self.assertEqual(dx_newsitem.image.contentType, 'image/png')
         self.assertEqual(dx_newsitem.image.data, test_image_data)
 


Repository: plone.app.contenttypes
Branch: refs/heads/master
Date: 2014-04-25T18:11:15+02:00
Author: Andrea Cecchi (cekk) <andrea.cecchi85@gmail.com>
Commit: https://github.com/plone/plone.app.contenttypes/commit/1392ff6c20f142d55ebf5cdf1dad310dd13dd10b

Merge branch 'issue133_custom_types_migration' of https://github.com/plone/plone.app.contenttypes into issue133_custom_types_migration

Files changed:
M plone/app/contenttypes/migration/custom_migration.pt
M plone/app/contenttypes/migration/custom_migration.py

diff --git a/plone/app/contenttypes/migration/custom_migration.pt b/plone/app/contenttypes/migration/custom_migration.pt
index 74678fd..36b6db0 100644
--- a/plone/app/contenttypes/migration/custom_migration.pt
+++ b/plone/app/contenttypes/migration/custom_migration.pt
@@ -68,7 +68,11 @@
                 <tr tal:repeat="at_type at_types">
                     <td valign="top">
                         <p tal:content="at_type/title" style="font-weight: bold;">AT content type title</p>
-                        <p tal:repeat="field python: view.getFieldsForATType(at_type['id'])" tal:content="field/title">Field name</p>
+                        <tal:block repeat="field python: view.getFieldsForATType(at_type['id'])">
+                            <p tal:content="field/title">Field name</p>
+                            <input type="hidden" tal:attributes="name string:${at_type/id}:list;
+                                                                 value string:${field/id};" />
+                        </tal:block>
                     </td>
                     <td valign="top">
                         <select tal:attributes="onChange string:javascript:getDXFields(at_typename='${at_type/id}', this.value);
@@ -90,7 +94,7 @@
             </table>
             <div>
               <br />
-              <input type="submit" name="form.button.Apply" class="context" value="Apply" i18n:attributes="value" i18n:domain="plone"/>&nbsp;
+              <input type="submit" name="form.button.Migrate" class="context" value="Migrate" i18n:attributes="value" i18n:domain="plone"/>&nbsp;
               <input type="submit" name="form.button.Cancel" class="standalone" value="Cancel" i18n:attributes="value" i18n:domain="plone"/>
             </div>
             </form>
diff --git a/plone/app/contenttypes/migration/custom_migration.py b/plone/app/contenttypes/migration/custom_migration.py
index ea28b2a..5977c32 100644
--- a/plone/app/contenttypes/migration/custom_migration.py
+++ b/plone/app/contenttypes/migration/custom_migration.py
@@ -1,4 +1,5 @@
 # -*- coding: UTF-8 -*-
+from zope.i18n import translate
 from Products.Five.browser import BrowserView
 from plone.dexterity.interfaces import IDexterityFTI
 from plone.dexterity.utils import iterSchemataForType
@@ -30,11 +31,12 @@ def __call__(self):
         # check that we can actually access this form, aka the current user has an advice to add or edit
         form = self.request.form
         cancelled = form.get('form.button.Cancel', False)
-        submitted = form.get('form.button.Apply', False)
+        submitted = form.get('form.button.Migrate', False)
         if submitted:
             # proceed, call the migration methdd
-            self.apply()
-            msg = self.context.utranslate('Migration applied.', domain='plone.app.contenttypes')
+            self.migrate()
+            msg = translate('Migration applied.',
+                            domain='plone.app.contenttypes')
             self.context.plone_utils.addPortalMessage(msg)
         elif cancelled:
             self.request.response.redirect(form.get('form.HTTP_REFERER'))
@@ -93,7 +95,8 @@ def getFieldsForATType(self, typename):
         for field in schema.fields():
             if not field.getName() in self.at_metadata_fields:
                 results.append({'id': field.getName(),
-                                'title': '%s (%s)' % (field.widget.label, field.widget.getName())})
+                                'title': '%s (%s)' % (field.widget.label, field.widget.getName()),
+                                'type': field.widget.getName()})
         return results
 
     def getFieldsForDXType(self, typename):
@@ -110,7 +113,8 @@ def getFieldsForDXType(self, typename):
                 if fieldName in self.dx_metadata_fields:
                     continue
                 results.append({'id': fieldName,
-                                'title': '%s (%s)' % (field.title, field.__class__.__name__)})
+                                'title': '%s (%s)' % (field.title, field.__class__.__name__),
+                                'type': field.__class__.__name__})
         return results
 
     def getPossibleTargetField(self, fieldtype):
@@ -119,20 +123,37 @@ def getPossibleTargetField(self, fieldtype):
     def isFolderish(self):
         ''' decide which base-class we use for the migrator'''
 
-    def apply(self):
-        '''
-        '''
-        # dictionnary structure is like :
-        # ({'AT_field_name': 'text',
-        #   'AT_field_type': 'RichText',
-        #   'DX_field_name': 'text',
-        #   'DX_field_type': 'TextLine', }), },
-        # }
-        data = ({'AT_field_name': 'text',
-                 'AT_field_type': 'RichText',
-                 'DX_field_name': 'text',
-                 'DX_field_type': 'TextLine', }, )
-        migrateCustomAT(self.context, fields_mapping=data, src_type='DocumentAT', dst_type='Document')
+    def migrate(self):
+        '''Build data from self.request.form, we will build something like :
+           {'MyATPortalType': {'MyDXPortalType': {'at_fielname1': 'dx_fieldname1', 'at_fieldname2': 'dx_fieldname2'}}}
+           Call the migrateCustomAT migrator for each AT content_type we choose to migrate.'''
+        data = {}
+        form = self.request.form
+        for k in self.request.form.keys():
+            if k.startswith('dx_select_'):
+                # we found select where we choose a DX type regarding an AT type
+                # the selelect name is like 'dx_select_MyATPortalType'
+                if not form[k]:
+                    # nothing selected in this select, continue
+                    continue
+                at_typename = k[10:]
+                dx_typename = form[k]
+                data[at_typename] = {dx_typename: {}}
+                # now handle fields mapping for found DX/AT type migration definition
+                # we have 2 keys we relevant mappings, first key is the AT typename
+                # second key is a particular key like 'dx_DXPortalType__for__MyATPortalType
+                dx_key = 'dx_%s__for__%s' % (dx_typename, at_typename)
+                for at_fieldname in form[at_typename]:
+                    data[at_typename][dx_typename][at_fieldname] = form[dx_key][form[at_typename].index(at_fieldname)]
+        for at_typename, dx_mappings in data.items():
+            for k, v in dx_mappings.items():
+                migrateCustomAT(self.context, fields_mapping=v, src_type=at_typename, dst_type=dx_typename)
+
+        #data = ({'AT_field_name': 'text',
+        #         'AT_field_type': 'RichText',
+        #         'DX_field_name': 'text',
+        #         'DX_field_type': 'TextLine', }, )
+        #migrateCustomAT(self.context, fields_mapping=data, src_type='DocumentAT', dst_type='Document')
 
 
 class DisplayDXFields(CustomMigrationForm):


Repository: plone.app.contenttypes
Branch: refs/heads/master
Date: 2014-04-25T19:47:09+02:00
Author: Gauthier Bastien (gbastien) <g.bastien@imio.be>
Commit: https://github.com/plone/plone.app.contenttypes/commit/4e62824b37dfd31d2a264949f18ff2e923a11ed6

Get the meta_type from portal_type as several portal_types can use same meta_type but only one meta_type instance is registered in archetype_tool

Files changed:
M plone/app/contenttypes/migration/migration.py

diff --git a/plone/app/contenttypes/migration/migration.py b/plone/app/contenttypes/migration/migration.py
index 18d2de9..c2f7331 100644
--- a/plone/app/contenttypes/migration/migration.py
+++ b/plone/app/contenttypes/migration/migration.py
@@ -634,16 +634,21 @@ def migrateCustomAT(fields_mapping, src_type, dst_type):
     src_type_infos = None
     if not archetype_tool:
         return
+    # get the src meta_type from the portal_type
+    portal_types = getToolByName(portal, 'portal_types')
+    src_meta_type = getattr(portal_types, src_type).content_meta_type
+    # lookup registered type in archetype_tool with
+    # meta_type because several portal_types can use same meta_type
     for info in archetype_tool.listRegisteredTypes():
-        if info.get('portal_type') == src_type:
+        if info.get('meta_type') == src_meta_type:
             src_type_infos = info
     is_folderish = src_type_infos.get('klass').isPrincipiaFolderish
     migrator = makeCustomATMigrator(context=portal,
-                                 src_type=src_type,
-                                 dst_type=dst_type,
-                                 fields_mapping=fields_mapping,
-                                 is_folderish=is_folderish)
+                                    src_type=src_type,
+                                    dst_type=dst_type,
+                                    fields_mapping=fields_mapping,
+                                    is_folderish=is_folderish)
     if migrator:
-        migrator.src_meta_type = src_type_infos.get('meta_type')
+        migrator.src_meta_type = src_meta_type
         migrator.dst_meta_type = ''
         migrate(portal, migrator)


Repository: plone.app.contenttypes
Branch: refs/heads/master
Date: 2014-04-25T19:48:02+02:00
Author: Gauthier Bastien (gbastien) <g.bastien@imio.be>
Commit: https://github.com/plone/plone.app.contenttypes/commit/44550ce76feee420afba5a78e3d674fe173e4500

Adapted build data dict to pass correct format to migrateCustomAT

Files changed:
M plone/app/contenttypes/migration/custom_migration.pt
M plone/app/contenttypes/migration/custom_migration.py

diff --git a/plone/app/contenttypes/migration/custom_migration.pt b/plone/app/contenttypes/migration/custom_migration.pt
index 36b6db0..1284eef 100644
--- a/plone/app/contenttypes/migration/custom_migration.pt
+++ b/plone/app/contenttypes/migration/custom_migration.pt
@@ -71,7 +71,7 @@
                         <tal:block repeat="field python: view.getFieldsForATType(at_type['id'])">
                             <p tal:content="field/title">Field name</p>
                             <input type="hidden" tal:attributes="name string:${at_type/id}:list;
-                                                                 value string:${field/id};" />
+                                                                 value string:${field/id}__type__${field/type};" />
                         </tal:block>
                     </td>
                     <td valign="top">
diff --git a/plone/app/contenttypes/migration/custom_migration.py b/plone/app/contenttypes/migration/custom_migration.py
index 5977c32..f8f3fd7 100644
--- a/plone/app/contenttypes/migration/custom_migration.py
+++ b/plone/app/contenttypes/migration/custom_migration.py
@@ -94,9 +94,10 @@ def getFieldsForATType(self, typename):
             return results
         for field in schema.fields():
             if not field.getName() in self.at_metadata_fields:
+                translated_label = translate(field.widget.label)
                 results.append({'id': field.getName(),
-                                'title': '%s (%s)' % (field.widget.label, field.widget.getName()),
-                                'type': field.widget.getName()})
+                                'title': '%s (%s)' % (translated_label, field.getType()),
+                                'type': field.getType()})
         return results
 
     def getFieldsForDXType(self, typename):
@@ -125,10 +126,15 @@ def isFolderish(self):
 
     def migrate(self):
         '''Build data from self.request.form, we will build something like :
-           {'MyATPortalType': {'MyDXPortalType': {'at_fielname1': 'dx_fieldname1', 'at_fieldname2': 'dx_fieldname2'}}}
+           {'MyATPortalType': {'MyDXPortalType': ({'AT_field_name': 'fieldname1',
+                                                   'AT_field_type': 'TextField',
+                                                   'DX_field_name': 'field_name1',
+                                                   'DX_field_type': 'RichText'}, )
+                                                   }}
            Call the migrateCustomAT migrator for each AT content_type we choose to migrate.'''
         data = {}
         form = self.request.form
+        # manipulate what we receive in the form and build a useable data dict
         for k in self.request.form.keys():
             if k.startswith('dx_select_'):
                 # we found select where we choose a DX type regarding an AT type
@@ -143,17 +149,21 @@ def migrate(self):
                 # we have 2 keys we relevant mappings, first key is the AT typename
                 # second key is a particular key like 'dx_DXPortalType__for__MyATPortalType
                 dx_key = 'dx_%s__for__%s' % (dx_typename, at_typename)
-                for at_fieldname in form[at_typename]:
-                    data[at_typename][dx_typename][at_fieldname] = form[dx_key][form[at_typename].index(at_fieldname)]
+                for at_field in form[at_typename]:
+                    at_field_name, at_field_type = at_field.split('__type__')
+                    if not hasattr(data[at_typename][dx_typename], at_field_name):
+                        data[at_typename][dx_typename] = []
+                    dx_field_name, dx_field_type = form[dx_key][form[at_typename].index(at_field)].split('__type__')
+                    field_data = {'AT_field_name': at_field_name,
+                                  'AT_field_type': at_field_type,
+                                  'DX_field_name': dx_field_name,
+                                  'DX_field_type': dx_field_type, }
+                    data[at_typename][dx_typename].append(field_data)
+
+        # now that the data dict contains relevant information, we can call the custom migrator
         for at_typename, dx_mappings in data.items():
             for k, v in dx_mappings.items():
-                migrateCustomAT(self.context, fields_mapping=v, src_type=at_typename, dst_type=dx_typename)
-
-        #data = ({'AT_field_name': 'text',
-        #         'AT_field_type': 'RichText',
-        #         'DX_field_name': 'text',
-        #         'DX_field_type': 'TextLine', }, )
-        #migrateCustomAT(self.context, fields_mapping=data, src_type='DocumentAT', dst_type='Document')
+                migrateCustomAT(fields_mapping=v, src_type=at_typename, dst_type=dx_typename)
 
 
 class DisplayDXFields(CustomMigrationForm):


Repository: plone.app.contenttypes
Branch: refs/heads/master
Date: 2014-04-25T19:51:11+02:00
Author: Gauthier Bastien (gbastien) <g.bastien@imio.be>
Commit: https://github.com/plone/plone.app.contenttypes/commit/5c29d12ad79c5394cccb08d5a394afa58f10e7d1

Adapted changelog regarding recent changes about issue #133

Files changed:
M docs/CHANGES.rst
M docs/README.rst

diff --git a/docs/CHANGES.rst b/docs/CHANGES.rst
index 74910ed..b9caaa7 100644
--- a/docs/CHANGES.rst
+++ b/docs/CHANGES.rst
@@ -4,7 +4,9 @@ Changelog
 1.2a4 (unreleased)
 ------------------
 
-- Nothing changed yet.
+- Added helper view for migration custom AT types to available DX types,
+  see issue #133.
+  [gbastien]
 
 
 1.2a3 (2014-04-19)
diff --git a/docs/README.rst b/docs/README.rst
index 7fbddf2..2f28b32 100644
--- a/docs/README.rst
+++ b/docs/README.rst
@@ -439,3 +439,4 @@ Contributors
 * David Glick <david@glicksoftware.com>
 * Kees Hink <keeshink@gmail.com>
 * Roman Kozlovskyi <krzroman@gmail.com>
+* Gauthier Bastien <gauthier.bastien@imio.be>


Repository: plone.app.contenttypes
Branch: refs/heads/master
Date: 2014-04-26T09:54:08+02:00
Author: Gauthier Bastien (gbastien) <g.bastien@imio.be>
Commit: https://github.com/plone/plone.app.contenttypes/commit/8e21bd0125561c952e122ea7fb1cf042d28ff90a

Do not fail if we receive some fields that will not be migrated

Files changed:
M plone/app/contenttypes/migration/custom_migration.py

diff --git a/plone/app/contenttypes/migration/custom_migration.py b/plone/app/contenttypes/migration/custom_migration.py
index f8f3fd7..134e1e1 100644
--- a/plone/app/contenttypes/migration/custom_migration.py
+++ b/plone/app/contenttypes/migration/custom_migration.py
@@ -150,10 +150,14 @@ def migrate(self):
                 # second key is a particular key like 'dx_DXPortalType__for__MyATPortalType
                 dx_key = 'dx_%s__for__%s' % (dx_typename, at_typename)
                 for at_field in form[at_typename]:
+                    dx_field = form[dx_key][form[at_typename].index(at_field)]
+                    if not dx_field:
+                        continue
                     at_field_name, at_field_type = at_field.split('__type__')
                     if not hasattr(data[at_typename][dx_typename], at_field_name):
                         data[at_typename][dx_typename] = []
-                    dx_field_name, dx_field_type = form[dx_key][form[at_typename].index(at_field)].split('__type__')
+
+                    dx_field_name, dx_field_type = dx_field.split('__type__')
                     field_data = {'AT_field_name': at_field_name,
                                   'AT_field_type': at_field_type,
                                   'DX_field_name': dx_field_name,


Repository: plone.app.contenttypes
Branch: refs/heads/master
Date: 2014-04-26T12:24:56+02:00
Author: Andrea Cecchi (cekk) <andrea.cecchi85@gmail.com>
Commit: https://github.com/plone/plone.app.contenttypes/commit/b7488fdb99d5a04d7140038b12910e16241d658d

updated CHANGES and README

Files changed:
M docs/CHANGES.rst
M docs/README.rst

diff --git a/docs/CHANGES.rst b/docs/CHANGES.rst
index b9caaa7..22a4c7c 100644
--- a/docs/CHANGES.rst
+++ b/docs/CHANGES.rst
@@ -8,6 +8,9 @@ Changelog
   see issue #133.
   [gbastien]
 
+- Added migration method that allows to migrate custom AT types to
+  available DX types (#133)
+  [cekk]
 
 1.2a3 (2014-04-19)
 ------------------
diff --git a/docs/README.rst b/docs/README.rst
index 2f28b32..a690e46 100644
--- a/docs/README.rst
+++ b/docs/README.rst
@@ -440,3 +440,4 @@ Contributors
 * Kees Hink <keeshink@gmail.com>
 * Roman Kozlovskyi <krzroman@gmail.com>
 * Gauthier Bastien <gauthier.bastien@imio.be>
+* Andrea Cecchi <andrea.cecchi@redturtle.it>


Repository: plone.app.contenttypes
Branch: refs/heads/master
Date: 2014-04-28T11:12:33+02:00
Author: Gauthier Bastien (gbastien) <g.bastien@imio.be>
Commit: https://github.com/plone/plone.app.contenttypes/commit/af68128f56ee10221177fe199bd87a9fb355e9bb

Added relevant template for showing DX fields

Files changed:
A plone/app/contenttypes/migration/custom_migration_display_dx_fields.pt

diff --git a/plone/app/contenttypes/migration/custom_migration_display_dx_fields.pt b/plone/app/contenttypes/migration/custom_migration_display_dx_fields.pt
new file mode 100644
index 0000000..bfe5a2b
--- /dev/null
+++ b/plone/app/contenttypes/migration/custom_migration_display_dx_fields.pt
@@ -0,0 +1,8 @@
+<tal:loop repeat="at_field python: view.getFieldsForATType(view.at_typename)">
+    <select tal:attributes="name string:dx_${view/dx_typename}__for__${view/at_typename}:list;">
+        <option value="">Do not migrate</option>
+        <option tal:repeat="dx_field python: view.getFieldsForDXType(view.dx_typename)"
+                tal:attributes="value string:${dx_field/id}__type__${dx_field/type};"
+                tal:content="string:${dx_field/title}">DX field name</option>
+    </select>
+</tal:loop>
\ No newline at end of file


Repository: plone.app.contenttypes
Branch: refs/heads/master
Date: 2014-04-28T11:26:46+02:00
Author: Gauthier Bastien (gbastien) <g.bastien@imio.be>
Commit: https://github.com/plone/plone.app.contenttypes/commit/e08d1baeee2126ee389fcaf7b8c52ba92868d50d

Merge branch 'issue133_custom_types_migration' of git://github.com/plone/plone.app.contenttypes into issue133_custom_types_migration

Files changed:
M docs/CHANGES.rst
M docs/README.rst

diff --git a/docs/CHANGES.rst b/docs/CHANGES.rst
index b9caaa7..22a4c7c 100644
--- a/docs/CHANGES.rst
+++ b/docs/CHANGES.rst
@@ -8,6 +8,9 @@ Changelog
   see issue #133.
   [gbastien]
 
+- Added migration method that allows to migrate custom AT types to
+  available DX types (#133)
+  [cekk]
 
 1.2a3 (2014-04-19)
 ------------------
diff --git a/docs/README.rst b/docs/README.rst
index 2f28b32..a690e46 100644
--- a/docs/README.rst
+++ b/docs/README.rst
@@ -440,3 +440,4 @@ Contributors
 * Kees Hink <keeshink@gmail.com>
 * Roman Kozlovskyi <krzroman@gmail.com>
 * Gauthier Bastien <gauthier.bastien@imio.be>
+* Andrea Cecchi <andrea.cecchi@redturtle.it>


Repository: plone.app.contenttypes
Branch: refs/heads/master
Date: 2014-10-23T17:11:24+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.app.contenttypes/commit/a9b97886517aba0cd5f8c78fca0d5e356d6817f7

Merge branch 'master' into issue133_custom_types_migration

Conflicts:
	docs/CHANGES.rst
	docs/README.rst
	plone/app/contenttypes/migration/migration.py

Files changed:
A plone/app/contenttypes/behaviors/richtext_gettext.pt
M docs/CHANGES.rst
M docs/LICENSE.txt
M docs/README.rst
M plone/app/contenttypes/behaviors/__init__.py
M plone/app/contenttypes/behaviors/collection.py
M plone/app/contenttypes/behaviors/configure.zcml
M plone/app/contenttypes/behaviors/leadimage.py
M plone/app/contenttypes/behaviors/richtext.py
M plone/app/contenttypes/behaviors/tableofcontents.py
M plone/app/contenttypes/behaviors/viewlets.py
M plone/app/contenttypes/browser/__init__.py
M plone/app/contenttypes/browser/collection.py
M plone/app/contenttypes/browser/link_redirect_view.py
M plone/app/contenttypes/browser/templates/folder_listing.pt
M plone/app/contenttypes/browser/templates/folder_tabular_view.pt
M plone/app/contenttypes/browser/templates/image.pt
M plone/app/contenttypes/browser/templates/image_view_fullscreen.pt
M plone/app/contenttypes/browser/templates/newsitem.pt
M plone/app/contenttypes/browser/utils.py
M plone/app/contenttypes/browser/viewlets.py
M plone/app/contenttypes/content.py
M plone/app/contenttypes/indexers.py
M plone/app/contenttypes/interfaces.py
M plone/app/contenttypes/migration/atct_migrator.pt
M plone/app/contenttypes/migration/atct_migrator_results.pt
M plone/app/contenttypes/migration/browser.py
M plone/app/contenttypes/migration/dxmigration.py
M plone/app/contenttypes/migration/migration.py
M plone/app/contenttypes/migration/utils.py
M plone/app/contenttypes/migration/vocabularies.py
M plone/app/contenttypes/permissions.py
M plone/app/contenttypes/profiles/default/diff_tool.xml
M plone/app/contenttypes/profiles/default/types/Collection.xml
M plone/app/contenttypes/profiles/default/types/Document.xml
M plone/app/contenttypes/profiles/default/types/Event.xml
M plone/app/contenttypes/profiles/default/types/File.xml
M plone/app/contenttypes/profiles/default/types/Folder.xml
M plone/app/contenttypes/profiles/default/types/Image.xml
M plone/app/contenttypes/profiles/default/types/Link.xml
M plone/app/contenttypes/profiles/default/types/News_Item.xml
M plone/app/contenttypes/schema/__init__.py
M plone/app/contenttypes/setuphandlers.py
M plone/app/contenttypes/testing.py
M plone/app/contenttypes/tests/robot/keywords.txt
M plone/app/contenttypes/tests/robot/test_collection_creator_criterion.robot
M plone/app/contenttypes/tests/robot/test_collection_location_criterion.robot
M plone/app/contenttypes/tests/robot/test_collection_review_state_criterion.robot
M plone/app/contenttypes/tests/robot/test_collection_short_name_criterion.robot
M plone/app/contenttypes/tests/robot/test_collection_type_criterion.robot
M plone/app/contenttypes/tests/test_behaviors_collection.py
M plone/app/contenttypes/tests/test_behaviors_leadimage.py
M plone/app/contenttypes/tests/test_behaviors_richtext.py
M plone/app/contenttypes/tests/test_behaviors_table_of_contents.py
M plone/app/contenttypes/tests/test_collection.py
M plone/app/contenttypes/tests/test_content_profile.py
M plone/app/contenttypes/tests/test_migration.py
M plone/app/contenttypes/tests/test_migration_browser.py
M plone/app/contenttypes/tests/test_setup.py
M plone/app/contenttypes/upgrades.py
M setup.py
M test-plone-4.3.x.cfg

diff --git a/docs/CHANGES.rst b/docs/CHANGES.rst
index 22a4c7c..5b21afe 100644
--- a/docs/CHANGES.rst
+++ b/docs/CHANGES.rst
@@ -1,13 +1,67 @@
 Changelog
 =========
 
-1.2a4 (unreleased)
+1.2a5 (unreleased)
 ------------------
 
 - Added helper view for migration custom AT types to available DX types,
   see issue #133.
   [gbastien]
 
+- Code modernization: sorted imports, use decorators, utf8 headers.
+  [jensens]
+
+- Fix: Added missing types to CMFDiffTool configuraion.
+  [jensens]
+
+- Integration of the new markup update and CSS for both Plone and Barceloneta
+  theme. This is the work done in the GSOC Barceloneta theme project. Fix
+  several templates.
+  [albertcasado, sneridagh]
+
+
+1.2a4 (2014-09-17)
+------------------
+
+- Include translated content into migration-information (see #170)
+  [pbauer]
+
+- Add simple confirmation to prevent unintentional migration.
+  [pbauer]
+
+- Don't remove custom behaviors on reinstalling.
+  [pbauer]
+
+- Add bbb getText view for content with IRichText-behavior
+  [datakurre]
+
+- Support ``custom_query`` parameter in the ``result`` method of the
+  ``Collection`` behavior. This allows for run time customization of the
+  stored query, e.g. by request parameters.
+  [thet]
+
+- Fix 'AttributeError: image' when NewsItem unused the lead image behavior.
+  [jianaijun]
+
+- Restore Plone 4.3 compatibility by depending on ``plone.app.event >= 2.0a4``.
+  The previous release of p.a.c got an implicit Plone 5 dependency through a
+  previous version of plone.app.event.
+  [thet]
+
+- Replace AT-fti with DX-fti when migrating a type.
+  [esteele, pbauer]
+
+- Only show migrateable types (fixes #155)
+  [pbauer]
+
+- Add logging during and after migration (fixes #156)
+  [pbauer]
+
+- When replacing the default news and events collections, reverse the
+  sort order correctly.
+  [maurits]
+>>>>>>> master
+
 - Added migration method that allows to migrate custom AT types to
   available DX types (#133)
   [cekk]
@@ -85,6 +139,59 @@ Changelog
   [pbauer]
 
 
+1.1b3 (2014-09-07)
+------------------
+
+- Include translated content into migration-information (see #170)
+  [pbauer]
+
+- Add simple confirmation to prevent unintentional migration.
+  [pbauer]
+
+- Don't remove custom behaviors on reinstalling.
+  [pbauer]
+
+- Remove enabling simple_publication_workflow from testing fixture.
+  [timo]
+
+- Only show migrateable types (fixes #155)
+  [pbauer]
+
+- Add logging during and after migration (fixes #156)
+  [pbauer]
+
+- Remove 'robot-test-folder' from p.a.contenttypes test setup. It is bad to
+  add content to test layers, especially if those test layers are used by
+  other packages.
+  [timo]
+
+- When replacing the default news and events collections, reverse the
+  sort order correctly.
+  [maurits]
+
+- For plone.app.contenttypes 1.1.x, depend on plone.app.event < 1.1.999.
+  Closes/Fixes #149.
+  [khink, thet]
+
+
+1.1b2 (2014-02-21)
+------------------
+
+- Fix viewlet warning about ineditable content (fixes #130)
+  [pbauer]
+
+- Reintroduce the removed schema-files and add upgrade-step to migrate to
+  behavior-driven richtext-fields (fixes #127)
+  [pbauer]
+
+- Delete Archetypes Member-folder before creating new default-content
+  (fixes #128)
+  [pbauer]
+
+- Remove outdated summary-behavior from event (fixes #129)
+  [pbauer]
+
+
 1.1b1 (2014-02-19)
 ------------------
 
diff --git a/docs/LICENSE.txt b/docs/LICENSE.txt
index 4d68aa9..7379eb1 100644
--- a/docs/LICENSE.txt
+++ b/docs/LICENSE.txt
@@ -1,4 +1,4 @@
-  plone.app.contenttypes is copyright 
+  plone.app.contenttypes is copyright
 
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
diff --git a/docs/README.rst b/docs/README.rst
index a690e46..ef496d8 100644
--- a/docs/README.rst
+++ b/docs/README.rst
@@ -29,7 +29,7 @@ It contains the following types:
 * Image
 * Link
 * Event (Using behaviors from plone.app.event)
-* Collection (this already replaces plone.app.collection which is no longer needed then)
+* Collection
 
 The main difference from a users perspective is that these types are extendable through-the-web. This means you can add or remove fields and behaviors using the control-panel "Dexterity Content Types" (``/@@dexterity-types``).
 
@@ -43,11 +43,11 @@ plone.app.contenttypes has been merged into the Plone 5.0 branch and will be shi
 Compatibility
 -------------
 
-Version 1.1b1 is tested with Plone 4.3.x. The versions 1.1.x will stay compatible with Plone 4.3.x.
+Version 1.1b3 is tested with Plone 4.3.x. The versions of branch 1.1.x will stay compatible with Plone 4.3.x.
 
 For support of Plone 4.1 and 4.2 please use version 1.0.x. Please note that they do not provide the full functionality.
 
-The future versions 1.2.x will be compatible with Plone 5 only and add support for plone.app.widgets
+The versions 1.2.x of the master-branch are compatible with Plone 5 and plone.app.widgets.
 
 
 Installation
@@ -95,7 +95,7 @@ If you install plone.app.contenttypes on a fresh site (i.e. when no content has
 
 
 Uninstalling
-^^^^^^^^^^^^
+------------
 
 To remove plone.app.contenttypes and return full functionality to old content and restore the AT-based default-types you have to install the import step "Types Tool" of the current base profile. Follow the following steps:
 
@@ -109,7 +109,7 @@ Any content you created based on plone.app.contenttypes will not be editable unt
 
 
 Dependencies
-^^^^^^^^^^^^
+------------
 
 * ``plone.app.dexterity >= 2.0.7``. Dexterity is shipped with Plone 4.3.x. Version pinns for Dexterity are included in Plone 4.2.x. For Plone 4.1.x you need to pin the correct version for Dexterity in your buildout. See `Installing Dexterity on older versions of Plone <http://developer.plone.org/reference_manuals/external/plone.app.dexterity/install.html#installing-dexterity-on-older-versions-of-plone>`_.
 
@@ -127,8 +127,8 @@ These are the version-pinns for Plone 4.3.3:
     versions = versions
 
     [versions]
-    plone.app.event = 1.1b1
-    plone.app.portlets = 2.5a1
+    plone.app.event = 1.1.1
+    plone.app.portlets = 2.5.1
 
 Plone-versions before 4.3.3 need to pinn more packages:
 
@@ -142,7 +142,7 @@ Plone-versions before 4.3.3 need to pinn more packages:
     plone.app.dexterity = 2.0.11
     plone.schemaeditor = 1.3.5
     plone.app.event = 1.1b1
-    plone.app.portlets = 2.5a1
+    plone.app.portlets = 2.5.1
 
 
 Migration
@@ -150,7 +150,7 @@ Migration
 
 To migrate your existing content from Archetypes to Dexterity use the form at ``/@@atct_migrator``.
 
-For migrations to work you need at least ``Products.contentmigration = 2.1.3`` (part of Plone since Plone 4.2.5) and ``plone.app.intid`` (part of Plone since Plone 4.1.0).
+For migrations to work you need at least ``Products.contentmigration = 2.1.9`` and ``plone.app.intid`` (part of Plone since Plone 4.1.0).
 
 
 Migrating Archetypes-based content to plone.app.contenttypes
@@ -176,7 +176,7 @@ The following non-default types will also be migrated:
 * Files and Images without blobs
 * AT-based collection provided by plone.app.collection
 
-Migrations that might come in a future version:
+Migrations that are coming in future versions:
 
 * from ATTopic to Collections
 
@@ -211,7 +211,11 @@ You need to implement a custom migration for your types and dexterity-behaviors
 Migrating custom content
 ^^^^^^^^^^^^^^^^^^^^^^^^
 
-Custom content-types will not be touched by the migration plone.app.contenttypes and will continue to work as expeced. However if you'd like to migrate your content-types to Dexterity (you'll have to create these types in Dexterity first) you might want to have a look at the code of plone.app.contenttypes.migration.migration.NewsItemMigrator as a blueprint.
+Custom content-types will not be touched by the migration plone.app.contenttypes and will continue to work as expected.
+
+Future versions of plone.app.contenttypes will have with a form that allows you to migrate old custom Archetypes-content to Dexterity (you'll have to create the Dexterity-types before) .
+
+However if you'd like to migrate your content-types to Dexterity before this feature is completed you might want to have a look at the code of plone.app.contenttypes.migration.migration.NewsItemMigrator as a blueprint for a migration.
 
 
 Widgets
@@ -266,10 +270,10 @@ Once you install ``collective.z3cform.widgets`` in the quickinstaller, the new w
 Information for Addon-Developers
 --------------------------------
 
-Design decicions
+Design decisions
 ^^^^^^^^^^^^^^^^
 
-The schemata for the types File, Image and Link are defined in xml-files using ``plone.supermodel``. This allows the types to be editable trough the web. The types Document, News Item, Folder and Event have no schemata but only use behaviors to provide their fields.
+The schemata for the types File, Image and Link are defined in xml-files using ``plone.supermodel``. This allows the types to be editable trough the web. The types Document, News Item, Folder and Event have no schemata at all but only use behaviors to provide their fields.
 
 
 Installation as a dependency from another product
@@ -357,7 +361,7 @@ You have several options:
       </schema>
     </model>
 
-For more complex features you should create custom behaviors and/or write your own content-types. For more information on creating custom dexterity-types or custom behaviors to extend these types with read the `dexterity documentation <http://developer.plone.org/reference_manuals/external/plone.app.dexterity/>`_.
+For more complex features you should create custom behaviors and/or write your own content-types. For more information on creating custom dexterity-types or custom behaviors to extend these types with read the `dexterity documentation <http://docs.plone.org/external/plone.app.dexterity/docs/>`_.
 
 
 Reordering fields provided by behaviors
@@ -406,13 +410,13 @@ The 1.1.x-branch supports Plone 4.3.x. From this 1.1.x-releases will be cut.
 
 
 License
-^^^^^^^
+-------
 
 GNU General Public License, version 2
 
 
 Contributors
-^^^^^^^^^^^^
+------------
 
 * Philip Bauer <bauer@starzel.de>
 * Michael Mulich <michael.mulich@gmail.com>
diff --git a/plone/app/contenttypes/behaviors/__init__.py b/plone/app/contenttypes/behaviors/__init__.py
index e69de29..40a96af 100644
--- a/plone/app/contenttypes/behaviors/__init__.py
+++ b/plone/app/contenttypes/behaviors/__init__.py
@@ -0,0 +1 @@
+# -*- coding: utf-8 -*-
diff --git a/plone/app/contenttypes/behaviors/collection.py b/plone/app/contenttypes/behaviors/collection.py
index 906096d..81dc156 100644
--- a/plone/app/contenttypes/behaviors/collection.py
+++ b/plone/app/contenttypes/behaviors/collection.py
@@ -5,21 +5,24 @@
 from Products.CMFPlone.interfaces.syndication import IFeed
 from Products.CMFPlone.interfaces.syndication import ISyndicatable
 from plone.app.contentlisting.interfaces import IContentListing
+from plone.app.contenttypes import _
 from plone.autoform.interfaces import IFormFieldProvider
 from plone.dexterity.interfaces import IDexterityContent
 from plone.supermodel import model
 from zope import schema
-from zope.component import adapts, getMultiAdapter, getUtility
-from zope.interface import alsoProvides, implements
+from zope.component import adapter
+from zope.component import getMultiAdapter
+from zope.component import getUtility
+from zope.interface import provider
+from zope.interface import implementer
 from zope.schema.interfaces import IVocabularyFactory
-from zope.schema.vocabulary import SimpleTerm, SimpleVocabulary
-from plone.app.contenttypes import _
+from zope.schema.vocabulary import SimpleTerm
+from zope.schema.vocabulary import SimpleVocabulary
 
 
+@implementer(IVocabularyFactory)
 class MetaDataFieldsVocabulary(object):
 
-    implements(IVocabularyFactory)
-
     def __call__(self, context):
         cat = getToolByName(context, 'portal_catalog')
         items = [
@@ -31,6 +34,7 @@ def __call__(self, context):
 MetaDataFieldsVocabularyFactory = MetaDataFieldsVocabulary()
 
 
+@provider(IFormFieldProvider, ISyndicatable)
 class ICollection(model.Schema):
 
     query = schema.List(
@@ -81,24 +85,21 @@ class ICollection(model.Schema):
         )
 
 
-alsoProvides(ICollection, IFormFieldProvider)
-alsoProvides(ICollection, ISyndicatable)
-
-
 class ISyndicatableCollection(ISyndicatable):
     """Marker interface for syndicatable collections.
     """
 
 
+@implementer(ICollection)
+@adapter(IDexterityContent)
 class Collection(object):
-    implements(ICollection)
-    adapts(IDexterityContent)
 
     def __init__(self, context):
         self.context = context
 
     def results(self, batch=True, b_start=0, b_size=None,
-                sort_on=None, limit=None, brains=False):
+                sort_on=None, limit=None, brains=False,
+                custom_query={}):
         querybuilder = getMultiAdapter((self.context, self.context.REQUEST),
                                        name='querybuilderresults')
         sort_order = 'reverse' if self.sort_reversed else 'ascending'
@@ -138,7 +139,7 @@ def results(self, batch=True, b_start=0, b_size=None,
         return querybuilder(
             query=query, batch=batch, b_start=b_start, b_size=b_size,
             sort_on=sort_on, sort_order=sort_order,
-            limit=limit, brains=brains
+            limit=limit, brains=brains, custom_query=custom_query
         )
 
     def getFoldersAndImages(self):
@@ -236,8 +237,8 @@ def _get_customViewFields(self):
     customViewFields = property(_get_customViewFields, _set_customViewFields)
 
 
+@implementer(IFeed)
 class CollectionFeed(BaseCollectionFeed):
-    implements(IFeed)
 
     def _brains(self):
         return ICollection(self.context).results(batch=False)[:self.limit]
diff --git a/plone/app/contenttypes/behaviors/configure.zcml b/plone/app/contenttypes/behaviors/configure.zcml
index 350fe48..7352482 100644
--- a/plone/app/contenttypes/behaviors/configure.zcml
+++ b/plone/app/contenttypes/behaviors/configure.zcml
@@ -51,6 +51,14 @@
     marker=".richtext.IRichText"
     />
 
+  <browser:page
+    name="getText"
+    for=".richtext.IRichText"
+    class=".richtext.WidgetView"
+    permission="zope2.View"
+    template="richtext_gettext.pt"
+    />
+
   <utility
       component=".collection.MetaDataFieldsVocabularyFactory"
       name="plone.app.contenttypes.metadatafields" />
diff --git a/plone/app/contenttypes/behaviors/leadimage.py b/plone/app/contenttypes/behaviors/leadimage.py
index 4360107..fbe6388 100644
--- a/plone/app/contenttypes/behaviors/leadimage.py
+++ b/plone/app/contenttypes/behaviors/leadimage.py
@@ -1,16 +1,16 @@
 # -*- coding: utf-8 -*-
-from zope.interface import alsoProvides, implements
-from zope.component import adapts
-from zope import schema
-from plone.supermodel import model
-from plone.dexterity.interfaces import IDexterityContent
+from plone.app.contenttypes import _
 from plone.autoform.interfaces import IFormFieldProvider
-
+from plone.dexterity.interfaces import IDexterityContent
 from plone.namedfile import field as namedfile
-
-from plone.app.contenttypes import _
+from plone.supermodel import model
+from zope import schema
+from zope.component import adapter
+from zope.interface import implementer
+from zope.interface import provider
 
 
+@provider(IFormFieldProvider)
 class ILeadImage(model.Schema):
 
     image = namedfile.NamedBlobImage(
@@ -25,12 +25,10 @@ class ILeadImage(model.Schema):
         required=False,
     )
 
-alsoProvides(ILeadImage, IFormFieldProvider)
-
 
+@implementer(ILeadImage)
+@adapter(IDexterityContent)
 class LeadImage(object):
-    implements(ILeadImage)
-    adapts(IDexterityContent)
 
     def __init__(self, context):
         self.context = context
diff --git a/plone/app/contenttypes/behaviors/richtext.py b/plone/app/contenttypes/behaviors/richtext.py
index 73e4e57..a3b20ba 100644
--- a/plone/app/contenttypes/behaviors/richtext.py
+++ b/plone/app/contenttypes/behaviors/richtext.py
@@ -1,14 +1,16 @@
 # -*- coding: utf-8 -*-
+from plone.app.contenttypes import _
+from plone.app.textfield import RichText as RichTextField
 from plone.autoform.interfaces import IFormFieldProvider
+from plone.autoform.view import WidgetsView
 from plone.dexterity.interfaces import IDexterityContent
-from plone.app.textfield import RichText as RichTextField
 from plone.supermodel import model
-from zope.component import adapts
-from zope.interface import alsoProvides, implements
-
-from plone.app.contenttypes import _
+from zope.component import adapter
+from zope.interface import implementer
+from zope.interface import provider
 
 
+@provider(IFormFieldProvider)
 class IRichText(model.Schema):
 
     text = RichTextField(
@@ -19,12 +21,13 @@ class IRichText(model.Schema):
     model.primary('text')
 
 
-alsoProvides(IRichText, IFormFieldProvider)
-
-
+@implementer(IRichText)
+@adapter(IDexterityContent)
 class RichText(object):
-    implements(IRichText)
-    adapts(IDexterityContent)
 
     def __init__(self, context):
         self.context = context
+
+
+class WidgetView(WidgetsView):
+    schema = IRichText
diff --git a/plone/app/contenttypes/behaviors/richtext_gettext.pt b/plone/app/contenttypes/behaviors/richtext_gettext.pt
new file mode 100644
index 0000000..2cfe273
--- /dev/null
+++ b/plone/app/contenttypes/behaviors/richtext_gettext.pt
@@ -0,0 +1 @@
+<div tal:replace="structure view/++widget++text/render" />
\ No newline at end of file
diff --git a/plone/app/contenttypes/behaviors/tableofcontents.py b/plone/app/contenttypes/behaviors/tableofcontents.py
index 2184131..3bcf4d8 100644
--- a/plone/app/contenttypes/behaviors/tableofcontents.py
+++ b/plone/app/contenttypes/behaviors/tableofcontents.py
@@ -2,12 +2,13 @@
 from plone.autoform.interfaces import IFormFieldProvider
 from plone.supermodel import model
 from zope import schema
-from zope.interface import alsoProvides
 from zope.i18nmessageid import MessageFactory
+from zope.interface import provider
 
 _ = MessageFactory('atcontenttypes')
 
 
+@provider(IFormFieldProvider)
 class ITableOfContents(model.Schema):
 
     model.fieldset('settings', label=_(u"Settings"),
@@ -23,5 +24,3 @@ class ITableOfContents(model.Schema):
                     u' at the top of the page.'),
         required=False,
     )
-
-alsoProvides(ITableOfContents, IFormFieldProvider)
diff --git a/plone/app/contenttypes/behaviors/viewlets.py b/plone/app/contenttypes/behaviors/viewlets.py
index da7ca68..bfa37ae 100644
--- a/plone/app/contenttypes/behaviors/viewlets.py
+++ b/plone/app/contenttypes/behaviors/viewlets.py
@@ -1,8 +1,7 @@
 # -*- coding: utf-8 -*-
-from plone.app.layout.viewlets import ViewletBase
-
-from plone.app.contenttypes.interfaces import INewsItem
 from plone.app.contenttypes.behaviors.leadimage import ILeadImage
+from plone.app.contenttypes.interfaces import INewsItem
+from plone.app.layout.viewlets import ViewletBase
 
 
 class LeadImageViewlet(ViewletBase):
diff --git a/plone/app/contenttypes/browser/__init__.py b/plone/app/contenttypes/browser/__init__.py
index e69de29..40a96af 100644
--- a/plone/app/contenttypes/browser/__init__.py
+++ b/plone/app/contenttypes/browser/__init__.py
@@ -0,0 +1 @@
+# -*- coding: utf-8 -*-
diff --git a/plone/app/contenttypes/browser/collection.py b/plone/app/contenttypes/browser/collection.py
index 6551f54..ddb2f6f 100644
--- a/plone/app/contenttypes/browser/collection.py
+++ b/plone/app/contenttypes/browser/collection.py
@@ -1,7 +1,6 @@
 # -*- coding: utf-8 -*-
 from Acquisition import aq_inner
 from Products.Five import BrowserView
-
 from plone.app.contenttypes.behaviors.collection import ICollection
 
 
diff --git a/plone/app/contenttypes/browser/link_redirect_view.py b/plone/app/contenttypes/browser/link_redirect_view.py
index 2ed037a..4e4a45d 100644
--- a/plone/app/contenttypes/browser/link_redirect_view.py
+++ b/plone/app/contenttypes/browser/link_redirect_view.py
@@ -1,10 +1,8 @@
 # -*- coding: utf-8 -*-
+from Products.CMFCore.utils import getToolByName
 from Products.Five.browser import BrowserView
 from Products.Five.browser.pagetemplatefile import ViewPageTemplateFile
-
-from Products.CMFCore.utils import getToolByName
-
-from ..utils import replace_link_variables_by_paths
+from plone.app.contenttypes.utils import replace_link_variables_by_paths
 
 
 class LinkRedirectView(BrowserView):
diff --git a/plone/app/contenttypes/browser/templates/folder_listing.pt b/plone/app/contenttypes/browser/templates/folder_listing.pt
index 9159898..39d3d28 100644
--- a/plone/app/contenttypes/browser/templates/folder_listing.pt
+++ b/plone/app/contenttypes/browser/templates/folder_listing.pt
@@ -46,8 +46,8 @@
                         plone_view context/@@plone;">
     <tal:listing condition="batch">
 
-        <div metal:define-slot="entries">
-            <article tal:repeat="item batch" metal:define-macro="entries">
+        <ul metal:define-slot="entries">
+            <li tal:repeat="item batch" metal:define-macro="entries">
             <tal:block tal:define="item_url item/getURL|item/absolute_url;
                                    item_id item/getId|item/id;
                                    item_title_or_id item/pretty_title_or_id;
@@ -66,8 +66,9 @@
                                    item_sametime python: item_start == item_end;
                                    item_samedate python: (item_end - item_start &lt; 1) if item_type == 'Event' else False">
                 <metal:block define-slot="entry">
-                <header metal:define-macro="listitem"
-                    tal:attributes="class python: item_type == 'Event' and 'vevent' or ''">
+                <span metal:define-macro="listitem"
+                    tal:define="item_type_event_class python: item_type == 'Event' and 'vevent' or None"
+                    tal:attributes="class item_type_event_class|nothing">
 
                     <span class="summary">
                         <img tal:replace="structure item_icon/html_tag" />
@@ -160,17 +161,17 @@
                         </tal:byline>
                     </span>
 
-                </header>
+                </span>
 
-                <span class="description"
+                <p class="description discreet"
                     tal:condition="item_description"
                     tal:content="item_description">
                     description
-                </span>
+                </p>
             </metal:block>
             </tal:block>
-            </article>
-        </div>
+            </li>
+        </ul>
 
         <div metal:use-macro="context/batch_macros/macros/navigation" />
 
diff --git a/plone/app/contenttypes/browser/templates/folder_tabular_view.pt b/plone/app/contenttypes/browser/templates/folder_tabular_view.pt
index af528ad..c5e87a8 100644
--- a/plone/app/contenttypes/browser/templates/folder_tabular_view.pt
+++ b/plone/app/contenttypes/browser/templates/folder_tabular_view.pt
@@ -8,12 +8,12 @@
 
 <body>
 
-    <metal:content-core fill-slot="content-core">
-        <metal:block define-macro="listing" extend-macro="context/folder_listing/macros/content-core">
-            <metal:entries fill-slot="entries">
-
-            <div metal:use-macro="context/batch_macros/macros/navigation" />
+  <metal:content-core fill-slot="content-core">
+    <metal:block define-macro="listing" extend-macro="context/folder_listing/macros/content-core">
+      <metal:entries fill-slot="entries">
 
+          <div metal:use-macro="context/batch_macros/macros/navigation" />
+          <div class="has-table">
             <table class="listing"
                    summary="Content listing"
                    i18n:attributes="summary summary_content_listing;">
@@ -86,11 +86,11 @@
                     </metal:block>
                 </tbody>
             </table>
+          </div>
+      </metal:entries>
+    </metal:block>
 
-            </metal:entries>
-        </metal:block>
-
-    </metal:content-core>
+  </metal:content-core>
 
 </body>
 </html>
diff --git a/plone/app/contenttypes/browser/templates/image.pt b/plone/app/contenttypes/browser/templates/image.pt
index 44e852a..3090cab 100644
--- a/plone/app/contenttypes/browser/templates/image.pt
+++ b/plone/app/contenttypes/browser/templates/image.pt
@@ -10,27 +10,20 @@
     <metal:content-core fill-slot="content-core">
         <metal:block define-macro="content-core"
                      tal:define="size context/image/getSize">
-
-            <a class="discreet"
-               tal:attributes="href string:${context/@@plone_context_state/object_url}/image_view_fullscreen"
-               tal:define="scale context/@@images;
-                           img_tag python:scale.scale('image', scale='preview').tag()"
-                tal:on-error="string: Image cannot be displayed">
+            <figure class="image-product">
+              <a class="discreet"
+                 tal:attributes="href string:${context/@@plone_context_state/object_url}/image_view_fullscreen"
+                 tal:define="scale context/@@images;
+                             img_tag python:scale.scale('image', scale='large').tag()"
+                  tal:on-error="string: Image cannot be displayed">
                 <img tal:replace="structure img_tag" />
-                <br />
-                <span class="visualNoPrint">
-                    <img src="" alt="" tal:replace="structure context/search_icon.png" />
-                    <span i18n:translate="label_click_to_view_full_image">Click to view full-size image&hellip;</span>
-                </span>
-            </a>
-
-            <span class="discreet visualNoPrint">
-            &mdash;
-                <span i18n:translate="label_size">Size</span>:
-                <span tal:replace="python:size/1024">
-                    File size
-                </span>KB
-            </span>
+              
+              <figcaption class="discreet">
+                <strong class="sr-only" i18n:translate="label_click_to_view_full_image">Click to view full-size image&hellip;</strong>
+                <span><tal:span i18n:translate="label_size">Size</tal:span>: <tal:span tal:replace="python:size/1024"> File size </tal:span>KB</span>
+              </figcaption>
+              </a>
+            </figure>
         </metal:block>
     </metal:content-core>
 </body>
diff --git a/plone/app/contenttypes/browser/templates/image_view_fullscreen.pt b/plone/app/contenttypes/browser/templates/image_view_fullscreen.pt
index 673a206..1cb6ca2 100644
--- a/plone/app/contenttypes/browser/templates/image_view_fullscreen.pt
+++ b/plone/app/contenttypes/browser/templates/image_view_fullscreen.pt
@@ -18,25 +18,27 @@
     body {
         background-color: white;
         color: black;
-        font-family: "Lucida Grande", Verdana, Lucida, Helvetica, Arial, sans-serif;
-        font-size: 69%;
+        font-family: Helvetica, Arial, sans-serif;
+        font-size: 14px;
+        padding:0;
+        margin:0;
     }
-
     a {
-        display:block;
-        margin: 0.5em;
-        color: #436976;
-        text-decoration: underline;
-        line-height:1.5em;
+        color: #08c;
+        text-decoration: none;
+        text-align:center;
     }
+      a:hover {text-decoration:underline;}
+      a span {
+          display:block;
+          line-height:1.5em;
+          padding:12px;
+      }
 
     img {
-        border: 0px;
-        padding: 5px;
-    }
-
-    #content-core {
-        text-align: center;
+        border: 0;
+        display:block;
+        margin:0 auto;
     }
 
     </style>
@@ -50,12 +52,16 @@
     <a href=""
        tal:attributes="href request/HTTP_REFERER"
        tal:condition="request/HTTP_REFERER"
-       ><span i18n:translate="label_back_to_site">Back to site</span><br /><tal:block replace="structure context/@@images/image" /></a>
+       ><span i18n:translate="label_back_to_site">Back to site</span>
+    <tal:block replace="structure context/@@images/image" />
+  </a>
 
     <a href=""
        tal:attributes="href context/portal_url"
        tal:condition="not: request/HTTP_REFERER"
-       ><span i18n:translate="label_home">Home</span><br /><tal:block replace="structure context/@@images/image" /></a>
+       ><span i18n:translate="label_home">Home</span>
+       <tal:block replace="structure context/@@images/image" />
+    </a>
 </div>
 
 </body>
diff --git a/plone/app/contenttypes/browser/templates/newsitem.pt b/plone/app/contenttypes/browser/templates/newsitem.pt
index 20efd6b..009e8d9 100644
--- a/plone/app/contenttypes/browser/templates/newsitem.pt
+++ b/plone/app/contenttypes/browser/templates/newsitem.pt
@@ -19,9 +19,9 @@
     <metal:block define-macro="content-core"
           tal:define="templateId template/getId;
                       scale_func context/@@images;
-                      scaled_image python: context.image and scale_func.scale('image', scale='mini')">
+                      scaled_image python: getattr(context.aq_explicit, 'image', False) and scale_func.scale('image', scale='mini')">
 
-        <div class="newsImageContainer"
+        <figure class="newsImageContainer"
              tal:condition="python: scaled_image">
             <a href="#"
                tal:define="here_url context/@@plone_context_state/object_url;
@@ -29,13 +29,13 @@
                tal:attributes="href large_image/url">
               <img tal:replace="structure python: scaled_image.tag(css_class='newsImage')" />
 
-              <p class="discreet"
+              <figcaption
                  tal:condition="context/image_caption|nothing"
                  tal:content="structure context/image_caption" >
-              </p>
+              </figcaption>
 
             </a>
-        </div>
+        </figure>
 
 
         <div id="parent-fieldname-text"
@@ -43,7 +43,7 @@
              tal:content="structure context/text/output" />
 
         <div class="newsFileContainer"
-             tal:condition="python: context.image and not scaled_image">
+             tal:condition="python: getattr(context.aq_explicit, 'image', False) and not scaled_image">
             <a tal:content="structure python:context.image_caption or context.image.filename"
                tal:attributes="href python:'%s/@@download/image' % context.absolute_url()">
             </a>
diff --git a/plone/app/contenttypes/browser/utils.py b/plone/app/contenttypes/browser/utils.py
index e540950..b816539 100644
--- a/plone/app/contenttypes/browser/utils.py
+++ b/plone/app/contenttypes/browser/utils.py
@@ -6,7 +6,7 @@
 from plone.memoize.view import memoize
 from zope.component import getMultiAdapter
 from zope.interface import Interface
-from zope.interface import implements
+from zope.interface import implementer
 
 
 class IUtils(Interface):
@@ -19,8 +19,8 @@ def getMimeTypeIcon(content_file):
         """
 
 
+@implementer(IUtils)
 class Utils(BrowserView):
-    implements(IUtils)
 
     @memoize
     def getMimeTypeIcon(self, content_file):
diff --git a/plone/app/contenttypes/browser/viewlets.py b/plone/app/contenttypes/browser/viewlets.py
index 2b58ba3..5344410 100644
--- a/plone/app/contenttypes/browser/viewlets.py
+++ b/plone/app/contenttypes/browser/viewlets.py
@@ -4,7 +4,6 @@
 from Products.CMFCore.permissions import ManagePortal
 from plone.app.layout.viewlets import ViewletBase
 from plone.dexterity.interfaces import IDexterityFTI
-
 import pkg_resources
 
 try:
diff --git a/plone/app/contenttypes/content.py b/plone/app/contenttypes/content.py
index c76985a..5b8d4e5 100644
--- a/plone/app/contenttypes/content.py
+++ b/plone/app/contenttypes/content.py
@@ -1,24 +1,19 @@
 # -*- coding: utf-8 -*-
-from plone.app.contenttypes.interfaces import (
-    ICollection,
-    IDocument,
-    IFile,
-    IFolder,
-    IImage,
-    ILink,
-    INewsItem,
-    IEvent,
-)
-
-from plone.dexterity.content import Item
+from plone.app.contenttypes.interfaces import ICollection
+from plone.app.contenttypes.interfaces import IDocument
+from plone.app.contenttypes.interfaces import IEvent
+from plone.app.contenttypes.interfaces import IFile
+from plone.app.contenttypes.interfaces import IFolder
+from plone.app.contenttypes.interfaces import IImage
+from plone.app.contenttypes.interfaces import ILink
+from plone.app.contenttypes.interfaces import INewsItem
 from plone.dexterity.content import Container
-
-from zope.interface import implements
+from plone.dexterity.content import Item
+from zope.interface import implementer
 
 
+@implementer(ICollection)
 class Collection(Item):
-    implements(ICollection)
-
     # BBB
 
     def listMetaDataFields(self, exclude=True):
@@ -60,29 +55,43 @@ def results(self, **kwargs):
         return ICollection_behavior(self).results(**kwargs)
 
 
+@implementer(IDocument)
 class Document(Item):
-    implements(IDocument)
+    """Convinience Item subclass for ``Document`` portal type
+    """
 
 
+@implementer(IFile)
 class File(Item):
-    implements(IFile)
+    """Convinience subclass for ``File`` portal type
+    """
 
 
+@implementer(IFolder)
 class Folder(Container):
-    implements(IFolder)
+    """Convinience subclass for ``File`` portal type
+    """
 
 
+@implementer(IImage)
 class Image(Item):
-    implements(IImage)
+    """Convinience subclass for ``File`` portal type
+    """
 
 
+@implementer(ILink)
 class Link(Item):
-    implements(ILink)
+    """Convinience subclass for ``File`` portal type
+    """
 
 
+@implementer(INewsItem)
 class NewsItem(Item):
-    implements(INewsItem)
+    """Convinience subclass for ``File`` portal type
+    """
 
 
+@implementer(IEvent)
 class Event(Item):
-    implements(IEvent)
+    """Convinience subclass for ``File`` portal type
+    """
diff --git a/plone/app/contenttypes/indexers.py b/plone/app/contenttypes/indexers.py
index 473f261..c5a1b9f 100644
--- a/plone/app/contenttypes/indexers.py
+++ b/plone/app/contenttypes/indexers.py
@@ -1,5 +1,4 @@
 # -*- coding: utf-8 -*-
-from plone.app.contenttypes.utils import replace_link_variables_by_paths
 from Products.CMFCore.utils import getToolByName
 from Products.CMFPlone.utils import safe_unicode
 from ZODB.POSException import ConflictError
@@ -10,6 +9,7 @@
 from plone.app.contenttypes.interfaces import IImage
 from plone.app.contenttypes.interfaces import ILink
 from plone.app.contenttypes.interfaces import INewsItem
+from plone.app.contenttypes.utils import replace_link_variables_by_paths
 from plone.indexer.decorator import indexer
 from plone.rfc822.interfaces import IPrimaryFieldInfo
 
diff --git a/plone/app/contenttypes/interfaces.py b/plone/app/contenttypes/interfaces.py
index 2da0381..3b8a90b 100644
--- a/plone/app/contenttypes/interfaces.py
+++ b/plone/app/contenttypes/interfaces.py
@@ -13,40 +13,40 @@ class IPloneAppContenttypesLayer(Interface):
 
 
 class ICollection(Interface):
-    """
+    """Explixiet marker interface for Collection
     """
 
 
 class IDocument(Interface):
-    """
+    """Explixit marker interface for Document
     """
 
 
 class IFile(Interface):
-    """
+    """Explixit marker interface for File
     """
 
 
 class IFolder(Interface):
-    """
+    """Explixit marker interface for Folder
     """
 
 
 class IImage(Interface):
-    """
+    """Explixit marker interface for Image
     """
 
 
 class ILink(Interface):
-    """
+    """Explixit marker interface for Link
     """
 
 
 class INewsItem(Interface):
-    """
+    """Explixit marker interface for News Item
     """
 
 
 class IEvent(Interface):
-    """
+    """Explixit marker interface for Event
     """
diff --git a/plone/app/contenttypes/migration/atct_migrator.pt b/plone/app/contenttypes/migration/atct_migrator.pt
index d9fa25d..fabe764 100644
--- a/plone/app/contenttypes/migration/atct_migrator.pt
+++ b/plone/app/contenttypes/migration/atct_migrator.pt
@@ -51,6 +51,8 @@
           <tal:block i18n:name="minutes" content="time/minutes">45</tal:block> minutes
           <tal:block i18n:name="seconds" content="time/seconds">23</tal:block> seconds
         </span>
+        <br />
+        Please note that migrating references will increase this time.
         </p>
       </div>
       <div id="migration-options">
diff --git a/plone/app/contenttypes/migration/atct_migrator_results.pt b/plone/app/contenttypes/migration/atct_migrator_results.pt
index 32801f0..74a7422 100644
--- a/plone/app/contenttypes/migration/atct_migrator_results.pt
+++ b/plone/app/contenttypes/migration/atct_migrator_results.pt
@@ -26,7 +26,7 @@
     tal:define="results view/results">
 
   <tal:success tal:condition="results">
-    <p>The migration finished within <span tal:replace="results/duration">20</span> seconds</p>
+    <p>The migration finished within <span tal:replace="results/duration">20</span></p>
 
     <h3>Migrated Content</h3>
     <table>
@@ -38,7 +38,7 @@
     <tal:block tal:repeat="ct results/content_types">
     <tr>
       <td tal:content="python:results['migrated_types'][ct]['old_meta_type']"></td>
-      <td tal:content="python:results['migrated_types'][ct]['new_type_name']"></td>
+      <td tal:content="python:results['migrated_types'][ct]['type_name']"></td>
       <td tal:content="python:results['migrated_types'][ct]['amount_migrated']"></td>
     </tr>
     </tal:block>
diff --git a/plone/app/contenttypes/migration/browser.py b/plone/app/contenttypes/migration/browser.py
index a811e6c..2e82fa9 100644
--- a/plone/app/contenttypes/migration/browser.py
+++ b/plone/app/contenttypes/migration/browser.py
@@ -8,9 +8,13 @@
 from Products.Five.browser.pagetemplatefile import ViewPageTemplateFile
 from Products.statusmessages.interfaces import IStatusMessage
 from datetime import datetime
+from datetime import timedelta
 from plone.app.contenttypes.migration import migration
 from plone.app.contenttypes.migration.utils import ATCT_LIST
+from plone.app.contenttypes.migration.utils import HAS_MULTILINGUAL
+from plone.app.contenttypes.migration.utils import installTypeIfNeeded
 from plone.app.contenttypes.migration.utils import isSchemaExtended
+from plone.app.contenttypes.utils import DEFAULT_TYPES
 from plone.browserlayer.interfaces import ILocalBrowserLayerType
 from plone.dexterity.content import DexterityContent
 from plone.dexterity.interfaces import IDexterityContent
@@ -25,8 +29,8 @@
 from zope.component import getMultiAdapter
 from zope.component import queryUtility
 from zope.interface import Interface
-
 import logging
+
 logger = logging.getLogger(__name__)
 
 # Schema Extender allowed interfaces
@@ -68,8 +72,12 @@ def __call__(self):
             ('News Item', NewsItem),
         ]
         catalog = getToolByName(self.context, "portal_catalog")
+        query = {}
+        if HAS_MULTILINGUAL and 'Language' in catalog.indexes():
+            query['Language'] = 'all'
         for portal_type, portal_type_class in portal_types:
-            results = catalog.searchResults(portal_type=portal_type)
+            query['portal_type'] = portal_type
+            results = catalog(query)
             for brain in results:
                 obj = brain.getObject()
                 if IDexterityContent.providedBy(obj):
@@ -92,15 +100,25 @@ class MigrateFromATContentTypes(BrowserView):
     """
 
     def __call__(self,
+                 migrate=False,
                  content_types="all",
                  migrate_schemaextended_content=False,
                  migrate_references=True,
                  from_form=False):
 
-        stats_before = self.stats()
-        starttime = datetime.now()
         portal = self.context
-        catalog = portal.portal_catalog
+        if not from_form and migrate not in ['1', 'True', 'true', 1]:
+            url1 = '{0}/@@migrate_from_atct?migrate=1'.format(
+                portal.absolute_url())
+            url2 = '{0}/@@atct_migrator'.format(portal.absolute_url())
+            msg = u'Warning \n'
+            msg += u'-------\n'
+            msg += u'You are accessing "@@migrate_from_atct" directly. '
+            msg += u'This will migrate all content to dexterity!\n\n'
+            msg += u'Really migrate all content now: {0}\n\n'.format(url1)
+            msg += u'First select what to migrate: {0}'.format(url2)
+            return msg
+
         helpers = getMultiAdapter((portal, self.request),
                                   name="atct_migrator_helpers")
         if helpers.linguaplone_installed():
@@ -111,6 +129,10 @@ def __call__(self,
             msg += 'for more information.'
             return msg
 
+        stats_before = self.stats()
+        starttime = datetime.now()
+        catalog = portal.portal_catalog
+
         # switch linkintegrity temp off
         ptool = queryUtility(IPropertiesTool)
         site_props = getattr(ptool, 'site_properties', None)
@@ -133,23 +155,37 @@ def __call__(self,
                     and not migrate_schemaextended_content:
                 not_migrated.append(k)
                 continue
-            amount_to_be_migrated = len(catalog(
-                object_provides=v['iface'].__identifier__,
-                meta_type=v['old_meta_type'])
-            )
-            # TODO: num objects is 0 for BlobFile and BlobImage
-            logger.info(
-                "Migrating %s objects of type %s" %
-                (amount_to_be_migrated, k)
-            )
+            query = {
+                'object_provides': v['iface'].__identifier__,
+                'meta_type': v['old_meta_type'],
+            }
+            if HAS_MULTILINGUAL and 'Language' in catalog.indexes():
+                query['Language'] = 'all'
+            amount_to_be_migrated = len(catalog(query))
+            starttime_for_current = datetime.now()
+            logger.info("Start migrating %s objects from %s to %s" % (
+                amount_to_be_migrated,
+                v['old_meta_type'],
+                v['type_name']))
+            installTypeIfNeeded(v['type_name'])
+
             # call the migrator
             v['migrator'](portal)
 
+            # logging
+            duration_current = datetime.now() - starttime_for_current
+            duration_human = str(timedelta(seconds=duration_current.seconds))
+            logger.info("Finished migrating %s objects from %s to %s in %s" % (
+                amount_to_be_migrated,
+                v['old_meta_type'],
+                v['type_name'],
+                duration_human))
+
             # some data for the results-page
             migrated_types[k] = {}
             migrated_types[k]['amount_migrated'] = amount_to_be_migrated
             migrated_types[k]['old_meta_type'] = v['old_meta_type']
-            migrated_types[k]['new_type_name'] = v['new_type_name']
+            migrated_types[k]['type_name'] = v['type_name']
 
         # if there are blobnewsitems we just migrate them silently.
         migration.migrate_blobnewsitems(portal)
@@ -165,25 +201,26 @@ def __call__(self,
         # switch on setModificationDate on changes
         self.resetNotifyModified()
 
-        endtime = datetime.now()
-        duration = (endtime - starttime).seconds
+        duration = str(timedelta(seconds=(datetime.now() - starttime).seconds))
+        if not_migrated:
+            msg = ("The following types were not migrated: \n %s"
+                   % "\n".join(not_migrated))
+        else:
+            msg = "Migration successful\n\n"
+        msg += '\n-----------------------------\n'
+        msg += 'Migration finished in: %s' % duration
+        msg += '\n-----------------------------\n'
+        msg += 'Migration statictics:\n'
+        msg += pformat(migrated_types)
+        msg += '\n-----------------------------\n'
+        msg += 'State before:\n'
+        msg += pformat(stats_before)
+        msg += '\n-----------------------------\n'
+        msg += 'Stats after:\n'
+        msg += pformat(self.stats())
+        msg += '\n-----------------------------\n'
         if not from_form:
-            if not_migrated:
-                msg = ("The following were not migrated as they "
-                       "have extended schemas (from "
-                       "archetypes.schemaextender): \n %s"
-                       % "\n".join(not_migrated))
-            else:
-                msg = "Default content types successfully migrated\n\n"
-
-            msg += 'Migration finished in %s seconds' % duration
-            msg += '\n-----------------------------\n'
-            msg += 'State before:\n'
-            msg += pformat(stats_before)
-            msg += '\n-----------------------------\n'
-            msg += 'Stats after:\n'
-            msg += pformat(self.stats())
-            msg += '\n-----------------------------\n'
+            logger.info(msg)
             return msg
         else:
             stats = {
@@ -197,7 +234,11 @@ def __call__(self,
 
     def stats(self):
         results = {}
-        for brain in self.context.portal_catalog():
+        query = {}
+        catalog = self.context.portal_catalog
+        if HAS_MULTILINGUAL and 'Language' in catalog.indexes():
+            query['Language'] ='all'
+        for brain in catalog(query):
             classname = brain.getObject().__class__.__name__
             results[classname] = results.get(classname, 0) + 1
         return results
@@ -242,7 +283,9 @@ class IATCTMigratorForm(Interface):
         title=u"Migrate references?",
         description=(
             u"Select this option to migrate all "
-            u"references to each content type"
+            u"references to each content type. "
+            u"This will rebuild the whole catalog and "
+            u"increase the migration-time."
         ),
         default=True
     )
@@ -324,7 +367,10 @@ class ATCTMigratorHelpers(BrowserView):
     def objects_to_be_migrated(self):
         """ Return the number of AT objects in the portal """
         catalog = getToolByName(self.context, "portal_catalog")
-        brains = catalog(portal_type=ATCT_LIST.keys())
+        query = {'meta_type': [i['old_meta_type'] for i in ATCT_LIST.values()]}
+        if HAS_MULTILINGUAL and 'Language' in catalog.indexes():
+            query['Language'] = 'all'
+        brains = catalog(query)
         self._objects_to_be_migrated = len(brains)
         return self._objects_to_be_migrated
 
@@ -388,15 +434,26 @@ def handle_install(self, action):
         fail = qi.installProduct(
             'plone.app.contenttypes',
             profile='plone.app.contenttypes:default',
+            blacklistedSteps=['typeinfo'],
         )
         if fail:
             messages = IStatusMessage(self.request)
             messages.addStatusMessage(fail, type='error')
             self.request.response.redirect(url)
 
+        # For types without any instances we want to instantly
+        # replace the AT-FTI's with DX-FTI's.
+        self.installTypesWithoutItems()
+
         url = url + '/@@atct_migrator'
         self.request.response.redirect(url)
 
+    def installTypesWithoutItems(self):
+        catalog = getToolByName(self.context, "portal_catalog")
+        for types_name in DEFAULT_TYPES:
+            if not catalog.unrestrictedSearchResults(portal_type=types_name):
+                installTypeIfNeeded(types_name)
+
     @button.buttonAndHandler(
         _(u'label_cancel', default=u'Cancel'), name='cancel')
     def handle_cancel(self, action):
diff --git a/plone/app/contenttypes/migration/dxmigration.py b/plone/app/contenttypes/migration/dxmigration.py
index 468333b..b5ce49a 100644
--- a/plone/app/contenttypes/migration/dxmigration.py
+++ b/plone/app/contenttypes/migration/dxmigration.py
@@ -1,11 +1,11 @@
 # -*- coding: utf-8 -*-
-from Products.contentmigration.basemigrator.walker import CatalogWalker
 from Products.contentmigration.basemigrator.migrator import CMFItemMigrator
+from Products.contentmigration.basemigrator.walker import CatalogWalker
 from plone.app.contenttypes.interfaces import IEvent
 from plone.app.contenttypes.migration import datetime_fixer
+from plone.event.utils import default_timezone
 from zope.annotation.interfaces import IAnnotations
 from zope.component.hooks import getSite
-from plone.event.utils import default_timezone
 
 
 def migrate(portal, migrator):
diff --git a/plone/app/contenttypes/migration/migration.py b/plone/app/contenttypes/migration/migration.py
index c2f7331..7860322 100644
--- a/plone/app/contenttypes/migration/migration.py
+++ b/plone/app/contenttypes/migration/migration.py
@@ -35,6 +35,7 @@
 from zope.intid.interfaces import IIntIds
 
 import logging
+
 logger = logging.getLogger(__name__)
 
 
@@ -242,12 +243,11 @@ def beforeChange_relatedItemsOrder(self):
                 relatedItemsOrder = [item.UID() for item in relatedItems]
                 obj._relatedItemsOrder = PersistentList(relatedItemsOrder)
 
-    def migrate_relatedItems(self):
+    def migrate_at_relatedItems(self):
         """ Store Archetype relations as target uids on the dexterity object
             for later restore. Backrelations are saved as well because all
             relation to deleted objects would be lost.
         """
-
         # Relations:
         relItems = self.old.getRelatedItems()
         relUids = [item.UID() for item in relItems]
diff --git a/plone/app/contenttypes/migration/utils.py b/plone/app/contenttypes/migration/utils.py
index f0f2292..a5c12c0 100644
--- a/plone/app/contenttypes/migration/utils.py
+++ b/plone/app/contenttypes/migration/utils.py
@@ -6,6 +6,9 @@
 from Products.ATContentTypes.interfaces.image import IATImage
 from Products.ATContentTypes.interfaces.link import IATLink
 from Products.ATContentTypes.interfaces.news import IATNewsItem
+from Products.CMFCore.utils import getToolByName
+from Products.GenericSetup.context import DirectoryImportContext
+from Products.GenericSetup.utils import importObjects
 from archetypes.schemaextender.interfaces import IBrowserLayerAwareExtender
 from archetypes.schemaextender.interfaces import IOrderableSchemaExtender
 from archetypes.schemaextender.interfaces import ISchemaExtender
@@ -13,9 +16,11 @@
 from plone.app.blob.interfaces import IATBlobFile
 from plone.app.blob.interfaces import IATBlobImage
 from plone.app.contenttypes.migration import migration
+from plone.app.contenttypes.utils import DEFAULT_TYPES
+from plone.dexterity.interfaces import IDexterityFTI
 from zope.component import getGlobalSiteManager
 from zope.component.hooks import getSite
-
+import os
 import pkg_resources
 
 try:
@@ -27,69 +32,87 @@
     HAS_APP_COLLECTION = True
     from plone.app.collection.interfaces import ICollection
 
+# Is there a multilingual addon?
+try:
+    pkg_resources.get_distribution('Products.LinguaPlone')
+except pkg_resources.DistributionNotFound:
+    HAS_MULTILINGUAL = False
+else:
+    HAS_MULTILINGUAL = True
+
+if not HAS_MULTILINGUAL:
+    try:
+        pkg_resources.get_distribution('plone.app.multilingual')
+    except pkg_resources.DistributionNotFound:
+        HAS_MULTILINGUAL = False
+    else:
+        HAS_MULTILINGUAL = True
+
 ATCT_LIST = {
     "Folder": {
         'iface': IATFolder,
         'migrator': migration.migrate_folders,
         'extended_fields': [],
-        'new_type_name': 'Folder',
+        'type_name': 'Folder',
         'old_meta_type': 'ATFolder',
     },
     "Document": {
         'iface': IATDocument,
         'migrator': migration.migrate_documents,
         'extended_fields': [],
-        'new_type_name': 'Document',
+        'type_name': 'Document',
         'old_meta_type': 'ATDocument',
     },
+    # File without blobs
     "File": {
         'iface': IATFile,
         'migrator': migration.migrate_files,
-        'extended_fields': ['file'],
-        'new_type_name': 'File',
+        'extended_fields': [],
+        'type_name': 'File',
         'old_meta_type': 'ATFile',
     },
+    # Image without blobs
     "Image": {
         'iface': IATImage,
         'migrator': migration.migrate_images,
-        'extended_fields': ['image'],
-        'new_type_name': 'Image',
+        'extended_fields': [],
+        'type_name': 'Image',
         'old_meta_type': 'ATImage',
     },
     "News Item": {
         'iface': IATNewsItem,
         'migrator': migration.migrate_newsitems,
         'extended_fields': [],
-        'new_type_name': 'News Item',
+        'type_name': 'News Item',
         'old_meta_type': 'ATNewsItem',
     },
     "Link": {
         'iface': IATLink,
         'migrator': migration.migrate_links,
         'extended_fields': [],
-        'new_type_name': 'Link',
+        'type_name': 'Link',
         'old_meta_type': 'ATLink',
     },
     "Event": {
         'iface': IATEvent,
         'migrator': migration.migrate_events,
         'extended_fields': [],
-        'new_type_name': 'Event',
+        'type_name': 'Event',
         'old_meta_type': 'ATEvent',
     },
     "BlobImage": {
         'iface': IATBlobImage,
         'migrator': migration.migrate_blobimages,
         'extended_fields': ['image'],
-        'new_type_name': 'Image',
-        'old_meta_type': 'ATBlobImage',
+        'type_name': 'Image',
+        'old_meta_type': 'ATBlob',
     },
     "BlobFile": {
         'iface': IATBlobFile,
         'migrator': migration.migrate_blobfiles,
         'extended_fields': ['file'],
-        'new_type_name': 'File',
-        'old_meta_type': 'ATBlobFile',
+        'type_name': 'File',
+        'old_meta_type': 'ATBlob',
     },
 }
 
@@ -98,7 +121,7 @@
         'iface': ICollection,
         'migrator': migration.migrate_collections,
         'extended_fields': [],
-        'new_type_name': 'Collection',
+        'type_name': 'Collection',
         'old_meta_type': 'Collection',
     }
 
@@ -152,3 +175,27 @@ def _checkForExtenderInterfaces(interface):
             fields = getattr(adapter.factory(None), 'fields', [])
             return [field.getName() for field in fields]
     return []
+
+
+def installTypeIfNeeded(type_name):
+    """Make sure the dexterity-fti is already installed.
+    If not we create a empty dexterity fti and load the
+    information from the fti in the profile.
+    """
+    if type_name not in DEFAULT_TYPES:
+        raise KeyError("%s is not one of the default types" % type_name)
+    portal = getSite()
+    tt = getToolByName(portal, 'portal_types')
+    fti = tt.getTypeInfo(type_name)
+    if IDexterityFTI.providedBy(fti):
+        # the dx-type is already installed
+        return
+    tt.manage_delObjects(type_name)
+    tt.manage_addTypeInformation('Dexterity FTI', id=type_name)
+    dx_fti = tt.getTypeInfo(type_name)
+    ps = getToolByName(portal, 'portal_setup')
+    profile_info = ps.getProfileInfo('profile-plone.app.contenttypes:default')
+    profile_path = os.path.join(profile_info['path'])
+    environ = DirectoryImportContext(ps, profile_path)
+    parent_path = 'types/'
+    importObjects(dx_fti, parent_path, environ)
diff --git a/plone/app/contenttypes/migration/vocabularies.py b/plone/app/contenttypes/migration/vocabularies.py
index e53cbc1..9406106 100644
--- a/plone/app/contenttypes/migration/vocabularies.py
+++ b/plone/app/contenttypes/migration/vocabularies.py
@@ -1,14 +1,20 @@
 # -*- coding: utf-8 -*-
 from Products.CMFCore.utils import getToolByName
+from plone.app.contenttypes import _
 from plone.app.contenttypes.migration.utils import ATCT_LIST
 from plone.app.contenttypes.migration.utils import isSchemaExtended
 from zope.interface import implements
 from zope.schema.interfaces import IVocabularyFactory
 from zope.schema.vocabulary import SimpleVocabulary
-from .. import _
 
 
 def get_terms(context, counter, ext_dict, show_extended):
+    """Takes dicts of types and their numbers and their extended fields
+    Returns a list of SimpleVocabularyTerms:
+    value = meta_type,
+    token = meta_type,
+    title = translated_meta_type (number_of_instances) - extended fields: list
+    """
     results = []
     for k, v in counter.iteritems():
         if not show_extended:
@@ -29,17 +35,21 @@ def get_terms(context, counter, ext_dict, show_extended):
 
 
 def count(brains):
+    """Turns a list of brains into a dict {<meta_type>:<number_of_instances>,}
+    Since Image and File both have the meta_type 'ATBlob' they are handled
+    differently.
+    """
     counter = {}
-    for i in brains:
-        pt = i.portal_type
-        if "Blob" in i.meta_type:
+    for brain in brains:
+        pt = brain.portal_type
+        if "Blob" in brain.meta_type:
             if pt == "File":
                 pt = "BlobFile"
             else:
                 pt = "BlobImage"
         if not counter.get(pt):
             counter[pt] = 0
-        if not i.meta_type or 'dexterity' in i.meta_type.lower():
+        if not brain.meta_type or 'dexterity' in brain.meta_type.lower():
             # There might be DX types with same iface and meta_type than AT
             continue
         counter[pt] += 1
@@ -48,26 +58,27 @@ def count(brains):
 
 def results(context, show_extended=False):
     """Helper method to create the vocabularies used below.
+    Searches the catalog for AT-meta_types to get all Archetypes content.
+    If show_extended is true the returned SimpleVocabulary will include
+    types that are extended beyond what is expected.
     """
     ext_dict = {}
-    ifaces = []
+    meta_types = []
     for k, v in ATCT_LIST.items():
-        iface = v['iface'].__identifier__
         extendend_fields = isSchemaExtended(v['iface'])
         expected = v['extended_fields']
         is_extended = len(extendend_fields) > len(expected)
         if is_extended and show_extended:
-            ifaces.append(iface)
+            meta_types.append(v['old_meta_type'])
             ext_dict[k] = {}
             if expected:
                 extendend_fields.remove(expected[0])
             ext_dict[k]['fields'] = extendend_fields
 
         elif not show_extended and not is_extended:
-            ifaces.append(iface)
-
+            meta_types.append(v['old_meta_type'])
     catalog = getToolByName(context, "portal_catalog")
-    brains = catalog.search({'object_provides': ifaces})
+    brains = catalog.search({'meta_type': meta_types})
     counter = count(brains)
 
     return SimpleVocabulary(get_terms(context,
diff --git a/plone/app/contenttypes/permissions.py b/plone/app/contenttypes/permissions.py
index 7f703aa..9186734 100644
--- a/plone/app/contenttypes/permissions.py
+++ b/plone/app/contenttypes/permissions.py
@@ -2,10 +2,13 @@
 from AccessControl.SecurityInfo import ModuleSecurityInfo
 from Products.CMFCore.permissions import setDefaultRoles
 from plone.app.contenttypes.utils import DEFAULT_TYPES
-# http://developer.plone.org/security/custom_permissions.html
+
 security = ModuleSecurityInfo('plone.app.contenttypes')
+
 TYPE_ROLES = ('Manager', 'Site Administrator', 'Owner', 'Contributor')
+
 perms = []
+
 for typename in DEFAULT_TYPES:
     permid = 'Add' + typename
     permname = 'plone.app.contenttypes: Add ' + typename
diff --git a/plone/app/contenttypes/profiles/default/diff_tool.xml b/plone/app/contenttypes/profiles/default/diff_tool.xml
index 836bb33..834b9b6 100644
--- a/plone/app/contenttypes/profiles/default/diff_tool.xml
+++ b/plone/app/contenttypes/profiles/default/diff_tool.xml
@@ -7,6 +7,15 @@
     <type portal_type="Event">
       <field name="any" difftype="Compound Diff for Dexterity types"/>
     </type>
+    <type portal_type="File">
+      <field name="any" difftype="Compound Diff for Dexterity types"/>
+    </type>
+    <type portal_type="Folder">
+      <field name="any" difftype="Compound Diff for Dexterity types"/>
+    </type>
+    <type portal_type="Image">
+      <field name="any" difftype="Compound Diff for Dexterity types"/>
+    </type>
     <type portal_type="Link">
       <field name="any" difftype="Compound Diff for Dexterity types"/>
     </type>
diff --git a/plone/app/contenttypes/profiles/default/types/Collection.xml b/plone/app/contenttypes/profiles/default/types/Collection.xml
index f1b54c1..a525995 100644
--- a/plone/app/contenttypes/profiles/default/types/Collection.xml
+++ b/plone/app/contenttypes/profiles/default/types/Collection.xml
@@ -16,7 +16,7 @@
   <property name="schema"></property>
   <property name="model_source"></property>
   <property name="model_file">plone.app.contenttypes.schema:collection.xml</property>
-  <property name="behaviors">
+  <property name="behaviors" purge="false">
     <element value="plone.app.content.interfaces.INameFromTitle"/>
     <element value="plone.app.contenttypes.behaviors.collection.ICollection"/>
     <element value="plone.app.dexterity.behaviors.discussion.IAllowDiscussion"/>
diff --git a/plone/app/contenttypes/profiles/default/types/Document.xml b/plone/app/contenttypes/profiles/default/types/Document.xml
index 6dd4cd8..169527a 100644
--- a/plone/app/contenttypes/profiles/default/types/Document.xml
+++ b/plone/app/contenttypes/profiles/default/types/Document.xml
@@ -22,7 +22,7 @@
  <property name="schema"></property>
  <property name="model_source"></property>
  <property name="model_file">plone.app.contenttypes.schema:document.xml</property>
- <property name="behaviors">
+ <property name="behaviors" purge="false">
   <element value="plone.app.content.interfaces.INameFromTitle"/>
   <element value="plone.app.dexterity.behaviors.discussion.IAllowDiscussion"/>
   <element value="plone.app.dexterity.behaviors.exclfromnav.IExcludeFromNavigation"/>
diff --git a/plone/app/contenttypes/profiles/default/types/Event.xml b/plone/app/contenttypes/profiles/default/types/Event.xml
index 77d9c62..1958136 100644
--- a/plone/app/contenttypes/profiles/default/types/Event.xml
+++ b/plone/app/contenttypes/profiles/default/types/Event.xml
@@ -25,7 +25,7 @@
  <property name="add_permission">plone.app.contenttypes.addEvent</property>
 
  <!-- Enabled behaviors -->
- <property name="behaviors">
+ <property name="behaviors" purge="false">
   <element value="plone.app.event.dx.behaviors.IEventBasic"/>
   <element value="plone.app.event.dx.behaviors.IEventRecurrence"/>
   <element value="plone.app.event.dx.behaviors.IEventLocation"/>
diff --git a/plone/app/contenttypes/profiles/default/types/File.xml b/plone/app/contenttypes/profiles/default/types/File.xml
index 3e2aaeb..5097df0 100644
--- a/plone/app/contenttypes/profiles/default/types/File.xml
+++ b/plone/app/contenttypes/profiles/default/types/File.xml
@@ -22,7 +22,7 @@
  <property name="schema"></property>
  <property name="model_source"></property>
  <property name="model_file">plone.app.contenttypes.schema:file.xml</property>
- <property name="behaviors">
+ <property name="behaviors" purge="false">
   <element value="plone.app.dexterity.behaviors.metadata.ICategorization"/>
   <element value="plone.app.dexterity.behaviors.metadata.IPublication"/>
   <element value="plone.app.dexterity.behaviors.metadata.IOwnership"/>
diff --git a/plone/app/contenttypes/profiles/default/types/Folder.xml b/plone/app/contenttypes/profiles/default/types/Folder.xml
index 5d2f584..01a3166 100644
--- a/plone/app/contenttypes/profiles/default/types/Folder.xml
+++ b/plone/app/contenttypes/profiles/default/types/Folder.xml
@@ -26,7 +26,7 @@
  <property name="schema"></property>
  <property name="model_source"></property>
  <property name="model_file">plone.app.contenttypes.schema:folder.xml</property>
- <property name="behaviors">
+ <property name="behaviors" purge="false">
   <element value="plone.app.dexterity.behaviors.metadata.IDublinCore"/>
   <element value="plone.app.content.interfaces.INameFromTitle"/>
   <element value="plone.app.dexterity.behaviors.discussion.IAllowDiscussion"/>
diff --git a/plone/app/contenttypes/profiles/default/types/Image.xml b/plone/app/contenttypes/profiles/default/types/Image.xml
index 8f90fdd..453802f 100644
--- a/plone/app/contenttypes/profiles/default/types/Image.xml
+++ b/plone/app/contenttypes/profiles/default/types/Image.xml
@@ -23,7 +23,7 @@
  <property name="schema"></property>
  <property name="model_source"></property>
  <property name="model_file">plone.app.contenttypes.schema:image.xml</property>
- <property name="behaviors">
+ <property name="behaviors" purge="false">
   <element value="plone.app.dexterity.behaviors.metadata.ICategorization"/>
   <element value="plone.app.dexterity.behaviors.metadata.IPublication"/>
   <element value="plone.app.dexterity.behaviors.metadata.IOwnership"/>
diff --git a/plone/app/contenttypes/profiles/default/types/Link.xml b/plone/app/contenttypes/profiles/default/types/Link.xml
index f2c71d9..4851046 100644
--- a/plone/app/contenttypes/profiles/default/types/Link.xml
+++ b/plone/app/contenttypes/profiles/default/types/Link.xml
@@ -22,7 +22,7 @@
  <property name="schema"></property>
  <property name="model_source"></property>
  <property name="model_file">plone.app.contenttypes.schema:link.xml</property>
- <property name="behaviors">
+ <property name="behaviors" purge="false">
   <element value="plone.app.dexterity.behaviors.discussion.IAllowDiscussion"/>
   <element value="plone.app.dexterity.behaviors.id.IShortName"/>
   <element value="plone.app.dexterity.behaviors.metadata.IDublinCore"/>
diff --git a/plone/app/contenttypes/profiles/default/types/News_Item.xml b/plone/app/contenttypes/profiles/default/types/News_Item.xml
index 1df682e..daacf1b 100644
--- a/plone/app/contenttypes/profiles/default/types/News_Item.xml
+++ b/plone/app/contenttypes/profiles/default/types/News_Item.xml
@@ -22,7 +22,7 @@
  <property name="schema"></property>
  <property name="model_source"></property>
  <property name="model_file">plone.app.contenttypes.schema:news_item.xml</property>
- <property name="behaviors">
+ <property name="behaviors" purge="false">
   <element value="plone.app.dexterity.behaviors.metadata.IDublinCore"/>
   <element value="plone.app.contenttypes.behaviors.richtext.IRichText"/>
   <element value="plone.app.content.interfaces.INameFromTitle"/>
diff --git a/plone/app/contenttypes/schema/__init__.py b/plone/app/contenttypes/schema/__init__.py
index e69de29..40a96af 100644
--- a/plone/app/contenttypes/schema/__init__.py
+++ b/plone/app/contenttypes/schema/__init__.py
@@ -0,0 +1 @@
+# -*- coding: utf-8 -*-
diff --git a/plone/app/contenttypes/setuphandlers.py b/plone/app/contenttypes/setuphandlers.py
index e6c1d79..3246133 100644
--- a/plone/app/contenttypes/setuphandlers.py
+++ b/plone/app/contenttypes/setuphandlers.py
@@ -51,15 +51,6 @@ def getNonInstallableProfiles(self):
         return [
             u'plone.app.contenttypes:uninstall',
             u'plone.app.contenttypes:default',
-            u'plone.app.contenttypes:event',
-            u'plone.app.contenttypes:collection',
-            u'plone.app.contenttypes:document',
-            u'plone.app.contenttypes:file',
-            u'plone.app.contenttypes:folder',
-            u'plone.app.contenttypes:image',
-            u'plone.app.contenttypes:link',
-            u'plone.app.contenttypes:newsitem',
-            u'plone.app.contenttypes:core',
         ]
 
 
@@ -244,7 +235,7 @@ def create_news_topic(portal, target_language):
                             description=description)
         aggregator = container['aggregator']
 
-        # Constain types
+        # Constrain types
         allowed_types = ['News Item', ]
         _setup_constrains(container, allowed_types)
 
@@ -255,7 +246,7 @@ def create_news_topic(portal, target_language):
         # Set the Collection criteria.
         #: Sort on the Effective date
         aggregator.sort_on = u'effective'
-        aggregator.reverse_sort = True
+        aggregator.sort_reversed = True
         #: Query by Type and Review State
         aggregator.query = [
             {'i': u'portal_type',
@@ -300,7 +291,7 @@ def create_events_topic(portal, target_language):
         # Set the Collection criteria.
         #: Sort on the Event start date
         aggregator.sort_on = u'start'
-        aggregator.reverse_sort = True
+        aggregator.sort_reversed = True
         #: Query by Type, Review State and Event start date after today
         aggregator.query = [
             {'i': 'portal_type',
diff --git a/plone/app/contenttypes/testing.py b/plone/app/contenttypes/testing.py
index 341a7cc..9e6d8ed 100644
--- a/plone/app/contenttypes/testing.py
+++ b/plone/app/contenttypes/testing.py
@@ -1,20 +1,20 @@
 # -*- coding: utf-8 -*-
 from plone.app.contenttypes.interfaces import IPloneAppContenttypesLayer
+from plone.app.contenttypes.tests.robot.variables import TEST_FOLDER_ID
 from plone.app.event.testing import PAEvent_FIXTURE
-from plone.app.testing import PloneSandboxLayer
-from plone.app.testing import applyProfile
-from plone.app.testing import PLONE_FIXTURE
-from plone.app.testing import IntegrationTesting
+from plone.app.robotframework.testing import REMOTE_LIBRARY_BUNDLE_FIXTURE
 from plone.app.testing import FunctionalTesting
+from plone.app.testing import IntegrationTesting
+from plone.app.testing import PLONE_FIXTURE
+from plone.app.testing import PloneSandboxLayer
 from plone.app.testing import TEST_USER_ID
-from plone.app.testing import setRoles
+from plone.app.testing import applyProfile
 from plone.app.testing import login
+from plone.app.testing import setRoles
 from plone.testing import z2
 from zope.configuration import xmlconfig
 from zope.interface import alsoProvides
-
 import pkg_resources
-from .tests.robot.variables import TEST_FOLDER_ID
 
 
 def set_browserlayer(request):
@@ -133,6 +133,10 @@ def setUpPloneSite(self, portal):
     name="PloneAppContenttypes:Functional"
 )
 PLONE_APP_CONTENTTYPES_ROBOT_TESTING = FunctionalTesting(
-    bases=(PLONE_APP_CONTENTTYPES_FIXTURE, z2.ZSERVER_FIXTURE),
+    bases=(
+        PLONE_APP_CONTENTTYPES_FIXTURE,
+        REMOTE_LIBRARY_BUNDLE_FIXTURE,
+        z2.ZSERVER_FIXTURE
+    ),
     name="PloneAppContenttypes:Robot"
 )
diff --git a/plone/app/contenttypes/tests/robot/keywords.txt b/plone/app/contenttypes/tests/robot/keywords.txt
index 0dfe5ea..25de625 100644
--- a/plone/app/contenttypes/tests/robot/keywords.txt
+++ b/plone/app/contenttypes/tests/robot/keywords.txt
@@ -1,9 +1,13 @@
+*** Settings ***
+
+Library  Remote  ${PLONE_URL}/RobotRemote
+
 Variables  plone/app/contenttypes/tests/robot/variables.py
 
 *** Keywords ***
 
 I am logged in as site owner
-  Log in as site owner
+  Enable autologin as  Site Administrator
 
 Click Edit
   Click Link  xpath=//a[contains(., "Edit")]
@@ -14,27 +18,33 @@ Click Edit
 
 a collection
   [Arguments]  ${title}
-  Go to  ${PLONE_URL}/++add++Collection
-  Wait until page contains  Add Collection
-  Input text  name=form.widgets.IDublinCore.title  ${title}
-  Click Button  Save
-  Wait until page contains  Item created
+  [Return]  ${uid}
+  ${uid} =  Create content  type=Collection  title=${title}
+# Go to  ${PLONE_URL}/++add++Collection
+# Wait until page contains  Add Collection
+# Input text  name=form.widgets.IDublinCore.title  ${title}
+# Click Button  Save
+# Wait until page contains  Item created
 
 a document
   [Arguments]  ${title}
-  Go to  ${PLONE_URL}/++add++Document
-  Wait until page contains  Add Page
-  Input text  name=form.widgets.IDublinCore.title  ${title}
-  Click Button  Save
-  Wait until page contains  Item created
+  [Return]  ${uid}
+  ${uid} =  Create content  type=Document  title=${title}
+# Go to  ${PLONE_URL}/++add++Document
+# Wait until page contains  Add Page
+# Input text  name=form.widgets.IDublinCore.title  ${title}
+# Click Button  Save
+# Wait until page contains  Item created
 
 a event
   [Arguments]  ${title}
-  Go to  ${PLONE_URL}/++add++Event
-  Wait until page contains  Add Event
-  Input text  name=form.widgets.IDublinCore.title  ${title}
-  Click Button  Save
-  Wait until page contains  Item created
+  [Return]  ${uid}
+  ${uid} =  Create content  type=Event  title=${title}
+# Go to  ${PLONE_URL}/++add++Event
+# Wait until page contains  Add Event
+# Input text  name=form.widgets.IDublinCore.title  ${title}
+# Click Button  Save
+# Wait until page contains  Item created
 
 a file
   [Arguments]  ${title}
@@ -47,11 +57,13 @@ a file
 
 a folder
   [Arguments]  ${title}
-  Go to  ${PLONE_URL}/++add++Folder
-  Wait until page contains  Add Folder
-  Input text  name=form.widgets.IDublinCore.title  ${title}
-  Click Button  Save
-  Wait until page contains  Item created
+  [Return]  ${uid}
+  ${uid} =  Create content  type=Folder  title=${title}
+# Go to  ${PLONE_URL}/++add++Folder
+# Wait until page contains  Add Folder
+# Input text  name=form.widgets.IDublinCore.title  ${title}
+# Click Button  Save
+# Wait until page contains  Item created
 
 a image
   [Arguments]  ${title}
@@ -64,11 +76,13 @@ a image
 
 a link
   [Arguments]  ${title}
-  Go to  ${PLONE_URL}/++add++Link
-  Wait until page contains  Add Link
-  Input text  name=form.widgets.IDublinCore.title  ${title}
-  Click Button  Save
-  Wait until page contains  Item created
+  [Return]  ${uid}
+  ${uid} =  Create content  type=Link  title=${title}
+# Go to  ${PLONE_URL}/++add++Link
+# Wait until page contains  Add Link
+# Input text  name=form.widgets.IDublinCore.title  ${title}
+# Click Button  Save
+# Wait until page contains  Item created
 
 a news item
   [Arguments]  ${title}
@@ -129,17 +143,19 @@ fill date field
 
 I set the criteria ${type} in row ${number} to the option '${label}'
   ${criteria_row} =  Convert to String  .querystring-criteria-wrapper:nth-child(${number})
-  Wait until page contains Element  css=${criteria_row} .querystring-criteria-${type} .select2-choice
+  Wait until page contains element  css=${criteria_row} .querystring-criteria-${type} .select2-choice
   Click Element  css=${criteria_row} .querystring-criteria-${type} .select2-choice
-  Wait until page contains Element  xpath=//div[@class='select2-result-label']/descendant-or-self::*[contains(text(), '${label}')]
-  Click Element  xpath=//div[@class='select2-result-label']/descendant-or-self::*[contains(text(), '${label}')]
+  Wait until page contains element  css=.select2-input.select2-focused
+  Input text  css=.select2-input.select2-focused  ${label}\n
+# Click Element  xpath=//div[@class='select2-result-label']/descendant-or-self::*[contains(text(), '${label}')]
 
 I set the criteria ${type} in row ${number} to the options '${label}'
   ${criteria_row} =  Convert to String  .querystring-criteria-wrapper:nth-child(${number})
-  Wait until page contains Element  css=${criteria_row} .querystring-criteria-${type} .select2-choices
+  Wait until page contains element  css=${criteria_row} .querystring-criteria-${type} .select2-choices
   Click Element  css=${criteria_row} .querystring-criteria-${type} .select2-choices
-  Wait until page contains Element  xpath=//div[@class='select2-result-label']/descendant-or-self::*[contains(text(), '${label}')]
-  Click Element  xpath=//div[@class='select2-result-label']/descendant-or-self::*[contains(text(), '${label}')]
+  Wait until page contains element  css=.select2-input.select2-focused
+  Input text  css=.select2-input.select2-focused  ${label}\n
+# Click Element  xpath=//div[@class='select2-result-label']/descendant-or-self::*[contains(text(), '${label}')]
 
 I set the criteria ${type} in row ${number} to the text '${label}'
   ${criteria_row} =  Convert to String  .querystring-criteria-wrapper:nth-child(${number})
diff --git a/plone/app/contenttypes/tests/robot/test_collection_creator_criterion.robot b/plone/app/contenttypes/tests/robot/test_collection_creator_criterion.robot
index f86de5e..6135aca 100644
--- a/plone/app/contenttypes/tests/robot/test_collection_creator_criterion.robot
+++ b/plone/app/contenttypes/tests/robot/test_collection_creator_criterion.robot
@@ -1,42 +1,46 @@
-*** Settings ***
+*** Settings *****************************************************************
 
 Resource  plone/app/robotframework/keywords.robot
+Resource  plone/app/robotframework/saucelabs.robot
 Resource  plone/app/contenttypes/tests/robot/keywords.txt
 
-Test Setup  Run keywords  Open test browser
-Test Teardown  Close all browsers
+Library  Remote  ${PLONE_URL}/RobotRemote
 
-*** Variables ***
+Test Setup  Open SauceLabs test browser
+Test Teardown  Run keywords  Report test status  Close all browsers
 
-*** Test cases ***
 
-Scenario: Test Creator Criterion
+*** Test cases ***************************************************************
+
+Scenario: Test Creator Criterions
     Given a site owner document  Site Owner Document
       And a test user document  Test User Document
-      And a collection  My Collection
-     When I set the collection's creator criterion to  ${TEST_USER_ID}
-     Then the collection should contain  Test User Document
-      And the collection should not contain  Site Owner Document
+      and a logged in site administrator
+      and a collection  My Collection
+     When I set the collection's creator criterion to  ${SITE_OWNER_NAME}
+     Then the collection should not contain  Test User Document
+      And the collection should contain  Site Owner Document
 
 
-*** Keywords ***
+*** Keywords *****************************************************************
 
 a site owner document
     [Arguments]  ${title}
-    Log in as site owner
+    a logged in site owner
     a document  ${title}
+    Disable autologin
 
 a test user document
     [Arguments]  ${title}
-    Log in as test user
+    a logged in test user
     a document  ${title}
-    Log out
-    Log in as site owner
+    Disable autologin
 
 I set the collection's creator criterion to
     [Arguments]  ${criterion}
+    Go to  ${PLONE_URL}/my-collection
     Click Edit
-
+    Wait until page contains  Edit Collection
     I set the criteria index in row 1 to the option 'Creator'
     I set the criteria operator in row 1 to the option 'Is'
     I set the criteria value in row 1 to the text '${criterion}'
diff --git a/plone/app/contenttypes/tests/robot/test_collection_location_criterion.robot b/plone/app/contenttypes/tests/robot/test_collection_location_criterion.robot
index e259537..8259f7b 100644
--- a/plone/app/contenttypes/tests/robot/test_collection_location_criterion.robot
+++ b/plone/app/contenttypes/tests/robot/test_collection_location_criterion.robot
@@ -47,23 +47,25 @@ a folder '${folder-id}' with a document '${document-title}'
 
 I set the collection's relative location criterion to
     [Arguments]  ${criterion}
+    Go to  ${PLONE_URL}/my-collection
     Click Edit
 
     I set the criteria index in row 1 to the option 'Location'
     I set the criteria operator in row 1 to the option 'Relative path'
     I set the criteria value in row 1 to the text '${criterion}'
-    
+
     Click Button  Save
     Wait until page contains  Changes saved
 
 I set the collection's absolute location criterion to
     [Arguments]  ${criterion}
+    Go to  ${PLONE_URL}/my-collection
     Click Edit
 
     I set the criteria index in row 1 to the option 'Location'
     I set the criteria operator in row 1 to the option 'Absolute path'
     I set the criteria value in row 1 to the text '${criterion}'
-    
+
     Sleep  1
     Click Button  Save
     Wait until page contains  Changes saved
diff --git a/plone/app/contenttypes/tests/robot/test_collection_review_state_criterion.robot b/plone/app/contenttypes/tests/robot/test_collection_review_state_criterion.robot
index 393a7a2..8562f50 100644
--- a/plone/app/contenttypes/tests/robot/test_collection_review_state_criterion.robot
+++ b/plone/app/contenttypes/tests/robot/test_collection_review_state_criterion.robot
@@ -24,9 +24,8 @@ Scenario: Test Review state Criterion
 
 a published document
     [Arguments]  ${title}
-    a document  ${title}
-    Click link  css=#plone-contentmenu-workflow a.actionMenuHeader
-    Click Link  workflow-transition-publish
+    ${uid} =  a document  ${title}
+    Fire transition  ${uid}  publish
 
 a private document
     [Arguments]  ${title}
@@ -34,12 +33,13 @@ a private document
 
 I set the collection's review state criterion to
     [Arguments]  ${criterion}
+    Go to  ${PLONE_URL}/my-collection
     Click Edit
 
     I set the criteria index in row 1 to the option 'Review state'
     I set the criteria operator in row 1 to the option 'Is'
     I set the criteria value in row 1 to the options '${criterion}'
-    
+
     Sleep  1
     Click Button  Save
     Wait until page contains  Changes saved
diff --git a/plone/app/contenttypes/tests/robot/test_collection_short_name_criterion.robot b/plone/app/contenttypes/tests/robot/test_collection_short_name_criterion.robot
index 1b89bdb..ab1e1b6 100644
--- a/plone/app/contenttypes/tests/robot/test_collection_short_name_criterion.robot
+++ b/plone/app/contenttypes/tests/robot/test_collection_short_name_criterion.robot
@@ -24,12 +24,13 @@ Test Short name (id) Criterion
 
 I set the collection short name (id) criterion to
     [Arguments]  ${criterion}
+    Go to  ${PLONE_URL}/my-collection
     Click Edit
 
-    I set the criteria index in row 1 to the option 'Short name (id)'
+    I set the criteria index in row 1 to the option 'Short name'
     I set the criteria operator in row 1 to the option 'Is'
     I set the criteria value in row 1 to the text '${criterion}'
-    
+
     Sleep  1
     Click Button  Save
     Wait until page contains  Changes saved
diff --git a/plone/app/contenttypes/tests/robot/test_collection_type_criterion.robot b/plone/app/contenttypes/tests/robot/test_collection_type_criterion.robot
index ff819b3..2ac2c36 100644
--- a/plone/app/contenttypes/tests/robot/test_collection_type_criterion.robot
+++ b/plone/app/contenttypes/tests/robot/test_collection_type_criterion.robot
@@ -24,12 +24,13 @@ Test Type Criterion
 
 I set the collection's type criterion to
     [Arguments]  ${criterion}
+    Go to  ${PLONE_URL}/my-collection
     Click Edit
 
     I set the criteria index in row 1 to the option 'Type'
     I set the criteria operator in row 1 to the option 'Is'
     I set the criteria value in row 1 to the options '${criterion}'
-    
+
     Sleep  1
     Click Button  Save
     Wait until page contains  Changes saved
diff --git a/plone/app/contenttypes/tests/test_behaviors_collection.py b/plone/app/contenttypes/tests/test_behaviors_collection.py
index badf4d9..3354f25 100644
--- a/plone/app/contenttypes/tests/test_behaviors_collection.py
+++ b/plone/app/contenttypes/tests/test_behaviors_collection.py
@@ -24,7 +24,7 @@
 }]
 
 
-class DocumentFunctionalTest(unittest.TestCase):
+class CollectionBehaviorFunctionalTest(unittest.TestCase):
 
     layer = PLONE_APP_CONTENTTYPES_FUNCTIONAL_TESTING
 
diff --git a/plone/app/contenttypes/tests/test_behaviors_leadimage.py b/plone/app/contenttypes/tests/test_behaviors_leadimage.py
index e4bebe4..dcf6fba 100644
--- a/plone/app/contenttypes/tests/test_behaviors_leadimage.py
+++ b/plone/app/contenttypes/tests/test_behaviors_leadimage.py
@@ -18,7 +18,7 @@
 from plone.app.testing import TEST_USER_ID, setRoles
 
 
-class DocumentFunctionalTest(unittest.TestCase):
+class LeadImageBehaviorFunctionalTest(unittest.TestCase):
 
     layer = PLONE_APP_CONTENTTYPES_FUNCTIONAL_TESTING
 
diff --git a/plone/app/contenttypes/tests/test_behaviors_richtext.py b/plone/app/contenttypes/tests/test_behaviors_richtext.py
index 1bc18cc..54bc77f 100644
--- a/plone/app/contenttypes/tests/test_behaviors_richtext.py
+++ b/plone/app/contenttypes/tests/test_behaviors_richtext.py
@@ -25,7 +25,7 @@ def _setupFTI(self):
         fti.behaviors = self._behaviors
 
 
-class RichTextBehaviorTests(RichTextBase, unittest.TestCase):
+class RichTextBehaviorFunctionalTest(RichTextBase, unittest.TestCase):
     """ basic use cases and tests for richtext behavior"""
 
     layer = PLONE_APP_CONTENTTYPES_FUNCTIONAL_TESTING
@@ -60,8 +60,3 @@ def test_richtext_in_edit_form(self):
 
     def test_richtext_behavior(self):
         IRichText.providedBy(self.portal.doc1)
-
-
-def test_suite():
-    from unittest import defaultTestLoader
-    return defaultTestLoader.loadTestsFromName(__name__)
diff --git a/plone/app/contenttypes/tests/test_behaviors_table_of_contents.py b/plone/app/contenttypes/tests/test_behaviors_table_of_contents.py
index 4ec0705..8db0743 100644
--- a/plone/app/contenttypes/tests/test_behaviors_table_of_contents.py
+++ b/plone/app/contenttypes/tests/test_behaviors_table_of_contents.py
@@ -17,7 +17,7 @@
 from plone.app.testing import TEST_USER_ID, setRoles
 
 
-class DocumentFunctionalTest(unittest.TestCase):
+class TableOfContentsBehaviorFunctionalTest(unittest.TestCase):
 
     layer = PLONE_APP_CONTENTTYPES_FUNCTIONAL_TESTING
 
@@ -67,4 +67,4 @@ def test_toc_viewlet_shows_up(self):
         toc_ctl.value = [u"selected"]
         # Submit form
         self.browser.getControl('Save').click()
-        self.assertTrue('<dl id="document-toc"' in self.browser.contents)
+        self.assertTrue('<section id="document-toc"' in self.browser.contents)
diff --git a/plone/app/contenttypes/tests/test_collection.py b/plone/app/contenttypes/tests/test_collection.py
index 0dd3554..3efdf42 100644
--- a/plone/app/contenttypes/tests/test_collection.py
+++ b/plone/app/contenttypes/tests/test_collection.py
@@ -313,6 +313,51 @@ def test_sorting_1(self):
         self.assertTrue(ritem0.CreationDate() > ritem1.CreationDate())
         self.assertTrue(ritem1.CreationDate() > ritem2.CreationDate())
 
+    def test_custom_query(self):
+        portal = self.layer['portal']
+        login(portal, 'admin')
+        query = [{
+            'i': 'portal_type',
+            'o': 'plone.app.querystring.operation.string.is',
+            'v': ['News Item', 'Document'],
+        }]
+        portal.invokeFactory("Collection",
+                             "collection",
+                             title="New Collection",
+                             query=query,
+                             )
+
+        # item 1
+        portal.invokeFactory(id='testnews',
+                             type_name='News Item')
+        item1 = portal.testnews
+        item1.reindexObject()
+
+        # item 2
+        portal.invokeFactory(id="testdoc",
+                             type_name='Document')
+        item2 = portal.testdoc
+        item2.reindexObject()
+
+        collection = portal['collection']
+        wrapped = ICollection_behavior(collection)
+
+        # Test unmodified query
+        results = wrapped.results(batch=False)
+        self.assertEqual(len(results), 2)
+
+        # Test with custom query
+        results = wrapped.results(batch=False,
+                                  custom_query={'portal_type': 'Document'})
+        self.assertEqual(len(results), 1)
+        self.assertEqual(results[0].id, 'testdoc')
+
+        # Test with custom query, which should not find anything
+        results = wrapped.results(batch=False,
+                                  custom_query={'portal_type': 'Document',
+                                                'id': 'bla'})
+        self.assertEqual(len(results), 0)
+
     def test_getFoldersAndImages(self):
         portal = self.layer['portal']
         login(portal, 'admin')
diff --git a/plone/app/contenttypes/tests/test_content_profile.py b/plone/app/contenttypes/tests/test_content_profile.py
index 92e2dff..5c40408 100644
--- a/plone/app/contenttypes/tests/test_content_profile.py
+++ b/plone/app/contenttypes/tests/test_content_profile.py
@@ -182,6 +182,6 @@ def test_news_aggregator_settings(self):
                  ]
         collection = self.portal['news']['aggregator']
         self.assertEqual(collection.sort_on, u'effective')
-        self.assertEqual(collection.reverse_sort, True)
+        self.assertEqual(collection.sort_reversed, True)
         self.assertItemsEqual(collection.query, query)
         self.assertEqual(collection.getLayout(), 'summary_view')
diff --git a/plone/app/contenttypes/tests/test_migration.py b/plone/app/contenttypes/tests/test_migration.py
index f034f16..76e1ff8 100644
--- a/plone/app/contenttypes/tests/test_migration.py
+++ b/plone/app/contenttypes/tests/test_migration.py
@@ -847,12 +847,14 @@ def test_modifield_date_is_unchanged(self):
         # This would result in changed modification-dates on the folders
         # unless this is patched in the migration-view.
         migration_view(
+            migrate=True,
             content_types=['Document'],
             migrate_schemaextended_content=True,
             migrate_references=True,
             from_form=False,
         )
         migration_view(
+            migrate=True,
             content_types=['Folder'],
             migrate_schemaextended_content=True,
             migrate_references=True,
@@ -1265,3 +1267,16 @@ def test_aaa_migration_results_page(self):
         self.assertEqual(stats['Document']['amount_migrated'], 2)
         self.assertEqual(stats['Folder']['amount_migrated'], 2)
         self.assertEqual(stats['Collection']['amount_migrated'], 1)
+
+    def test_migration_view_confirmation(self):
+        set_browserlayer(self.request)
+        # IIntIds is not registered in the test env. So register it here
+        sm = getSiteManager(self.portal)
+        addUtility(sm, IIntIds, IntIds, ofs_name='intids', findroot=False)
+        applyProfile(self.portal, 'plone.app.contenttypes:default')
+        migration_view = getMultiAdapter(
+            (self.portal, self.request),
+            name=u'migrate_from_atct'
+        )
+        results = migration_view()
+        self.assertIn('@@migrate_from_atct?migrate=1', results)
diff --git a/plone/app/contenttypes/tests/test_migration_browser.py b/plone/app/contenttypes/tests/test_migration_browser.py
index d918c54..a9d0924 100644
--- a/plone/app/contenttypes/tests/test_migration_browser.py
+++ b/plone/app/contenttypes/tests/test_migration_browser.py
@@ -1,6 +1,7 @@
 # -*- coding: utf-8 -*-
 from Products.CMFCore.utils import getToolByName
 from plone.dexterity.fti import DexterityFTI
+from plone.dexterity.interfaces import IDexterityFTI
 from plone.app.contenttypes.interfaces import IPloneAppContenttypesLayer
 from plone.app.contenttypes.interfaces import IDocument
 from plone.app.contenttypes.interfaces import IFile
@@ -10,6 +11,7 @@
 from plone.app.contenttypes.interfaces import INewsItem
 from plone.app.contenttypes.testing import \
     PLONE_APP_CONTENTTYPES_INTEGRATION_TESTING
+from plone.app.testing import applyProfile
 from plone.app.testing import TEST_USER_ID, setRoles
 from plone.event.interfaces import IEvent
 from zope.interface import directlyProvides
@@ -94,3 +96,31 @@ def test_fix_interface_for_news_item(self):
         self.portal.restrictedTraverse('fix_base_classes')()
 
         self.assertTrue(INewsItem.providedBy(self.obj))
+
+    def test_install_dx_type_if_needed(self):
+        from plone.app.contenttypes.migration.utils import installTypeIfNeeded
+        tt = self.portal.portal_types
+        tt.manage_delObjects('Document')
+        tt.manage_addTypeInformation(
+            'Factory-based Type Information with dynamic views',
+            id='Document')
+        applyProfile(
+            self.portal,
+            'plone.app.contenttypes:default',
+            blacklisted_steps=['typeinfo'])
+        fti = tt.getTypeInfo('Document')
+        self.assertFalse(IDexterityFTI.providedBy(fti))
+        installTypeIfNeeded('Document')
+        fti = tt.getTypeInfo('Document')
+        self.assertTrue(IDexterityFTI.providedBy(fti))
+
+    def test_install_dx_type_if_needed_wrong_type_name(self):
+        from plone.app.contenttypes.migration.utils import installTypeIfNeeded
+        self.assertRaises(KeyError, installTypeIfNeeded, ['Unknown'])
+        try:
+            installTypeIfNeeded('Unknown')
+        except KeyError as e:
+            self.assertEqual(
+                e.message,
+                'Unknown is not one of the default types'
+            )
diff --git a/plone/app/contenttypes/tests/test_setup.py b/plone/app/contenttypes/tests/test_setup.py
index 87fe047..650c92b 100644
--- a/plone/app/contenttypes/tests/test_setup.py
+++ b/plone/app/contenttypes/tests/test_setup.py
@@ -39,7 +39,8 @@ def test_browserlayer_available(self):
         )
 
     def test_css_registered(self):
-        cssreg = getattr(self.portal, 'portal_css')
-        stylesheets_ids = cssreg.getResourceIds()
+        resreg = getattr(self.portal, 'portal_registry')
+        from Products.CMFPlone.interfaces import IResourceRegistry
+        resources_ids = resreg.collectionOfInterface(IResourceRegistry, prefix="plone.resources").keys()
         self.assertTrue(
-            '++resource++collection.css' in stylesheets_ids)
+            'resource-collection-css' in resources_ids)
diff --git a/plone/app/contenttypes/upgrades.py b/plone/app/contenttypes/upgrades.py
index 0660b20..5615b06 100644
--- a/plone/app/contenttypes/upgrades.py
+++ b/plone/app/contenttypes/upgrades.py
@@ -65,11 +65,25 @@ def enable_collection_behavior(context):
 def migrate_to_richtext(context):
     """Update fti's to add RichText behaviors and remove old text-fields."""
 
-    # TODO: Don't reload the profile. Only change the settings.
-    context.runImportStepFromProfile(
-        'profile-plone.app.contenttypes:default',
-        'typeinfo',
-    )
+    behavior = "plone.app.contenttypes.behaviors.richtext.IRichText"
+    types = [
+        "Document",
+        "News Item",
+        "Event",
+        "Collection",
+    ]
+    for type_name in types:
+        fti = queryUtility(
+            IDexterityFTI,
+            name=type_name
+        )
+        if not fti:
+            continue
+        if behavior in fti.behaviors:
+            continue
+        behaviors = list(fti.behaviors)
+        behaviors.append(behavior)
+        fti._updateProperty('behaviors', tuple(behaviors))
 
 
 def migrate_album_view(context):
diff --git a/setup.py b/setup.py
index 0200426..76da20a 100644
--- a/setup.py
+++ b/setup.py
@@ -2,7 +2,7 @@
 
 import os
 
-version = '1.2a4.dev0'
+version = '1.2a5.dev0'
 
 
 def read(*rnames):
@@ -39,8 +39,9 @@ def read(*rnames):
           'setuptools',
           'Products.CMFPlone',
           'plone.app.contentmenu',
-          'plone.app.event >= 2.0a1',
+          'plone.app.event >= 2.0a4',
           'plone.app.dexterity >= 2.0.7',  # has a fix for INameFromFilename
+          'plone.app.querystring >= 1.2.2',  # custom_query support
           'plone.dexterity >= 2.2.1',  # behaviors can provide primaryfields
           'plone.app.relationfield',
           'plone.namedfile [blobs]',
diff --git a/test-plone-4.3.x.cfg b/test-plone-4.3.x.cfg
index 346a2f5..39683d3 100644
--- a/test-plone-4.3.x.cfg
+++ b/test-plone-4.3.x.cfg
@@ -66,7 +66,7 @@ eggs = jarn.mkrelease
 
 [autopep8]
 recipe = zc.recipe.egg
-eggs = autopep8 
+eggs = autopep8
 
 [zopepy]
 recipe = zc.recipe.egg
@@ -115,11 +115,11 @@ plone.app.jquery = 1.8.3
 
 # testing
 plone.app.testing = 4.2.4
-plone.app.robotframework = 0.8.1
+plone.app.robotframework = 0.9.5
 robotframework = 2.8.4
 robotframework-selenium2library = 1.5.0
 robotsuite = 1.4.3
-selenium = 2.39.0
+selenium = 2.43.0
 robotframework-selenium2screenshots = 0.4.0
 sphinxcontrib-robotframework = 0.4.3
 Pygments = 1.6


Repository: plone.app.contenttypes
Branch: refs/heads/master
Date: 2014-10-23T17:56:30+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.app.contenttypes/commit/6f4fa82b39713f9cbd8fcf103186874f6fed18ff

fix test by installing only the news item before migration

Files changed:
M plone/app/contenttypes/tests/test_migration_custom.py

diff --git a/plone/app/contenttypes/tests/test_migration_custom.py b/plone/app/contenttypes/tests/test_migration_custom.py
index 4f26f79..63887b0 100644
--- a/plone/app/contenttypes/tests/test_migration_custom.py
+++ b/plone/app/contenttypes/tests/test_migration_custom.py
@@ -1,11 +1,15 @@
 # -*- coding: utf-8 -*-
+from plone.app.contenttypes.migration.migration import migrate_imagefield
+from plone.app.contenttypes.migration.migration import migrate_simplefield
+from plone.app.contenttypes.migration.utils import installTypeIfNeeded
 from plone.app.contenttypes.testing import \
     PLONE_APP_CONTENTTYPES_MIGRATION_TESTING
+from plone.app.testing import TEST_USER_ID
 from plone.app.testing import applyProfile
+from plone.app.testing import setRoles
+
 import os.path
 import unittest2 as unittest
-from plone.app.testing import TEST_USER_ID, setRoles
-from plone.app.contenttypes.migration.migration import migrate_imagefield, migrate_simplefield
 
 
 class MigrateFieldsTest(unittest.TestCase):
@@ -169,7 +173,13 @@ def test_migrate_extended_document(self):
             migrateCustomAT
         from plone.app.contenttypes.interfaces import INewsItem
         at_document = self.createCustomATDocument('foo-document')
-        applyProfile(self.portal, 'plone.app.contenttypes:default')
+        qi = self.portal.portal_quickinstaller
+        # install pac but only install News Items
+        qi.installProduct(
+            'plone.app.contenttypes',
+            profile='plone.app.contenttypes:default',
+            blacklistedSteps=['typeinfo'])
+        installTypeIfNeeded("News Item")
         fields_mapping = ({'AT_field_name': 'textExtended',
                            'AT_field_type': 'TextField',
                            'DX_field_name': 'text',
@@ -178,6 +188,7 @@ def test_migrate_extended_document(self):
                            'AT_field_type': 'StringField',
                            'DX_field_name': 'title',
                            'DX_field_type': 'StringField', },)
+        # migrate extended AT Document to default DX News Item
         migrateCustomAT(fields_mapping, src_type='Document', dst_type='News Item')
         dx_newsitem = self.portal['foo-document']
         self.assertTrue(INewsItem.providedBy(dx_newsitem))


Repository: plone.app.contenttypes
Branch: refs/heads/master
Date: 2014-10-24T13:32:43+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.app.contenttypes/commit/690df1adb32206831ca1a60f9c6c85507b00df2e

remove merge-residuum

Files changed:
M docs/CHANGES.rst

diff --git a/docs/CHANGES.rst b/docs/CHANGES.rst
index 5b21afe..2369420 100644
--- a/docs/CHANGES.rst
+++ b/docs/CHANGES.rst
@@ -60,7 +60,6 @@ Changelog
 - When replacing the default news and events collections, reverse the
   sort order correctly.
   [maurits]
->>>>>>> master
 
 - Added migration method that allows to migrate custom AT types to
   available DX types (#133)


Repository: plone.app.contenttypes
Branch: refs/heads/master
Date: 2014-11-01T12:15:51Z
Author: Andrea Cecchi (cekk) <andrea.cecchi85@gmail.com>
Commit: https://github.com/plone/plone.app.contenttypes/commit/eb707df72e51d2c0e85a1ab23cd9a4977b79dd53

add docstrings and removed unused parameters

Files changed:
M plone/app/contenttypes/migration/migration.py

diff --git a/plone/app/contenttypes/migration/migration.py b/plone/app/contenttypes/migration/migration.py
index 7860322..977ab07 100644
--- a/plone/app/contenttypes/migration/migration.py
+++ b/plone/app/contenttypes/migration/migration.py
@@ -39,7 +39,10 @@
 logger = logging.getLogger(__name__)
 
 
-def migrate_simplefield(src_obj, dst_obj, src_fieldname, dst_fieldname, dst_fieldtype):
+def migrate_simplefield(src_obj, dst_obj, src_fieldname, dst_fieldname):
+    """
+    migrate a generic simple field (like a string field or a date field)
+    """
     field = src_obj.getField(src_fieldname)
     if field:
         at_value = field.get(src_obj)
@@ -51,7 +54,11 @@ def migrate_simplefield(src_obj, dst_obj, src_fieldname, dst_fieldname, dst_fiel
         setattr(dst_obj, dst_fieldname, at_value)
 
 
-def migrate_textfield(src_obj, dst_obj, src_fieldname, dst_fieldname, dst_fieldtype):
+def migrate_richtextfield(src_obj, dst_obj, src_fieldname, dst_fieldname):
+    """
+    migrate a rich text field.
+    This field needs some extra stuffs like keep the same mimetype.
+    """
     field = src_obj.getField(src_fieldname)
     raw_text = ''
     if field:
@@ -70,7 +77,11 @@ def migrate_textfield(src_obj, dst_obj, src_fieldname, dst_fieldname, dst_fieldt
     setattr(dst_obj, dst_fieldname, richtext)
 
 
-def migrate_imagefield(src_obj, dst_obj, src_fieldname, dst_fieldname, dst_fieldtype):
+def migrate_imagefield(src_obj, dst_obj, src_fieldname, dst_fieldname):
+    """
+    migrate an image field.
+    This field needs to be migrated with an NamedBlobImage instance.
+    """
     old_image = src_obj.getField(src_fieldname).get(src_obj)
     if old_image == '':
         return
@@ -87,8 +98,10 @@ def migrate_imagefield(src_obj, dst_obj, src_fieldname, dst_fieldname, dst_field
     logger.info("Migrating image %s" % filename)
 
 
-def migrate_filefield(src_obj, dst_obj, src_fieldname, dst_fieldname, dst_fieldtype):
+def migrate_filefield(src_obj, dst_obj, src_fieldname, dst_fieldname):
     """
+    migrate an image field.
+    This field needs to be migrated with an NamedBlobFile instance.
     BBB to be tested
     """
     old_file = src_obj.getField(src_fieldname).get(src_obj)
@@ -104,7 +117,8 @@ def migrate_filefield(src_obj, dst_obj, src_fieldname, dst_fieldname, dst_fieldt
     logger.info("Migrating file %s" % filename)
 
 
-FIELDS_MAPPING = {'TextField': migrate_textfield,
+#this mapping is needed to use the right migration method
+FIELDS_MAPPING = {'TextField': migrate_richtextfield,
                   'FileField': migrate_filefield,
                   'ImageField': migrate_imagefield}
 


Repository: plone.app.contenttypes
Branch: refs/heads/master
Date: 2014-11-01T16:14:53Z
Author: Florent Michon (flohcim) <florent.michon@gmail.com>
Commit: https://github.com/plone/plone.app.contenttypes/commit/db9a21a70d365d77edd8b63752a76c803992abb1

Removes a parameter useless which is not in the prototype of the called methods.

Files changed:
M plone/app/contenttypes/migration/migration.py

diff --git a/plone/app/contenttypes/migration/migration.py b/plone/app/contenttypes/migration/migration.py
index 977ab07..9ab9083 100644
--- a/plone/app/contenttypes/migration/migration.py
+++ b/plone/app/contenttypes/migration/migration.py
@@ -626,15 +626,13 @@ def migrate_schema_fields(self):
                 at_fieldname = fields_dict.get('AT_field_name')
                 at_fieldtype = fields_dict.get('AT_field_type')
                 dx_fieldname = fields_dict.get('DX_field_name')
-                dx_fieldtype = fields_dict.get('DX_field_type')
                 migration_field_method = migrate_simplefield
                 if at_fieldtype in FIELDS_MAPPING:
                     migration_field_method = FIELDS_MAPPING[at_fieldtype]
                 migration_field_method(src_obj=self.old,
                                        dst_obj=self.new,
                                        src_fieldname=at_fieldname,
-                                       dst_fieldname=dx_fieldname,
-                                       dst_fieldtype=dx_fieldtype)
+                                       dst_fieldname=dx_fieldname)
 
     return CustomATMigrator
 


Repository: plone.app.contenttypes
Branch: refs/heads/master
Date: 2014-11-01T17:02:19Z
Author: tiazma (tiazma) <mbroquet@atreal.fr>
Commit: https://github.com/plone/plone.app.contenttypes/commit/9b9101227f12d6321e6e416092643f88412a488f

Correct mapping to support full field type path

Files changed:
M plone/app/contenttypes/migration/migration.py

diff --git a/plone/app/contenttypes/migration/migration.py b/plone/app/contenttypes/migration/migration.py
index 9ab9083..a45715c 100644
--- a/plone/app/contenttypes/migration/migration.py
+++ b/plone/app/contenttypes/migration/migration.py
@@ -117,10 +117,14 @@ def migrate_filefield(src_obj, dst_obj, src_fieldname, dst_fieldname):
     logger.info("Migrating file %s" % filename)
 
 
-#this mapping is needed to use the right migration method
-FIELDS_MAPPING = {'TextField': migrate_richtextfield,
-                  'FileField': migrate_filefield,
-                  'ImageField': migrate_imagefield}
+# this mapping is needed to use the right migration method
+# XXX we use the full field type path as it is retrieved from the field
+# (fiel.getType()), to avoid conflict. In the __future__ we should have a more
+# dynamic way to configure this mapping
+FIELDS_MAPPING = {'Products.Archetypes.Field.TextField': migrate_richtextfield,
+                  'Products.Archetypes.Field.FileField': migrate_filefield,
+                  'plone.app.blob.field.FileField': migrate_filefield,
+                  'Products.Archetypes.Field.ImageField': migrate_imagefield}
 
 
 def migrate(portal, migrator):


Repository: plone.app.contenttypes
Branch: refs/heads/master
Date: 2014-11-01T18:51:50Z
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.app.contenttypes/commit/dfd7b9082eb76a19a4f9eb0c4ed5b95d3da91804

Add methods to get AT-Types that were removed and get the schema from their instances

Files changed:
M docs/CHANGES.rst
M plone/app/contenttypes/migration/custom_migration.py

diff --git a/docs/CHANGES.rst b/docs/CHANGES.rst
index 2369420..ad7c6db 100644
--- a/docs/CHANGES.rst
+++ b/docs/CHANGES.rst
@@ -4,6 +4,10 @@ Changelog
 1.2a5 (unreleased)
 ------------------
 
+- Add methods to get AT-Types that were removed and get the schema from their
+  instances.
+  [pbauer]
+
 - Added helper view for migration custom AT types to available DX types,
   see issue #133.
   [gbastien]
diff --git a/plone/app/contenttypes/migration/custom_migration.py b/plone/app/contenttypes/migration/custom_migration.py
index 134e1e1..22c9340 100644
--- a/plone/app/contenttypes/migration/custom_migration.py
+++ b/plone/app/contenttypes/migration/custom_migration.py
@@ -1,6 +1,7 @@
 # -*- coding: UTF-8 -*-
 from zope.i18n import translate
 from Products.Five.browser import BrowserView
+from plone.dexterity.interfaces import IDexterityContent
 from plone.dexterity.interfaces import IDexterityFTI
 from plone.dexterity.utils import iterSchemataForType
 from Products.CMFCore.utils import getToolByName
@@ -62,6 +63,24 @@ def getATFTIs(self):
                                 'title': fti.Title()})
         return results
 
+    def getATTypesWithoutFTI(self):
+        """Returns a list of the id's of archetypes-types that are
+           not registered in portal_types but still have instances.
+        """
+        results = []
+        all_registered_types = [i['id'] for i in self.getATFTIs()]
+        catalog = getToolByName(self.context, 'portal_catalog')
+        for meta_type in catalog.uniqueValuesFor('meta_type'):
+            # querying for meta_type will only return at-types
+            brain = catalog(meta_type=meta_type, sort_limit=1)[0]
+            if IDexterityContent.providedBy(brain.getObject()):
+                continue
+            typename = brain.portal_type
+            if typename not in all_registered_types:
+                    results.append({'id': typename,
+                                    'title': typename})
+        return results
+
     def getDXFTIs(self):
         '''Returns the FTI's of all DX-Types (including default-types).'''
         results = []
@@ -100,6 +119,26 @@ def getFieldsForATType(self, typename):
                                 'type': field.getType()})
         return results
 
+    def getFieldsForATTypeWithoutFTI(self, typename):
+        """Returns a list of fields for archetypes-types without a fti.
+           Instead of iterating over the schema in the fti it takes one
+           instance and gets the schema from that.
+        """
+        catalog = getToolByName(self.context, 'portal_catalog')
+        results = []
+        brains = catalog(portal_type=typename, sort_limit=1)
+        if not brains:
+            return results
+        obj = brains[0].getObject()
+        for field_name in obj.schema._fields:
+            field = obj.schema._fields[field_name]
+            if not field.getName() in self.at_metadata_fields:
+                translated_label = translate(field.widget.label)
+                results.append({'id': field.getName(),
+                                'title': '%s (%s)' % (translated_label, field.getType()),
+                                'type': field.getType()})
+        return results
+
     def getFieldsForDXType(self, typename):
         '''Returns schema fields (name and type) for the given DX typename.'''
         results = []


Repository: plone.app.contenttypes
Branch: refs/heads/master
Date: 2014-11-01T19:41:45Z
Author: Andrea Cecchi (cekk) <andrea.cecchi85@gmail.com>
Commit: https://github.com/plone/plone.app.contenttypes/commit/a5a0966098ae4a1696e20d8adc24539d62922ea1

fixed tests

Files changed:
M plone/app/contenttypes/tests/test_migration_custom.py

diff --git a/plone/app/contenttypes/tests/test_migration_custom.py b/plone/app/contenttypes/tests/test_migration_custom.py
index 63887b0..59b6b10 100644
--- a/plone/app/contenttypes/tests/test_migration_custom.py
+++ b/plone/app/contenttypes/tests/test_migration_custom.py
@@ -51,7 +51,7 @@ def test_migrate_stringfield(self):
                                                    title="Bar document")
         at_document = self.portal[at_document_id]
         dx_document = self.portal[dx_document_id]
-        migrate_simplefield(at_document, dx_document, 'title', 'title', '')
+        migrate_simplefield(at_document, dx_document, 'title', 'title')
         self.assertEqual(dx_document.Title(), at_document.Title())
 
     def test_migrate_richtextfield(self):
@@ -68,7 +68,7 @@ def test_migrate_richtextfield(self):
         at_document = self.portal[at_document_id]
         dx_document = self.portal[dx_document_id]
         self.assertEqual(dx_document.text, None)
-        migrate_simplefield(at_document, dx_document, 'text', 'text', '')
+        migrate_simplefield(at_document, dx_document, 'text', 'text')
         self.assertEqual(dx_document.text, at_document.getText())
 
     def test_migrate_listfield(self):
@@ -84,7 +84,7 @@ def test_migrate_listfield(self):
                                                    title="Bar document")
         at_document = self.portal[at_document_id]
         dx_document = self.portal[dx_document_id]
-        migrate_simplefield(at_document, dx_document, 'subject', 'subject', '')
+        migrate_simplefield(at_document, dx_document, 'subject', 'subject',)
         self.assertEqual(dx_document.Subject(), at_document.Subject())
 
     def test_migrate_imagefield(self):
@@ -101,7 +101,7 @@ def test_migrate_imagefield(self):
         at_newsitem = self.portal[at_newsitem_id]
         dx_newsitem = self.portal[dx_newsitem_id]
         self.assertEqual(dx_newsitem.image, None)
-        migrate_imagefield(at_newsitem, dx_newsitem, 'image', 'image', '')
+        migrate_imagefield(at_newsitem, dx_newsitem, 'image', 'image')
         self.assertEqual(dx_newsitem.image.contentType, 'image/png')
         self.assertEqual(dx_newsitem.image.data, test_image_data)
 


Repository: plone.app.contenttypes
Branch: refs/heads/master
Date: 2014-11-01T19:42:18Z
Author: tiazma (tiazma) <mbroquet@atreal.fr>
Commit: https://github.com/plone/plone.app.contenttypes/commit/b75636de1a3a8107dfe421bb2fc40893bf8ba52f

Change a semantic's comment XXX &gt; TODO

Files changed:
M plone/app/contenttypes/migration/migration.py

diff --git a/plone/app/contenttypes/migration/migration.py b/plone/app/contenttypes/migration/migration.py
index a45715c..21457c6 100644
--- a/plone/app/contenttypes/migration/migration.py
+++ b/plone/app/contenttypes/migration/migration.py
@@ -118,9 +118,10 @@ def migrate_filefield(src_obj, dst_obj, src_fieldname, dst_fieldname):
 
 
 # this mapping is needed to use the right migration method
-# XXX we use the full field type path as it is retrieved from the field
-# (fiel.getType()), to avoid conflict. In the __future__ we should have a more
-# dynamic way to configure this mapping
+# we use the full field type path as it is retrieved from the field
+# (fiel.getType()), to avoid conflict. 
+# TODO In the __future__ we should have a more dynamic way to configure this 
+# mapping
 FIELDS_MAPPING = {'Products.Archetypes.Field.TextField': migrate_richtextfield,
                   'Products.Archetypes.Field.FileField': migrate_filefield,
                   'plone.app.blob.field.FileField': migrate_filefield,


Repository: plone.app.contenttypes
Branch: refs/heads/master
Date: 2014-11-01T19:42:41Z
Author: Andrea Cecchi (cekk) <andrea.cecchi85@gmail.com>
Commit: https://github.com/plone/plone.app.contenttypes/commit/6939ac1229ef9db67067fa29651f378a1c04e4b8

some fixes to the migration and add dry_run support for testing a migration configuration

Files changed:
M plone/app/contenttypes/migration/migration.py

diff --git a/plone/app/contenttypes/migration/migration.py b/plone/app/contenttypes/migration/migration.py
index 977ab07..21aa888 100644
--- a/plone/app/contenttypes/migration/migration.py
+++ b/plone/app/contenttypes/migration/migration.py
@@ -25,15 +25,17 @@
 from Products.contentmigration.basemigrator.migrator import CMFFolderMigrator
 from Products.contentmigration.basemigrator.migrator import CMFItemMigrator
 from Products.contentmigration.basemigrator.walker import CatalogWalker
+from Products.contentmigration.walker import CustomQueryWalker
+import transaction
 from z3c.relationfield import RelationValue
 from zope.component import adapter
 from zope.component import getAdapters
+from zope.component import getMultiAdapter
 from zope.component import getUtility
 from zope.component.hooks import getSite
 from zope.interface import implementer
 from zope.interface import Interface
 from zope.intid.interfaces import IIntIds
-
 import logging
 
 logger = logging.getLogger(__name__)
@@ -609,7 +611,7 @@ def migrate_events(portal):
     migrate(portal, DXEventMigrator)
 
 
-def makeCustomATMigrator(context, src_type, dst_type, fields_mapping, is_folderish=False):
+def makeCustomATMigrator(context, src_type, dst_type, fields_mapping, is_folderish=False, dry_run=False):
     """ generate a migrator for the given at-based folderish portal type """
 
     base_class = ATCTContentMigrator
@@ -620,28 +622,37 @@ class CustomATMigrator(base_class):
 
         src_portal_type = src_type
         dst_portal_type = dst_type
+        dry_run_mode = dry_run
 
         def migrate_schema_fields(self):
             for fields_dict in fields_mapping:
                 at_fieldname = fields_dict.get('AT_field_name')
                 at_fieldtype = fields_dict.get('AT_field_type')
                 dx_fieldname = fields_dict.get('DX_field_name')
-                dx_fieldtype = fields_dict.get('DX_field_type')
                 migration_field_method = migrate_simplefield
                 if at_fieldtype in FIELDS_MAPPING:
                     migration_field_method = FIELDS_MAPPING[at_fieldtype]
                 migration_field_method(src_obj=self.old,
                                        dst_obj=self.new,
                                        src_fieldname=at_fieldname,
-                                       dst_fieldname=dx_fieldname,
-                                       dst_fieldtype=dx_fieldtype)
+                                       dst_fieldname=dx_fieldname)
+
+        def last_migrate_check(self):
+            """
+            BBB to be checked
+            if there is an error with the fields, an exception will be raised.
+            """
+            if self.dry_run_mode:
+                view = getMultiAdapter((self.new, self.new.REQUEST), name="view")
+                view()
 
     return CustomATMigrator
 
 
-def migrateCustomAT(fields_mapping, src_type, dst_type):
+def migrateCustomAT(fields_mapping, src_type, dst_type, dry_run=False):
     """
-    try to get types infos from archetype_tool, then set a migrator an pass it given values
+    Try to get types infos from archetype_tool, then set a migrator an pass it given values.
+    There is a dry_run mode that allows to check the success of a migration without committing.
     """
     portal = getSite()
     archetype_tool = getToolByName(portal, 'archetype_tool', None)
@@ -657,12 +668,38 @@ def migrateCustomAT(fields_mapping, src_type, dst_type):
         if info.get('meta_type') == src_meta_type:
             src_type_infos = info
     is_folderish = src_type_infos.get('klass').isPrincipiaFolderish
+    #to be removed when this parameter comes from the view
+    dry_run = True
     migrator = makeCustomATMigrator(context=portal,
                                     src_type=src_type,
                                     dst_type=dst_type,
                                     fields_mapping=fields_mapping,
-                                    is_folderish=is_folderish)
+                                    is_folderish=is_folderish,
+                                    dry_run=dry_run)
     if migrator:
         migrator.src_meta_type = src_meta_type
         migrator.dst_meta_type = ''
-        migrate(portal, migrator)
+        walker_settings = {'portal': portal,
+                           'migrator': migrator,
+                           'src_portal_type': src_type,
+                           'dst_portal_type': dst_type,
+                           'src_meta_type': src_meta_type,
+                           'dst_meta_type': '',
+                           'use_savepoint': True}
+        if dry_run:
+            tools = getMultiAdapter((portal, portal.REQUEST), name=u'plone_tools')
+            portal_catalog = tools.catalog()
+            #BBB search_limit doesn't seems working
+            test_search = portal_catalog(portal_type=src_type, search_limit=1)
+            if test_search:
+                walker_settings['query'] = {'UID': test_search[0].UID}
+        walker = CustomQueryWalker(**walker_settings)
+        walker.go()
+        walker_infos = {'errors': walker.errors,
+                        'msg': walker.getOutput().splitlines(),
+                        'counter': walker.counter}
+        for error in walker.errors:
+            logger.error(error.get('message'))
+        if dry_run:
+            transaction.abort()
+        return walker_infos


Repository: plone.app.contenttypes
Branch: refs/heads/master
Date: 2014-11-01T19:43:02Z
Author: Andrea Cecchi (cekk) <andrea.cecchi85@gmail.com>
Commit: https://github.com/plone/plone.app.contenttypes/commit/f19ada5ebded92c320958da1c2282aaa7e32206f

fix view to handle differrent status messages

Files changed:
M plone/app/contenttypes/migration/custom_migration.py

diff --git a/plone/app/contenttypes/migration/custom_migration.py b/plone/app/contenttypes/migration/custom_migration.py
index 134e1e1..100be51 100644
--- a/plone/app/contenttypes/migration/custom_migration.py
+++ b/plone/app/contenttypes/migration/custom_migration.py
@@ -6,9 +6,9 @@
 from Products.CMFCore.utils import getToolByName
 from Products.Five.browser.pagetemplatefile import ViewPageTemplateFile
 from Products.ATContentTypes.content.schemata import ATContentTypeSchema
+from Products.statusmessages.interfaces import IStatusMessage
 from plone.app.contenttypes.migration.migration import migrateCustomAT
 
-
 HAS_EXTENDER = True
 try:
     from archetypes.schemaextender.extender import instanceSchemaFactory
@@ -34,10 +34,18 @@ def __call__(self):
         submitted = form.get('form.button.Migrate', False)
         if submitted:
             # proceed, call the migration methdd
-            self.migrate()
-            msg = translate('Migration applied.',
-                            domain='plone.app.contenttypes')
-            self.context.plone_utils.addPortalMessage(msg)
+            results = self.migrate()
+            messages = IStatusMessage(self.request)
+            for migration_result in results:
+                res_type = migration_result.get('type')
+                res_infos = migration_result.get('infos')
+                if res_infos.get('errors'):
+                    messages.add(u'Error when migrating "%s" type. Check the log for other informations.' % res_type, type=u"error")
+                else:
+                    msg = translate('Migration applied succesfully for %s "%s" items.' % (res_infos.get('counter'),
+                                                                                          res_type),
+                                domain='plone.app.contenttypes')
+                    messages.add(msg, type=u"info")
         elif cancelled:
             self.request.response.redirect(form.get('form.HTTP_REFERER'))
         return self.index()
@@ -165,9 +173,13 @@ def migrate(self):
                     data[at_typename][dx_typename].append(field_data)
 
         # now that the data dict contains relevant information, we can call the custom migrator
+        migration_results = []
         for at_typename, dx_mappings in data.items():
             for k, v in dx_mappings.items():
-                migrateCustomAT(fields_mapping=v, src_type=at_typename, dst_type=dx_typename)
+                res = migrateCustomAT(fields_mapping=v, src_type=at_typename, dst_type=dx_typename)
+                migration_results.append({'type': at_typename,
+                                          'infos': res})
+        return migration_results
 
 
 class DisplayDXFields(CustomMigrationForm):


Repository: plone.app.contenttypes
Branch: refs/heads/master
Date: 2014-11-01T19:44:45Z
Author: Andrea Cecchi (cekk) <andrea.cecchi85@gmail.com>
Commit: https://github.com/plone/plone.app.contenttypes/commit/068f07b929d6caf1c075d2aa74e9af76a6130ae0

Merge branch 'issue133_custom_types_migration' of git://github.com/plone/plone.app.contenttypes into issue133_custom_types_migration

Conflicts:
	plone/app/contenttypes/migration/migration.py

Files changed:
M docs/CHANGES.rst
M plone/app/contenttypes/migration/custom_migration.py
M plone/app/contenttypes/migration/migration.py

diff --git a/docs/CHANGES.rst b/docs/CHANGES.rst
index 2369420..ad7c6db 100644
--- a/docs/CHANGES.rst
+++ b/docs/CHANGES.rst
@@ -4,6 +4,10 @@ Changelog
 1.2a5 (unreleased)
 ------------------
 
+- Add methods to get AT-Types that were removed and get the schema from their
+  instances.
+  [pbauer]
+
 - Added helper view for migration custom AT types to available DX types,
   see issue #133.
   [gbastien]
diff --git a/plone/app/contenttypes/migration/custom_migration.py b/plone/app/contenttypes/migration/custom_migration.py
index 100be51..27a5c0d 100644
--- a/plone/app/contenttypes/migration/custom_migration.py
+++ b/plone/app/contenttypes/migration/custom_migration.py
@@ -1,6 +1,7 @@
 # -*- coding: UTF-8 -*-
 from zope.i18n import translate
 from Products.Five.browser import BrowserView
+from plone.dexterity.interfaces import IDexterityContent
 from plone.dexterity.interfaces import IDexterityFTI
 from plone.dexterity.utils import iterSchemataForType
 from Products.CMFCore.utils import getToolByName
@@ -70,6 +71,24 @@ def getATFTIs(self):
                                 'title': fti.Title()})
         return results
 
+    def getATTypesWithoutFTI(self):
+        """Returns a list of the id's of archetypes-types that are
+           not registered in portal_types but still have instances.
+        """
+        results = []
+        all_registered_types = [i['id'] for i in self.getATFTIs()]
+        catalog = getToolByName(self.context, 'portal_catalog')
+        for meta_type in catalog.uniqueValuesFor('meta_type'):
+            # querying for meta_type will only return at-types
+            brain = catalog(meta_type=meta_type, sort_limit=1)[0]
+            if IDexterityContent.providedBy(brain.getObject()):
+                continue
+            typename = brain.portal_type
+            if typename not in all_registered_types:
+                    results.append({'id': typename,
+                                    'title': typename})
+        return results
+
     def getDXFTIs(self):
         '''Returns the FTI's of all DX-Types (including default-types).'''
         results = []
@@ -108,6 +127,26 @@ def getFieldsForATType(self, typename):
                                 'type': field.getType()})
         return results
 
+    def getFieldsForATTypeWithoutFTI(self, typename):
+        """Returns a list of fields for archetypes-types without a fti.
+           Instead of iterating over the schema in the fti it takes one
+           instance and gets the schema from that.
+        """
+        catalog = getToolByName(self.context, 'portal_catalog')
+        results = []
+        brains = catalog(portal_type=typename, sort_limit=1)
+        if not brains:
+            return results
+        obj = brains[0].getObject()
+        for field_name in obj.schema._fields:
+            field = obj.schema._fields[field_name]
+            if not field.getName() in self.at_metadata_fields:
+                translated_label = translate(field.widget.label)
+                results.append({'id': field.getName(),
+                                'title': '%s (%s)' % (translated_label, field.getType()),
+                                'type': field.getType()})
+        return results
+
     def getFieldsForDXType(self, typename):
         '''Returns schema fields (name and type) for the given DX typename.'''
         results = []
diff --git a/plone/app/contenttypes/migration/migration.py b/plone/app/contenttypes/migration/migration.py
index 21aa888..d85655e 100644
--- a/plone/app/contenttypes/migration/migration.py
+++ b/plone/app/contenttypes/migration/migration.py
@@ -119,10 +119,15 @@ def migrate_filefield(src_obj, dst_obj, src_fieldname, dst_fieldname):
     logger.info("Migrating file %s" % filename)
 
 
-#this mapping is needed to use the right migration method
-FIELDS_MAPPING = {'TextField': migrate_richtextfield,
-                  'FileField': migrate_filefield,
-                  'ImageField': migrate_imagefield}
+# this mapping is needed to use the right migration method
+# we use the full field type path as it is retrieved from the field
+# (fiel.getType()), to avoid conflict. 
+# TODO In the __future__ we should have a more dynamic way to configure this 
+# mapping
+FIELDS_MAPPING = {'Products.Archetypes.Field.TextField': migrate_richtextfield,
+                  'Products.Archetypes.Field.FileField': migrate_filefield,
+                  'plone.app.blob.field.FileField': migrate_filefield,
+                  'Products.Archetypes.Field.ImageField': migrate_imagefield}
 
 
 def migrate(portal, migrator):


Repository: plone.app.contenttypes
Branch: refs/heads/master
Date: 2014-11-01T19:53:29Z
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.app.contenttypes/commit/4aaf18f2d7279e83ec1dcc958d0feed99e48603a

Add custom migration for AT-Types that were removed from portal_types

Files changed:
M docs/CHANGES.rst
M plone/app/contenttypes/migration/custom_migration.pt
M plone/app/contenttypes/migration/custom_migration.py
M plone/app/contenttypes/migration/custom_migration_display_dx_fields.pt

diff --git a/docs/CHANGES.rst b/docs/CHANGES.rst
index ad7c6db..85172ac 100644
--- a/docs/CHANGES.rst
+++ b/docs/CHANGES.rst
@@ -4,8 +4,7 @@ Changelog
 1.2a5 (unreleased)
 ------------------
 
-- Add methods to get AT-Types that were removed and get the schema from their
-  instances.
+- Add custom migration for AT-Types that were removed from portal_types.
   [pbauer]
 
 - Added helper view for migration custom AT types to available DX types,
diff --git a/plone/app/contenttypes/migration/custom_migration.pt b/plone/app/contenttypes/migration/custom_migration.pt
index 1284eef..dab4401 100644
--- a/plone/app/contenttypes/migration/custom_migration.pt
+++ b/plone/app/contenttypes/migration/custom_migration.pt
@@ -25,7 +25,8 @@
 </metal:custom_desc>
 
 <metal:content-core fill-slot="content-core">
-<metal:block define-macro="content-core" tal:define="at_types view/getATFTIs">
+<metal:block define-macro="content-core"
+             tal:define="at_types view/getAllArchetypeTypes">
   <div class="important">
     <h2 i18n:translate="">Important</h2>
     <p i18n:translate="">Before migrating your content please read the <a href="https://github.com/plone/plone.app.contenttypes#migration">migration-section in the documentation of plone.app.contenttypes</a></p>
@@ -66,9 +67,10 @@
                   tal:attributes="action python:context.absolute_url() + '/@@custom_migration'">
             <table>
                 <tr tal:repeat="at_type at_types">
+                <p tal:content="at_type"></p>
                     <td valign="top">
                         <p tal:content="at_type/title" style="font-weight: bold;">AT content type title</p>
-                        <tal:block repeat="field python: view.getFieldsForATType(at_type['id'])">
+                        <tal:block repeat="field python: view.getFieldsForATType(at_type)">
                             <p tal:content="field/title">Field name</p>
                             <input type="hidden" tal:attributes="name string:${at_type/id}:list;
                                                                  value string:${field/id}__type__${field/type};" />
diff --git a/plone/app/contenttypes/migration/custom_migration.py b/plone/app/contenttypes/migration/custom_migration.py
index 27a5c0d..a058f16 100644
--- a/plone/app/contenttypes/migration/custom_migration.py
+++ b/plone/app/contenttypes/migration/custom_migration.py
@@ -51,6 +51,11 @@ def __call__(self):
             self.request.response.redirect(form.get('form.HTTP_REFERER'))
         return self.index()
 
+    def getAllArchetypeTypes(self):
+        at_types = self.getATFTIs()
+        at_types.extend(self.getATTypesWithoutFTI())
+        return at_types
+
     def getATFTIs(self):
         '''Returns a list of all AT types with existing instances (including default-types).'''
         results = []
@@ -68,7 +73,8 @@ def getATFTIs(self):
                fti.content_meta_type in registeredTypeNames and \
                catalog(portal_type=ftiId):
                 results.append({'id': ftiId,
-                                'title': fti.Title()})
+                                'title': fti.Title(),
+                                'removed': False})
         return results
 
     def getATTypesWithoutFTI(self):
@@ -86,7 +92,8 @@ def getATTypesWithoutFTI(self):
             typename = brain.portal_type
             if typename not in all_registered_types:
                     results.append({'id': typename,
-                                    'title': typename})
+                                    'title': typename,
+                                    'removed': True})
         return results
 
     def getDXFTIs(self):
@@ -100,8 +107,14 @@ def getDXFTIs(self):
                                 'title': fti.Title()})
         return results
 
-    def getFieldsForATType(self, typename):
+    def getFieldsForATType(self, typeinfo):
         '''Returns schema fields (name and type) for the given AT typename.'''
+        if typeinfo['removed']:
+            return self.getFieldsForATTypeWithoutFTI(typeinfo['id'])
+        return self.getFieldsForATTypeWithFTI(typeinfo['id'])
+
+    def getFieldsForATTypeWithFTI(self, typename):
+        '''Returns schema fields (name and type) from the fti.'''
         results = []
         typesTool = getToolByName(self.context, 'portal_types')
         fti = typesTool.getTypeInfo(typename)
diff --git a/plone/app/contenttypes/migration/custom_migration_display_dx_fields.pt b/plone/app/contenttypes/migration/custom_migration_display_dx_fields.pt
index bfe5a2b..75cda2a 100644
--- a/plone/app/contenttypes/migration/custom_migration_display_dx_fields.pt
+++ b/plone/app/contenttypes/migration/custom_migration_display_dx_fields.pt
@@ -1,4 +1,4 @@
-<tal:loop repeat="at_field python: view.getFieldsForATType(view.at_typename)">
+<tal:loop repeat="at_field python: view.getFieldsForATTypeWithoutFTI(view.at_typename)">
     <select tal:attributes="name string:dx_${view/dx_typename}__for__${view/at_typename}:list;">
         <option value="">Do not migrate</option>
         <option tal:repeat="dx_field python: view.getFieldsForDXType(view.dx_typename)"


Repository: plone.app.contenttypes
Branch: refs/heads/master
Date: 2014-11-02T12:08:53Z
Author: tiazma (tiazma) <mbroquet@atreal.fr>
Commit: https://github.com/plone/plone.app.contenttypes/commit/9fc830e30a66cf65067a4a1f9622e26001ec2f36

Allow to set a file with a different name + pep8

Files changed:
M plone/app/contenttypes/migration/migration.py

diff --git a/plone/app/contenttypes/migration/migration.py b/plone/app/contenttypes/migration/migration.py
index d85655e..9dc553a 100644
--- a/plone/app/contenttypes/migration/migration.py
+++ b/plone/app/contenttypes/migration/migration.py
@@ -115,14 +115,14 @@ def migrate_filefield(src_obj, dst_obj, src_fieldname, dst_fieldname):
         old_file_data = old_file_data.data
     namedblobfile = NamedBlobFile(data=old_file_data,
                                     filename=filename)
-    dst_obj.file = namedblobfile
+    setattr(dst_obj, dst_fieldname, namedblobfile)
     logger.info("Migrating file %s" % filename)
 
 
 # this mapping is needed to use the right migration method
 # we use the full field type path as it is retrieved from the field
-# (fiel.getType()), to avoid conflict. 
-# TODO In the __future__ we should have a more dynamic way to configure this 
+# (field.getType()), to avoid conflict.
+# TODO In the __future__ we should have a more dynamic way to configure this
 # mapping
 FIELDS_MAPPING = {'Products.Archetypes.Field.TextField': migrate_richtextfield,
                   'Products.Archetypes.Field.FileField': migrate_filefield,
@@ -673,7 +673,7 @@ def migrateCustomAT(fields_mapping, src_type, dst_type, dry_run=False):
         if info.get('meta_type') == src_meta_type:
             src_type_infos = info
     is_folderish = src_type_infos.get('klass').isPrincipiaFolderish
-    #to be removed when this parameter comes from the view
+    # TODO : to be removed when this parameter comes from the view
     dry_run = True
     migrator = makeCustomATMigrator(context=portal,
                                     src_type=src_type,


Repository: plone.app.contenttypes
Branch: refs/heads/master
Date: 2014-11-02T12:55:49Z
Author: Florent Michon (flohcim) <florent.michon@gmail.com>
Commit: https://github.com/plone/plone.app.contenttypes/commit/33f2f6bddaee16e10d93a15083e30ee946ac5200

Corrects and optimizes migrate_imagefield method.

* New object attribute for the image field was always 'image' and not the
  destination field name.
* Same problem for the caption field.
* Some comments.

Files changed:
M plone/app/contenttypes/migration/migration.py

diff --git a/plone/app/contenttypes/migration/migration.py b/plone/app/contenttypes/migration/migration.py
index 9dc553a..cb5c248 100644
--- a/plone/app/contenttypes/migration/migration.py
+++ b/plone/app/contenttypes/migration/migration.py
@@ -84,6 +84,7 @@ def migrate_imagefield(src_obj, dst_obj, src_fieldname, dst_fieldname):
     migrate an image field.
     This field needs to be migrated with an NamedBlobImage instance.
     """
+    # get old image data and filename
     old_image = src_obj.getField(src_fieldname).get(src_obj)
     if old_image == '':
         return
@@ -91,12 +92,26 @@ def migrate_imagefield(src_obj, dst_obj, src_fieldname, dst_fieldname):
     old_image_data = old_image.data
     if safe_hasattr(old_image_data, 'data'):
         old_image_data = old_image_data.data
+
+    # create the new image field
     namedblobimage = NamedBlobImage(data=old_image_data,
                                     filename=filename)
-    dst_obj.image = namedblobimage
-    caption_field = src_obj.getField('imageCaption', None)
+
+    # set new field on destination object
+    setattr(dst_obj, dst_fieldname, namedblobimage)
+
+    # handle a possible image caption field
+    # postulate is the old caption field name is ending by 'Caption'
+    # and the new field name is ending by '_caption'
+    # is this postulate correct ?
+    # should this field not be handle by itself because it will appear in the
+    # old field list ?
+    caption_field = src_obj.getField('%sCaption' % src_fieldname, None)
     if caption_field:
-        dst_obj.image_caption = safe_unicode(caption_field.get(src_obj))
+        setattr(dst_obj,
+                ('%s_caption' % dst_fieldname),
+                safe_unicode(caption_field.get(src_obj)))
+
     logger.info("Migrating image %s" % filename)
 
 


Repository: plone.app.contenttypes
Branch: refs/heads/master
Date: 2014-11-02T13:05:35Z
Author: Florent Michon (flohcim) <florent.michon@gmail.com>
Commit: https://github.com/plone/plone.app.contenttypes/commit/d7d1baf8d57a9c943c2c2b152686613886e1f82f

Removes a developemnt assignment who was there to test the dry run mode.

Files changed:
M plone/app/contenttypes/migration/migration.py

diff --git a/plone/app/contenttypes/migration/migration.py b/plone/app/contenttypes/migration/migration.py
index cb5c248..0dbdd68 100644
--- a/plone/app/contenttypes/migration/migration.py
+++ b/plone/app/contenttypes/migration/migration.py
@@ -688,8 +688,6 @@ def migrateCustomAT(fields_mapping, src_type, dst_type, dry_run=False):
         if info.get('meta_type') == src_meta_type:
             src_type_infos = info
     is_folderish = src_type_infos.get('klass').isPrincipiaFolderish
-    # TODO : to be removed when this parameter comes from the view
-    dry_run = True
     migrator = makeCustomATMigrator(context=portal,
                                     src_type=src_type,
                                     dst_type=dst_type,


Repository: plone.app.contenttypes
Branch: refs/heads/master
Date: 2014-11-02T13:21:25Z
Author: Florent Michon (flohcim) <florent.michon@gmail.com>
Commit: https://github.com/plone/plone.app.contenttypes/commit/65454be16b9f5fb94ed3af6f47ff8f92629384f9

Add a tescase for file field migration.

Files changed:
M plone/app/contenttypes/migration/migration.py
M plone/app/contenttypes/tests/test_migration_custom.py

diff --git a/plone/app/contenttypes/migration/migration.py b/plone/app/contenttypes/migration/migration.py
index 0dbdd68..58bb371 100644
--- a/plone/app/contenttypes/migration/migration.py
+++ b/plone/app/contenttypes/migration/migration.py
@@ -117,9 +117,8 @@ def migrate_imagefield(src_obj, dst_obj, src_fieldname, dst_fieldname):
 
 def migrate_filefield(src_obj, dst_obj, src_fieldname, dst_fieldname):
     """
-    migrate an image field.
+    migrate a file field.
     This field needs to be migrated with an NamedBlobFile instance.
-    BBB to be tested
     """
     old_file = src_obj.getField(src_fieldname).get(src_obj)
     if old_file == '':
diff --git a/plone/app/contenttypes/tests/test_migration_custom.py b/plone/app/contenttypes/tests/test_migration_custom.py
index 59b6b10..a0e09e5 100644
--- a/plone/app/contenttypes/tests/test_migration_custom.py
+++ b/plone/app/contenttypes/tests/test_migration_custom.py
@@ -1,5 +1,6 @@
 # -*- coding: utf-8 -*-
 from plone.app.contenttypes.migration.migration import migrate_imagefield
+from plone.app.contenttypes.migration.migration import migrate_filefield
 from plone.app.contenttypes.migration.migration import migrate_simplefield
 from plone.app.contenttypes.migration.utils import installTypeIfNeeded
 from plone.app.contenttypes.testing import \
@@ -105,6 +106,23 @@ def test_migrate_imagefield(self):
         self.assertEqual(dx_newsitem.image.contentType, 'image/png')
         self.assertEqual(dx_newsitem.image.data, test_image_data)
 
+    def test_migrate_filefield(self):
+        test_file_data = self.get_test_file_data()
+        at_file_id = self.portal.invokeFactory('File',
+                                               'foo',
+                                               title="Foo file",
+                                               file=test_file_data)
+        # register p.a.contenttypes profile
+        applyProfile(self.portal, 'plone.app.contenttypes:default')
+        dx_file_id = self.portal.invokeFactory('File',
+                                               'bar',
+                                                title="Bar file")
+        at_file = self.portal[at_file_id]
+        dx_file = self.portal[dx_file_id]
+        self.assertEqual(dx_file.file, None)
+        migrate_filefield(at_file, dx_file, 'file', 'file')
+        self.assertEqual(dx_file.file.data, test_file_data)
+
 
 class MigrateCustomATTest(unittest.TestCase):
 


Repository: plone.app.contenttypes
Branch: refs/heads/master
Date: 2014-11-15T18:12:25+01:00
Author: cekk (cekk) <andrea.cecchi85@gmail.com>
Commit: https://github.com/plone/plone.app.contenttypes/commit/5c579a84e4e305b6a5d6603d875bf7217522ce2b

fixed testing support. Now there is a button for testing a single migration without committing anything.

Files changed:
M plone/app/contenttypes/migration/configure.zcml
M plone/app/contenttypes/migration/custom_migration.pt
M plone/app/contenttypes/migration/custom_migration.py
M plone/app/contenttypes/migration/custom_migration_display_dx_fields.pt
M plone/app/contenttypes/migration/migration.py
M plone/app/contenttypes/migration/migrator.css

diff --git a/plone/app/contenttypes/migration/configure.zcml b/plone/app/contenttypes/migration/configure.zcml
index 1b267a2..f3df083 100644
--- a/plone/app/contenttypes/migration/configure.zcml
+++ b/plone/app/contenttypes/migration/configure.zcml
@@ -77,6 +77,14 @@
     template="custom_migration_display_dx_fields.pt"
     />
 
+  <browser:page
+    name="test_migration"
+    for="Products.CMFPlone.interfaces.IPloneSiteRoot"
+    class=".custom_migration.TestMigration"
+    layer="..interfaces.IPloneAppContenttypesLayer"
+    permission="cmf.ManagePortal"
+    />
+
   <utility
       factory=".vocabularies.ATCTypesVocabulary"
       name="plone.app.contenttypes.migration.atctypes"
diff --git a/plone/app/contenttypes/migration/custom_migration.pt b/plone/app/contenttypes/migration/custom_migration.pt
index dab4401..a648c93 100644
--- a/plone/app/contenttypes/migration/custom_migration.pt
+++ b/plone/app/contenttypes/migration/custom_migration.pt
@@ -56,6 +56,36 @@
               }
             });
         }
+        $(document).ready(function () {
+            $('input[name="form.button.Test"]').on( "click", function(e) {
+                e.preventDefault();
+                var $this = $(this);
+                var tested_type = $this.parent().siblings('select.selectedType');
+                $this.parent().removeClass('error');
+                $this.parent().siblings('.fieldsMapping').removeClass('error');
+                $this.parent().removeClass('success');
+                $this.parent().addClass('testing');
+                $.ajax({
+                    url: '@@test_migration?' + $(this).parents('form').serialize() + '&tested_type=' + tested_type.attr('name'),
+                    dataType: 'json',
+                    success: function(data) {
+                        $this.parent().removeClass('testing');
+                        if(data.status === 'error') {
+                            $this.parent().addClass('error');
+                            $this.parent().siblings('.fieldsMapping').addClass('error');
+                        }
+                        else{
+                            $this.parent().addClass('success');
+                        }
+                    },
+                    error: function(jqXHR, textStatus, errorThrown) {
+                        $this.parent().removeClass('testing');
+                        $this.parent().addClass('error');
+                        $this.parent().siblings('.fieldsMapping').addClass('error');
+                    }
+                });
+            });
+        });
     </script>
     <tal:block condition="at_types">
         <div id="migration-options">
@@ -78,19 +108,23 @@
                     </td>
                     <td valign="top">
                         <select tal:attributes="onChange string:javascript:getDXFields(at_typename='${at_type/id}', this.value);
-                                                name string:dx_select_${at_type/id};">
+                                                name string:dx_select_${at_type/id};"
+                                class="selectedType">
                             <option value="" selected="selected">Do not migrate</option>
                             <option tal:repeat="dx_type view/getDXFTIs"
                                     tal:attributes="value dx_type/id"
                                     tal:content="dx_type/title">DX type name</option>
                         </select>
-                        <!--tal:block repeat='dx_type view/getDXFTIs'>
-                            <h3 tal:content="dx_type/title"></h3>
-                            <tal:block repeat="field python: view.getFieldsForDXType(dx_type['id'])">
-                                <p tal:content="field/id">AT field</p>
-                            </tal:block>
-                        </tal:block-->
-                        <div id="hook_at_fti" tal:attributes="id string:hook_at_fti_${at_type/id}" />
+                        <div id="hook_at_fti" class="field fieldsMapping" tal:attributes="id string:hook_at_fti_${at_type/id}" />
+                        <br />
+                        <div class="testConfig">
+                            <input type="submit"
+                                   name="form.button.Test"
+                                   class="context"
+                                   value="Test configuration"
+                                   i18n:attributes="value"
+                                   i18n:domain="plone"/>&nbsp;
+                        </div>
                     </td>
                 </tr>
             </table>
diff --git a/plone/app/contenttypes/migration/custom_migration.py b/plone/app/contenttypes/migration/custom_migration.py
index a058f16..ed18a66 100644
--- a/plone/app/contenttypes/migration/custom_migration.py
+++ b/plone/app/contenttypes/migration/custom_migration.py
@@ -9,6 +9,7 @@
 from Products.ATContentTypes.content.schemata import ATContentTypeSchema
 from Products.statusmessages.interfaces import IStatusMessage
 from plone.app.contenttypes.migration.migration import migrateCustomAT
+import json
 
 HAS_EXTENDER = True
 try:
@@ -33,6 +34,7 @@ def __call__(self):
         form = self.request.form
         cancelled = form.get('form.button.Cancel', False)
         submitted = form.get('form.button.Migrate', False)
+        test = form.get('form.button.Test', False)
         if submitted:
             # proceed, call the migration methdd
             results = self.migrate()
@@ -173,8 +175,9 @@ def getFieldsForDXType(self, typename):
                 # ignore Dublin Core fields
                 if fieldName in self.dx_metadata_fields:
                     continue
+                translated_title = translate(field.title)
                 results.append({'id': fieldName,
-                                'title': '%s (%s)' % (field.title, field.__class__.__name__),
+                                'title': '%s (%s)' % (translated_title, field.__class__.__name__),
                                 'type': field.__class__.__name__})
         return results
 
@@ -184,7 +187,7 @@ def getPossibleTargetField(self, fieldtype):
     def isFolderish(self):
         ''' decide which base-class we use for the migrator'''
 
-    def migrate(self):
+    def migrate(self, dry_run=False):
         '''Build data from self.request.form, we will build something like :
            {'MyATPortalType': {'MyDXPortalType': ({'AT_field_name': 'fieldname1',
                                                    'AT_field_type': 'TextField',
@@ -199,7 +202,7 @@ def migrate(self):
             if k.startswith('dx_select_'):
                 # we found select where we choose a DX type regarding an AT type
                 # the selelect name is like 'dx_select_MyATPortalType'
-                if not form[k]:
+                if not form[k] or (dry_run and k != form.get('tested_type')):
                     # nothing selected in this select, continue
                     continue
                 at_typename = k[10:]
@@ -228,7 +231,7 @@ def migrate(self):
         migration_results = []
         for at_typename, dx_mappings in data.items():
             for k, v in dx_mappings.items():
-                res = migrateCustomAT(fields_mapping=v, src_type=at_typename, dst_type=dx_typename)
+                res = migrateCustomAT(fields_mapping=v, src_type=at_typename, dst_type=dx_typename, dry_run=dry_run)
                 migration_results.append({'type': at_typename,
                                           'infos': res})
         return migration_results
@@ -247,3 +250,26 @@ def __call__(self):
         '''
         '''
         return self.index()
+
+class TestMigration(CustomMigrationForm):
+
+    def __call__(self):
+        '''
+        View that call migrate method with dry_run mode set.
+        Returns a json response with the result.
+        This view is called by a js.
+        '''
+        results = self.migrate(dry_run=True)
+        response = {}
+        if results:
+            migration_result = results[0]
+            res_infos = migration_result.get('infos')
+            if res_infos.get('errors'):
+                response['status'] = 'error'
+                response['message'] = "Impossible migrating to this content type with this configuration"
+            else:
+                response['status'] = 'success'
+                response['message'] = "Testing migration succesful"
+        #i need to fix the response header because in case of success, it is set to text/html
+        self.request.response.setHeader("Content-type", "application/json")
+        return json.dumps(response)
diff --git a/plone/app/contenttypes/migration/custom_migration_display_dx_fields.pt b/plone/app/contenttypes/migration/custom_migration_display_dx_fields.pt
index 75cda2a..775f40a 100644
--- a/plone/app/contenttypes/migration/custom_migration_display_dx_fields.pt
+++ b/plone/app/contenttypes/migration/custom_migration_display_dx_fields.pt
@@ -5,4 +5,4 @@
                 tal:attributes="value string:${dx_field/id}__type__${dx_field/type};"
                 tal:content="string:${dx_field/title}">DX field name</option>
     </select>
-</tal:loop>
\ No newline at end of file
+</tal:loop>
diff --git a/plone/app/contenttypes/migration/migration.py b/plone/app/contenttypes/migration/migration.py
index 58bb371..a4d7ac5 100644
--- a/plone/app/contenttypes/migration/migration.py
+++ b/plone/app/contenttypes/migration/migration.py
@@ -704,12 +704,7 @@ def migrateCustomAT(fields_mapping, src_type, dst_type, dry_run=False):
                            'dst_meta_type': '',
                            'use_savepoint': True}
         if dry_run:
-            tools = getMultiAdapter((portal, portal.REQUEST), name=u'plone_tools')
-            portal_catalog = tools.catalog()
-            #BBB search_limit doesn't seems working
-            test_search = portal_catalog(portal_type=src_type, search_limit=1)
-            if test_search:
-                walker_settings['query'] = {'UID': test_search[0].UID}
+            walker_settings['limit'] = 1
         walker = CustomQueryWalker(**walker_settings)
         walker.go()
         walker_infos = {'errors': walker.errors,
diff --git a/plone/app/contenttypes/migration/migrator.css b/plone/app/contenttypes/migration/migrator.css
index ed6e42d..53cdf51 100644
--- a/plone/app/contenttypes/migration/migrator.css
+++ b/plone/app/contenttypes/migration/migrator.css
@@ -68,3 +68,21 @@ table th {
     text-align: center;
     font-weight: normal;
 }
+
+.testConfig.error {
+    padding-right: 30px;
+    background: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAClklEQVR42q3VX0gUQRwH8N/M3N7tnXe3Z4IiESc9FBaBWHg99VSET0F/HxIKKg1FK4gK8grUoB59UaEetKAwoojAsCgIIsw/ROSRhCFpecVpd7d6f/Zmd6fZJY2ebmHu97Asw373w/x2ZhaBg1IPH78JNRsuMxeGQoFCYmbh1raRZ1ecZFGxB3JHm/pJY+1Z5JcBGAOEMdB0BmIP3/XsGn0eFQa0S+0M1VUDFIz1MeJ2wfe3nyHcd7dovjhwsZWh2koAw1wfwy4CP8ZnITxwrwTAhVYGW8o5wP4DFqe+Qvj2fXEgf66FobACYHIAYd4fYrco/mkeNvUPlgBoPs3Q1hB/sQQs8QtYbBqIqsLYh/jKnmQ6KAzkzjSPoY0oYo6MAkuqAC4XuPlyfT2bHN+f0yLCQCayewoSs/VgfQJM7ISbIHgzn/q4N5evEwZUr/8FrvLtg3/fGGQO9M0tRTuY0SMMpH3BKAl5uqxNtlZejGAgnuxqM/XrpQA6id/dvQZYAcZX1FBKPd9m6L0lAJSdWMYTCJD9rHXN6CY8Wc3Uthh0RhhI+RQJS1jlL5bXAjnTLDzOZKs4kBIG7FkEQnO87TXWPeFSnNL0K00rbzYoK5Z1BPwuU3rdCHVY9xIHYlSbrs9ndzjJOgJ+likVfJkmKDNRlpkQM/SGg1SbKBkgUo6AJX/oDiLolJdgUHUK8wX9UUM+e6QkQNobPIED0iDmu9c+LXhCpyYMLasn2019SBhQQ6EuUilH7eP6b3k49vJbqrsxn78mDKTKlB73duUq45vLngJPyBKBB5OLN5oM2ineIjnYQDYH35Nqn/3bxPyoXl1QYfjLcqSV0XFhwKq4J3jAVeEZRgHJk0lq2uTSyrFDZuGpk+wfCfYGKNjXCTAAAAAASUVORK5CYII=') no-repeat right center;
+}
+.testConfig.success {
+    padding-right: 30px;
+    background: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAC9ElEQVR42u2UW0gUURjH/7Pj7tIqhu5tvK/aRS3K7KGHepAQ7SJBEBaESmAXqAeJKDQQipKgEiPEiCAzLE2CLlCQREVvIhEopuaq7a6aI67rXp3ZnTnNDrZYupqXeuqDMwNzzvn95nznO4fCXw7qv+CfC5hXTEV+ek5116gZn3J7qVUVbHqbRrYnZuBq6g2UdB7BiG1q9VYwG37ZVgErZ8HXz+OrIwjCq3ecQ44qV4ZbuG9wu3lYexwrF/wOH/QNwc+LGOyaAK8VK1ckyGpLJQ931cFAm2S42TOAYN0Mddvh9vJgj7HL3+S4pwy5U1AV+vN+txk0TcPa78DkuA9sGSuz5Ufca4YIrChPZEvZRaVMM0MqC0pRFHUc5UMnMeL9DpUyAmNWt9RcIbgsYF4wpGBjDs4mnMFd9j5aP34IK2GeMZToEcWSvD04H3sJF63l6HH2Qq1Uwz4+jeE+B8ZOjP0yl8p4YyKnthSi3dmBC/FVONx5GvY+z7wSQ5OB5O3MRk1CPerY63jHvpfgKkw5eQx3T2K0bGzOHCqzLY1sSzFAE6GGN8CFlRhbjCRraxLXmNaoful4gsejLVDSEXA6/eBcfnQWmOddNcU8Z0iyPsa/2ahTTgt+BKSPu2P2ora/ISQxPDCQpGwtmjMb0OFqR72tHgqFAm5XAKzZCUvxSNh9o4J3B/yoXmfUwqRbC14UEZBavna/LEFw7xVAU85tTEx7cc1yReoX4PUIsNvcGCiyLVgUcqckIZSPQqZJD310JLhAQFqJiELdAVgjvuDgmqOwcz7cGq6Bk3fC5xXhtnPoKRxctOJCA4LVpPLTyEjXIVKjliUCEZCiScah2GLUDt+U4dNesmDOwwpmypCoBBqZ6/WglQoIgiilLABO4KCgVBJcSo2DR/e+gT8+oHMGMq0MiaSVSN+glZJEIIoEgtQ8Xv+S4fMKgmF8ZCQx0RokmqKlNBG4XPyy4GEFwTDcMxBdfNRMDWFZ8AUFPyXB9+y7ZanxA2o0cjyUQuVrAAAAAElFTkSuQmCC') no-repeat right center;
+}
+
+.testConfig.testing {
+  background: #ffffff url('++plone++static/components//select2/select2-spinner.gif') no-repeat 100% right center;
+  background: url('++plone++static/components//select2/select2-spinner.gif') no-repeat 100%, -webkit-gradient(linear, left bottom, left top, color-stop(0.85, #ffffff), color-stop(0.99, #eeeeee));
+  background: url('++plone++static/components//select2/select2-spinner.gif') no-repeat 100%, -webkit-linear-gradient(center bottom, #ffffff 85%, #eeeeee 99%);
+  background: url('++plone++static/components//select2/select2-spinner.gif') no-repeat 100%, -moz-linear-gradient(center bottom, #ffffff 85%, #eeeeee 99%);
+  background: url('++plone++static/components//select2/select2-spinner.gif') no-repeat 100%, linear-gradient(to bottom, #ffffff 85%, #eeeeee 99%) right center;
+  padding-right: 30px;
+}


Repository: plone.app.contenttypes
Branch: refs/heads/master
Date: 2015-04-07T23:26:14+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.app.contenttypes/commit/9e842510a93c347874d05f42c30873b577dea432

Merge branch 'master' into issue133_custom_types_migration

Conflicts:
	docs/README.rst
	plone/app/contenttypes/migration/migration.py

Files changed:
A buildout.d/base.cfg
A buildout.d/checkouts.cfg
A buildout.d/development.cfg
A buildout.d/jenkins.cfg
A buildout.d/sources.cfg
A buildout.d/versions.cfg
A plone/app/contenttypes/browser/file.py
A plone/app/contenttypes/browser/folder.py
A plone/app/contenttypes/browser/full_view.py
A plone/app/contenttypes/browser/templates/full_view.pt
A plone/app/contenttypes/browser/templates/full_view_item.pt
A plone/app/contenttypes/browser/templates/listing.pt
A plone/app/contenttypes/browser/templates/listing_album.pt
A plone/app/contenttypes/browser/templates/listing_summary.pt
A plone/app/contenttypes/browser/templates/listing_tabular.pt
A plone/app/contenttypes/migration/patches.py
A plone/app/contenttypes/migration/topics.py
A plone/app/contenttypes/profiles/default/propertiestool.xml
A plone/app/contenttypes/profiles/default/types/Plone_Site.xml
A plone/app/contenttypes/profiles/uninstall/types/Plone_Site.xml
A plone/app/contenttypes/tests/test_migration_topic.py
M bootstrap.py
M buildout.cfg
M docs/CHANGES.rst
M docs/README.rst
M jenkins.cfg
M plone/app/contenttypes/behaviors/collection.py
M plone/app/contenttypes/behaviors/leadimage.pt
M plone/app/contenttypes/behaviors/richtext.py
M plone/app/contenttypes/browser/collection.py
M plone/app/contenttypes/browser/configure.zcml
M plone/app/contenttypes/browser/link_redirect_view.py
M plone/app/contenttypes/browser/templates/archetypes_warning_viewlet.pt
M plone/app/contenttypes/browser/templates/document.pt
M plone/app/contenttypes/browser/templates/file.pt
M plone/app/contenttypes/browser/templates/image.pt
M plone/app/contenttypes/browser/templates/image_view_fullscreen.pt
M plone/app/contenttypes/browser/templates/link.pt
M plone/app/contenttypes/browser/templates/newsitem.pt
M plone/app/contenttypes/browser/utils.py
M plone/app/contenttypes/content.py
M plone/app/contenttypes/interfaces.py
M plone/app/contenttypes/migration/__init__.py
M plone/app/contenttypes/migration/atct_migrator.pt
M plone/app/contenttypes/migration/atct_migrator_results.pt
M plone/app/contenttypes/migration/browser.py
M plone/app/contenttypes/migration/configure.zcml
M plone/app/contenttypes/migration/dxmigration.py
M plone/app/contenttypes/migration/migration.py
M plone/app/contenttypes/migration/utils.py
M plone/app/contenttypes/migration/vocabularies.py
M plone/app/contenttypes/profiles/default/metadata.xml
M plone/app/contenttypes/profiles/default/types.xml
M plone/app/contenttypes/profiles/default/types/Collection.xml
M plone/app/contenttypes/profiles/default/types/Folder.xml
M plone/app/contenttypes/profiles/uninstall/types.xml
M plone/app/contenttypes/schema/image.xml
M plone/app/contenttypes/setuphandlers.py
M plone/app/contenttypes/testing.py
M plone/app/contenttypes/tests/oldtypes.py
M plone/app/contenttypes/tests/robot/keywords.txt
M plone/app/contenttypes/tests/robot/test_collection_creator_criterion.robot
M plone/app/contenttypes/tests/robot/test_collection_location_criterion.robot
M plone/app/contenttypes/tests/robot/test_collection_review_state_criterion.robot
M plone/app/contenttypes/tests/robot/test_collection_short_name_criterion.robot
M plone/app/contenttypes/tests/robot/test_collection_type_criterion.robot
M plone/app/contenttypes/tests/robot/test_folderlisting.robot
M plone/app/contenttypes/tests/robot/variables.py
M plone/app/contenttypes/tests/test_behaviors_collection.py
M plone/app/contenttypes/tests/test_collection.py
M plone/app/contenttypes/tests/test_document.py
M plone/app/contenttypes/tests/test_file.py
M plone/app/contenttypes/tests/test_folder.py
M plone/app/contenttypes/tests/test_link.py
M plone/app/contenttypes/tests/test_migration.py
M plone/app/contenttypes/tests/test_setup.py
M plone/app/contenttypes/tests/test_upgrades_migrate_to_pa_event.py
M plone/app/contenttypes/upgrades.py
M plone/app/contenttypes/upgrades.zcml
M setup.py
M travis.cfg
D dev.cfg
D plone/app/contenttypes/browser/album_view.py
D plone/app/contenttypes/browser/templates/all_content.pt
D plone/app/contenttypes/browser/templates/folder_album_view.pt
D plone/app/contenttypes/browser/templates/folder_full_view.pt
D plone/app/contenttypes/browser/templates/folder_full_view_item.pt
D plone/app/contenttypes/browser/templates/folder_listing.pt
D plone/app/contenttypes/browser/templates/folder_summary_view.pt
D plone/app/contenttypes/browser/templates/folder_tabular_view.pt
D plone/app/contenttypes/browser/templates/standard_view.pt
D plone/app/contenttypes/browser/templates/summary_view.pt
D plone/app/contenttypes/browser/templates/tabular_view.pt
D plone/app/contenttypes/browser/templates/thumbnail_view.pt
D sphinx.cfg
D test-plone-4.3.x.cfg

diff --git a/bootstrap.py b/bootstrap.py
index 1cce2ce..a629566 100644
--- a/bootstrap.py
+++ b/bootstrap.py
@@ -18,75 +18,14 @@
 use the -c option to specify an alternate configuration file.
 """
 
-import os, shutil, sys, tempfile, urllib, urllib2, subprocess
+import os
+import shutil
+import sys
+import tempfile
+
 from optparse import OptionParser
 
-if sys.platform == 'win32':
-    def quote(c):
-        if ' ' in c:
-            return '"%s"' % c  # work around spawn lamosity on windows
-        else:
-            return c
-else:
-    quote = str
-
-# See zc.buildout.easy_install._has_broken_dash_S for motivation and comments.
-stdout, stderr = subprocess.Popen(
-    [sys.executable, '-Sc',
-     'try:\n'
-     '    import ConfigParser\n'
-     'except ImportError:\n'
-     '    print 1\n'
-     'else:\n'
-     '    print 0\n'],
-    stdout=subprocess.PIPE, stderr=subprocess.PIPE).communicate()
-has_broken_dash_S = bool(int(stdout.strip()))
-
-# In order to be more robust in the face of system Pythons, we want to
-# run without site-packages loaded.  This is somewhat tricky, in
-# particular because Python 2.6's distutils imports site, so starting
-# with the -S flag is not sufficient.  However, we'll start with that:
-if not has_broken_dash_S and 'site' in sys.modules:
-    # We will restart with python -S.
-    args = sys.argv[:]
-    args[0:0] = [sys.executable, '-S']
-    args = map(quote, args)
-    os.execv(sys.executable, args)
-# Now we are running with -S.  We'll get the clean sys.path, import site
-# because distutils will do it later, and then reset the path and clean
-# out any namespace packages from site-packages that might have been
-# loaded by .pth files.
-clean_path = sys.path[:]
-import site  # imported because of its side effects
-sys.path[:] = clean_path
-for k, v in sys.modules.items():
-    if k in ('setuptools', 'pkg_resources') or (
-        hasattr(v, '__path__') and
-        len(v.__path__) == 1 and
-        not os.path.exists(os.path.join(v.__path__[0], '__init__.py'))):
-        # This is a namespace package.  Remove it.
-        sys.modules.pop(k)
-
-is_jython = sys.platform.startswith('java')
-
-setuptools_source = 'http://peak.telecommunity.com/dist/ez_setup.py'
-distribute_source = 'http://python-distribute.org/distribute_setup.py'
-
-
-# parsing arguments
-def normalize_to_url(option, opt_str, value, parser):
-    if value:
-        if '://' not in value:  # It doesn't smell like a URL.
-            value = 'file://%s' % (
-                urllib.pathname2url(
-                    os.path.abspath(os.path.expanduser(value))),)
-        if opt_str == '--download-base' and not value.endswith('/'):
-            # Download base needs a trailing slash to make the world happy.
-            value += '/'
-    else:
-        value = None
-    name = opt_str[2:].replace('-', '_')
-    setattr(parser.values, name, value)
+tmpeggs = tempfile.mkdtemp()
 
 usage = '''\
 [DESIRED PYTHON FOR BUILDOUT] bootstrap.py [options]
@@ -96,31 +35,13 @@ def normalize_to_url(option, opt_str, value, parser):
 Simply run this script in a directory containing a buildout.cfg, using the
 Python that you want bin/buildout to use.
 
-Note that by using --setup-source and --download-base to point to
-local resources, you can keep this script from going over the network.
+Note that by using --find-links to point to local resources, you can keep
+this script from going over the network.
 '''
 
 parser = OptionParser(usage=usage)
-parser.add_option("-v", "--version", dest="version",
-                          help="use a specific zc.buildout version")
-parser.add_option("-d", "--distribute",
-                   action="store_true", dest="use_distribute", default=False,
-                   help="Use Distribute rather than Setuptools.")
-parser.add_option("--setup-source", action="callback", dest="setup_source",
-                  callback=normalize_to_url, nargs=1, type="string",
-                  help=("Specify a URL or file location for the setup file. "
-                        "If you use Setuptools, this will default to " +
-                        setuptools_source + "; if you use Distribute, this "
-                        "will default to " + distribute_source + "."))
-parser.add_option("--download-base", action="callback", dest="download_base",
-                  callback=normalize_to_url, nargs=1, type="string",
-                  help=("Specify a URL or directory for downloading "
-                        "zc.buildout and either Setuptools or Distribute. "
-                        "Defaults to PyPI."))
-parser.add_option("--eggs",
-                  help=("Specify a directory for storing eggs.  Defaults to "
-                        "a temporary directory that is deleted when the "
-                        "bootstrap script completes."))
+parser.add_option("-v", "--version", help="use a specific zc.buildout version")
+
 parser.add_option("-t", "--accept-buildout-test-releases",
                   dest='accept_buildout_test_releases',
                   action="store_true", default=False,
@@ -130,80 +51,80 @@ def normalize_to_url(option, opt_str, value, parser):
                         "extensions for you.  If you use this flag, "
                         "bootstrap and buildout will get the newest releases "
                         "even if they are alphas or betas."))
-parser.add_option("-c", None, action="store", dest="config_file",
-                   help=("Specify the path to the buildout configuration "
-                         "file to be used."))
-
-options, args = parser.parse_args()
+parser.add_option("-c", "--config-file",
+                  help=("Specify the path to the buildout configuration "
+                        "file to be used."))
+parser.add_option("-f", "--find-links",
+                  help=("Specify a URL to search for buildout releases"))
+parser.add_option("--allow-site-packages",
+                  action="store_true", default=False,
+                  help=("Let bootstrap.py use existing site packages"))
+parser.add_option("--setuptools-version",
+                  help="use a specific setuptools version")
 
-if options.eggs:
-    eggs_dir = os.path.abspath(os.path.expanduser(options.eggs))
-else:
-    eggs_dir = tempfile.mkdtemp()
 
-if options.setup_source is None:
-    if options.use_distribute:
-        options.setup_source = distribute_source
-    else:
-        options.setup_source = setuptools_source
+options, args = parser.parse_args()
 
-if options.accept_buildout_test_releases:
-    args.insert(0, 'buildout:accept-buildout-test-releases=true')
+######################################################################
+# load/install setuptools
 
 try:
-    import pkg_resources
-    import setuptools  # A flag.  Sometimes pkg_resources is installed alone.
-    if not hasattr(pkg_resources, '_distribute'):
-        raise ImportError
+    if options.allow_site_packages:
+        import setuptools
+        import pkg_resources
+    from urllib.request import urlopen
 except ImportError:
-    ez_code = urllib2.urlopen(
-        options.setup_source).read().replace('\r\n', '\n')
-    ez = {}
-    exec ez_code in ez
-    setup_args = dict(to_dir=eggs_dir, download_delay=0)
-    if options.download_base:
-        setup_args['download_base'] = options.download_base
-    if options.use_distribute:
-        setup_args['no_fake'] = True
-        if sys.version_info[:2] == (2, 4):
-            setup_args['version'] = '0.6.32'
-    ez['use_setuptools'](**setup_args)
-    if 'pkg_resources' in sys.modules:
-        reload(sys.modules['pkg_resources'])
-    import pkg_resources
-    # This does not (always?) update the default working set.  We will
-    # do it.
-    for path in sys.path:
-        if path not in pkg_resources.working_set.entries:
-            pkg_resources.working_set.add_entry(path)
-
-cmd = [quote(sys.executable),
-       '-c',
-       quote('from setuptools.command.easy_install import main; main()'),
-       '-mqNxd',
-       quote(eggs_dir)]
-
-if not has_broken_dash_S:
-    cmd.insert(1, '-S')
-
-find_links = options.download_base
-if not find_links:
-    find_links = os.environ.get('bootstrap-testing-find-links')
-if not find_links and options.accept_buildout_test_releases:
-    find_links = 'http://downloads.buildout.org/'
-if find_links:
-    cmd.extend(['-f', quote(find_links)])
+    from urllib2 import urlopen
+
+ez = {}
+exec(urlopen('https://bootstrap.pypa.io/ez_setup.py').read(), ez)
+
+if not options.allow_site_packages:
+    # ez_setup imports site, which adds site packages
+    # this will remove them from the path to ensure that incompatible versions
+    # of setuptools are not in the path
+    import site
+    # inside a virtualenv, there is no 'getsitepackages'.
+    # We can't remove these reliably
+    if hasattr(site, 'getsitepackages'):
+        for sitepackage_path in site.getsitepackages():
+            sys.path[:] = [x for x in sys.path if sitepackage_path not in x]
+
+setup_args = dict(to_dir=tmpeggs, download_delay=0)
+
+if options.setuptools_version is not None:
+    setup_args['version'] = options.setuptools_version
+
+ez['use_setuptools'](**setup_args)
+import setuptools
+import pkg_resources
+
+# This does not (always?) update the default working set.  We will
+# do it.
+for path in sys.path:
+    if path not in pkg_resources.working_set.entries:
+        pkg_resources.working_set.add_entry(path)
+
+######################################################################
+# Install buildout
 
-if options.use_distribute:
-    setup_requirement = 'distribute'
-else:
-    setup_requirement = 'setuptools'
 ws = pkg_resources.working_set
-setup_requirement_path = ws.find(
-    pkg_resources.Requirement.parse(setup_requirement)).location
-env = dict(
-    os.environ,
-    PYTHONPATH=setup_requirement_path)
+
+cmd = [sys.executable, '-c',
+       'from setuptools.command.easy_install import main; main()',
+       '-mZqNxd', tmpeggs]
+
+find_links = os.environ.get(
+    'bootstrap-testing-find-links',
+    options.find_links or
+    ('http://downloads.buildout.org/'
+     if options.accept_buildout_test_releases else None)
+    )
+if find_links:
+    cmd.extend(['-f', find_links])
+
+setuptools_path = ws.find(
+    pkg_resources.Requirement.parse('setuptools')).location
 
 requirement = 'zc.buildout'
 version = options.version
@@ -213,12 +134,17 @@ def normalize_to_url(option, opt_str, value, parser):
     _final_parts = '*final-', '*final'
 
     def _final_version(parsed_version):
-        for part in parsed_version:
-            if (part[:1] == '*') and (part not in _final_parts):
-                return False
-        return True
+        try:
+            return not parsed_version.is_prerelease
+        except AttributeError:
+            # Older setuptools
+            for part in parsed_version:
+                if (part[:1] == '*') and (part not in _final_parts):
+                    return False
+            return True
+
     index = setuptools.package_index.PackageIndex(
-        search_path=[setup_requirement_path])
+        search_path=[setuptools_path])
     if find_links:
         index.add_find_links((find_links,))
     req = pkg_resources.Requirement.parse(requirement)
@@ -227,8 +153,6 @@ def _final_version(parsed_version):
         bestv = None
         for dist in index[req.project_name]:
             distv = dist.parsed_version
-            if distv >= pkg_resources.parse_version('2dev'):
-                continue
             if _final_version(distv):
                 if bestv is None or distv > bestv:
                     best = [dist]
@@ -238,40 +162,28 @@ def _final_version(parsed_version):
         if best:
             best.sort()
             version = best[-1].version
-
 if version:
-    requirement += '=='+version
-else:
-    requirement += '<2dev'
-
+    requirement = '=='.join((requirement, version))
 cmd.append(requirement)
 
-if is_jython:
-    import subprocess
-    exitcode = subprocess.Popen(cmd, env=env).wait()
-else:  # Windows prefers this, apparently; otherwise we would prefer subprocess
-    exitcode = os.spawnle(*([os.P_WAIT, sys.executable] + cmd + [env]))
-if exitcode != 0:
-    sys.stdout.flush()
-    sys.stderr.flush()
-    print ("An error occurred when trying to install zc.buildout. "
-           "Look above this message for any errors that "
-           "were output by easy_install.")
-    sys.exit(exitcode)
-
-ws.add_entry(eggs_dir)
+import subprocess
+if subprocess.call(cmd, env=dict(os.environ, PYTHONPATH=setuptools_path)) != 0:
+    raise Exception(
+        "Failed to execute command:\n%s" % repr(cmd)[1:-1])
+
+######################################################################
+# Import and run buildout
+
+ws.add_entry(tmpeggs)
 ws.require(requirement)
 import zc.buildout.buildout
 
-# If there isn't already a command in the args, add bootstrap
 if not [a for a in args if '=' not in a]:
     args.append('bootstrap')
 
-
-# if -c was provided, we push it back into args for buildout's main function
+# if -c was provided, we push it back into args for buildout' main function
 if options.config_file is not None:
     args[0:0] = ['-c', options.config_file]
 
 zc.buildout.buildout.main(args)
-if not options.eggs:  # clean up temporary egg directory
-    shutil.rmtree(eggs_dir)
+shutil.rmtree(tmpeggs)
diff --git a/buildout.cfg b/buildout.cfg
index 1e41162..3def417 100644
--- a/buildout.cfg
+++ b/buildout.cfg
@@ -1,3 +1,2 @@
 [buildout]
-extends = test-plone-4.3.x.cfg
-
+extends = buildout.d/development.cfg
diff --git a/buildout.d/base.cfg b/buildout.d/base.cfg
new file mode 100644
index 0000000..2c60554
--- /dev/null
+++ b/buildout.d/base.cfg
@@ -0,0 +1,22 @@
+[buildout]
+package-name = plone.app.contenttypes
+package-extras = [test]
+
+extends =
+    https://raw.github.com/collective/buildout.plonetest/master/plone-5.0.x.cfg
+    https://raw.github.com/collective/buildout.plonetest/master/qa.cfg
+    checkouts.cfg
+    sources.cfg
+    versions.cfg
+
+parts += createcoverage
+
+develop = .
+
+eggs +=
+    Pillow
+
+[code-analysis]
+recipe = plone.recipe.codeanalysis
+directory = ${buildout:directory}/plone
+flake8-ignore = E123,E124,E501,E126,E127,E128
diff --git a/buildout.d/checkouts.cfg b/buildout.d/checkouts.cfg
new file mode 100644
index 0000000..5b289e6
--- /dev/null
+++ b/buildout.d/checkouts.cfg
@@ -0,0 +1,5 @@
+[buildout]
+always-checkout = force
+auto-checkout +=
+    plone.app.dexterity
+    plone.app.robotframework
diff --git a/buildout.d/development.cfg b/buildout.d/development.cfg
new file mode 100644
index 0000000..6ff9460
--- /dev/null
+++ b/buildout.d/development.cfg
@@ -0,0 +1,38 @@
+[buildout]
+extends =
+    base.cfg
+
+eggs +=
+    plone.reload
+#    Products.PDBDebugMode
+#    Products.DocFinderTab
+#    aws.zope2zcmldoc
+#    collective.profiler
+
+extensions +=
+    mr.developer
+
+parts +=
+    omelette
+    test
+    robot
+
+show-picked-versions = true
+
+[omelette]
+recipe = collective.recipe.omelette
+eggs = ${test:eggs}
+
+[test]
+recipe = zc.recipe.testrunner
+eggs =
+    ${buildout:eggs}
+    ${buildout:package-name} ${buildout:package-extras}
+defaults = ['-s', '${buildout:package-name}', '--auto-color', '--auto-progress']
+
+[robot]
+recipe = zc.recipe.egg
+eggs =
+    Pillow
+    ${test:eggs}
+    plone.app.robotframework[ride,reload]
diff --git a/buildout.d/jenkins.cfg b/buildout.d/jenkins.cfg
new file mode 100644
index 0000000..34fa93f
--- /dev/null
+++ b/buildout.d/jenkins.cfg
@@ -0,0 +1,24 @@
+[buildout]
+extends =
+    base.cfg
+    https://raw.github.com/plone/buildout.jenkins/master/jenkins.cfg
+    https://raw.github.com/plone/buildout.jenkins/master/jenkins-code-analysis.cfg
+
+jenkins-test-eggs = ${buildout:package-name} ${buildout:package-extras}
+jenkins-test-directories = src/plone/app/contenttypes
+
+parts += pylint
+
+[pylint]
+recipe = zc.recipe.egg
+eggs = pylint
+       ${buildout:eggs}
+scripts = pylint
+entry-points = pylint=pylint.lint:Run
+arguments = [
+    '--output-format=parseable',
+    '--zope=y',
+    '--reports=y',
+    '--disable=E0611,F0401,W0232,E1101,C0103,C0111,R0201,W0201,R0911,R0904,F0220,E1103,R0901,E0211,E0213,E1002,W0622,C0301,W0212,R0903',
+    '--generated-members=objects',
+    ] + (sys.argv[1:] or ["${buildout:jenkins-test-directories}"])
diff --git a/buildout.d/sources.cfg b/buildout.d/sources.cfg
new file mode 100644
index 0000000..585af8e
--- /dev/null
+++ b/buildout.d/sources.cfg
@@ -0,0 +1,9 @@
+[remotes]
+collective = git://github.com/collective
+collective_push = git@github.com:collective
+plone = git://github.com/plone
+plone_push = git@github.com:plone
+
+[sources]
+plone.app.dexterity = git ${remotes:plone}/plone.app.dexterity.git pushurl=${remotes:plone_push}/plone.app.dexterity.git branch=2.0.x
+plone.app.robotframework = git ${remotes:plone}/plone.app.robotframework.git pushurl=${remotes:plone_push}/plone.app.robotframework.git branch=master
diff --git a/buildout.d/versions.cfg b/buildout.d/versions.cfg
new file mode 100644
index 0000000..88aafe4
--- /dev/null
+++ b/buildout.d/versions.cfg
@@ -0,0 +1,10 @@
+[versions]
+setuptools = 6.1
+zc.buildout = 2.2.5
+zc.recipe.egg = 2.0.1
+
+robotframework = 2.8.4
+robotframework-ride = 1.3
+robotframework-selenium2library = 1.6.0
+robotsuite = 1.6.1
+selenium = 2.44.0
diff --git a/dev.cfg b/dev.cfg
deleted file mode 100644
index 5eaf2dd..0000000
--- a/dev.cfg
+++ /dev/null
@@ -1,15 +0,0 @@
-[buildout]
-extends =
-    buildout.cfg
-
-[instance]
-eggs +=
-    Pillow
-    plone.app.debugtoolbar
-    plone.reload
-#    Products.PDBDebugMode
-#    bpython
-#    Products.PrintingMailHost
-#    ipdb
-
-#demo-storage = on
diff --git a/docs/CHANGES.rst b/docs/CHANGES.rst
index 85172ac..a89f145 100644
--- a/docs/CHANGES.rst
+++ b/docs/CHANGES.rst
@@ -1,7 +1,101 @@
 Changelog
 =========
 
-1.2a5 (unreleased)
+1.2a8 (unreleased)
+------------------
+
+- Fix ``test_warning_for_uneditable_content`` to work with recent browser layer
+  changes in ``plone.app.z3cform``.
+  [thet]
+
+- Update image_view_fullscreen.pt for mobile friendliness.
+  [fulv]
+
+
+1.2a7 (2015-03-27)
+------------------
+
+- Re-relase 1.2a6. See https://github.com/plone/plone.app.contenttypes/commit/7cb74a2fcbf108acd43fe4ae3713f007db2073bf for details.
+  [timo]
+
+
+1.2a6 (2015-03-26)
+------------------
+
+- In the listing view, don't repeat on the ``article`` tag, which makes it
+  impossible to override this structure. Instead, repeat on a unrendered
+  ``tal`` tag and move the article tag within.
+  [thet]
+
+- Don't try to show IContentLeadImage images, if theree none. Use the "mini"
+  scale as default scale for IContentLeadImage.
+  [thet]
+
+- Improve handling of Link types with other URL schemes than ``http://`` and
+  ``https://``.
+  [thet]
+
+- When installing the default profile, restrict uninstalling of old types to
+  old FTI based ones.
+  [thet]
+
+- Reformatted all templates for 2 space indentation, 4 space for attributes.
+  [thet]
+
+- Register folder and collection views under the same name. Old registrations
+  are kept for BBB compatibility.
+  [thet]
+
+- Refactor full_view and incorporate fixes from collective.fullview to
+  1) display the default views of it's items, 2) be recursively callable
+  and 3) have the same templates for folder and collections.
+  [thet]
+
+- Refactor folder_listing, folder_summary_view, folder_tabular_view and
+  folder_album_view for folders as well as standard_view (collection_view),
+  summary_view, tabular_view and thumbnail_view for collections to use the same
+  templates and base view class.
+  [thet]
+
+- In the file view, render HTML5 ``<audio>`` or ``<video>`` tags for audio
+  respectively video file types. Ancient browsers, which do not support that,
+  just don't render these tags.
+  [thet]
+
+- Define ``default_page_types`` in the ``propertiestool.xml`` profile.
+  [thet]
+
+- Add ``event_listing`` to available view methods for the Folder and Collection
+  types.
+  [thet]
+
+- Add migration for images added with collective.contentleadimage.
+  [pbauer]
+
+- Add migration for contentrules.
+  [pbauer]
+
+- Fix folder_full_view_item and allow overriding with jbot (fix #162).
+  [pbauer]
+
+- Migrate comments created with plone.app.discussion.
+  [gbastien, pbauer]
+
+- Allow migrating Topics and Subtopics to folderish Collections.
+  [pbauer]
+
+- Add migration from Topics to Collections (fixes #131).
+  [maurits, pbauer]
+
+- Add helpers and a form to update object with changed base class. Also
+  allows migrating from itemish to folderish.
+  [bogdangi, pbauer]
+
+- Keep portlets when migrating AT to DX (fixes #161)
+  [frisi, gbastien, petschki]
+
+
+1.2a5 (2014-10-23)
 ------------------
 
 - Add custom migration for AT-Types that were removed from portal_types.
diff --git a/docs/README.rst b/docs/README.rst
index ef496d8..8728a01 100644
--- a/docs/README.rst
+++ b/docs/README.rst
@@ -1,8 +1,5 @@
 .. contents::
 
-.. image:: http://jenkins.plone.org/job/kgs-plone.app.contenttypes-plone-5.0-python-2.7/badge/icon
-    :target: http://jenkins.plone.org/job/kgs-plone.app.contenttypes-plone-5.0-python-2.7/
-
 .. image:: https://pypip.in/d/plone.app.contenttypes/badge.png
     :target: https://crate.io/packages/plone.app.contenttypes
 
@@ -16,28 +13,22 @@ plone.app.contenttypes documentation
 Introduction
 ------------
 
-
-
-plone.app.contenttypes offers default content types for Plone based on Dexterity. This package replaces ``Products.ATContenttypes`` and will provide the default-types in Plone 5.
+plone.app.contenttypes provides default content types for Plone based on Dexterity. It replaces ``Products.ATContentTypes`` and provides the default-types in Plone 5. It can be used as an add-on in Plone 4.x.
 
 It contains the following types:
 
-* Folder
+* Collection
 * Document
-* News item
+* Event
 * File
+* Folder
 * Image
 * Link
-* Event (Using behaviors from plone.app.event)
-* Collection
+* News Item
 
 The main difference from a users perspective is that these types are extendable through-the-web. This means you can add or remove fields and behaviors using the control-panel "Dexterity Content Types" (``/@@dexterity-types``).
 
-The aim is to mimick the default-types as closely as possible.
-
-plone.app.contenttypes has been merged into the Plone 5.0 branch and will be shipped with the next Plone release: https://dev.plone.org/ticket/12344
-
-**Warning: Using plone.app.contenttypes on a site with existing content requires migrating the sites content. Please see the chapter "Migration". It can be used on a new site without problems.**
+**Warning: Using plone.app.contenttypes on a site with existing Archetypes-based content requires migrating the sites content. Please see the chapter "Migration".**
 
 
 Compatibility
@@ -53,7 +44,9 @@ The versions 1.2.x of the master-branch are compatible with Plone 5 and plone.ap
 Installation
 ------------
 
-Add this line in the eggs section of your ``buildout.cfg``
+This package is included in Plone 5 and does not need installation.
+
+To use plone.app.contenttypes in Plone 4.x add this line in the eggs section of your ``buildout.cfg``
 
 .. code:: ini
 
@@ -97,29 +90,27 @@ If you install plone.app.contenttypes on a fresh site (i.e. when no content has
 Uninstalling
 ------------
 
-To remove plone.app.contenttypes and return full functionality to old content and restore the AT-based default-types you have to install the import step "Types Tool" of the current base profile. Follow the following steps:
+Uninstalling the default-types is not supported in Plone 5. If you really want to switch back to Archetypes-based types you have to to the following:
 
-* in the ZMI navigate to portal_setup and the tab "import"
-* in "Select Profile or Snapshot" leave "Current base profile (<Name of your Plonesite>)" selected. This is usually Products.CMFPlone
-* select the Types Tool (usually Step 44)
-* click "import selected steps"
-
-Any content you created based on plone.app.contenttypes will not be editable until you reinstall plone.app.contenttypes.
+* Go to the ZMI
+* In portal_types delete the default-types
+* In portal_setup navigate to the tab 'import', select the profile 'Archetypes Content Types for Plone' and install all step including dependencies.
 
+Any content you created based on plone.app.contenttypes will no longer be editable until you reinstall plone.app.contenttypes.
 
 
 Dependencies
 ------------
 
-* ``plone.app.dexterity >= 2.0.7``. Dexterity is shipped with Plone 4.3.x. Version pinns for Dexterity are included in Plone 4.2.x. For Plone 4.1.x you need to pin the correct version for Dexterity in your buildout. See `Installing Dexterity on older versions of Plone <http://developer.plone.org/reference_manuals/external/plone.app.dexterity/install.html#installing-dexterity-on-older-versions-of-plone>`_.
+* ``plone.app.dexterity >= 2.0.7``. Dexterity is shipped with Plone 4.3.x. Version pinns for Dexterity are included in Plone 4.2.x. For Plone 4.1.x you need to pin the right version for Dexterity in your buildout. See `Installing Dexterity on older versions of Plone <http://docs.plone.org/external/plone.app.dexterity/docs/install.html#installing-dexterity-on-older-versions-of-plone>`_.
 
 * ``plone.dexterity >= 2.2.1``. Olders version of plone.dexterity break the rss-views because plone.app.contenttypes uses behaviors for the richtext-fields.
 
-* ``plone.app.event >= 1.1b1``. This provides the behaviors used for the event-type.
+* ``plone.app.event >= 1.1.4``. This provides the behaviors used for the event-type.
 
 * ``plone.app.portlets >= 2.5a1``. In older version the event-portlet will not work with the new event-type.
 
-These are the version-pinns for Plone 4.3.3:
+These are the version-pinns for Plone 4.3.4:
 
 .. code:: ini
 
@@ -127,8 +118,9 @@ These are the version-pinns for Plone 4.3.3:
     versions = versions
 
     [versions]
-    plone.app.event = 1.1.1
-    plone.app.portlets = 2.5.1
+    plone.app.event = 1.1.4
+
+Plone 4.3.3 also needs ``plone.app.portlets = 2.5.2``
 
 Plone-versions before 4.3.3 need to pinn more packages:
 
@@ -144,19 +136,19 @@ Plone-versions before 4.3.3 need to pinn more packages:
     plone.app.event = 1.1b1
     plone.app.portlets = 2.5.1
 
+For migrations to work you need at least ``Products.contentmigration = 2.1.9`` and ``plone.app.intid`` (part of Plone since Plone 4.1.0).
+
 
 Migration
 ---------
 
 To migrate your existing content from Archetypes to Dexterity use the form at ``/@@atct_migrator``.
 
-For migrations to work you need at least ``Products.contentmigration = 2.1.9`` and ``plone.app.intid`` (part of Plone since Plone 4.1.0).
-
 
 Migrating Archetypes-based content to plone.app.contenttypes
 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 
-plone.app.contenttypes can migrate the following default types:
+plone.app.contenttypes can migrate the following archetypes-based default types:
 
 * Document
 * Event
@@ -166,6 +158,7 @@ plone.app.contenttypes can migrate the following default types:
 * Link
 * News Item
 * Collection
+* Topic (old Collections)
 
 The following non-default types will also be migrated:
 
@@ -174,13 +167,49 @@ The following non-default types will also be migrated:
 * The Event-type provided by plone.app.contenttypes until version 1.0
 * News Items with blobs (provoded by https://github.com/plone/plone.app.blob/pull/2)
 * Files and Images without blobs
-* AT-based collection provided by plone.app.collection
 
-Migrations that are coming in future versions:
+The migration tries to keep most features (including portlets, comments, contentrules, local roles and local workflows).
+
+**Warning:** Versions of content are not migrated. During migration you will lose all old revisions.
+
+
+Migrating only certain types
+^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+
+There is also a view ``/@@pac_installer`` that allows you to install plone.app.contenttypes without replacing those archetypes-types with the dexterity-types of which there are existing objects in the site. Afterwards it redirects to the migration-form and only the types that you chose to migrate are installed. This allows you to keep certain types as archetypes while migrating others to dexterity (for example if you did heavy customizations of these types and do not have the time to reimplement these features in dexterity.
 
-* from ATTopic to Collections
 
-Please note that migrating versions of content is not supported. Only the current state of items is migrated without any content- or workflow-history.
+Migrating Topics
+^^^^^^^^^^^^^^^^
+
+Topics are migrated to Collections. However, the old type Topic had support for Subtopics, a feature that does not exit in Collections. Subtopics are nested Topics that inherited search terms from their parents. Since Collections are not folderish (i.e. they cannot contain content) Subtopics cannot be migrated unless Collections are made folderish (i.e. that they can contain content). Also the feature that search terms can be inherited from parents does not exist for Collections.
+
+The migration-form will warn you if you have subtopics in your site and your Collections are not folderish. You then have several options:
+
+1. You can delete all Subtopics before migrating and achieve their functionality in another way (e.g. using eea.facetednavigation).
+2. You can choose to not migrate Topics by not selecting them. This will keep your old Topics functional. You can still add new Collections.
+3. You can modify Collections to be folderish or create your own folderish content-type.   That type would need a base-class that inherits from ``plone.dexterity.content.Container`` instead of ``plone.dexterity.content.Item``:
+
+   .. code-block:: python
+
+      from plone.app.contenttypes.behaviors.collection import ICollection
+      from plone.dexterity.content import Container
+      from zope.interface import implementer
+
+      @implementer(ICollection)
+      class FolderishCollection(Container):
+          pass
+
+   You can either use a new Collection type or simply modify the default type to use this new base-class by overriding the klass-attribute of the default Collection. To override add a ``Collection.xml`` in your own package:
+
+   .. code-block:: xml
+
+      <?xml version="1.0"?>
+      <object name="Collection" meta_type="Dexterity FTI">
+       <property name="klass">my.package.content.FolderishCollection</property>
+      </object>
+
+   If you really need it you could add the functionality to inherit search terms to your own folderish Collections by extending the behavior like in the example at https://github.com/plone/plone.app.contenttypes/commit/366cc1a911c81954645ec6aabce925df4a297c63
 
 
 Migrating content that is translated with LinguaPlone
@@ -192,7 +221,7 @@ Since LinguaPlone does not support Dexterity you need to migrate from LinguaPlon
 Migrating from old versions of plone.app.contenttypes
 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 
-Before version 1.0a2 the content-items did not implement marker-interfaces.  They will break in newer versions since the views are now registered for these interfaces (e.g. ``plone.app.contenttypes.interfaces.IDocument``). To fix this you can call the view ``/@@fix_base_classes`` on your site-root.
+Before version 1.0a2 the content-items did not implement marker-interfaces. They will break in newer versions since the views are now registered for these interfaces (e.g. ``plone.app.contenttypes.interfaces.IDocument``). To fix this you can call the view ``/@@fix_base_classes`` on your site-root.
 
 Since plone.app.contenttypes 1.1a1, the Collection type uses the new Collection behavior and the Event type utilizes behaviors from `plone.app.event <http://pypi.python.org/pypi/plone.app.event>`_. In order to upgrade:
 
@@ -203,9 +232,17 @@ Since plone.app.contenttypes 1.1a1, the Collection type uses the new Collection
 Migrating default-content that was extended with archetypes.schemaextender
 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 
-The migration should warn you if any of your types are extended with archetypes.schemaextender. The data contained in these fields will be lost.
+The migration-form warns you if any of your old types were extended with aditional fields using archetypes.schemaextender. The data contained in these fields will be lost during migration (with the exception of images added with collective.contentleadimage).
+
+To keep the data you would need to write a custom migration for your types dexterity-behaviors for the functionality provided by the schemaextenders. This is an advanced development task and beyond the scope of this documentation.
 
-You need to implement a custom migration for your types and dexterity-behaviors for the functionality provided by the schemaextenders. This is an advanced development task and beyond the scope of this documentation.
+
+Migrating images created with collective.contentleadimage
+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+
+`collective.contentleadimage <https://pypi.python.org/pypi/collective.contentleadimage/>`_ was a popular addon that allows you to add images to any content in your site by extending the default types. To make sure these images are kept during migration you have to enable the behavior "Lead Image" on all those types where you want to migrate images added using collective.contentleadimage.
+
+The old types that use leadimages are listed in the navigation-form with the comment *"extended fields: 'leadImage', 'leadImage_caption'"*. The migration-form informs you which new types have the behavior enabled and which do not. Depending on the way you installed plone.app.contenttypes you might have to first install these types by (re-)installing plone.app.contenttypes.
 
 
 Migrating custom content
@@ -213,9 +250,9 @@ Migrating custom content
 
 Custom content-types will not be touched by the migration plone.app.contenttypes and will continue to work as expected.
 
-Future versions of plone.app.contenttypes will have with a form that allows you to migrate old custom Archetypes-content to Dexterity (you'll have to create the Dexterity-types before) .
+Future versions of plone.app.contenttypes will have with a form that allows you to migrate old custom Archetypes-content to Dexterity (you'll still have to create the Dexterity-types before migrating).
 
-However if you'd like to migrate your content-types to Dexterity before this feature is completed you might want to have a look at the code of plone.app.contenttypes.migration.migration.NewsItemMigrator as a blueprint for a migration.
+If you want to migrate your custom types to Dexterity before this feature is completed you might want to have a look at the code of plone.app.contenttypes.migration.migration.NewsItemMigrator as a blueprint for a migration.
 
 
 Widgets
@@ -293,6 +330,20 @@ If you want to add plone.app.contenttypes as a dependency from another products
 If you use the profile ``default`` then the default-content in new sites will still be Archetypes-based. You'll then have to migrate that content using the migration-form ``@@atct_migrator`` or delete it by hand.
 
 
+Using folderish types
+^^^^^^^^^^^^^^^^^^^^^
+
+At some point all default types will probably be folderish. If you want the default types to be folderish before that happens please look at https://pypi.python.org/pypi/collective.folderishtypes.
+
+
+Changing the base class for existing objects
+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+
+If you changed the base-class of existing types (e.g. because you changed them to be folderish) you also need to upgrade the base-class of existing objects. You can use the following form for this: ``@@base_class_migrator_form``.
+
+This form lets you select classes to be updated and shows the number of objects for each class. This form can be used to change the base-class of any dexterity-types instances. The migration will also transform itemish content to folderish content if the new class is folderish. You might want to use the method ``plone.app.contenttypes.migration.dxmigration.migrate_base_class_to_new_class`` in your own upgrade-steps.
+
+
 Extending the types
 ^^^^^^^^^^^^^^^^^^^
 
@@ -445,3 +496,5 @@ Contributors
 * Roman Kozlovskyi <krzroman@gmail.com>
 * Gauthier Bastien <gauthier.bastien@imio.be>
 * Andrea Cecchi <andrea.cecchi@redturtle.it>
+* Bogdan Girman <bogdan.girman@gmail.com>
+* Martin Opstad Reistadbakk <martin@blaastolen.com>
diff --git a/jenkins.cfg b/jenkins.cfg
index 3cf872c..870651f 100644
--- a/jenkins.cfg
+++ b/jenkins.cfg
@@ -1,6 +1,6 @@
 [buildout]
 extends =
-    test-plone-4.3.x.cfg
+    buildout.d/base.cfg
     https://raw.github.com/plone/buildout.jenkins/master/jenkins.cfg
     https://raw.github.com/plone/buildout.jenkins/master/jenkins-code-analysis.cfg
 parts += code-analysis
diff --git a/plone/app/contenttypes/behaviors/collection.py b/plone/app/contenttypes/behaviors/collection.py
index 81dc156..fef593c 100644
--- a/plone/app/contenttypes/behaviors/collection.py
+++ b/plone/app/contenttypes/behaviors/collection.py
@@ -4,8 +4,9 @@
     as BaseCollectionFeed
 from Products.CMFPlone.interfaces.syndication import IFeed
 from Products.CMFPlone.interfaces.syndication import ISyndicatable
-from plone.app.contentlisting.interfaces import IContentListing
 from plone.app.contenttypes import _
+from plone.app.z3cform.widget import QueryStringFieldWidget
+from plone.autoform import directives as form
 from plone.autoform.interfaces import IFormFieldProvider
 from plone.dexterity.interfaces import IDexterityContent
 from plone.supermodel import model
@@ -13,8 +14,8 @@
 from zope.component import adapter
 from zope.component import getMultiAdapter
 from zope.component import getUtility
-from zope.interface import provider
 from zope.interface import implementer
+from zope.interface import provider
 from zope.schema.interfaces import IVocabularyFactory
 from zope.schema.vocabulary import SimpleTerm
 from zope.schema.vocabulary import SimpleVocabulary
@@ -47,6 +48,7 @@ class ICollection(model.Schema):
         required=False,
         missing_value=''
     )
+    form.widget('query', QueryStringFieldWidget)
 
     sort_on = schema.TextLine(
         title=_(u'label_sort_on', default=u'Sort on'),
@@ -142,36 +144,6 @@ def results(self, batch=True, b_start=0, b_size=None,
             limit=limit, brains=brains, custom_query=custom_query
         )
 
-    def getFoldersAndImages(self):
-        catalog = getToolByName(self.context, 'portal_catalog')
-        results = self.results(batch=False)
-
-        _mapping = {'results': results, 'images': {}}
-        portal_atct = getToolByName(self.context, 'portal_atct', None)
-        image_types = getattr(portal_atct, 'image_types', ['Image'])
-
-        filtered_results = []
-        for item in results:
-            item_path = item.getPath()
-            if item.isPrincipiaFolderish:
-                query = {
-                    'portal_type': image_types,
-                    'path': item_path,
-                }
-                _mapping['images'][item_path] = IContentListing(catalog(query))
-            elif item.portal_type in image_types:
-                _mapping['images'][item_path] = [item, ]
-            else:
-                continue
-            filtered_results.append(item)
-
-        _mapping['total_number_of_images'] = sum(map(
-            len,
-            _mapping['images'].values()
-        ))
-        _mapping['results'] = filtered_results
-        return _mapping
-
     def selectedViewFields(self):
         """Returns a list of all metadata fields from the catalog that were
            selected.
@@ -184,7 +156,8 @@ def selectedViewFields(self):
                            name='plone.app.contenttypes.metadatafields')
         for field in vocab(self.context):
             _mapping[field.value] = (field.value, field.title)
-        return [_mapping[field] for field in self.customViewFields]
+        ret = [_mapping[field] for field in self.customViewFields]
+        return ret
 
     # Getters and setters for our fields.
 
diff --git a/plone/app/contenttypes/behaviors/leadimage.pt b/plone/app/contenttypes/behaviors/leadimage.pt
index 5e3b3ca..1c50f80 100644
--- a/plone/app/contenttypes/behaviors/leadimage.pt
+++ b/plone/app/contenttypes/behaviors/leadimage.pt
@@ -1,5 +1,6 @@
-<div class="leadImage"
-     tal:condition="view/available">
-  <img tal:define="scale context/@@images"
-       tal:replace="structure python: scale.scale('image', width=200, height=200).tag(css_class='newsImage')" />
-</div>
\ No newline at end of file
+<div class="leadImage" tal:condition="view/available">
+  <img tal:define="has_img context/image|nothing;
+                   scales context/@@images|nothing"
+       tal:condition="python:has_img and scales" 
+       tal:replace="structure python: scales.scale('image', scale='mini').tag(css_class='newsImage')" />
+</div>
diff --git a/plone/app/contenttypes/behaviors/richtext.py b/plone/app/contenttypes/behaviors/richtext.py
index a3b20ba..1dac2fe 100644
--- a/plone/app/contenttypes/behaviors/richtext.py
+++ b/plone/app/contenttypes/behaviors/richtext.py
@@ -3,11 +3,13 @@
 from plone.app.textfield import RichText as RichTextField
 from plone.autoform.interfaces import IFormFieldProvider
 from plone.autoform.view import WidgetsView
+from plone.autoform import directives as form
 from plone.dexterity.interfaces import IDexterityContent
 from plone.supermodel import model
 from zope.component import adapter
 from zope.interface import implementer
 from zope.interface import provider
+from plone.app.z3cform.widget import RichTextFieldWidget
 
 
 @provider(IFormFieldProvider)
@@ -18,6 +20,7 @@ class IRichText(model.Schema):
         description=u"",
         required=False,
     )
+    form.widget('text', RichTextFieldWidget)
     model.primary('text')
 
 
diff --git a/plone/app/contenttypes/browser/album_view.py b/plone/app/contenttypes/browser/album_view.py
deleted file mode 100644
index fca86d8..0000000
--- a/plone/app/contenttypes/browser/album_view.py
+++ /dev/null
@@ -1,57 +0,0 @@
-# -*- coding: utf-8 -*-
-from Products.CMFCore.utils import getToolByName
-from Products.Five.browser import BrowserView
-from Products.Five.browser.pagetemplatefile import ViewPageTemplateFile
-
-# from Products.CMFCore.utils import getToolByName
-
-
-class AlbumView(BrowserView):
-
-    template = ViewPageTemplateFile('templates/folder_album_view.pt')
-
-    def getAlbumContent(self,
-                        container=None,
-                        images=0,
-                        folders=0,
-                        subimages=0,
-                        others=0):
-        """ Mostly ripped out from atctListAlbum.py
-        """
-
-        if not container:
-            container = self.context
-
-        result = {}
-
-        if images:
-            result['images'] = container.getFolderContents(
-                {'portal_type': ('Image',)}, full_objects=True)
-
-        if folders:
-            result['folders'] = container.getFolderContents(
-                {'portal_type': ('Folder',)})
-
-        if subimages:
-            # Handle brains or objects
-            if getattr(container, 'getPath', None) is not None:
-                path = container.getPath()
-            else:
-                path = '/'.join(container.getPhysicalPath())
-            # Explicitly set path to remove default depth
-            result['subimages'] = container.getFolderContents(
-                {'portal_type': ('Image',), 'path': path})
-
-        if others:
-            utils = getToolByName(self.context, 'plone_utils')
-            searchContentTypes = utils.getUserFriendlyTypes()
-            filtered = [p_type for p_type in searchContentTypes
-                        if p_type not in ('Image', 'Folder',)]
-            if filtered:
-                # We don't need the full objects for the folder_listing
-                result['others'] = container.getFolderContents(
-                    {'portal_type': filtered})
-            else:
-                result['others'] = ()
-
-        return result
diff --git a/plone/app/contenttypes/browser/collection.py b/plone/app/contenttypes/browser/collection.py
index ddb2f6f..bfafca0 100644
--- a/plone/app/contenttypes/browser/collection.py
+++ b/plone/app/contenttypes/browser/collection.py
@@ -1,25 +1,82 @@
 # -*- coding: utf-8 -*-
 from Acquisition import aq_inner
-from Products.Five import BrowserView
+from plone.app.contenttypes import _
 from plone.app.contenttypes.behaviors.collection import ICollection
+from plone.app.contenttypes.browser.folder import FolderView
+from plone.app.contenttypes.interfaces import IFolder
+from plone.app.contenttypes.interfaces import IImage
+from plone.memoize.view import memoize
 
 
-class CollectionView(BrowserView):
+class CollectionView(FolderView):
 
-    def results(self, **kwargs):
+    def __init__(self, *args, **kwargs):
+        super(CollectionView, self).__init__(*args, **kwargs)
         context = aq_inner(self.context)
-        wrapped = ICollection(context)
-        return wrapped.results(**kwargs)
+        self.collection_behavior = ICollection(context)
+        self.b_size = self.collection_behavior.item_count
 
-    def getFoldersAndImages(self, **kwargs):
-        context = aq_inner(self.context)
-        wrapped = ICollection(context)
-        return wrapped.getFoldersAndImages(**kwargs)
+    def results(self, **kwargs):
+        """Return a content listing based result set with results from the
+        collection query.
+
+        :param **kwargs: Any keyword argument, which can be used for catalog
+                         queries.
+        :type  **kwargs: keyword argument
+
+        :returns: plone.app.contentlisting based result set.
+        :rtype: ``plone.app.contentlisting.interfaces.IContentListing`` based
+                sequence.
+        """
+        # Extra filter
+        kwargs.update(dict(getattr(self.request, 'contentFilter', {})))
+        kwargs.setdefault('batch', True)
+        kwargs.setdefault('b_size', self.b_size)
+        kwargs.setdefault('b_start', self.b_start)
 
-    def selectedViewFields(self):
+        return self.collection_behavior.results(**kwargs)
+
+    @property
+    @memoize
+    def _album_results(self):
+        """Get results to display an album with subalbums.
+        """
+        results = self.results()
+        images = []
+        folders = []
+        for it in results:
+            # TODO: potentially expensive!
+            ob = it.getObject()
+            if IImage.providedBy(ob):
+                images.append(it)
+            elif IFolder.providedBy(ob):
+                folders.append(it)
+        return {'images': images, 'folders': folders}
+
+    @property
+    def album_images(self):
+        """Get all images within this collection.
+        """
+        return self._album_results['images']
+
+    @property
+    def album_folders(self):
+        """Get all folders within this collection.
+        """
+        return self._album_results['folders']
+
+    def tabular_fields(self):
         """Returns a list of all metadata fields from the catalog that were
            selected.
         """
         context = aq_inner(self.context)
         wrapped = ICollection(context)
-        return wrapped.selectedViewFields()
+        fields = wrapped.selectedViewFields()
+        fields = [field[0] for field in fields]
+        return fields
+
+    def no_items_message(self):
+        return _(
+            'description_no_results_found',
+            default=u"No results were found."
+        )
diff --git a/plone/app/contenttypes/browser/configure.zcml b/plone/app/contenttypes/browser/configure.zcml
index 13730b4..49136b1 100644
--- a/plone/app/contenttypes/browser/configure.zcml
+++ b/plone/app/contenttypes/browser/configure.zcml
@@ -9,248 +9,213 @@
 
   <browser:resource
       name="collection.css"
-      file="stylesheets/collection.css" />
+      file="stylesheets/collection.css"
+      layer="plone.app.contenttypes.interfaces.IPloneAppContenttypesLayer"/>
 
 
-  <!-- VIEWS FOR COLLECTION ITEM -->
+  <!-- VIEWS FOR PLONE SITE ROOT -->
+  <browser:pages
+      for="Products.CMFPlone.interfaces.IPloneSiteRoot"
+      class=".folder.FolderView"
+      layer="plone.app.contenttypes.interfaces.IPloneAppContenttypesLayer"
+      permission="zope2.View">
+    <browser:page
+        name="listing_view"
+        template="templates/listing.pt"
+        menu="plone_displayviews"
+        title="Standard view"
+        />
+    <browser:page
+        name="summary_view"
+        template="templates/listing_summary.pt"
+        menu="plone_displayviews"
+        title="Summary view"
+        />
+    <browser:page
+        name="tabular_view"
+        template="templates/listing_tabular.pt"
+        menu="plone_displayviews"
+        title="Tabular view"
+        />
+    <browser:page
+        name="full_view"
+        template="templates/full_view.pt"
+        menu="plone_displayviews"
+        title="All content"
+        />
+    <browser:page
+        name="album_view"
+        template="templates/listing_album.pt"
+        menu="plone_displayviews"
+        title="Album view"
+        />
+  </browser:pages>
+
+
+  <!-- VIEWS FOR FOLDERS -->
+  <browser:pages
+      for="plone.dexterity.interfaces.IDexterityContainer"
+      class=".folder.FolderView"
+      layer="plone.app.contenttypes.interfaces.IPloneAppContenttypesLayer"
+      permission="zope2.View">
+    <browser:page
+        name="listing_view"
+        template="templates/listing.pt"
+        menu="plone_displayviews"
+        title="Standard view"
+        />
+    <browser:page
+        name="summary_view"
+        template="templates/listing_summary.pt"
+        menu="plone_displayviews"
+        title="Summary view"
+        />
+    <browser:page
+        name="tabular_view"
+        template="templates/listing_tabular.pt"
+        menu="plone_displayviews"
+        title="Tabular view"
+        />
+    <browser:page
+        name="full_view"
+        template="templates/full_view.pt"
+        menu="plone_displayviews"
+        title="All content"
+        />
+    <browser:page
+        name="album_view"
+        template="templates/listing_album.pt"
+        menu="plone_displayviews"
+        title="Album view"
+        />
+  </browser:pages>
 
-  <browser:page
-    name="view"
-    permission="zope2.View"
-    for="plone.app.contenttypes.interfaces.ICollection"
-    class=".collection.CollectionView"
-    template="templates/standard_view.pt"
-    />
 
+  <!-- VIEWS FOR COLLECTION ITEM -->
   <browser:page
-    name="standard_view"
-    permission="zope2.View"
-    for="plone.app.contenttypes.interfaces.ICollection"
-    class=".collection.CollectionView"
-    template="templates/standard_view.pt"
-    />
+      name="listing_view"
+      for="plone.app.contenttypes.interfaces.ICollection"
+      class=".collection.CollectionView"
+      layer="plone.app.contenttypes.interfaces.IPloneAppContenttypesLayer"
+      template="templates/listing.pt"
+      permission="zope2.View"
+      />
 
   <!-- VIEWS FOR ANYTHING WITH THE COLLECTION BEHAVIOR.
-
        Note that these ignore other fields, but integrators should
        create other themplates if they want that.  Or improve the
        query view widget.  -->
-
-  <browser:page
-    name="collection_view"
-    permission="zope2.View"
-    for="plone.app.contenttypes.behaviors.collection.ISyndicatableCollection"
-    class=".collection.CollectionView"
-    template="templates/standard_view.pt"
-    />
-
-  <browser:page
-    name="summary_view"
-    permission="zope2.View"
-    for="plone.app.contenttypes.behaviors.collection.ISyndicatableCollection"
-    class=".collection.CollectionView"
-    template="templates/summary_view.pt"
-    />
-
-  <browser:page
-    name="all_content"
-    permission="zope2.View"
-    for="plone.app.contenttypes.behaviors.collection.ISyndicatableCollection"
-    class=".collection.CollectionView"
-    template="templates/all_content.pt"
-    />
-
-  <browser:page
-    name="tabular_view"
-    permission="zope2.View"
-    for="plone.app.contenttypes.behaviors.collection.ISyndicatableCollection"
-    class=".collection.CollectionView"
-    template="templates/tabular_view.pt"
-    />
-
+  <browser:pages
+      for="plone.app.contenttypes.behaviors.collection.ISyndicatableCollection"
+      class=".collection.CollectionView"
+      layer="plone.app.contenttypes.interfaces.IPloneAppContenttypesLayer"
+      permission="zope2.View">
+    <browser:page
+        name="listing_view"
+        template="templates/listing.pt"
+        menu="plone_displayviews"
+        title="Standard view"
+        />
+    <browser:page
+        name="summary_view"
+        template="templates/listing_summary.pt"
+        menu="plone_displayviews"
+        title="Summary view"
+        />
+    <browser:page
+        name="tabular_view"
+        template="templates/listing_tabular.pt"
+        menu="plone_displayviews"
+        title="Tabular view"
+        />
+    <browser:page
+        name="full_view"
+        template="templates/full_view.pt"
+        menu="plone_displayviews"
+        title="All content"
+        />
+    <browser:page
+        name="album_view"
+        template="templates/listing_album.pt"
+        menu="plone_displayviews"
+        title="Album view"
+        />
+  </browser:pages>
+
+
+  <!-- OTHER VIEWS -->
   <browser:page
-    name="thumbnail_view"
-    permission="zope2.View"
-    for="plone.app.contenttypes.behaviors.collection.ISyndicatableCollection"
-    class=".collection.CollectionView"
-    template="templates/thumbnail_view.pt"
-    />
-
-  <!-- COLLECTION MENU ITEMS -->
-
-  <browser:menuItems
-    for="plone.app.contenttypes.interfaces.ICollection"
-    menu="plone_displayviews">
-    <browser:menuItem
-      title="Standard view"
-      action="standard_view"
-      />
-    <browser:menuItem
-      title="Summary view"
-      action="summary_view"
-      />
-    <browser:menuItem
-      title="All content"
-      action="all_content"
-      />
-    <browser:menuItem
-      title="Tabular view"
-      action="tabular_view"
-      />
-    <browser:menuItem
-      title="Thumbnail view"
-      action="thumbnail_view"
+      name="full_view_item"
+      for="*"
+      class=".full_view.FullViewItem"
+      template="templates/full_view_item.pt"
+      layer="plone.app.contenttypes.interfaces.IPloneAppContenttypesLayer"
+      permission="zope2.View"
       />
-  </browser:menuItems>
-
-  <browser:page
-    name="document_view"
-    for="plone.app.contenttypes.interfaces.IDocument"
-    layer="plone.app.contenttypes.interfaces.IPloneAppContenttypesLayer"
-    template="templates/document.pt"
-    permission="zope2.View"
-    menu="plone_displayviews"
-    title="View Document"
-    />
-
-  <browser:page
-    name="file_view"
-    for="plone.app.contenttypes.interfaces.IFile"
-    layer="plone.app.contenttypes.interfaces.IPloneAppContenttypesLayer"
-    template="templates/file.pt"
-    permission="zope2.View"
-    menu="plone_displayviews"
-    title="View File"
-    />
-
-  <browser:page
-    name="folder_listing"
-    for="plone.dexterity.interfaces.IDexterityContainer"
-    layer="plone.app.contenttypes.interfaces.IPloneAppContenttypesLayer"
-    template="templates/folder_listing.pt"
-    permission="zope2.View"
-    menu="plone_displayviews"
-    title="Standard view"
-    />
-
-  <browser:page
-    name="folder_listing"
-    for="Products.CMFPlone.interfaces.IPloneSiteRoot"
-    layer="plone.app.contenttypes.interfaces.IPloneAppContenttypesLayer"
-    template="templates/folder_listing.pt"
-    permission="zope2.View"
-    menu="plone_displayviews"
-    title="Standard view"
-    />
-
   <browser:page
-    name="folder_full_view"
-    for="plone.dexterity.interfaces.IDexterityContainer"
-    layer="plone.app.contenttypes.interfaces.IPloneAppContenttypesLayer"
-    template="templates/folder_full_view.pt"
-    permission="zope2.View"
-    menu="plone_displayviews"
-    title="All content"
-    />
-
-  <browser:page
-    name="folder_summary_view"
-    for="plone.dexterity.interfaces.IDexterityContainer"
-    layer="plone.app.contenttypes.interfaces.IPloneAppContenttypesLayer"
-    template="templates/folder_summary_view.pt"
-    permission="zope2.View"
-    menu="plone_displayviews"
-    title="Summary view"
-    />
-
-  <browser:page
-    name="folder_summary_view"
-    for="Products.CMFPlone.interfaces.siteroot.IPloneSiteRoot"
-    layer="plone.app.contenttypes.interfaces.IPloneAppContenttypesLayer"
-    template="templates/folder_summary_view.pt"
-    permission="zope2.View"
-    menu="plone_displayviews"
-    title="Summary view"
-    />
-
-  <browser:page
-    name="folder_tabular_view"
-    for="plone.dexterity.interfaces.IDexterityContainer"
-    layer="plone.app.contenttypes.interfaces.IPloneAppContenttypesLayer"
-    template="templates/folder_tabular_view.pt"
-    permission="zope2.View"
-    menu="plone_displayviews"
-    title="Tabular view"
-    />
-
+      name="document_view"
+      for="plone.app.contenttypes.interfaces.IDocument"
+      template="templates/document.pt"
+      layer="plone.app.contenttypes.interfaces.IPloneAppContenttypesLayer"
+      permission="zope2.View"
+      menu="plone_displayviews"
+      title="View Document"
+      />
   <browser:page
-    name="folder_album_view"
-    for="plone.dexterity.interfaces.IDexterityContainer"
-    layer="plone.app.contenttypes.interfaces.IPloneAppContenttypesLayer"
-    class=".album_view.AlbumView"
-    template="templates/folder_album_view.pt"
-    permission="zope2.View"
-    />
-
-  <!-- BBB -->
+      name="file_view"
+      for="plone.app.contenttypes.interfaces.IFile"
+      class=".file.FileView"
+      template="templates/file.pt"
+      layer="plone.app.contenttypes.interfaces.IPloneAppContenttypesLayer"
+      permission="zope2.View"
+      menu="plone_displayviews"
+      title="View File"
+      />
   <browser:page
-    name="atct_album_view"
-    for="plone.dexterity.interfaces.IDexterityContainer"
-    layer="plone.app.contenttypes.interfaces.IPloneAppContenttypesLayer"
-    class=".album_view.AlbumView"
-    template="templates/folder_album_view.pt"
-    permission="zope2.View"
-    menu="plone_displayviews"
-    title="Album"
-    />
-
+      name="image_view"
+      for="plone.app.contenttypes.interfaces.IImage"
+      template="templates/image.pt"
+      layer="plone.app.contenttypes.interfaces.IPloneAppContenttypesLayer"
+      permission="zope2.View"
+      menu="plone_displayviews"
+      title="View Image"
+      />
   <browser:page
-    name="image_view"
-    for="plone.app.contenttypes.interfaces.IImage"
-    layer="plone.app.contenttypes.interfaces.IPloneAppContenttypesLayer"
-    template="templates/image.pt"
-    permission="zope2.View"
-    menu="plone_displayviews"
-    title="View Image"
-    />
-
+      name="image_view_fullscreen"
+      for="plone.app.contenttypes.interfaces.IImage"
+      template="templates/image_view_fullscreen.pt"
+      layer="plone.app.contenttypes.interfaces.IPloneAppContenttypesLayer"
+      permission="zope2.View"
+      menu="plone_displayviews"
+      title="View Image Fullscreen"
+      />
   <browser:page
-    name="image_view_fullscreen"
-    for="plone.app.contenttypes.interfaces.IImage"
-    layer="plone.app.contenttypes.interfaces.IPloneAppContenttypesLayer"
-    template="templates/image_view_fullscreen.pt"
-    permission="zope2.View"
-    menu="plone_displayviews"
-    title="View Image Fullscreen"
-    />
-
+      name="link_redirect_view"
+      for="plone.app.contenttypes.interfaces.ILink"
+      class=".link_redirect_view.LinkRedirectView"
+      layer="plone.app.contenttypes.interfaces.IPloneAppContenttypesLayer"
+      permission="zope2.View"
+      menu="plone_displayviews"
+      title="View Link"
+      />
   <browser:page
-    name="link_redirect_view"
-    for="plone.app.contenttypes.interfaces.ILink"
-    layer="plone.app.contenttypes.interfaces.IPloneAppContenttypesLayer"
-    class=".link_redirect_view.LinkRedirectView"
-    permission="zope2.View"
-    menu="plone_displayviews"
-    title="View Link"
-    />
-
+      name="newsitem_view"
+      for="plone.app.contenttypes.interfaces.INewsItem"
+      template="templates/newsitem.pt"
+      layer="plone.app.contenttypes.interfaces.IPloneAppContenttypesLayer"
+      permission="zope2.View"
+      menu="plone_displayviews"
+      title="View News Item"
+      />
   <browser:page
-    name="newsitem_view"
-    for="plone.app.contenttypes.interfaces.INewsItem"
-    layer="plone.app.contenttypes.interfaces.IPloneAppContenttypesLayer"
-    template="templates/newsitem.pt"
-    permission="zope2.View"
-    menu="plone_displayviews"
-    title="View News Item"
-    />
+      name="contenttype_utils"
+      for="*"
+      class=".utils.Utils"
+      allowed_interface="plone.app.contenttypes.browser.utils.IUtils"
+      layer="plone.app.contenttypes.interfaces.IPloneAppContenttypesLayer"
+      permission="zope2.View"
+      />
 
-  <browser:page
-    name="contenttype_utils"
-    for="*"
-    permission="zope2.View"
-    class=".utils.Utils"
-    allowed_interface="plone.app.contenttypes.browser.utils.IUtils"
-    />
 
   <configure zcml:condition="installed Products.Archetypes">
     <browser:viewlet
@@ -264,4 +229,45 @@
       />
   </configure>
 
+
+  <!-- BBB OlD VIEW NAME REGISTRATIONS -->
+  <browser:pages
+      for="plone.dexterity.interfaces.IDexterityContainer"
+      class=".folder.FolderView"
+      layer="plone.app.contenttypes.interfaces.IPloneAppContenttypesLayer"
+      permission="zope2.View">
+    <browser:page name="folder_listing" template="templates/listing.pt"/>
+    <browser:page name="folder_full_view" template="templates/full_view.pt"/>
+    <browser:page name="folder_summary_view" template="templates/listing_summary.pt"/>
+    <browser:page name="folder_tabular_view" template="templates/listing_tabular.pt"/>
+    <browser:page name="folder_album_view" template="templates/listing_album.pt"/>
+    <browser:page name="atct_album_view" template="templates/listing_album.pt"/>
+  </browser:pages>
+  <browser:pages
+      for="Products.CMFPlone.interfaces.IPloneSiteRoot"
+      class=".folder.FolderView"
+      layer="plone.app.contenttypes.interfaces.IPloneAppContenttypesLayer"
+      permission="zope2.View">
+    <browser:page name="folder_listing" template="templates/listing.pt"/>
+    <browser:page name="folder_summary_view" template="templates/listing_summary.pt"/>
+    <browser:page name="folder_tabular_view" template="templates/listing_tabular.pt"/>
+  </browser:pages>
+  <browser:pages
+      for="plone.app.contenttypes.interfaces.ICollection"
+      class=".collection.CollectionView"
+      layer="plone.app.contenttypes.interfaces.IPloneAppContenttypesLayer"
+      permission="zope2.View">
+    <browser:page name="view" template="templates/listing.pt"/>
+    <browser:page name="standard_view" template="templates/listing.pt"/>
+  </browser:pages>
+  <browser:pages
+      for="plone.app.contenttypes.behaviors.collection.ISyndicatableCollection"
+      class=".collection.CollectionView"
+      layer="plone.app.contenttypes.interfaces.IPloneAppContenttypesLayer"
+      permission="zope2.View">
+    <browser:page name="collection_view" template="templates/listing.pt"/>
+    <browser:page name="all_content" template="templates/full_view.pt"/>
+    <browser:page name="thumbnail_view" template="templates/listing_album.pt"/>
+  </browser:pages>
+
 </configure>
diff --git a/plone/app/contenttypes/browser/file.py b/plone/app/contenttypes/browser/file.py
new file mode 100644
index 0000000..a633498
--- /dev/null
+++ b/plone/app/contenttypes/browser/file.py
@@ -0,0 +1,19 @@
+# -*- coding: utf-8 -*-
+from plone.app.contenttypes.browser.utils import Utils
+
+
+class FileView(Utils):
+
+    def __init__(self, context, request):
+        super(FileView, self).__init__(context, request)
+
+    def is_videotype(self):
+        ct = self.context.file.contentType
+        return 'video/' in ct
+
+    def is_audiotype(self):
+        ct = self.context.file.contentType
+        return 'audio/' in ct
+
+    def get_mimetype_icon(self):
+        return super(FileView, self).getMimeTypeIcon(self.context.file)
diff --git a/plone/app/contenttypes/browser/folder.py b/plone/app/contenttypes/browser/folder.py
new file mode 100644
index 0000000..2de8505
--- /dev/null
+++ b/plone/app/contenttypes/browser/folder.py
@@ -0,0 +1,217 @@
+# -*- coding: utf-8 -*-
+from Acquisition import aq_base
+from Products.CMFPlone.PloneBatch import Batch
+from Products.CMFPlone.utils import safe_callable
+from Products.Five import BrowserView
+from plone.app.contenttypes import _
+from plone.app.contenttypes.interfaces import IFolder
+from plone.app.contenttypes.interfaces import IImage
+from plone.event.interfaces import IEvent
+from plone.memoize.view import memoize
+from plone.registry.interfaces import IRegistry
+from zope.component import getMultiAdapter
+from zope.component import getUtility
+from zope.contentprovider.interfaces import IContentProvider
+import random
+
+HAS_SECURITY_SETTINGS = True
+try:
+    from Products.CMFPlone.interfaces import ISecuritySchema
+except ImportError:
+    HAS_SECURITY_SETTINGS = False
+
+
+class FolderView(BrowserView):
+
+    def __init__(self, context, request):
+        super(FolderView, self).__init__(context, request)
+
+        self.plone_view = getMultiAdapter(
+            (context, request), name=u"plone")
+        self.portal_state = getMultiAdapter(
+            (context, request), name=u"plone_portal_state")
+        self.pas_member = getMultiAdapter(
+            (context, request), name=u"pas_member")
+
+        self.text_class = None
+
+        limit_display = getattr(self.request, 'limit_display', None)
+        limit_display = int(limit_display) if limit_display is not None else 20
+        b_size = getattr(self.request, 'b_size', None)
+        self.b_size = int(b_size) if b_size is not None else limit_display
+        b_start = getattr(self.request, 'b_start', None)
+        self.b_start = int(b_start) if b_start is not None else 0
+
+    def results(self, **kwargs):
+        """Return a content listing based result set with contents of the
+        folder.
+
+        :param **kwargs: Any keyword argument, which can be used for catalog
+                         queries.
+        :type  **kwargs: keyword argument
+
+        :returns: plone.app.contentlisting based result set.
+        :rtype: ``plone.app.contentlisting.interfaces.IContentListing`` based
+                sequence.
+        """
+        # Extra filter
+        kwargs.update(dict(getattr(self.request, 'contentFilter', {})))
+        kwargs.setdefault('portal_type', self.friendly_types)
+        kwargs.setdefault('batch', True)
+        kwargs.setdefault('b_size', self.b_size)
+        kwargs.setdefault('b_start', self.b_start)
+
+        results = self.context.restrictedTraverse(
+            '@@folderListing')(**kwargs)
+        return results
+
+    def batch(self):
+        batch = Batch(
+            self.results(), size=self.b_size, start=self.b_start, orphan=1)
+        return batch
+
+    def normalizeString(self, text):
+        return self.plone_view.normalizeString(text)
+
+    def toLocalizedTime(self, time, long_format=None, time_only=None):
+        return self.plone_view.toLocalizedTime(time, long_format, time_only)
+
+    @property
+    def friendly_types(self):
+        return self.portal_state.friendly_types()
+
+    @property
+    def isAnon(self):
+        return self.portal_state.anonymous()
+
+    @property
+    def navigation_root_url(self):
+        return self.portal_state.navigation_root_url()
+
+    @property
+    def use_view_action(self):
+        site_props = self.context.restrictedTraverse(
+            'portal_properties').site_properties
+        return getattr(site_props, 'typesUseViewActionInListings', ())
+
+    @property
+    def show_about(self):
+        if not HAS_SECURITY_SETTINGS:
+            # BBB
+            site_props = self.context.restrictedTraverse(
+                'portal_properties').site_properties
+            show_about = getattr(site_props, 'allowAnonymousViewAbout', False)
+        else:
+            registry = getUtility(IRegistry)
+            settings = registry.forInterface(ISecuritySchema, prefix="plone")
+            show_about = getattr(settings, 'allow_anon_views_about', False)
+        return show_about or not self.isAnon
+
+    @property
+    def text(self):
+        textfield = getattr(aq_base(self.context), 'text', None)
+        text = getattr(textfield, 'output', None)
+        if text:
+            self.text_class = 'stx' if textfield.mimeType in (
+                'text/structured', 'text/x-rst', 'text/restructured'
+            ) else 'plain'
+        return text
+
+    @property
+    def tabular_fields(self):
+        ret = []
+        ret.append('Title')
+        if self.show_about:
+            ret.append('Creator')
+        ret.append('Type')
+        if self.show_about:
+            ret.append('ModificationDate')
+        return ret
+
+    def tabular_fielddata(self, item, fieldname):
+        value = getattr(item, fieldname, '')
+        if safe_callable(value):
+            value = value()
+        if fieldname in [
+                'CreationDate',
+                'ModificationDate',
+                'Date',
+                'EffectiveDate',
+                'ExpirationDate',
+                'effective',
+                'expires',
+                'start',
+                'end',
+                'created',
+                'modified',
+                'last_comment_date']:
+            value = self.toLocalizedTime(value, long_format=1)
+
+        return {
+            # 'title': _(fieldname, default=fieldname),
+            'value': value
+        }
+
+    def has_image(self, obj):
+        if getattr(obj, 'getObject', False):
+            obj = obj.getObject()
+        img = getattr(aq_base(obj), 'image', None)
+        return True if img else False
+
+    def is_event(self, obj):
+        if getattr(obj, 'getObject', False):
+            obj = obj.getObject()
+        return IEvent.providedBy(obj)
+
+    def formatted_date(self, item):
+        provider = getMultiAdapter(
+            (self.context, self.request, self),
+            IContentProvider, name='formatted_date'
+        )
+        return provider(item)
+
+    @property
+    @memoize
+    def album_images(self):
+        """Get all images within this folder.
+        """
+        images = self.results(
+            batch=False,
+            object_provides=IImage.__identifier__
+        )
+        return images
+
+    @property
+    @memoize
+    def album_folders(self):
+        """Get all folders within this folder.
+        """
+        images = self.results(
+            batch=False,
+            object_provides=IFolder.__identifier__
+        )
+        return images
+
+    @property
+    def album_random_image(self):
+        """Get random image from this folder.
+        """
+        img = None
+        images = self.album_images
+        if images:
+            img = random.choice(images)
+        return img
+
+    @property
+    def album_number_images(self):
+        """Get number of images from this folder.
+        """
+        images = self.album_images
+        return len(images)
+
+    @property
+    def no_items_message(self):
+        return _(
+            'description_no_items_in_folder',
+            default=u"There are currently no items in this folder."
+        )
diff --git a/plone/app/contenttypes/browser/full_view.py b/plone/app/contenttypes/browser/full_view.py
new file mode 100644
index 0000000..58201f7
--- /dev/null
+++ b/plone/app/contenttypes/browser/full_view.py
@@ -0,0 +1,35 @@
+from Products.Five.browser import BrowserView
+from Products.CMFCore.utils import getToolByName
+from zope.publisher.interfaces.browser import IBrowserView
+
+
+class FullViewItem(BrowserView):
+
+    def __init__(self, context, request):
+        super(FullViewItem, self).__init__(context, request)
+        self.item_type = self.context.portal_type
+
+    @property
+    def default_view(self):
+        context = self.context
+        item_layout = context.getLayout()
+        default_view = context.restrictedTraverse(item_layout)
+        return default_view
+
+    @property
+    def item_macros(self):
+        default_view = self.default_view
+        if IBrowserView.providedBy(default_view):
+            # IBrowserView
+            return default_view.index.macros
+        else:
+            # FSPageTemplate
+            return default_view.macros
+
+    @property
+    def item_url(self):
+        context = self.context
+        url = context.absolute_url()
+        props = getToolByName(context, 'portal_properties')
+        use_view_action = props.site_properties.typesUseViewActionInListings
+        return self.item_type in use_view_action and '%s/view' % url or url
diff --git a/plone/app/contenttypes/browser/link_redirect_view.py b/plone/app/contenttypes/browser/link_redirect_view.py
index 4e4a45d..adb74a1 100644
--- a/plone/app/contenttypes/browser/link_redirect_view.py
+++ b/plone/app/contenttypes/browser/link_redirect_view.py
@@ -5,14 +5,38 @@
 from plone.app.contenttypes.utils import replace_link_variables_by_paths
 
 
+# links starting with these URL scheme should not be redirected to
+NON_REDIRECTABLE_URL_SCHEMES = [
+    'mailto:',
+    'tel:',
+    'callto:',
+    'webdav:',
+    'caldav:'
+]
+
+# links starting with these URL scheme should not be resolved to paths
+NON_RESOLVABLE_URL_SCHEMES = NON_REDIRECTABLE_URL_SCHEMES + [
+    'file:',
+    'ftp:',
+]
+
+
 class LinkRedirectView(BrowserView):
 
     index = ViewPageTemplateFile('templates/link.pt')
 
+    def _url_uses_scheme(self, schemes, url=None):
+        url = url or self.context.remoteUrl
+        for scheme in schemes:
+            if url.startswith(scheme):
+                return True
+        return False
+
     def __call__(self):
         """Redirect to the Link target URL, if and only if:
          - redirect_links property is enabled in
            portal_properties/site_properties
+         - the link is of a redirectable type (no mailto:, etc)
          - AND current user doesn't have permission to edit the Link"""
         context = self.context
         ptool = getToolByName(context, 'portal_properties')
@@ -24,6 +48,8 @@ def __call__(self):
             False
         )
         can_edit = mtool.checkPermission('Modify portal content', context)
+        redirect_links = redirect_links\
+            and not self._url_uses_scheme(NON_REDIRECTABLE_URL_SCHEMES)
 
         if redirect_links and not can_edit:
             return self.request.RESPONSE.redirect(self.absolute_target_url())
@@ -32,7 +58,13 @@ def __call__(self):
 
     def absolute_target_url(self):
         """Compute the absolute target URL."""
-        if self.context.remoteUrl.startswith('.'):
+        url = self.context.remoteUrl
+
+        if self._url_uses_scheme(NON_RESOLVABLE_URL_SCHEMES):
+            # For non http/https url schemes, there is no path to resolve.
+            return url
+
+        if url.startswith('.'):
             # we just need to adapt ../relative/links, /absolute/ones work
             # anyway -> this requires relative links to start with ./ or
             # ../
@@ -41,13 +73,10 @@ def absolute_target_url(self):
             )
             url = '/'.join([
                 context_state.canonical_object_url(),
-                self.context.remoteUrl
+                url
             ])
         else:
-            url = replace_link_variables_by_paths(
-                self.context,
-                self.context.remoteUrl
-            )
+            url = replace_link_variables_by_paths(self.context, url)
             if not (url.startswith('http://') or url.startswith('https://')):
                 url = self.request.physicalPathToURL(url)
 
diff --git a/plone/app/contenttypes/browser/templates/all_content.pt b/plone/app/contenttypes/browser/templates/all_content.pt
deleted file mode 100644
index 7c78024..0000000
--- a/plone/app/contenttypes/browser/templates/all_content.pt
+++ /dev/null
@@ -1,29 +0,0 @@
-<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"
-      xmlns:tal="http://xml.zope.org/namespaces/tal"
-      xmlns:metal="http://xml.zope.org/namespaces/metal"
-      xmlns:i18n="http://xml.zope.org/namespaces/i18n"
-      lang="en"
-      metal:use-macro="here/main_template/macros/master"
-      i18n:domain="plone">
-
-<body>
-
-<metal:content-core fill-slot="content-core">
-<metal:block use-macro="context/standard_view/macros/content-core">
-
-    <metal:entries fill-slot="entries">
-    <metal:block use-macro="context/standard_view/macros/entries">
-    <metal:entry fill-slot="entry">
-
-        <div tal:define="realobject python:item.getObject()"
-             tal:replace="structure realobject/folder_full_view_item" />
-
-    </metal:entry>
-    </metal:block>
-    </metal:entries>
-
-</metal:block>
-</metal:content-core>
-
-</body>
-</html>
diff --git a/plone/app/contenttypes/browser/templates/archetypes_warning_viewlet.pt b/plone/app/contenttypes/browser/templates/archetypes_warning_viewlet.pt
index 3e1f9ce..8ba1390 100644
--- a/plone/app/contenttypes/browser/templates/archetypes_warning_viewlet.pt
+++ b/plone/app/contenttypes/browser/templates/archetypes_warning_viewlet.pt
@@ -1,20 +1,18 @@
 <tal:available condition="view/available">
-<div class="portalMessage alert-box secondary warning"
-     i18n:domain="plone">
+  <div class="portalMessage alert-box secondary warning" i18n:domain="plone">
     <strong i18n:translate="">Warning</strong>
-        <tal:manager tal:condition="not:view/can_migrate">
-            <span i18n:translate="">You can't edit this content. Ask your administrator to migrate to Dexterity!</span>
-        </tal:manager>
-        <tal:manager tal:condition="view/can_migrate">
-            <span i18n:translate="">You can't edit this content unless you
-                <a href="#" tal:attributes="href string:${context/plone_portal_state/portal_url}/@@atct_migrator">
-                    migrate the default content-types to Dexterity.
-                </a>
-            </span>
-        </tal:manager>
-</div>
-
-<style type="text/css">
-#contentview-edit {display: None;}
-</style>
+    <tal:manager tal:condition="not:view/can_migrate">
+      <span i18n:translate="">You can't edit this content. Ask your administrator to migrate to Dexterity!</span>
+    </tal:manager>
+    <tal:manager tal:condition="view/can_migrate">
+      <span i18n:translate="">You can't edit this content unless you
+        <a href="#" tal:attributes="href string:${context/plone_portal_state/portal_url}/@@atct_migrator">
+          migrate the default content-types to Dexterity.
+        </a>
+      </span>
+    </tal:manager>
+  </div>
+  <style type="text/css">
+    #contentview-edit {display: None;}
+  </style>
 </tal:available>
diff --git a/plone/app/contenttypes/browser/templates/document.pt b/plone/app/contenttypes/browser/templates/document.pt
index 25fefa0..0e6756b 100644
--- a/plone/app/contenttypes/browser/templates/document.pt
+++ b/plone/app/contenttypes/browser/templates/document.pt
@@ -1,20 +1,19 @@
 <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"
-      xmlns:tal="http://xml.zope.org/namespaces/tal"
-      xmlns:metal="http://xml.zope.org/namespaces/metal"
-      xmlns:i18n="http://xml.zope.org/namespaces/i18n"
-      lang="en"
-      metal:use-macro="context/main_template/macros/master"
-      i18n:domain="plone">
+    xmlns:tal="http://xml.zope.org/namespaces/tal"
+    xmlns:metal="http://xml.zope.org/namespaces/metal"
+    xmlns:i18n="http://xml.zope.org/namespaces/i18n"
+    lang="en"
+    metal:use-macro="context/main_template/macros/master"
+    i18n:domain="plone">
 <body>
 
 <metal:content-core fill-slot="content-core">
-    <metal:content-core define-macro="content-core">
-        <div id="parent-fieldname-text"
-             tal:condition="context/text"
-              tal:content="structure python:context.text.output_relative_to(view.context)" />
-    </metal:content-core>
+<metal:content-core define-macro="content-core">
+  <div id="parent-fieldname-text"
+      tal:condition="context/text"
+      tal:content="structure python:context.text.output_relative_to(view.context)" />
+</metal:content-core>
 </metal:content-core>
 
 </body>
 </html>
-
diff --git a/plone/app/contenttypes/browser/templates/file.pt b/plone/app/contenttypes/browser/templates/file.pt
index 3cfc525..b6e8eae 100644
--- a/plone/app/contenttypes/browser/templates/file.pt
+++ b/plone/app/contenttypes/browser/templates/file.pt
@@ -1,36 +1,43 @@
 <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"
-      xmlns:tal="http://xml.zope.org/namespaces/tal"
-      xmlns:metal="http://xml.zope.org/namespaces/metal"
-      xmlns:i18n="http://xml.zope.org/namespaces/i18n"
-      lang="en"
-      metal:use-macro="context/main_template/macros/master"
-      i18n:domain="plone">
-
+    xmlns:tal="http://xml.zope.org/namespaces/tal"
+    xmlns:metal="http://xml.zope.org/namespaces/metal"
+    xmlns:i18n="http://xml.zope.org/namespaces/i18n"
+    lang="en"
+    metal:use-macro="context/main_template/macros/master"
+    i18n:domain="plone">
 <body>
 
-    <metal:content-core fill-slot="content-core">
-        <metal:block define-macro="content-core"
-                     tal:define="content_type context/file/contentType|nothing;
-                                 v python:context.restrictedTraverse('contenttype_utils');">
-            <p>
-                <a tal:attributes="href string:${context/absolute_url}/@@download/file/${context/file/filename}">
-                    <img tal:attributes="src python: v.getMimeTypeIcon(context.file);
-                                         alt content_type;" border="0"  />
-                    <tal:name tal:content="context/file/filename" >Filename</tal:name>
-                </a>
-                <span class="discreet"
-                      tal:define="size context/file/getSize;
-                                  kb python:size/1024">
-                      &mdash; <span tal:replace="kb" /> KB</span>
-            </p>
+<metal:content-core fill-slot="content-core">
+<metal:block define-macro="content-core"
+    tal:define="content_type context/file/contentType|nothing;
+                download_url string:${context/absolute_url}/@@download/file/${context/file/filename}">
+  <p>
+    <a tal:attributes="href download_url">
+      <img tal:attributes="src view/get_mimetype_icon;
+                           alt content_type;" border="0" />
+      <tal:name tal:content="context/file/filename" >Filename</tal:name>
+    </a>
+    <span class="discreet"
+        tal:define="size context/file/getSize;
+                    kb python:size/1024">
+      &mdash; <span tal:replace="kb" /> KB</span>
+  </p>
 
-            <div tal:condition="python: content_type.startswith('text')">
-                <h2 i18n:translate="heading_file_contents">File contents</h2>
-                <pre tal:content="context/file/data|nothing" />
-            </div>
-        </metal:block>
-    </metal:content-core>
+  <video tal:condition="view/is_videotype" controls="controls">
+    <source tal:attributes="src download_url; type content_type"></source>
+  </video>
 
-</body>
+  <audio tal:condition="view/is_audiotype" controls="controls">
+    <source tal:attributes="src download_url; type content_type"></source>
+  </audio>
+
+  <div tal:condition="python: content_type.startswith('text')">
+    <h2 i18n:translate="heading_file_contents">File contents</h2>
+    <pre tal:content="context/file/data|nothing" />
+  </div>
 
+</metal:block>
+</metal:content-core>
+
+</body>
 </html>
diff --git a/plone/app/contenttypes/browser/templates/folder_album_view.pt b/plone/app/contenttypes/browser/templates/folder_album_view.pt
deleted file mode 100644
index 010170b..0000000
--- a/plone/app/contenttypes/browser/templates/folder_album_view.pt
+++ /dev/null
@@ -1,103 +0,0 @@
-<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US"
-      lang="en-US"
-      metal:use-macro="here/main_template/macros/master"
-      i18n:domain="plone">
-
-<body>
-
-<metal:content-core fill-slot="content-core">
-
-<metal:main_macro define-macro="content-core"
-     tal:define="result python:view.getAlbumContent(images=1, folders=1, subimages=0, others=1);
-                 images result/images;
-                 albums result/folders;
-                 otherContents result/others;
-                 Batch python:modules['Products.CMFPlone'].Batch;
-                 b_start python:request.get('b_start', 0);
-                 templateId template/getId;
-                 batch python:Batch(images, 12, int(b_start), orphan=1)">
-
-    <div metal:define-macro="text-field-view"
-         id="parent-fieldname-text" class="stx"
-         tal:define="has_text exists:context/aq_explicit/getText;
-                     text python:has_text and here.getText() or ''"
-         tal:condition="text"
-         tal:attributes="class python: here.Format() in ('text/structured',
-                                               'text/x-rst', ) and 'stx' or 'plain'">
-        <div metal:define-slot="inside" tal:replace="structure text">The body</div>
-    </div>
-
-    <tal:albumsimages tal:condition="python:albums or images">
-        <tal:images tal:condition="batch" tal:repeat="image batch">
-            <div class="photoAlbumEntry">
-                <a tal:define="id python:int(b_start)+int(repeat['image'].number()-1);
-                               scale image/@@images;
-                               img_tag python:scale.scale('image', scale='thumb').tag()"
-                   tal:attributes="href string:${image/absolute_url}/view;
-                                   title image/Description">
-                    <span class="photoAlbumEntryWrapper">
-                        <img src="" alt="" tal:replace="structure img_tag" />
-                    </span>
-                    <span class="photoAlbumEntryTitle" tal:content="image/pretty_title_or_id">
-                       Title
-                    </span>
-                </a>
-            </div>
-        </tal:images>
-
-        <div class="photoAlbum" tal:condition="albums">
-        <tal:albums tal:repeat="album albums">
-
-            <div class="photoAlbumEntry photoAlbumFolder"
-                 tal:define="image_brains_in_album python:view.getAlbumContent(subimages=1, container=album)['subimages'];
-                             number_of_images python:len(image_brains_in_album);
-                             random python:modules['random'];
-                             random_image python:number_of_images and random.choice(image_brains_in_album).getObject() or None">
-                        <a tal:attributes="href album/getURL;
-                                           title album/Description">
-                            <span class="photoAlbumEntryWrapper">
-                                <tal:block condition="number_of_images">
-                                <img src="" alt=""
-                                     tal:define="scale random_image/@@images;
-                                                 img_tag python:scale.scale('image', scale='thumb').tag()"
-                                     tal:replace="structure img_tag" />
-                                </tal:block>
-                            </span>
-                            <span class="photoAlbumEntryTitle">
-                               <tal:title content="album/pretty_title_or_id">Title</tal:title>
-                            (<tal:number content="number_of_images" />)
-                            </span>
-                        </a>
-            </div>
-
-        </tal:albums>
-        </div>
-
-        <div class="visualClear"><!-- --></div>
-
-    </tal:albumsimages>
-
-    <p class="discreet"
-       i18n:domain="atcontenttypes"
-       i18n:translate="text_no_albums_uploaded"
-       tal:condition="python:not (albums or images)">
-        No albums or photos uploaded yet.
-    </p>
-
-    <div tal:condition="python:albums or images"
-         metal:use-macro="here/batch_macros/macros/navigation" />
-
-    <tal:listing condition="otherContents"
-                 define="folderContents otherContents">
-        <metal:listing metal:use-macro="here/folder_listing/macros/listing">
-            <metal:empty metal:fill-slot="no_items_in_listing"></metal:empty>
-        </metal:listing>
-
-    </tal:listing>
-
-</metal:main_macro>
-</metal:content-core>
-
-</body>
-
-</html>
diff --git a/plone/app/contenttypes/browser/templates/folder_full_view.pt b/plone/app/contenttypes/browser/templates/folder_full_view.pt
deleted file mode 100644
index 3971b0f..0000000
--- a/plone/app/contenttypes/browser/templates/folder_full_view.pt
+++ /dev/null
@@ -1,25 +0,0 @@
-<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"
-      xmlns:tal="http://xml.zope.org/namespaces/tal"
-      xmlns:metal="http://xml.zope.org/namespaces/metal"
-      xmlns:i18n="http://xml.zope.org/namespaces/i18n"
-      lang="en"
-      metal:use-macro="context/main_template/macros/master"
-      i18n:domain="plone">
-
-<body>
-
-    <metal:content-core fill-slot="content-core">
-        <metal:block use-macro="context/folder_listing/macros/content-core">
-            <!-- we don't want the dl -->
-            <metal:entries fill-slot="entries">
-                <metal:block use-macro="context/folder_listing/macros/entries">
-                    <metal:entry fill-slot="entry">
-                        <div tal:replace="structure python:item.getObject().folder_full_view_item()" />
-                    </metal:entry>
-                </metal:block>
-            </metal:entries>
-        </metal:block>
-    </metal:content-core>
-
-</body>
-</html>
diff --git a/plone/app/contenttypes/browser/templates/folder_full_view_item.pt b/plone/app/contenttypes/browser/templates/folder_full_view_item.pt
deleted file mode 100644
index 6268a68..0000000
--- a/plone/app/contenttypes/browser/templates/folder_full_view_item.pt
+++ /dev/null
@@ -1,79 +0,0 @@
-<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"
-      xmlns:tal="http://xml.zope.org/namespaces/tal"
-      xmlns:metal="http://xml.zope.org/namespaces/metal"
-      xmlns:i18n="http://xml.zope.org/namespaces/i18n"
-      lang="en"
-      i18n:domain="plone"
-      tal:omit-tag="">
-
-<body tal:omit-tag="">
-
-    <div class="item visualIEFloatFix"
-         tal:define="portal_state context/@@plone_portal_state;
-                     context_state context/@@plone_context_state;
-                     plone_view context/@@plone;
-                     lang portal_state/language;
-                     view nocall:view | nocall: plone_view;
-                     dummy python: plone_view.mark_view(view);
-                     portal_url portal_state/portal_url;
-                     checkPermission nocall: context/portal_membership/checkPermission;
-                     site_properties context/portal_properties/site_properties;
-                     item_type context/portal_type;
-                     item_layout here/getLayout;
-                     override python: {'Link': 'link_view'};
-                     item_macro python:path('here/%s/macros/content-core | nothing' % override.get(item_type, item_layout));
-                     use_view_action site_properties/typesUseViewActionInListings|python:();
-                     item_url context/absolute_url;
-                     normalizeString nocall: context/plone_utils/normalizeString;
-                     item_type_class python: 'contenttype-' + normalizeString(item_type);
-                     kss_inline_editable python:False;
-                     rendering_error python:[];
-                     ">
-
-        <div tal:replace="structure provider:plone.abovecontenttitle" />
-
-        <h2 class="headline">
-            <a href="#" class="summary url" tal:content="context/Title"
-               tal:attributes="href python:test(item_type in use_view_action, item_url+'/view', item_url);">
-               Title or id
-             </a>
-        </h2>
-
-        <div tal:replace="structure provider:plone.belowcontenttitle" />
-
-        <div class="description"
-             tal:content="context/Description"
-             tal:condition="context/Description">
-            Description
-        </div>
-
-        <tal:block tal:condition="item_macro" tal:on-error="python:rendering_error.append(True)">
-
-            <div tal:replace="structure provider:plone.abovecontentbody" />
-
-            <div metal:use-macro="item_macro">
-                content
-            </div>
-
-            <div tal:replace="structure provider:plone.belowcontentbody" />
-
-        </tal:block>
-
-        <tal:block tal:condition="rendering_error">
-            <!-- Error rendering item macro -->
-        </tal:block>
-
-        <p class="more" tal:condition="python:not(item_macro) or rendering_error">
-            <a href=""
-               tal:attributes="href python: item_type in use_view_action and  item_url+'/view' or item_url;"
-               i18n:translate="read_more">
-                Read More&hellip;
-            </a>
-        </p>
-
-        <div class="visualClear"><!-- --></div>
-
-    </div>
-
-</body>
-</html>
diff --git a/plone/app/contenttypes/browser/templates/folder_listing.pt b/plone/app/contenttypes/browser/templates/folder_listing.pt
deleted file mode 100644
index 39d3d28..0000000
--- a/plone/app/contenttypes/browser/templates/folder_listing.pt
+++ /dev/null
@@ -1,194 +0,0 @@
-<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"
-      xmlns:tal="http://xml.zope.org/namespaces/tal"
-      xmlns:metal="http://xml.zope.org/namespaces/metal"
-      xmlns:i18n="http://xml.zope.org/namespaces/i18n"
-      lang="en"
-      metal:use-macro="context/main_template/macros/master"
-      i18n:domain="plone">
-
-<body>
-
-<metal:content-core fill-slot="content-core">
-<metal:block define-macro="content-core"
-                    tal:define="templateId template/getId">
-
-    <div metal:define-macro="text-field-view"
-         id="parent-fieldname-text" class="stx"
-         tal:define="has_text exists:context/aq_explicit/text/output;
-                     text python:has_text and here.text.output or ''"
-         tal:condition="text"
-         tal:attributes="class python: context.Format() in ('text/structured',
-                                               'text/x-rst', ) and  'stx' or 'plain'">
-        <div metal:define-slot="inside" tal:replace="structure text">The body</div>
-    </div>
-
-    <metal:listingmacro define-macro="listing">
-    <tal:foldercontents define="contentFilter contentFilter|request/contentFilter|nothing;
-                        contentFilter python:contentFilter and dict(contentFilter) or {};
-                        limit_display limit_display|request/limit_display|nothing;
-                        limit_display python:limit_display and int(limit_display) or None;
-                        more_url more_url|request/more_url|string:folder_contents;
-                        is_a_topic python:context.portal_type=='Topic';
-                        friendly_types context/@@plone_portal_state/friendly_types;
-                        dummy python:not is_a_topic and contentFilter.setdefault('portal_type', friendly_types);
-                        folderContents folderContents|nothing; folderContents python:folderContents or is_a_topic and context.queryCatalog(batch=True, **contentFilter) or context.getFolderContents(contentFilter, batch=True, b_size=limit_display or 100);
-                        site_properties context/portal_properties/site_properties;
-                        use_view_action site_properties/typesUseViewActionInListings|python:();
-                        Batch python:modules['Products.CMFPlone'].Batch;
-                        b_start python:request.get('b_start', 0);
-                        batch python:isinstance(folderContents, Batch) and folderContents or Batch(folderContents, limit_display or 100, int(b_start), orphan=1);
-                        isAnon context/@@plone_portal_state/anonymous;
-                        normalizeString nocall: context/plone_utils/normalizeString;
-                        toLocalizedTime nocall: context/@@plone/toLocalizedTime;
-                        show_about python:not isAnon or site_properties.allowAnonymousViewAbout;
-                        navigation_root_url context/@@plone_portal_state/navigation_root_url;
-                        pas_member context/@@pas_member;
-                        plone_view context/@@plone;">
-    <tal:listing condition="batch">
-
-        <ul metal:define-slot="entries">
-            <li tal:repeat="item batch" metal:define-macro="entries">
-            <tal:block tal:define="item_url item/getURL|item/absolute_url;
-                                   item_id item/getId|item/id;
-                                   item_title_or_id item/pretty_title_or_id;
-                                   item_description item/Description;
-                                   item_type item/portal_type;
-                                   item_type_title item/Type;
-                                   item_modified item/ModificationDate;
-                                   item_created item/CreationDate;
-                                   item_icon python:plone_view.getIcon(item);
-                                   item_type_class python:'contenttype-' + normalizeString(item_type);
-                                   item_wf_state item/review_state|python: context.portal_workflow.getInfoFor(item, 'review_state', '');
-                                   item_wf_state_class python:'state-' + normalizeString(item_wf_state);
-                                   item_creator item/Creator;
-                                   item_start item/start|item/StartDate|nothing;
-                                   item_end item/end|item/EndDate|nothing;
-                                   item_sametime python: item_start == item_end;
-                                   item_samedate python: (item_end - item_start &lt; 1) if item_type == 'Event' else False">
-                <metal:block define-slot="entry">
-                <span metal:define-macro="listitem"
-                    tal:define="item_type_event_class python: item_type == 'Event' and 'vevent' or None"
-                    tal:attributes="class item_type_event_class|nothing">
-
-                    <span class="summary">
-                        <img tal:replace="structure item_icon/html_tag" />
-                        <a href="#"
-                           tal:attributes="href python: item_type in use_view_action and item_url+'/view' or item_url;
-                                           class string:$item_type_class $item_wf_state_class url"
-                           tal:content="item_title_or_id">
-                            Item Title
-                        </a>
-                    </span>
-
-                    <span class="documentByLine">
-                        <span tal:condition="python: item_type == 'Event' and item_sametime"
-                              i18n:translate="label_event_byline_onlyfrom">
-                             <abbr class="dtstart"
-                                   tal:attributes="title python:item_start"
-                                   tal:content="python:toLocalizedTime(item_start,long_format=1)"
-                                   i18n:name="start">from date</abbr>
-                        </span>
-                        <span tal:condition="python: item_type == 'Event' and item_samedate and not item_sametime"
-                              i18n:translate="label_event_byline_samedate">
-                             <abbr class="dtstart"
-                                   tal:attributes="title python:item_start"
-                                   tal:content="python:toLocalizedTime(item_start)"
-                                   i18n:name="start">from date</abbr> from
-                             <abbr class="dtstart"
-                                   tal:attributes="title python:item_start"
-                                   tal:content="python:toLocalizedTime(item_start,time_only=1)"
-                                   i18n:name="starttime">from time</abbr> to
-                             <abbr class="dtend"
-                                   tal:attributes="title python:item_end"
-                                   tal:content="python:toLocalizedTime(item_end,time_only=1)"
-                                   i18n:name="end">to time</abbr>
-                        </span>
-                        <span tal:condition="python: item_type == 'Event' and not item_samedate and not item_sametime"
-                              i18n:translate="label_event_byline">
-                              from
-                                   <abbr class="dtstart"
-                                   tal:attributes="title python:item_start"
-                                   tal:content="python:toLocalizedTime(item_start,long_format=1)"
-                                   i18n:name="start">from date</abbr> to
-                             <abbr class="dtend"
-                                   tal:attributes="title python:item_end"
-                                   tal:content="python:toLocalizedTime(item_end,long_format=1)"
-                                   i18n:name="end">to date</abbr>
-                        </span>
-                         <span tal:condition="python: item_type == 'Event' and item.location"
-                              i18n:translate="label_event_byline_location">&mdash;
-                             <span tal:content="string:${item/location}"
-                                   class="location"
-                                   i18n:name="location">Oslo</span>,
-                        </span>
-                        <tal:byline condition="show_about">
-                            &mdash;
-
-                            <tal:name tal:condition="item_creator"
-                                tal:define="author python:pas_member.info(item_creator);
-                                            creator_short_form author/username;
-                                            creator_long_form string:?author=${author/username};
-                                            creator_is_openid python:'/' in creator_short_form;
-                                            creator_id python:(creator_short_form, creator_long_form)[creator_is_openid];">
-                              <span i18n:translate="label_by_author">
-                                by
-                              <a href="#"
-                                 tal:attributes="href string:${navigation_root_url}/author/${item_creator}"
-                                 tal:content="author/name_or_id"
-                                 tal:omit-tag="not:author"
-                                 i18n:name="author">
-                                Bob Dobalina
-                              </a>
-                              </span>
-
-                            </tal:name>
-
-                            <tal:modified condition="python: item_type != 'Event'">
-                                &mdash;
-                                <tal:mod i18n:translate="box_last_modified">
-                                  last modified
-                                </tal:mod>
-                                <span tal:replace="python:toLocalizedTime(item_modified,long_format=1)">
-                                  August 16, 2001 at 23:35:59
-                                </span>
-                            </tal:modified>
-
-                            <metal:description define-slot="description_slot">
-                                <tal:comment replace="nothing">
-                                    Place custom listing info for custom types here
-                                </tal:comment>
-                            </metal:description>
-                        </tal:byline>
-                    </span>
-
-                </span>
-
-                <p class="description discreet"
-                    tal:condition="item_description"
-                    tal:content="item_description">
-                    description
-                </p>
-            </metal:block>
-            </tal:block>
-            </li>
-        </ul>
-
-        <div metal:use-macro="context/batch_macros/macros/navigation" />
-
-    </tal:listing>
-    <metal:empty metal:define-slot="no_items_in_listing">
-        <p class="discreet"
-           tal:condition="not: folderContents"
-           i18n:translate="description_no_items_in_folder">
-            There are currently no items in this folder.
-        </p>
-    </metal:empty>
-
-    </tal:foldercontents>
-    </metal:listingmacro>
-
-</metal:block>
-</metal:content-core>
-
-</body>
-</html>
diff --git a/plone/app/contenttypes/browser/templates/folder_summary_view.pt b/plone/app/contenttypes/browser/templates/folder_summary_view.pt
deleted file mode 100644
index c2d78c5..0000000
--- a/plone/app/contenttypes/browser/templates/folder_summary_view.pt
+++ /dev/null
@@ -1,122 +0,0 @@
-<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"
-      xmlns:tal="http://xml.zope.org/namespaces/tal"
-      xmlns:metal="http://xml.zope.org/namespaces/metal"
-      xmlns:i18n="http://xml.zope.org/namespaces/i18n"
-      lang="en"
-      metal:use-macro="context/main_template/macros/master"
-      i18n:domain="plone">
-
-<body>
-
-    <metal:content-core fill-slot="content-core">
-        <metal:block define-macro="listing" extend-macro="context/folder_listing/macros/content-core">
-            <!-- we don't want the dl -->
-            <metal:entries fill-slot="entries">
-                <metal:block use-macro="context/folder_listing/macros/entries">
-                    <metal:entry fill-slot="entry">
-                <div class="tileItem visualIEFloatFix"
-                     tal:define="item_object item/getObject;">
-
-                    <a href="#"
-                       tal:define="real_object python:item_object.aq_explicit"
-                       tal:condition="python:getattr(real_object, 'image', None)"
-                       tal:attributes="href python: item_type in use_view_action and item_url+'/view' or item_url">
-                        <img tal:define="images item_object/@@images;
-                                         scale python: images.scale('image', scale='thumb')"
-                             tal:condition="scale"
-                             src="" alt=""
-                             tal:replace="structure python: scale.tag(css_class='tileImage')" />
-                    </a>
-
-                    <h2 class="tileHeadline"
-                        metal:define-macro="listitem">
-
-                        <a href="#"
-                           class="summary url"
-                           tal:attributes="href python: item_type in use_view_action and item_url+'/view' or item_url;"
-                           tal:content="item_title_or_id">
-                            Item Title
-                        </a>
-
-                    </h2>
-
-                    <div class="documentByLine" tal:condition="python: site_properties.allowAnonymousViewAbout or not isAnon">
-                    <tal:event condition="python: item_type == 'Event'">
-                        <span tal:condition="python: item_type == 'Event' and item.location"
-                              i18n:translate="label_event_byline_with_location">
-                            (<span tal:content="string:${item/location}"
-                                   class="location"
-                                   i18n:name="location">Oslo</span>, from
-                             <abbr class="dtstart"
-                                   tal:attributes="title python:item_start"
-                                   tal:content="python:toLocalizedTime(item_start,long_format=1)"
-                                   i18n:name="start">from date</abbr> to
-                             <abbr class="dtend"
-                                   tal:attributes="title python:item_end"
-                                   tal:content="python:toLocalizedTime(item_end,long_format=1)"
-                                   i18n:name="end">to date</abbr>)
-                        </span>
-                        <span tal:condition="python: item_type == 'Event' and not item.location"
-                              i18n:translate="label_event_byline_without_location">
-                            (from
-                             <abbr class="dtstart"
-                                   tal:attributes="title python:item_start"
-                                   tal:content="python:toLocalizedTime(item_start,long_format=1)"
-                                   i18n:name="start">from date</abbr> to
-                             <abbr class="dtend"
-                                   tal:attributes="title python:item_end"
-                                   tal:content="python:toLocalizedTime(item_end,long_format=1)"
-                                   i18n:name="end">to date</abbr>)
-                        </span>
-                    </tal:event>
-                    <tal:newsitem condition="python: item_type == 'News Item'">
-                        <tal:name tal:condition="item_creator"
-                            tal:define="author python:pas_member.info(item_creator)">
-                          <span class="documentAuthor" i18n:translate="label_by_author">
-                            by
-                          <a href="#"
-                             tal:attributes="href string:${navigation_root_url}/author/${item_creator}"
-                             tal:content="author/name_or_id"
-                             tal:omit-tag="not:author"
-                             i18n:name="author">
-                            Bob Dobalina
-                          </a>
-                          </span>
-                        </tal:name>
-                        &mdash;
-                        <span class="documentModified">
-                              <tal:mod i18n:translate="box_last_modified">
-                              last modified
-                              </tal:mod>
-                              <span tal:replace="python:toLocalizedTime(item_modified,long_format=1)">
-                                      August 16, 2001 at 23:35:59
-                              </span>
-                        </span>
-                    </tal:newsitem>
-                    </div>
-
-                    <p class="tileBody" tal:condition="item_description">
-                        <span class="description" tal:content="item_description">
-                            description
-                        </span>
-                    </p>
-
-                    <p class="tileFooter">
-                        <a href=""
-                           tal:attributes="href python: item_type in use_view_action and item_url+'/view' or item_url;"
-                           i18n:translate="read_more">
-                        Read More&hellip;
-                        </a>
-                    </p>
-
-                    <div class="visualClear"><!-- --></div>
-
-                </div>
-                    </metal:entry>
-                </metal:block>
-            </metal:entries>
-        </metal:block>
-    </metal:content-core>
-
-</body>
-</html>
diff --git a/plone/app/contenttypes/browser/templates/folder_tabular_view.pt b/plone/app/contenttypes/browser/templates/folder_tabular_view.pt
deleted file mode 100644
index c5e87a8..0000000
--- a/plone/app/contenttypes/browser/templates/folder_tabular_view.pt
+++ /dev/null
@@ -1,96 +0,0 @@
-<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"
-      xmlns:tal="http://xml.zope.org/namespaces/tal"
-      xmlns:metal="http://xml.zope.org/namespaces/metal"
-      xmlns:i18n="http://xml.zope.org/namespaces/i18n"
-      lang="en"
-      metal:use-macro="context/main_template/macros/master"
-      i18n:domain="plone">
-
-<body>
-
-  <metal:content-core fill-slot="content-core">
-    <metal:block define-macro="listing" extend-macro="context/folder_listing/macros/content-core">
-      <metal:entries fill-slot="entries">
-
-          <div metal:use-macro="context/batch_macros/macros/navigation" />
-          <div class="has-table">
-            <table class="listing"
-                   summary="Content listing"
-                   i18n:attributes="summary summary_content_listing;">
-                <thead>
-                    <tr>
-                        <th class="nosort">&nbsp;<tal:title i18n:translate="listingheader_title"
-                          >Title</tal:title>&nbsp;</th>
-                        <th class="nosort"
-                            tal:condition="show_about">&nbsp;<tal:title i18n:translate="listingheader_author"
-                          >Author</tal:title>&nbsp;</th>
-                        <th class="nosort">&nbsp;<tal:title i18n:translate="listingheader_type"
-                          >Type</tal:title>&nbsp;</th>
-                        <th class="nosort"
-                            tal:condition="show_about">&nbsp;<tal:modified i18n:translate="listingheader_modified"
-                          >Modified</tal:modified>&nbsp;</th>
-                    </tr>
-                </thead>
-
-                <tbody>
-                    <metal:block use-macro="context/folder_listing/macros/entries">
-                        <metal:entry fill-slot="entry">
-
-                    <tr metal:define-macro="listitem"
-                        tal:define="oddrow repeat/item/odd;"
-                        tal:attributes="class python: oddrow and 'even' or 'odd'">
-
-                            <td>
-                                <img width="16" height="16"
-                                     src="" alt=""
-                                     tal:condition="item_icon/url"
-                                     tal:attributes="src item_icon/url;
-                                                     alt item_icon/description;
-                                                     title item_icon/title;
-                                                     width item_icon/width;
-                                                     height item_icon/height;" />
-                                <a href="#"
-                                   tal:attributes="href python: item_type in use_view_action and item_url+'/view' or item_url;
-                                                   class string:$item_wf_state_class $item_type_class;
-                                                   title item_description;"
-                                   tal:content="item_title_or_id">
-                                    Item Title
-                                </a>
-                            </td>
-
-                            <td tal:condition="show_about">
-                                <tal:name tal:condition="item_creator"
-                                  tal:define="author python:pas_member.info(item_creator)">
-                                <a href="#"
-                                   tal:attributes="href string:${navigation_root_url}/author/${item_creator}"
-                                   tal:content="author/name_or_id"
-                                   tal:omit-tag="not:author">
-                                  Bob Dobalina
-                                </a>
-                                </tal:name>
-                            </td>
-
-                            <td tal:content="item_type_title"
-                                i18n:translate="">
-                                Page
-                            </td>
-
-                        <td tal:condition="show_about"
-                            tal:content="python:toLocalizedTime(item_modified,long_format=1)">
-                          August 16, 2001 at 23:35:59
-                        </td>
-
-                    </tr>
-
-                        </metal:entry>
-                    </metal:block>
-                </tbody>
-            </table>
-          </div>
-      </metal:entries>
-    </metal:block>
-
-  </metal:content-core>
-
-</body>
-</html>
diff --git a/plone/app/contenttypes/browser/templates/full_view.pt b/plone/app/contenttypes/browser/templates/full_view.pt
new file mode 100644
index 0000000..2366c33
--- /dev/null
+++ b/plone/app/contenttypes/browser/templates/full_view.pt
@@ -0,0 +1,26 @@
+<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"
+    xmlns:tal="http://xml.zope.org/namespaces/tal"
+    xmlns:metal="http://xml.zope.org/namespaces/metal"
+    xmlns:i18n="http://xml.zope.org/namespaces/i18n"
+    lang="en"
+    metal:use-macro="context/main_template/macros/master"
+    i18n:domain="plone">
+<body>
+
+<metal:content-core fill-slot="content-core">
+<metal:block define-macro="content-core">
+  <metal:listing use-macro="context/@@listing_view/macros/content-core">
+    <!-- we don't want the dl -->
+    <metal:entries fill-slot="entries">
+      <metal:block use-macro="context/@@listing_view/macros/entries">
+        <metal:entry fill-slot="entry">
+          <div tal:define="obj item/getObject;" tal:replace="structure obj/@@full_view_item" />
+        </metal:entry>
+      </metal:block>
+    </metal:entries>
+  </metal:listing>
+</metal:block>
+</metal:content-core>
+
+</body>
+</html>
diff --git a/plone/app/contenttypes/browser/templates/full_view_item.pt b/plone/app/contenttypes/browser/templates/full_view_item.pt
new file mode 100644
index 0000000..f8407d7
--- /dev/null
+++ b/plone/app/contenttypes/browser/templates/full_view_item.pt
@@ -0,0 +1,71 @@
+<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"
+    xmlns:tal="http://xml.zope.org/namespaces/tal"
+    xmlns:metal="http://xml.zope.org/namespaces/metal"
+    xmlns:i18n="http://xml.zope.org/namespaces/i18n"
+    lang="en"
+    i18n:domain="plone"
+    tal:omit-tag="">
+<body tal:omit-tag="">
+
+  <div class="item visualIEFloatFix"
+      tal:define="item_macro nocall:view/item_macros/content-core|nothing;
+      item_url view/item_url;
+      rendering_error python:[];">
+
+    <div tal:replace="structure provider:plone.abovecontenttitle" />
+
+    <h2 class="headline">
+      <a class="summary url" tal:content="context/Title"
+        tal:attributes="href item_url;">
+        Title
+      </a>
+    </h2>
+
+    <div tal:replace="structure provider:plone.belowcontenttitle" />
+
+    <div class="description"
+        tal:content="context/Description"
+        tal:condition="context/Description">
+      Description
+    </div>
+
+    <tal:block tal:condition="item_macro">
+      <!-- tal:on-error="python:rendering_error.append(True)"-->
+
+      <div tal:replace="structure provider:plone.abovecontentbody" />
+
+      <div tal:define="view nocall:view/default_view;
+                       plone_view context/@@plone;
+                       portal_state context/@@plone_portal_state;
+                       context_state context/@@plone_context_state;
+                       plone_layout context/@@plone_layout;
+                       lang portal_state/language;
+                       dummy python: plone_layout.mark_view(view);
+                       portal_url portal_state/portal_url;
+                       checkPermission nocall: context/portal_membership/checkPermission;
+                       site_properties context/portal_properties/site_properties;">
+        <div metal:use-macro="item_macro">
+          content
+        </div>
+      </div>
+
+      <div tal:replace="structure provider:plone.belowcontentbody" />
+
+    </tal:block>
+
+    <tal:block tal:condition="rendering_error">
+      <!-- Error rendering item macro -->
+    </tal:block>
+
+    <p class="more" tal:condition="python:not(item_macro) or rendering_error">
+      <a tal:attributes="href item_url"
+          i18n:translate="read_more">
+        Read More&hellip;
+      </a>
+    </p>
+
+    <div class="visualClear"><!-- --></div>
+
+  </div>
+</body>
+</html>
diff --git a/plone/app/contenttypes/browser/templates/image.pt b/plone/app/contenttypes/browser/templates/image.pt
index 3090cab..8f15418 100644
--- a/plone/app/contenttypes/browser/templates/image.pt
+++ b/plone/app/contenttypes/browser/templates/image.pt
@@ -1,32 +1,29 @@
 <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"
-      xmlns:tal="http://xml.zope.org/namespaces/tal"
-      xmlns:metal="http://xml.zope.org/namespaces/metal"
-      xmlns:i18n="http://xml.zope.org/namespaces/i18n"
-      lang="en"
-      metal:use-macro="context/main_template/macros/master"
-      i18n:domain="plone">
-
+    xmlns:tal="http://xml.zope.org/namespaces/tal"
+    xmlns:metal="http://xml.zope.org/namespaces/metal"
+    xmlns:i18n="http://xml.zope.org/namespaces/i18n"
+    lang="en"
+    metal:use-macro="context/main_template/macros/master"
+    i18n:domain="plone">
 <body>
-    <metal:content-core fill-slot="content-core">
-        <metal:block define-macro="content-core"
-                     tal:define="size context/image/getSize">
-            <figure class="image-product">
-              <a class="discreet"
-                 tal:attributes="href string:${context/@@plone_context_state/object_url}/image_view_fullscreen"
-                 tal:define="scale context/@@images;
-                             img_tag python:scale.scale('image', scale='large').tag()"
-                  tal:on-error="string: Image cannot be displayed">
-                <img tal:replace="structure img_tag" />
-              
-              <figcaption class="discreet">
-                <strong class="sr-only" i18n:translate="label_click_to_view_full_image">Click to view full-size image&hellip;</strong>
-                <span><tal:span i18n:translate="label_size">Size</tal:span>: <tal:span tal:replace="python:size/1024"> File size </tal:span>KB</span>
-              </figcaption>
-              </a>
-            </figure>
-        </metal:block>
-    </metal:content-core>
-</body>
 
-</html>
+<metal:content-core fill-slot="content-core">
+<metal:block define-macro="content-core" tal:define="size context/image/getSize">
+  <figure class="image-product">
+    <a class="discreet"
+        tal:attributes="href string:${context/@@plone_context_state/object_url}/image_view_fullscreen"
+        tal:define="scale context/@@images;
+                    img_tag python:scale.scale('image', scale='large').tag()"
+        tal:on-error="string: Image cannot be displayed">
+    <img tal:replace="structure img_tag" />
+    <figcaption class="discreet">
+      <strong class="sr-only" i18n:translate="label_click_to_view_full_image">Click to view full-size image&hellip;</strong>
+      <span><tal:span i18n:translate="label_size">Size</tal:span>: <tal:span tal:replace="python:size/1024"> File size </tal:span>KB</span>
+    </figcaption>
+    </a>
+  </figure>
+</metal:block>
+</metal:content-core>
 
+</body>
+</html>
diff --git a/plone/app/contenttypes/browser/templates/image_view_fullscreen.pt b/plone/app/contenttypes/browser/templates/image_view_fullscreen.pt
index 1cb6ca2..2b796fd 100644
--- a/plone/app/contenttypes/browser/templates/image_view_fullscreen.pt
+++ b/plone/app/contenttypes/browser/templates/image_view_fullscreen.pt
@@ -1,69 +1,60 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
 <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"
-      xmlns:tal="http://xml.zope.org/namespaces/tal"
-      xmlns:metal="http://xml.zope.org/namespaces/metal"
-      xmlns:i18n="http://xml.zope.org/namespaces/i18n"
-      lang="en"
-      i18n:domain="plone">
-
+    xmlns:tal="http://xml.zope.org/namespaces/tal"
+    xmlns:metal="http://xml.zope.org/namespaces/metal"
+    xmlns:i18n="http://xml.zope.org/namespaces/i18n"
+    lang="en"
+    i18n:domain="plone">
 <head>
-
-    <metal:block tal:define="dummy python:request.RESPONSE.setHeader('Content-Type', 'text/html;;charset=utf-8')" />
-
-    <title tal:content="context/Title">
-        Title
-    </title>
-
-    <style type="text/css" media="screen">
+  <metal:block tal:define="dummy python:request.RESPONSE.setHeader('Content-Type', 'text/html;;charset=utf-8')" />
+  <meta name="viewport" content="width=device-width, initial-scale=1">
+  <title tal:content="context/Title">Title</title>
+  <style type="text/css" media="screen">
     body {
-        background-color: white;
-        color: black;
-        font-family: Helvetica, Arial, sans-serif;
-        font-size: 14px;
-        padding:0;
-        margin:0;
+      background-color: white;
+      color: black;
+      font-family: Helvetica, Arial, sans-serif;
+      font-size: 14px;
+      padding:0;
+      margin:0;
+    }
+    @media screen and (max-width: 768px) {
+        body {
+          font-size: 100%;
+        }
     }
     a {
-        color: #08c;
-        text-decoration: none;
-        text-align:center;
+      color: #08c;
+      text-decoration: none;
+      text-align:center;
+    }
+    a:hover {text-decoration:underline;}
+    a span {
+      display:block;
+      line-height:1.5em;
+      padding:12px;
     }
-      a:hover {text-decoration:underline;}
-      a span {
-          display:block;
-          line-height:1.5em;
-          padding:12px;
-      }
-
     img {
-        border: 0;
-        display:block;
-        margin:0 auto;
+      border: 0;
+      display:block;
+      margin:0 auto;
+      max-width: 100%; height: auto;
     }
-
-    </style>
-
+  </style>
 </head>
 
 <body>
-
-<div id="content-core"
-     tal:condition="context/@@images">
-    <a href=""
-       tal:attributes="href request/HTTP_REFERER"
-       tal:condition="request/HTTP_REFERER"
-       ><span i18n:translate="label_back_to_site">Back to site</span>
-    <tal:block replace="structure context/@@images/image" />
-  </a>
-
-    <a href=""
-       tal:attributes="href context/portal_url"
-       tal:condition="not: request/HTTP_REFERER"
-       ><span i18n:translate="label_home">Home</span>
-       <tal:block replace="structure context/@@images/image" />
+  <div id="content-core" tal:condition="context/@@images">
+    <a tal:attributes="href request/HTTP_REFERER"
+        tal:condition="request/HTTP_REFERER"
+      ><span i18n:translate="label_back_to_site">Back to site</span>
+      <tal:block replace="structure context/@@images/image" />
     </a>
-</div>
-
+    <a tal:attributes="href context/portal_url"
+        tal:condition="not: request/HTTP_REFERER"
+      ><span i18n:translate="label_home">Home</span>
+      <tal:block replace="structure context/@@images/image" />
+    </a>
+  </div>
 </body>
 </html>
-
diff --git a/plone/app/contenttypes/browser/templates/link.pt b/plone/app/contenttypes/browser/templates/link.pt
index b3fa2e1..c5752e4 100644
--- a/plone/app/contenttypes/browser/templates/link.pt
+++ b/plone/app/contenttypes/browser/templates/link.pt
@@ -1,38 +1,35 @@
 <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"
-      xmlns:tal="http://xml.zope.org/namespaces/tal"
-      xmlns:metal="http://xml.zope.org/namespaces/metal"
-      xmlns:i18n="http://xml.zope.org/namespaces/i18n"
-      lang="en"
-      metal:use-macro="context/main_template/macros/master"
-      i18n:domain="plone">
-
+    xmlns:tal="http://xml.zope.org/namespaces/tal"
+    xmlns:metal="http://xml.zope.org/namespaces/metal"
+    xmlns:i18n="http://xml.zope.org/namespaces/i18n"
+    lang="en"
+    metal:use-macro="context/main_template/macros/master"
+    i18n:domain="plone">
 <body>
 
-    <metal:header fill-slot="header">
-        <div class="portalMessage info"
-            tal:define="redirect_links context/portal_properties/site_properties/redirect_links|nothing;"
-            tal:condition="python: redirect_links and checkPermission('Modify portal content', context)">
-            <strong i18n:translate="">Info</strong>
-            <span tal:omit-tag=""
-                i18n:translate="message_permissions_blocking_link_redirect">
-              You see this page because you have permission to edit this link.
-              Others will be immediately redirected to the link's target URL.
-            </span>
-        </div>
-    </metal:header>
+<metal:header fill-slot="header">
+  <div class="portalMessage info"
+      tal:define="redirect_links context/portal_properties/site_properties/redirect_links|nothing;"
+      tal:condition="python: redirect_links and checkPermission('Modify portal content', context)">
+    <strong i18n:translate="">Info</strong>
+    <span tal:omit-tag=""
+        i18n:translate="message_permissions_blocking_link_redirect">
+      You see this page because you have permission to edit this link.
+      Others will be immediately redirected to the link's target URL.
+    </span>
+  </div>
+</metal:header>
 
-    <metal:content-core fill-slot="content-core">
-        <metal:block define-macro="content-core">
-        <p tal:define="portal_url context/@@plone_portal_state/portal_url;
-                       navigation_root_url context/@@plone_portal_state/navigation_root_url;
-                       url view/absolute_target_url">
-            <span i18n:translate="link_address">The link address is:</span>
-            <a href="#" tal:attributes="href url"
-                        tal:content="context/remoteUrl">remote url</a>
-        </p>
-        </metal:block>
-    </metal:content-core>
+<metal:content-core fill-slot="content-core">
+<metal:block define-macro="content-core">
+  <p tal:define="portal_url portal_state/portal_url;
+                 navigation_root_url portal_state/navigation_root_url;
+                 url view/absolute_target_url">
+    <span i18n:translate="link_address">The link address is:</span>
+    <a tal:attributes="href url" tal:content="context/remoteUrl">remote url</a>
+  </p>
+</metal:block>
+</metal:content-core>
 
 </body>
 </html>
-
diff --git a/plone/app/contenttypes/browser/templates/listing.pt b/plone/app/contenttypes/browser/templates/listing.pt
new file mode 100644
index 0000000..b21f554
--- /dev/null
+++ b/plone/app/contenttypes/browser/templates/listing.pt
@@ -0,0 +1,128 @@
+<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"
+    xmlns:tal="http://xml.zope.org/namespaces/tal"
+    xmlns:metal="http://xml.zope.org/namespaces/metal"
+    xmlns:i18n="http://xml.zope.org/namespaces/i18n"
+    lang="en"
+    metal:use-macro="context/main_template/macros/master"
+    i18n:domain="plone">
+<body>
+
+<metal:content-core fill-slot="content-core">
+<metal:block define-macro="content-core">
+
+  <div metal:define-macro="text-field-view"
+      id="parent-fieldname-text" class="stx"
+      tal:define="text view/text"
+      tal:condition="text"
+      tal:attributes="class view/text_class">
+    <div metal:define-slot="inside" tal:replace="structure text">The body</div>
+  </div>
+
+  <metal:listingmacro define-macro="listing">
+    <tal:results define="batch view/batch">
+      <tal:listing condition="batch">
+        <div class="entries" metal:define-slot="entries">
+          <tal:repeat repeat="item batch" metal:define-macro="entries">
+            <tal:block tal:define="obj item/getObject;
+                item_url item/getURL;
+                item_id item/getId;
+                item_title item/Title;
+                item_description item/Description;
+                item_type item/PortalType;
+                item_modified item/ModificationDate;
+                item_created item/CreationDate;
+                item_icon item/getIcon;
+                item_type_class python:'contenttype-' + view.normalizeString(item_type);
+                item_wf_state item/review_state;
+                item_wf_state_class python:'state-' + view.normalizeString(item_wf_state);
+                item_creator item/Creator;
+                item_link python:item_type in view.use_view_action and item_url+'/view' or item_url;
+                item_has_image python:view.has_image(obj);
+                item_is_event python:view.is_event(obj)">
+              <metal:block define-slot="entry">
+                <article class="entry">
+                  <header metal:define-macro="listitem" tal:attributes="class python:'vevent' if item_is_event else None">
+                    <span class="summary">
+                      <a tal:attributes="href item_link;
+                                         class string:$item_type_class $item_wf_state_class url;
+                                         title item_type"
+                          tal:content="item_title">
+                        Item Title
+                      </a>
+                    </span>
+
+                    <metal:block metal:define-macro="document_byline">
+                      <span class="documentByLine">
+                        <tal:event condition="item_is_event">
+                          <tal:date tal:replace="structure python:view.formatted_date(obj)"/>
+                          <span tal:condition="item/location" i18n:translate="label_event_byline_location">&mdash;
+                            <span tal:content="string:${item/location}" class="location" i18n:name="location">Oslo</span>,
+                          </span>
+                        </tal:event>
+                        <tal:byline condition="view/show_about">
+                          &mdash;
+                          <tal:name tal:condition="item_creator"
+                              tal:define="author python:view.pas_member.info(item_creator);
+                                          creator_short_form author/username;
+                                          creator_long_form string:?author=${author/username};
+                                          creator_is_openid python:'/' in creator_short_form;
+                                          creator_id python:(creator_short_form, creator_long_form)[creator_is_openid];">
+                          <span i18n:translate="label_by_author">
+                            by
+                            <a tal:attributes="href string:${view/navigation_root_url}/author/${item_creator}"
+                                tal:content="author/name_or_id"
+                                tal:omit-tag="not:author"
+                                i18n:name="author">
+                              Bob Dobalina
+                            </a>
+                          </span>
+                          </tal:name>
+
+                          <tal:modified condition="python: item_type != 'Event'">
+                            &mdash;
+                            <tal:mod i18n:translate="box_last_modified">last modified</tal:mod>
+                            <span tal:replace="python:view.toLocalizedTime(item_modified,long_format=1)">
+                              August 16, 2001 at 23:35:59
+                            </span>
+                          </tal:modified>
+
+                          <metal:description define-slot="description_slot">
+                            <tal:comment replace="nothing">
+                              Place custom listing info for custom types here
+                            </tal:comment>
+                          </metal:description>
+                        </tal:byline>
+                      </span>
+                    </metal:block>
+                  </header>
+                  <p class="description discreet"
+                      tal:condition="item_description"
+                      tal:content="item_description">
+                    description
+                  </p>
+                </article>
+              </metal:block>
+            </tal:block>
+          </tal:repeat>
+        </div>
+
+        <div metal:use-macro="context/batch_macros/macros/navigation" />
+
+      </tal:listing>
+
+      <metal:empty metal:define-slot="no_items_in_listing">
+        <p class="discreet"
+            tal:condition="not: view/batch"
+            tal:content="view/no_items_message">
+          There are currently no items in this folder.
+        </p>
+      </metal:empty>
+
+    </tal:results>
+  </metal:listingmacro>
+
+</metal:block>
+</metal:content-core>
+
+</body>
+</html>
diff --git a/plone/app/contenttypes/browser/templates/listing_album.pt b/plone/app/contenttypes/browser/templates/listing_album.pt
new file mode 100644
index 0000000..61f46e6
--- /dev/null
+++ b/plone/app/contenttypes/browser/templates/listing_album.pt
@@ -0,0 +1,80 @@
+<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"
+      xmlns:tal="http://xml.zope.org/namespaces/tal"
+      xmlns:metal="http://xml.zope.org/namespaces/metal"
+      xmlns:i18n="http://xml.zope.org/namespaces/i18n"
+      lang="en"
+      metal:use-macro="here/main_template/macros/master"
+      i18n:domain="plone">
+<body>
+
+<metal:content-core fill-slot="content-core">
+<metal:main_macro define-macro="content-core"
+    tal:define="images view/album_images;
+                albums view/album_folders">
+
+  <div metal:define-macro="text-field-view"
+      id="parent-fieldname-text" class="stx"
+      tal:define="text view/text"
+      tal:condition="text"
+      tal:attributes="class view/text_class">
+    <div metal:define-slot="inside" tal:replace="structure text">The body</div>
+  </div>
+
+  <tal:images tal:repeat="image images">
+    <div class="photoAlbumEntry">
+      <a tal:attributes="href string:${image/getURL}/view;
+                         title image/Description">
+        <span class="photoAlbumEntryWrapper">
+          <img tal:define="ob image/getObject;
+                           scale ob/@@images;
+                           img_tag python:scale.scale('image', scale='thumb').tag()"
+              tal:replace="structure img_tag" />
+        </span>
+        <span class="photoAlbumEntryTitle" tal:content="image/Title">
+            Title
+        </span>
+      </a>
+    </div>
+  </tal:images>
+
+  <div class="visualClear"><!-- --></div>
+
+  <tal:albums tal:repeat="album albums">
+    <div class="photoAlbumEntry photoAlbumFolder"
+        tal:define="album_ob album/getObject;
+                    subalbum_view nocall:album_ob/@@album_view;
+                    random_image subalbum_view/album_random_image;
+                    number_images subalbum_view/album_number_images"
+        tal:condition="random_image">
+      <a tal:attributes="href album/getURL;
+                         title album/Description">
+        <span class="photoAlbumEntryWrapper">
+          <img tal:define="random_img_ob random_image/getObject;
+                           scales random_img_ob/@@images"
+               tal:replace="structure python:scales.tag(fieldname='image', scale='thumb')" />
+        </span>
+        <span class="photoAlbumEntryTitle">
+          <tal:title content="album/Title">Title</tal:title>
+          (<tal:number content="number_images" />)
+        </span>
+      </a>
+    </div>
+  </tal:albums>
+
+  <div class="visualClear"><!-- --></div>
+
+  <div metal:use-macro="context/batch_macros/macros/navigation" />
+
+  <metal:empty metal:define-slot="no_items_in_listing">
+    <p class="discreet"
+        tal:condition="not: view/batch"
+        tal:content="view/no_items_message">
+      There are currently no items in this folder.
+    </p>
+  </metal:empty>
+
+</metal:main_macro>
+</metal:content-core>
+
+</body>
+</html>
diff --git a/plone/app/contenttypes/browser/templates/listing_summary.pt b/plone/app/contenttypes/browser/templates/listing_summary.pt
new file mode 100644
index 0000000..a4455e4
--- /dev/null
+++ b/plone/app/contenttypes/browser/templates/listing_summary.pt
@@ -0,0 +1,63 @@
+<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"
+    xmlns:tal="http://xml.zope.org/namespaces/tal"
+    xmlns:metal="http://xml.zope.org/namespaces/metal"
+    xmlns:i18n="http://xml.zope.org/namespaces/i18n"
+    lang="en"
+    metal:use-macro="context/main_template/macros/master"
+    i18n:domain="plone">
+<body>
+
+<metal:content-core fill-slot="content-core">
+<metal:block use-macro="context/@@listing_view/macros/content-core">
+
+  <metal:entries fill-slot="entries">
+    <metal:block use-macro="context/@@listing_view/macros/entries">
+      <metal:entry fill-slot="entry">
+
+        <article class="tileItem visualIEFloatFix" tal:define="obj item/getObject">
+
+          <div class="tileImage" tal:condition="item_has_image">
+            <a tal:attributes="href item_link">
+              <img tal:define="scales obj/@@images;
+                               scale python:scales.scale('image', 'thumb')"
+                  tal:replace="structure python:scale and scale.tag(css_class='tileImage') or None" />
+            </a>
+          </div>
+
+          <h2 class="tileHeadline" metal:define-macro="listitem">
+            <a class="summary url"
+                tal:attributes="href item_link;
+                                title item_type"
+                tal:content="item_title">
+              Item Title
+            </a>
+          </h2>
+
+          <div metal:use-macro="context/@@listing_view/macros/document_byline"></div>
+
+          <p class="tileBody" tal:condition="item_description">
+            <span class="description" tal:content="item_description">
+              description
+            </span>
+          </p>
+
+          <p class="tileFooter">
+            <a tal:attributes="href item_link"
+                i18n:translate="read_more">
+              Read More&hellip;
+            </a>
+          </p>
+
+          <div class="visualClear"><!-- --></div>
+
+        </article>
+
+      </metal:entry>
+    </metal:block>
+  </metal:entries>
+
+</metal:block>
+</metal:content-core>
+
+</body>
+</html>
diff --git a/plone/app/contenttypes/browser/templates/listing_tabular.pt b/plone/app/contenttypes/browser/templates/listing_tabular.pt
new file mode 100644
index 0000000..ab1d18e
--- /dev/null
+++ b/plone/app/contenttypes/browser/templates/listing_tabular.pt
@@ -0,0 +1,100 @@
+<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"
+    xmlns:tal="http://xml.zope.org/namespaces/tal"
+    xmlns:metal="http://xml.zope.org/namespaces/metal"
+    xmlns:i18n="http://xml.zope.org/namespaces/i18n"
+    lang="en"
+    metal:use-macro="context/main_template/macros/master"
+    i18n:domain="plone">
+<body>
+
+<metal:content-core fill-slot="content-core">
+<metal:block define-macro="content-core">
+
+  <div metal:define-macro="text-field-view"
+      id="parent-fieldname-text" class="stx"
+      tal:define="text view/text"
+      tal:condition="text"
+      tal:attributes="class view/text_class">
+    <div metal:define-slot="inside" tal:replace="structure text">The body</div>
+  </div>
+
+  <tal:results define="batch view/batch">
+    <tal:listing condition="batch">
+
+      <div metal:use-macro="context/batch_macros/macros/navigation" />
+      <div class="has-table">
+        <table class="listing"
+            summary="Content listing"
+            i18n:attributes="summary summary_content_listing;">
+          <thead>
+            <tr>
+              <th class="nosort"
+                  i18n:translate=""
+                  tal:repeat="field view/tabular_fields"
+                  tal:content="field">Field name</th>
+            </tr>
+          </thead>
+          <tbody>
+            <tal:entries tal:repeat="item batch">
+              <tal:block tal:define="item_url item/getURL;
+                                     item_title item/Title;
+                                     item_description item/Description;
+                                     item_type item/PortalType;
+                                     item_type_class python:'contenttype-' + view.normalizeString(item_type);
+                                     item_wf_state item/review_state;
+                                     item_wf_state_class python:'state-' + view.normalizeString(item_wf_state);
+                                     item_creator item/Creator;
+                                     item_link python:item_type in view.use_view_action and item_url+'/view' or item_url">
+                <tr metal:define-macro="listitem"
+                    tal:define="oddrow repeat/item/odd;"
+                    tal:attributes="class python: oddrow and 'even' or 'odd'">
+
+                  <tal:block tal:repeat="field view/tabular_fields">
+                    <td tal:condition="python:field not in ['Title', 'Creator', 'getIcon']"
+                        tal:define="field_data python:view.tabular_fielddata(item, field)">
+                      <tal:block tal:replace="field_data/value" />
+                    </td>
+                    <td tal:condition="python:field == 'Title'">
+                      <a href="#"
+                          tal:attributes="href item_link;
+                          class string:$item_wf_state_class $item_type_class;
+                          title item_description;"
+                          tal:content="item_title">
+                        Item Title
+                      </a>
+                    </td>
+                    <td tal:condition="python:field == 'Creator'"
+                        tal:define="author python:view.pas_member.info(item_creator);
+                                    name python:author['fullname'] or author['username']">
+                      <a tal:condition="author"
+                          tal:attributes="href string:${view/navigation_root_url}/author/${item_creator}"
+                          tal:content="name">Jos Henken</a>
+                    </td>
+                  </tal:block>
+
+                </tr>
+              </tal:block>
+            </tal:entries>
+          </tbody>
+        </table>
+      </div>
+
+      <div metal:use-macro="context/batch_macros/macros/navigation" />
+
+    </tal:listing>
+
+    <metal:empty metal:define-slot="no_items_in_listing">
+    <p class="discreet"
+    tal:condition="not: view/batch"
+    tal:content="view/no_items_message">
+    There are currently no items in this folder.
+    </p>
+    </metal:empty>
+
+  </tal:results>
+
+</metal:block>
+</metal:content-core>
+
+</body>
+</html>
diff --git a/plone/app/contenttypes/browser/templates/newsitem.pt b/plone/app/contenttypes/browser/templates/newsitem.pt
index 009e8d9..ebd41fe 100644
--- a/plone/app/contenttypes/browser/templates/newsitem.pt
+++ b/plone/app/contenttypes/browser/templates/newsitem.pt
@@ -1,57 +1,49 @@
 <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"
-      xmlns:tal="http://xml.zope.org/namespaces/tal"
-      xmlns:metal="http://xml.zope.org/namespaces/metal"
-      xmlns:i18n="http://xml.zope.org/namespaces/i18n"
-      lang="en"
-      metal:use-macro="context/main_template/macros/master"
-      i18n:domain="plone">
+    xmlns:tal="http://xml.zope.org/namespaces/tal"
+    xmlns:metal="http://xml.zope.org/namespaces/metal"
+    xmlns:i18n="http://xml.zope.org/namespaces/i18n"
+    lang="en"
+    metal:use-macro="context/main_template/macros/master"
+    i18n:domain="plone">
 <body>
 
 <metal:head fill-slot="javascript_head_slot">
-<script type="text/javascript">
-  jQuery(function($){
-    $('.newsImageContainer a').prepOverlay({subtype: 'image'});
-  })
-</script>
+  <script type="text/javascript">
+    jQuery(function ($) {
+      $('.newsImageContainer a').prepOverlay({subtype: 'image'});
+    });
+  </script>
 </metal:head>
 
 <metal:content-core fill-slot="content-core">
-    <metal:block define-macro="content-core"
-          tal:define="templateId template/getId;
-                      scale_func context/@@images;
-                      scaled_image python: getattr(context.aq_explicit, 'image', False) and scale_func.scale('image', scale='mini')">
-
-        <figure class="newsImageContainer"
-             tal:condition="python: scaled_image">
-            <a href="#"
-               tal:define="here_url context/@@plone_context_state/object_url;
-                           large_image python: scale_func.scale('image', scale='large');"
-               tal:attributes="href large_image/url">
-              <img tal:replace="structure python: scaled_image.tag(css_class='newsImage')" />
-
-              <figcaption
-                 tal:condition="context/image_caption|nothing"
-                 tal:content="structure context/image_caption" >
-              </figcaption>
-
-            </a>
-        </figure>
-
-
-        <div id="parent-fieldname-text"
-             tal:condition="context/text"
-             tal:content="structure context/text/output" />
-
-        <div class="newsFileContainer"
-             tal:condition="python: getattr(context.aq_explicit, 'image', False) and not scaled_image">
-            <a tal:content="structure python:context.image_caption or context.image.filename"
-               tal:attributes="href python:'%s/@@download/image' % context.absolute_url()">
-            </a>
-        </div>
-
-    </metal:block>
+<metal:block define-macro="content-core"
+    tal:define="templateId template/getId;
+                scale_func context/@@images;
+                scaled_image python: getattr(context.aq_explicit, 'image', False) and scale_func.scale('image', scale='mini')">
+  <figure class="newsImageContainer" tal:condition="python: scaled_image">
+    <a tal:define="here_url context/@@plone_context_state/object_url;
+                   large_image python: scale_func.scale('image', scale='large');"
+        tal:attributes="href large_image/url">
+      <img tal:replace="structure python: scaled_image.tag(css_class='newsImage')" />
+      <figcaption tal:condition="context/image_caption|nothing"
+          tal:content="structure context/image_caption">
+      </figcaption>
+    </a>
+  </figure>
+
+  <div id="parent-fieldname-text"
+      tal:condition="context/text"
+      tal:content="structure context/text/output" />
+
+  <div class="newsFileContainer"
+      tal:condition="python: getattr(context.aq_explicit, 'image', False) and not scaled_image">
+    <a tal:content="structure python:context.image_caption or context.image.filename"
+        tal:attributes="href python:'%s/@@download/image' % context.absolute_url()">
+    </a>
+  </div>
+
+</metal:block>
 </metal:content-core>
 
 </body>
 </html>
-
diff --git a/plone/app/contenttypes/browser/templates/standard_view.pt b/plone/app/contenttypes/browser/templates/standard_view.pt
deleted file mode 100644
index 5865930..0000000
--- a/plone/app/contenttypes/browser/templates/standard_view.pt
+++ /dev/null
@@ -1,181 +0,0 @@
-<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"
-      xmlns:tal="http://xml.zope.org/namespaces/tal"
-      xmlns:metal="http://xml.zope.org/namespaces/metal"
-      xmlns:i18n="http://xml.zope.org/namespaces/i18n"
-      lang="en"
-      metal:use-macro="here/main_template/macros/master"
-      i18n:domain="plone">
-
-<body>
-
-  <div metal:fill-slot="content-core">
-    <metal:block define-macro="content-core"
-                 tal:define="templateId template/getId">
-
-        <div metal:define-macro="text-field-view"
-             id="parent-fieldname-text" class="stx"
-             tal:define="has_text exists:context/aq_explicit/text/output;
-                         text python:has_text and here.text.output or ''"
-             tal:condition="text"
-             tal:attributes="class python:context.Format() in ('text/structured', 'text/x-rst', ) and 'stx' or 'plain'">
-            <div metal:define-slot="inside" tal:replace="structure text">The body</div>
-        </div>
-
-        <metal:listingmacro define-macro="listing">
-        <tal:results define="b_start python:request.get('b_start', 0);
-                             batch python:view.results(b_start=b_start);
-                             site_properties context/portal_properties/site_properties;
-                             use_view_action site_properties/typesUseViewActionInListings|python:();
-                             isAnon context/@@plone_portal_state/anonymous;
-                             normalizeString nocall: context/plone_utils/normalizeString;
-                             toLocalizedTime nocall: context/@@plone/toLocalizedTime;
-                             show_about python:not isAnon or site_properties.allowAnonymousViewAbout;
-                             navigation_root_url context/@@plone_portal_state/navigation_root_url;
-                             pas_member context/@@pas_member;">
-        <tal:listing condition="batch">
-
-            <div metal:define-slot="entries">
-                <article tal:repeat="item batch" metal:define-macro="entries">
-                <tal:block tal:define="item_url item/getURL;
-                                       item_id item/getId;
-                                       item_description item/Description;
-                                       item_type item/Type;
-                                       item_modified item/ModificationDate;
-                                       item_created item/CreationDate;
-                                       item_icon item/getIcon;
-                                       item_type_class item/ContentTypeClass;
-                                       item_wf_state_class python:'state-' + normalizeString(item.review_state());
-                                       item_creator item/Creator;
-                                       item_start python:(item.start or item.StartDate) if item_type == 'Event' else None;
-                                       item_end python:(item.end or item.EndDate) if item_type == 'Event' else None;
-                                       item_modified item/ModificationDate;
-                                       item_sametime python: item_start == item_end;
-                                       item_samedate python: (item_end - item_start &lt; 1) if item_type == 'Event' else False">
-                    <metal:block define-slot="entry">
-                    <header metal:define-macro="listitem"
-                        tal:attributes="class python:item_type == 'Event' and 'vevent' or ''">
-
-                        <span class="summary">
-                            <img tal:replace="structure item_icon" />
-                            <a href="#"
-                               tal:attributes="href python:item_type in use_view_action and item_url+'/view' or item_url;
-                                               class string:$item_type_class $item_wf_state_class url"
-                               tal:content="item/Title">
-                                Item Title
-                            </a>
-                        </span>
-
-                        <metal:block metal:define-macro="document_byline">
-                        <span class="documentByLine">
-                            <span tal:condition="python: item_type == 'Event' and item_sametime"
-                                  i18n:translate="label_event_byline_onlyfrom">
-                                 <abbr class="dtstart"
-                                       tal:attributes="title python:item_start"
-                                       tal:content="python:toLocalizedTime(item_start,long_format=1)"
-                                       i18n:name="start">from date</abbr>
-                            </span>
-                            <span tal:condition="python: item_type == 'Event' and item_samedate and not item_sametime"
-                                  i18n:translate="label_event_byline_samedate">
-                                 <abbr class="dtstart"
-                                       tal:attributes="title python:item_start"
-                                       tal:content="python:toLocalizedTime(item_start)"
-                                       i18n:name="start">from date</abbr> from
-                                 <abbr class="dtstart"
-                                       tal:attributes="title python:item_start"
-                                       tal:content="python:toLocalizedTime(item_start,time_only=1)"
-                                       i18n:name="starttime">from time</abbr> to
-                                 <abbr class="dtend"
-                                       tal:attributes="title python:item_end"
-                                       tal:content="python:toLocalizedTime(item_end,time_only=1)"
-                                       i18n:name="end">to time</abbr>
-                            </span>
-                            <span tal:condition="python: item_type == 'Event' and not item_samedate and not item_sametime"
-                                  i18n:translate="label_event_byline">
-                                  from
-                                       <abbr class="dtstart"
-                                       tal:attributes="title python:item_start"
-                                       tal:content="python:toLocalizedTime(item_start,long_format=1)"
-                                       i18n:name="start">from date</abbr> to
-                                 <abbr class="dtend"
-                                       tal:attributes="title python:item_end"
-                                       tal:content="python:toLocalizedTime(item_end,long_format=1)"
-                                       i18n:name="end">to date</abbr>
-                            </span>
-                             <span tal:condition="python: item_type == 'Event' and item.location"
-                                  i18n:translate="label_event_byline_location">&mdash;
-                                 <span tal:content="string:${item/location}"
-                                       class="location"
-                                       i18n:name="location">Oslo</span>,
-                            </span>
-                            <tal:byline condition="show_about">
-                                &mdash;
-
-                                <tal:name tal:condition="item_creator"
-                                    tal:define="author python:pas_member.info(item_creator);
-                                                creator_short_form author/username;
-                                                creator_long_form string:?author=${author/username};
-                                                creator_is_openid python:'/' in creator_short_form;
-                                                creator_id python:(creator_short_form, creator_long_form)[creator_is_openid];">
-                                  <span i18n:translate="label_by_author">
-                                    by
-                                  <a href="#"
-                                     tal:attributes="href string:${navigation_root_url}/author/${item_creator}"
-                                     tal:content="author/name_or_id"
-                                     tal:omit-tag="not:author"
-                                     i18n:name="author">
-                                    Bob Dobalina
-                                  </a>
-                                  </span>
-
-                                </tal:name>
-
-                                <tal:modified condition="python: item_type != 'Event'">
-                                    &mdash;
-                                    <tal:mod i18n:translate="box_last_modified">
-                                      last modified
-                                    </tal:mod>
-                                    <span tal:replace="python:toLocalizedTime(item_modified,long_format=1)">
-                                      August 16, 2001 at 23:35:59
-                                    </span>
-                                </tal:modified>
-
-                                <metal:description define-slot="description_slot">
-                                    <tal:comment replace="nothing">
-                                        Place custom listing info for custom types here
-                                    </tal:comment>
-                                </metal:description>
-                            </tal:byline>
-                        </span>
-                        </metal:block>
-
-                    </header>
-
-                    <span class="description"
-                        tal:condition="item_description"
-                        tal:content="item_description">
-                      description
-                    </span>
-                </metal:block>
-                </tal:block>
-                </article>
-            </div>
-
-            <div metal:use-macro="context/batch_macros/macros/navigation" />
-
-        </tal:listing>
-        <metal:empty metal:define-slot="no_items_in_listing">
-            <p class="discreet"
-               tal:condition="not: batch"
-               i18n:translate="description_no_items_in_folder">
-                There are currently no items in this folder.
-            </p>
-        </metal:empty>
-
-        </tal:results>
-        </metal:listingmacro>
-
-    </metal:block>
-  </div>
-
-</body>
-</html>
diff --git a/plone/app/contenttypes/browser/templates/summary_view.pt b/plone/app/contenttypes/browser/templates/summary_view.pt
deleted file mode 100644
index 880f1e0..0000000
--- a/plone/app/contenttypes/browser/templates/summary_view.pt
+++ /dev/null
@@ -1,67 +0,0 @@
-<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"
-      xmlns:tal="http://xml.zope.org/namespaces/tal"
-      xmlns:metal="http://xml.zope.org/namespaces/metal"
-      xmlns:i18n="http://xml.zope.org/namespaces/i18n"
-      lang="en"
-      metal:use-macro="here/main_template/macros/master"
-      i18n:domain="plone">
-
-<body>
-
-<metal:content-core fill-slot="content-core">
-<metal:block use-macro="context/standard_view/macros/content-core">
-
-    <metal:entries fill-slot="entries">
-    <metal:block use-macro="context/standard_view/macros/entries">
-    <metal:entry fill-slot="entry">
-
-        <div class="tileItem visualIEFloatFix"
-             tal:define="obj item/getObject">
-            <a href="#"
-                  tal:condition="python:getattr(obj.aq_explicit, 'image', None)"
-                  tal:attributes="href item/getURL">
-                  <div class="tileImage">
-                      <img src="" alt=""
-                           tal:define="scales obj/@@images;
-                                       scale python:scales.scale('image', 'thumb')"
-                           tal:replace="structure python:scale and scale.tag(css_class='tileImage') or None" />
-                  </div>
-            </a>
-
-            <h2 class="tileHeadline" metal:define-macro="listitem">
-                <a href="#"
-                   class="summary url"
-                   tal:attributes="href python:item_type in use_view_action and item_url+'/view' or item_url;"
-                   tal:content="item/Title">
-                    Item Title
-                </a>
-            </h2>
-
-            <div metal:use-macro="context/standard_view/macros/document_byline"></div>
-
-            <p class="tileBody" tal:condition="item_description">
-                <span class="description" tal:content="item_description">
-                    description
-                </span>
-            </p>
-
-            <p class="tileFooter">
-                <a href=""
-                   tal:attributes="href python:item_type in use_view_action and item_url+'/view' or item_url;"
-                   i18n:translate="read_more">
-                Read More&hellip;
-                </a>
-            </p>
-
-            <div class="visualClear"><!-- --></div>
-        </div>
-
-    </metal:entry>
-    </metal:block>
-    </metal:entries>
-
-</metal:block>
-</metal:content-core>
-
-</body>
-</html>
diff --git a/plone/app/contenttypes/browser/templates/tabular_view.pt b/plone/app/contenttypes/browser/templates/tabular_view.pt
deleted file mode 100644
index 4f2ea22..0000000
--- a/plone/app/contenttypes/browser/templates/tabular_view.pt
+++ /dev/null
@@ -1,77 +0,0 @@
-<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"
-      xmlns:tal="http://xml.zope.org/namespaces/tal"
-      xmlns:metal="http://xml.zope.org/namespaces/metal"
-      xmlns:i18n="http://xml.zope.org/namespaces/i18n"
-      lang="en"
-      metal:use-macro="here/main_template/macros/master"
-      i18n:domain="plone">
-
-<body>
-
-    <div metal:fill-slot="content-core"
-         tal:define="b_start python:request.get('b_start', 0);
-                     batch python:view.results(b_start=b_start);">
-
-         <div metal:define-macro="text-field-view"
-              id="parent-fieldname-text" class="stx"
-              tal:define="has_text exists:context/aq_explicit/text/output;
-                          text python:has_text and here.text.output or ''"
-              tal:condition="text"
-              tal:attributes="class python:here.Format() in ('text/structured', 'text/x-rst', ) and 'stx' or 'plain'">
-             <div metal:define-slot="inside" tal:replace="structure text">The body</div>
-         </div>
-
-        <p class="discreet"
-           tal:condition="not: batch"
-           i18n:translate="description_no_items_in_folder">
-            There are currently no items in this folder.
-        </p>
-
-        <table class="listing" summary="Content listing"
-            i18n:attributes="summary"
-            tal:condition="batch"
-            tal:define="fields view/selectedViewFields;
-                        pas_member context/@@pas_member">
-            <thead>
-                <tr>
-                    <th class="nosort"
-                        i18n:translate=""
-                        tal:repeat="field fields"
-                        tal:content="python: field[1]">Field name</th>
-                </tr>
-            </thead>
-            <tbody>
-            <tal:block tal:repeat="item batch">
-                <tr tal:define="oddrow repeat/item/odd;"
-                    tal:attributes="class python:oddrow and 'even' or 'odd'" >
-                <tal:block tal:repeat="field fields">
-                    <td tal:condition="python:field[0] not in ['Title', 'Creator', ]"
-                        tal:define="field_data python:getattr(item, field[0])">
-                        <tal:block tal:replace="field_data" />
-                    </td>
-                    <td tal:condition="python:field[0] == 'Title'">
-                        <a href="#"
-                           tal:attributes="href item/getURL;
-                                           title item/Title"
-                           tal:content="item/Title">Item Title</a>
-                    </td>
-                    <td tal:condition="python:field[0] == 'Creator'"
-                        tal:define="author python:pas_member.info(item.Creator());
-                                    name python:author['fullname'] or author['username']">
-                        <a href="#"
-                           tal:condition="author"
-                           tal:attributes="href string:author/${author/username};
-                                           title name"
-                           tal:content="name">Jos Henken</a>
-                    </td>
-                </tal:block>
-                </tr>
-            </tal:block>
-            </tbody>
-        </table>
-
-        <div metal:use-macro="context/batch_macros/macros/navigation" />
-  </div>
-
-</body>
-</html>
diff --git a/plone/app/contenttypes/browser/templates/thumbnail_view.pt b/plone/app/contenttypes/browser/templates/thumbnail_view.pt
deleted file mode 100644
index 220c22d..0000000
--- a/plone/app/contenttypes/browser/templates/thumbnail_view.pt
+++ /dev/null
@@ -1,70 +0,0 @@
-<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"
-      xmlns:tal="http://xml.zope.org/namespaces/tal"
-      xmlns:metal="http://xml.zope.org/namespaces/metal"
-      xmlns:i18n="http://xml.zope.org/namespaces/i18n"
-      lang="en"
-      metal:use-macro="here/main_template/macros/master"
-      i18n:domain="plone">
-
-<body>
-
-<metal:content-core fill-slot="content-core">
-<metal:main_macro define-macro="content-core"
-     tal:define="data view/getFoldersAndImages;
-                total_number_of_images data/total_number_of_images;
-                site_properties context/portal_properties/site_properties;
-                use_view_action site_properties/typesUseViewActionInListings|python:();">
-
-    <div metal:define-macro="text-field-view"
-         id="parent-fieldname-text" class="stx"
-         tal:define="has_text exists:context/aq_explicit/text/output;
-                     text python:has_text and here.text.output or ''"
-         tal:condition="text"
-         tal:attributes="class python:here.Format() in ('text/structured', 'text/x-rst', ) and 'stx' or 'plain'">
-        <div metal:define-slot="inside" tal:replace="structure text">The body</div>
-    </div>
-
-    <tal:results tal:repeat="item data/results"
-                 tal:condition="total_number_of_images">
-    <div class="photoAlbumEntry photoAlbumFolder"
-         tal:define="item_path item/getPath;
-                     item_type item/portal_type;
-                     is_album python:item_type=='Folder';
-                     images_album python:data['images'].get(item_path, []);
-                     number_of_images python:len(images_album);
-                     item_title item/Title;
-                     item_url item/getURL;
-                     item_description item/Description;
-                     item_view python:item_type in use_view_action and item_url+'/view' or item_url;
-                     random python:modules['random'];
-                     random_image python:number_of_images and random.choice(images_album).getObject() or None"
-          tal:attributes="class python:is_album and 'photoAlbumEntry photoAlbumFolder' or 'photoAlbumEntry'">
-                <a tal:attributes="href item_view;
-                                   title item_description">
-                    <span class="photoAlbumEntryWrapper"
-                          tal:condition="number_of_images">
-                     <img src="" alt=""
-                          tal:define="scales random_image/@@images;
-                                      scale python:scales.scale('image', 'thumb')"
-                          tal:replace="structure python:scale and scale.tag(title=item_description) or None" />
-                    </span>
-                    <span class="photoAlbumEntryTitle">
-                       <tal:title content="item_title">Title</tal:title>
-                       <tal:count condition="is_album">(<tal:number content="number_of_images" />)</tal:count>
-                    </span>
-                </a>
-    </div>
-    </tal:results>
-    <div class="visualClear"><!-- --></div>
-
-    <p class="discreet"
-       i18n:translate=""
-       tal:condition="not: total_number_of_images">
-        No images found in this collection.
-    </p>
-
-</metal:main_macro>
-</metal:content-core>
-
-</body>
-</html>
diff --git a/plone/app/contenttypes/browser/utils.py b/plone/app/contenttypes/browser/utils.py
index b816539..c4c7037 100644
--- a/plone/app/contenttypes/browser/utils.py
+++ b/plone/app/contenttypes/browser/utils.py
@@ -31,8 +31,11 @@ def getMimeTypeIcon(self, content_file):
         )
         portal_url = pstate.portal_url()
         mtr = getToolByName(context, "mimetypes_registry")
-        mime = list(mtr.lookup(content_file.contentType))
-        mime.append(mtr.lookupExtension(content_file.filename))
+        mime = []
+        if content_file.contentType:
+            mime.append(mtr.lookup(content_file.contentType))
+        if content_file.filename:
+            mime.append(mtr.lookupExtension(content_file.filename))
         mime.append(mtr.lookup("application/octet-stream")[0])
         icon_paths = [m.icon_path for m in mime if hasattr(m, 'icon_path')]
         if icon_paths:
diff --git a/plone/app/contenttypes/content.py b/plone/app/contenttypes/content.py
index 5b8d4e5..faeb33b 100644
--- a/plone/app/contenttypes/content.py
+++ b/plone/app/contenttypes/content.py
@@ -14,6 +14,8 @@
 
 @implementer(ICollection)
 class Collection(Item):
+    """Convenience subclass for ``Collection`` portal type
+    """
     # BBB
 
     def listMetaDataFields(self, exclude=True):
@@ -57,41 +59,41 @@ def results(self, **kwargs):
 
 @implementer(IDocument)
 class Document(Item):
-    """Convinience Item subclass for ``Document`` portal type
+    """Convenience subclass for ``Document`` portal type
     """
 
 
 @implementer(IFile)
 class File(Item):
-    """Convinience subclass for ``File`` portal type
+    """Convenience subclass for ``File`` portal type
     """
 
 
 @implementer(IFolder)
 class Folder(Container):
-    """Convinience subclass for ``File`` portal type
+    """Convenience subclass for ``Folder`` portal type
     """
 
 
 @implementer(IImage)
 class Image(Item):
-    """Convinience subclass for ``File`` portal type
+    """Convenience subclass for ``Image`` portal type
     """
 
 
 @implementer(ILink)
 class Link(Item):
-    """Convinience subclass for ``File`` portal type
+    """Convenience subclass for ``Link`` portal type
     """
 
 
 @implementer(INewsItem)
 class NewsItem(Item):
-    """Convinience subclass for ``File`` portal type
+    """Convenience subclass for ``News Item`` portal type
     """
 
 
 @implementer(IEvent)
 class Event(Item):
-    """Convinience subclass for ``File`` portal type
+    """Convenience subclass for ``Event`` portal type
     """
diff --git a/plone/app/contenttypes/interfaces.py b/plone/app/contenttypes/interfaces.py
index 3b8a90b..73908f8 100644
--- a/plone/app/contenttypes/interfaces.py
+++ b/plone/app/contenttypes/interfaces.py
@@ -13,40 +13,40 @@ class IPloneAppContenttypesLayer(Interface):
 
 
 class ICollection(Interface):
-    """Explixiet marker interface for Collection
+    """Explicit marker interface for Collection
     """
 
 
 class IDocument(Interface):
-    """Explixit marker interface for Document
+    """Explicit marker interface for Document
     """
 
 
 class IFile(Interface):
-    """Explixit marker interface for File
+    """Explicit marker interface for File
     """
 
 
 class IFolder(Interface):
-    """Explixit marker interface for Folder
+    """Explicit marker interface for Folder
     """
 
 
 class IImage(Interface):
-    """Explixit marker interface for Image
+    """Explicit marker interface for Image
     """
 
 
 class ILink(Interface):
-    """Explixit marker interface for Link
+    """Explicit marker interface for Link
     """
 
 
 class INewsItem(Interface):
-    """Explixit marker interface for News Item
+    """Explicit marker interface for News Item
     """
 
 
 class IEvent(Interface):
-    """Explixit marker interface for Event
+    """Explicit marker interface for Event
     """
diff --git a/plone/app/contenttypes/migration/__init__.py b/plone/app/contenttypes/migration/__init__.py
index 311a3e7..1ed467b 100644
--- a/plone/app/contenttypes/migration/__init__.py
+++ b/plone/app/contenttypes/migration/__init__.py
@@ -1,3 +1,4 @@
+# -*- coding: utf-8 -*-
 import pytz
 
 
diff --git a/plone/app/contenttypes/migration/atct_migrator.pt b/plone/app/contenttypes/migration/atct_migrator.pt
index fabe764..9bb49e9 100644
--- a/plone/app/contenttypes/migration/atct_migrator.pt
+++ b/plone/app/contenttypes/migration/atct_migrator.pt
@@ -10,7 +10,6 @@
     tal:define="dummy python:request.set('disable_border', 1);
                 disable_column_two python:request.set('disable_plone.rightcolumn', 1);
                 disable_column_two python:request.set('disable_plone.leftcolumn', 1);
-                portal_state context/@@plone_portal_state;
                 portal_url portal_state/portal_url">
   <link rel="stylesheet" type="text/css" href="" media="screen" tal:attributes="href string:${portal_url}/++resource++pac_migrator.css">
 </metal:block>
@@ -26,8 +25,13 @@
 
 <metal:content-core fill-slot="content-core">
 <metal:block define-macro="content-core"
-    tal:define="linguaplone_installed context/@@atct_migrator_helpers/linguaplone_installed;
-                object_number context/@@atct_migrator_helpers/objects_to_be_migrated">
+             tal:define="helpers context/@@atct_migrator_helpers;
+                         linguaplone_installed helpers/linguaplone_installed;
+                         object_number helpers/objects_to_be_migrated;
+                         subtopics helpers/site_has_subtopics;
+                         collections_are_folderish helpers/collections_are_folderish;
+                         has_contentleadimage helpers/has_contentleadimage;
+                         installed_types helpers/installed_types;">
   <div class="important">
     <h2 i18n:translate="">Important</h2>
     <p i18n:translate="">Before migrating your content please read the <a href="https://github.com/plone/plone.app.contenttypes#migration">migration-section in the documentation of plone.app.contenttypes</a></p>
@@ -38,14 +42,14 @@
     If you need to keep the data in these fields you need to write a custom migration for your types and dexterity-behaviors for the data stored in the extended fields.</p>
     <h3 i18n:translate="">Note about how long it might take</h3>
     <p i18n:translate="">Depending of the number of archetypes in your portal, it may take a <span class="strong">really</span> long time for the migration to be done.
-      Stay calm and be patient.</p>
+    Stay calm, be patient and check your logs for progress-information.</p>
   </div>
   <tal:block condition="object_number">
     <tal:block condition="not:linguaplone_installed">
       <div class="important">
         <h2 i18n:translate="">Estimation</h2>
-        <p i18n:translate="">You currently have <span class="strong" i18n:name="number_of_objects" tal:content="context/@@atct_migrator_helpers/objects_to_be_migrated">23</span> archetypes objects to be migrated.</p>
-        <p i18n:translate="" tal:define="time context/@@atct_migrator_helpers/estimated_migration_time">The estimated time for the migration is around :
+        <p i18n:translate="">You currently have <span class="strong" i18n:name="number_of_objects" tal:content="helpers/objects_to_be_migrated">23</span> archetypes objects to be migrated.</p>
+        <p i18n:translate="" tal:define="time helpers/estimated_migration_time">The estimated time for the migration is around :
         <span class="strong">
           <tal:block i18n:name="hours" content="time/hours">4</tal:block> hours
           <tal:block i18n:name="minutes" content="time/minutes">45</tal:block> minutes
@@ -74,7 +78,40 @@
         <p i18n:translate="" class="strong">Since you effectively have Products.LinguaPlone installed in your portal, you're not allowed to continue this migration.</p>
         <p i18n:translate="">Have a look above for more information.</p>
       </div>
-      </tal:block>
+    </tal:block>
+    <tal:block condition="python: subtopics and not collections_are_folderish">
+      <div class="important">
+        <h2 i18n:translate="">Error</h2>
+        <p i18n:translate="">Your site has <span tal:replace="python: len(subtopics)" /> subtopic(s). Before migrating them you have to either remove all subtopics or create folderish Collections to be able to migrate them. Inheriting criteria to sub-collections is not supported by the default types. You can still migrate other content.</p>
+        <p><a i18n:translate="" href="https://pypi.python.org/pypi/plone.app.contenttypes#migration">See here for details.</a></p>
+        <p i18n:translate="">Your subtopics:</p>
+        <ul>
+          <li tal:repeat="subtopic subtopics"><a href="" target="_new" tal:attributes="href subtopic" tal:content="subtopic"></a></li>
+        </ul>
+      </div>
+    </tal:block>
+    <tal:block condition="python: subtopics and collections_are_folderish">
+      <div class="important">
+        <h2 i18n:translate="">Warning</h2>
+        <p i18n:translate="">Your site has <span tal:replace="python: len(subtopics)" /> subtopic(s). You can migrate them since you have folderish Collections but their functionality to inherit criteria will not work unless you.</p>
+      </div>
+    </tal:block>
+    <tal:block condition="python: has_contentleadimage"
+               tal:define="installed_with_behavior python:installed_types['installed_with_behavior'];
+                           installed_without_behavior python:installed_types['installed_without_behavior'];
+                           not_installed python:installed_types['not_installed']">
+      <div class="important">
+        <h2 i18n:translate="">Warning</h2>
+        <p i18n:translate="">
+          Your site seems to use the addon <a href="https://pypi.python.org/pypi/collective.contentleadimage/">collective.contentleadimage</a>.
+          This addons allows you to add images to any content in your site. These images will <strong>not</strong> be migrated unless you enable the behavior "Lead Image" on all those types where you want to migrate images added using collective.contentleadimage. Depending on the way you installed plone.app.contenttypes you might have to first install these types by (re-)installing plone.app.contenttypes. The old types that use leadimages are listed in the navigation-form with the comment <em>"extended fields: 'leadImage', 'leadImage_caption'"</em>
+        </p>
+        <p tal:condition="python:installed_with_behavior">These types are installed and have the image-behavior: <span tal:content="python:', '.join(installed_with_behavior)">Document, Image</span></p>
+        <p tal:condition="python:installed_without_behavior">These types are installed but do not have the behavior enabled: <span tal:content="python:', '.join(installed_without_behavior)">Link, File</span></p>
+        <p tal:condition="python:not_installed">These types are not installed yet: <span tal:content="python:', '.join(not_installed)">News Item, Folder</span></p>
+      </div>
+    </tal:block>
+
   </tal:block>
   <tal:block condition="not:object_number">
     <div class="important">
diff --git a/plone/app/contenttypes/migration/atct_migrator_results.pt b/plone/app/contenttypes/migration/atct_migrator_results.pt
index 74a7422..470dc3e 100644
--- a/plone/app/contenttypes/migration/atct_migrator_results.pt
+++ b/plone/app/contenttypes/migration/atct_migrator_results.pt
@@ -10,7 +10,6 @@
     tal:define="dummy python:request.set('disable_border', 1);
                 disable_column_two python:request.set('disable_plone.rightcolumn', 1);
                 disable_column_two python:request.set('disable_plone.leftcolumn', 1);
-                portal_state context/@@plone_portal_state;
                 portal_url portal_state/portal_url">
   <link rel="stylesheet" type="text/css" href="" media="screen" tal:attributes="href string:${portal_url}/++resource++pac_migrator.css">
 </metal:block>
diff --git a/plone/app/contenttypes/migration/browser.py b/plone/app/contenttypes/migration/browser.py
index 2e82fa9..f6cec0c 100644
--- a/plone/app/contenttypes/migration/browser.py
+++ b/plone/app/contenttypes/migration/browser.py
@@ -6,18 +6,29 @@
 from Products.CMFPlone import PloneMessageFactory as _
 from Products.Five.browser import BrowserView
 from Products.Five.browser.pagetemplatefile import ViewPageTemplateFile
+from Products.contentmigration.utils import patch, undoPatch
 from Products.statusmessages.interfaces import IStatusMessage
 from datetime import datetime
 from datetime import timedelta
+from plone.app.contenttypes.content import Document
+from plone.app.contenttypes.content import File
+from plone.app.contenttypes.content import Folder
+from plone.app.contenttypes.content import Image
+from plone.app.contenttypes.content import Link
+from plone.app.contenttypes.content import NewsItem
+from plone.app.contenttypes.migration import dxmigration
 from plone.app.contenttypes.migration import migration
-from plone.app.contenttypes.migration.utils import ATCT_LIST
+from plone.app.contenttypes.migration.patches import \
+    patched_insertForwardIndexEntry
 from plone.app.contenttypes.migration.utils import HAS_MULTILINGUAL
 from plone.app.contenttypes.migration.utils import installTypeIfNeeded
 from plone.app.contenttypes.migration.utils import isSchemaExtended
+from plone.app.contenttypes.migration.vocabularies import ATCT_LIST
 from plone.app.contenttypes.utils import DEFAULT_TYPES
 from plone.browserlayer.interfaces import ILocalBrowserLayerType
 from plone.dexterity.content import DexterityContent
 from plone.dexterity.interfaces import IDexterityContent
+from plone.dexterity.interfaces import IDexterityFTI
 from plone.z3cform.layout import wrap_form
 from pprint import pformat
 from z3c.form import button
@@ -29,20 +40,19 @@
 from zope.component import getMultiAdapter
 from zope.component import queryUtility
 from zope.interface import Interface
-import logging
+from Products.PluginIndexes.UUIDIndex.UUIDIndex import UUIDIndex
 
-logger = logging.getLogger(__name__)
+import logging
+import pkg_resources
 
-# Schema Extender allowed interfaces
+try:
+    pkg_resources.get_distribution('collective.contentleadimage')
+except pkg_resources.DistributionNotFound:
+    HAS_CONTENTLEADIMAGE = False
+else:
+    HAS_CONTENTLEADIMAGE = True
 
-from plone.app.contenttypes.content import (
-    Document,
-    File,
-    Folder,
-    Image,
-    Link,
-    NewsItem,
-)
+logger = logging.getLogger(__name__)
 
 PATCH_NOTIFY = [
     DexterityContent,
@@ -55,6 +65,11 @@
 ONE_OBJECT_MIGRATION_TIME = 500
 
 
+def pass_fn(*args, **kwargs):
+    """Empty function used for patching."""
+    pass
+
+
 class FixBaseClasses(BrowserView):
 
     def __call__(self):
@@ -107,6 +122,9 @@ def __call__(self,
                  from_form=False):
 
         portal = self.context
+        if content_types == 'all':
+            content_types = DEFAULT_TYPES
+
         if not from_form and migrate not in ['1', 'True', 'true', 1]:
             url1 = '{0}/@@migrate_from_atct?migrate=1'.format(
                 portal.absolute_url())
@@ -143,11 +161,17 @@ def __call__(self,
         # switch of setModificationDate on changes
         self.patchNotifyModified()
 
+        # patch UUIDIndex
+        patch(
+            UUIDIndex,
+            'insertForwardIndexEntry',
+            patched_insertForwardIndexEntry)
+
         not_migrated = []
         migrated_types = {}
 
         for (k, v) in ATCT_LIST.items():
-            if content_types != "all" and k not in content_types:
+            if k not in content_types:
                 not_migrated.append(k)
                 continue
             # test if the ct is extended beyond blobimage and blobfile
@@ -190,8 +214,10 @@ def __call__(self,
         # if there are blobnewsitems we just migrate them silently.
         migration.migrate_blobnewsitems(portal)
 
-        if migrate_references:
-            migration.restoreReferences(portal)
+        catalog.clearFindAndRebuild()
+
+        # rebuild catalog, restore references and cleanup
+        migration.restoreReferences(portal, migrate_references, content_types)
 
         # switch linkintegrity back to what it was before migrating
         site_props.manage_changeProperties(
@@ -201,6 +227,9 @@ def __call__(self,
         # switch on setModificationDate on changes
         self.resetNotifyModified()
 
+        # unpatch UUIDIndex
+        undoPatch(UUIDIndex, 'insertForwardIndexEntry')
+
         duration = str(timedelta(seconds=(datetime.now() - starttime).seconds))
         if not_migrated:
             msg = ("The following types were not migrated: \n %s"
@@ -230,6 +259,7 @@ def __call__(self,
                 'content_types': content_types,
                 'migrated_types': migrated_types,
             }
+            logger.info(msg)
             return stats
 
     def stats(self):
@@ -237,7 +267,7 @@ def stats(self):
         query = {}
         catalog = self.context.portal_catalog
         if HAS_MULTILINGUAL and 'Language' in catalog.indexes():
-            query['Language'] ='all'
+            query['Language'] = 'all'
         for brain in catalog(query):
             classname = brain.getObject().__class__.__name__
             results[classname] = results.get(classname, 0) + 1
@@ -251,21 +281,13 @@ def patchNotifyModified(self):
         So when we migrate Documents before Folders the folders
         ModifiedDate gets changed.
         """
-        patch = lambda *args: None
         for klass in PATCH_NOTIFY:
-            old_notifyModified = getattr(klass, 'notifyModified', None)
-            klass.notifyModified = patch
-            klass.old_notifyModified = old_notifyModified
+            patch(klass, 'notifyModified', pass_fn)
 
     def resetNotifyModified(self):
         """reset notifyModified to old state"""
-
         for klass in PATCH_NOTIFY:
-            if klass.old_notifyModified is None:
-                del klass.notifyModified
-            else:
-                klass.notifyModified = klass.old_notifyModified
-            del klass.old_notifyModified
+            undoPatch(klass, 'notifyModified')
 
 
 class IATCTMigratorForm(Interface):
@@ -282,10 +304,7 @@ class IATCTMigratorForm(Interface):
     migrate_references = schema.Bool(
         title=u"Migrate references?",
         description=(
-            u"Select this option to migrate all "
-            u"references to each content type. "
-            u"This will rebuild the whole catalog and "
-            u"increase the migration-time."
+            u"Select this option to migrate references."
         ),
         default=True
     )
@@ -362,6 +381,76 @@ def updateWidgets(self):
 )
 
 
+class IBaseClassMigratorForm(Interface):
+
+    changed_base_classes = schema.List(
+        title=u'Changed base classes',
+        description=u'Select changed base classes you want to migrate',
+        value_type=schema.Choice(
+            vocabulary='plone.app.contenttypes.migration.changed_base_classes',
+        ),
+        required=True,
+    )
+    migrate_to_folderish = schema.Bool(
+        title=u"Migrate to folderish type?",
+        description=(
+            u"Select this option if you changed a type from being "
+            u"itemish to being folderish but the class of the type is still "
+            u"the same."
+        ),
+        default=False,
+    )
+
+
+class BaseClassMigratorForm(form.Form):
+
+    fields = field.Fields(IBaseClassMigratorForm)
+    fields['changed_base_classes'].widgetFactory = CheckBoxFieldWidget
+    ignoreContext = True
+    enableCSRFProtection = True
+
+    @button.buttonAndHandler(u'Update', name='update')
+    def handle_migrate(self, action):
+        data, errors = self.extractData()
+
+        if errors:
+            return
+
+        changed_base_classes = data.get('changed_base_classes', [])
+        if not changed_base_classes:
+            return
+
+        migrate_to_folderish = data.get('changed_base_classes', False)
+        catalog = getToolByName(self.context, "portal_catalog")
+        migrated = []
+        not_migrated = []
+        for brain in catalog():
+            obj = brain.getObject()
+            old_class_name = dxmigration.get_old_class_name_string(obj)
+            if old_class_name in changed_base_classes:
+                if dxmigration.migrate_base_class_to_new_class(
+                        obj, migrate_to_folderish=migrate_to_folderish):
+                    migrated.append(obj)
+                else:
+                    not_migrated.append(obj)
+
+        messages = IStatusMessage(self.request)
+        info_message_template = 'There are {0} objects migrated.'
+        warn_message_template = 'There are not {0} objects migrated.'
+        if migrated:
+            msg = info_message_template.format(len(migrated))
+            messages.addStatusMessage(msg, type='info')
+        if not_migrated:
+            msg = warn_message_template.format(len(not_migrated))
+            messages.addStatusMessage(msg, type='warn')
+        self.request.response.redirect(self.request['ACTUAL_URL'])
+
+
+BaseClassMigrator = wrap_form(
+    BaseClassMigratorForm,
+)
+
+
 class ATCTMigratorHelpers(BrowserView):
 
     def objects_to_be_migrated(self):
@@ -391,6 +480,91 @@ def linguaplone_installed(self):
         existing = queryUtility(ILocalBrowserLayerType, name='LinguaPlone')
         return bool(existing)
 
+    def site_has_subtopics(self):
+        """Check if there are subtopics. Since Collections are itemish by
+        default the migration of subtopics would fail Collections are changed
+        to be folderish.
+        """
+        catalog = getToolByName(self.context, "portal_catalog")
+        query = {'meta_type': 'ATTopic'}
+        results = []
+        if HAS_MULTILINGUAL and 'Language' in catalog.indexes():
+            query['Language'] = 'all'
+        brains = catalog(query)
+        for brain in brains:
+            for item in catalog(path={'query': brain.getPath(), 'depth': 1}):
+                results.append(item.getURL())
+        if results:
+            results = set(results)
+            paths = "\n".join(results)
+            logger.info("Found {0} subtopics at: \n{1}".format(
+                len(results), paths))
+            return results
+
+    def collections_are_folderish(self):
+        """Since Collections are itemish by default the migration would fail
+        if there are any subtopics. As a workaround we allow to migrate to
+        custom folderish Collections. The custom Collections have to fulfill
+        the following criteria:
+        1. The id if the type has to be Collection (not collection). You can
+           change a type's id in portal_types
+        2. The type has to have the collection-behavior.
+
+        This much can even be done ttw. For the views of collections
+        to work the base-class of the Collections also has to implement the
+        interface `plone.app.contenttypes.interfaces.ICollection`.
+
+        This is what such a class would look like:
+
+            from plone.app.contenttypes.behaviors.collection import ICollection
+            from plone.dexterity.content import Container
+            from zope.interface import implementer
+
+            @implementer(ICollection)
+            class FolderishCollection(Container):
+                pass
+
+        You can either use a completely new fti or overwrite the default fti
+        like this:
+
+            <?xml version="1.0"?>
+            <object name="Collection" meta_type="Dexterity FTI">
+             <property name="klass">my.package.content.FolderishCollection
+             </property>
+            </object>
+
+        """
+        fti = queryUtility(IDexterityFTI, name="Collection")
+        if fti and fti.content_meta_type == "Dexterity Container":
+            return True
+        # test for lowercase ttw-type
+        fti = queryUtility(IDexterityFTI, name="collection")
+        behavior = 'plone.app.contenttypes.behaviors.collection.ICollection'
+        if fti and behavior in fti.behaviors:
+            logger.warn("You are trying to migrate topic to collection. "
+                        "Instead you need a type 'Collection'.")
+
+    def has_contentleadimage(self):
+        return HAS_CONTENTLEADIMAGE
+
+    def installed_types(self):
+        """Which types are already Dexterity and which are not."""
+        results = {}
+        results['installed_with_behavior'] = []
+        results['installed_without_behavior'] = []
+        results['not_installed'] = []
+        behavior = 'plone.app.contenttypes.behaviors.leadimage.ILeadImage'
+        for type_name in DEFAULT_TYPES:
+            fti = queryUtility(IDexterityFTI, name=type_name)
+            if fti:
+                if behavior in fti.behaviors:
+                    results['installed_with_behavior'].append(type_name)
+                else:
+                    results['installed_without_behavior'].append(type_name)
+            else:
+                results['not_installed'].append(type_name)
+        return results
+
 
 class ATCTMigratorResults(BrowserView):
 
diff --git a/plone/app/contenttypes/migration/configure.zcml b/plone/app/contenttypes/migration/configure.zcml
index f3df083..78288f8 100644
--- a/plone/app/contenttypes/migration/configure.zcml
+++ b/plone/app/contenttypes/migration/configure.zcml
@@ -36,6 +36,14 @@
     />
 
   <browser:page
+    name="base_class_migrator_form"
+    for="Products.CMFPlone.interfaces.IPloneSiteRoot"
+    class=".browser.BaseClassMigrator"
+    layer="plone.app.contenttypes.interfaces.IPloneAppContenttypesLayer"
+    permission="cmf.ManagePortal"
+    />
+
+  <browser:page
     name="atct_migrator_helpers"
     for="Products.CMFPlone.interfaces.IPloneSiteRoot"
     class=".browser.ATCTMigratorHelpers"
@@ -95,6 +103,11 @@
       name="plone.app.contenttypes.migration.extendedtypes"
       provides="zope.schema.interfaces.IVocabularyFactory" />
 
+  <utility
+      factory=".vocabularies.ChangedBaseClasses"
+      name="plone.app.contenttypes.migration.changed_base_classes"
+      provides="zope.schema.interfaces.IVocabularyFactory" />
+
   <adapter name="nullmigrator" factory=".migration.BaseCustomMigator"/>
 
 </configure>
diff --git a/plone/app/contenttypes/migration/dxmigration.py b/plone/app/contenttypes/migration/dxmigration.py
index b5ce49a..4af24e4 100644
--- a/plone/app/contenttypes/migration/dxmigration.py
+++ b/plone/app/contenttypes/migration/dxmigration.py
@@ -1,11 +1,23 @@
 # -*- coding: utf-8 -*-
+from Products.BTreeFolder2.BTreeFolder2 import BTreeFolder2Base
+from Products.CMFCore.utils import getToolByName
 from Products.contentmigration.basemigrator.migrator import CMFItemMigrator
 from Products.contentmigration.basemigrator.walker import CatalogWalker
 from plone.app.contenttypes.interfaces import IEvent
 from plone.app.contenttypes.migration import datetime_fixer
+from plone.app.contenttypes.migration.utils import HAS_MULTILINGUAL
+from plone.dexterity.interfaces import IDexterityContent
+from plone.dexterity.interfaces import IDexterityFTI
 from plone.event.utils import default_timezone
+from zExceptions import NotFound
 from zope.annotation.interfaces import IAnnotations
 from zope.component.hooks import getSite
+from zope.component import queryUtility
+
+import importlib
+import logging
+
+logger = logging.getLogger(__name__)
 
 
 def migrate(portal, migrator):
@@ -100,3 +112,86 @@ def migrate_schema_fields(self):
         old_text = annotations.get(
             'plone.app.event.dx.behaviors.IEventSummary.text', None)
         self.new.text = old_text
+
+
+def get_old_class_name_string(obj):
+    """Returns the current class name string."""
+    return '{0}.{1}'.format(obj.__module__, obj.__class__.__name__)
+
+
+def get_portal_type_name_string(obj):
+    """Returns the klass-attribute of the fti."""
+    fti = queryUtility(IDexterityFTI, name=obj.portal_type)
+    if not fti:
+        return False
+    return fti.klass
+
+
+def migrate_base_class_to_new_class(obj,
+                                    indexes=[
+                                        'is_folderish',
+                                        'object_provides',
+                                    ],
+                                    old_class_name='',
+                                    new_class_name='',
+                                    migrate_to_folderish=False,
+                                    ):
+    if not old_class_name:
+        old_class_name = get_old_class_name_string(obj)
+    if not new_class_name:
+        new_class_name = get_portal_type_name_string(obj)
+        if not new_class_name:
+            logger.warning(
+                'The type {0} has no fti!'.format(obj.portal_type))
+            return False
+
+    was_item = not isinstance(obj, BTreeFolder2Base)
+    if old_class_name != new_class_name:
+        obj_id = obj.getId()
+        module_name, class_name = new_class_name.rsplit('.', 1)
+        module = importlib.import_module(module_name)
+        new_class = getattr(module, class_name)
+
+        # update obj class
+        parent = obj.__parent__
+        parent._delOb(obj_id)
+        obj.__class__ = new_class
+        parent._setOb(obj_id, obj)
+
+    is_container = isinstance(obj, BTreeFolder2Base)
+
+    if was_item and is_container or migrate_to_folderish and is_container:
+        #  If Itemish becomes Folderish we have to update obj _tree
+        BTreeFolder2Base._initBTrees(obj)
+
+    # reindex
+    obj.reindexObject(indexes)
+
+    return True
+
+
+def list_of_objects_with_changed_base_class(context):
+    catalog = getToolByName(context, "portal_catalog")
+    query = {'object_provides': IDexterityContent.__identifier__}
+    if HAS_MULTILINGUAL and 'Language' in catalog.indexes():
+        query['Language'] = 'all'
+    for brain in catalog(query):
+        try:
+            obj = brain.getObject()
+        except NotFound:
+            logger.warn("Object {0} not found".format(brain.getPath()))
+            continue
+        if get_portal_type_name_string(obj) != get_old_class_name_string(obj):
+            yield obj
+
+
+def list_of_changed_base_class_names(context):
+    """Returns list of class names that are not longer in portal_types."""
+    changed_base_class_names = {}
+    for obj in list_of_objects_with_changed_base_class(context):
+        changed_base_class_name = get_old_class_name_string(obj)
+        if changed_base_class_name not in changed_base_class_names:
+            changed_base_class_names[changed_base_class_name] = 1
+        else:
+            changed_base_class_names[changed_base_class_name] += 1
+    return changed_base_class_names
diff --git a/plone/app/contenttypes/migration/migration.py b/plone/app/contenttypes/migration/migration.py
index a4d7ac5..9f19d85 100644
--- a/plone/app/contenttypes/migration/migration.py
+++ b/plone/app/contenttypes/migration/migration.py
@@ -7,37 +7,48 @@
 module will only work if Products.contentmigration is installed so make sure
 you catch ImportErrors
 '''
+from Products.ATContentTypes.interfaces.interfaces import IATContentType
+from Products.Archetypes.config import REFERENCE_CATALOG
+from Products.CMFCore.utils import getToolByName
+from Products.CMFPlone.utils import safe_unicode
+from Products.CMFPlone.utils import safe_hasattr
+from Products.contentmigration.basemigrator.migrator import CMFFolderMigrator
+from Products.contentmigration.basemigrator.migrator import CMFItemMigrator
+from Products.contentmigration.basemigrator.walker import CatalogWalker
+from Products.contentmigration.walker import CustomQueryWalker
+from copy import deepcopy
 from persistent.list import PersistentList
 from plone.app.contenttypes.behaviors.collection import ICollection
 from plone.app.contenttypes.migration import datetime_fixer
 from plone.app.contenttypes.migration.dxmigration import DXEventMigrator
 from plone.app.contenttypes.migration.dxmigration import DXOldEventMigrator
+from plone.app.contenttypes.migration.utils import add_portlet
+from plone.app.contenttypes.migration.utils import copy_contentrules
+from plone.app.contenttypes.migration.utils import migrate_leadimage
+from plone.app.contenttypes.migration.utils import move_comments
+from plone.app.contenttypes.utils import DEFAULT_TYPES
 from plone.app.textfield.value import RichTextValue
 from plone.app.uuid.utils import uuidToObject
 from plone.dexterity.interfaces import IDexterityContent
 from plone.event.utils import default_timezone
 from plone.namedfile.file import NamedBlobFile
 from plone.namedfile.file import NamedBlobImage
-from Products.Archetypes.config import REFERENCE_CATALOG
-from Products.ATContentTypes.interfaces.interfaces import IATContentType
-from Products.CMFCore.utils import getToolByName
-from Products.CMFPlone.utils import safe_unicode, safe_hasattr
-from Products.contentmigration.basemigrator.migrator import CMFFolderMigrator
-from Products.contentmigration.basemigrator.migrator import CMFItemMigrator
-from Products.contentmigration.basemigrator.walker import CatalogWalker
-from Products.contentmigration.walker import CustomQueryWalker
-import transaction
+from plone.portlets.constants import CONTEXT_BLACKLIST_STATUS_KEY
+from plone.portlets.interfaces import IPortletAssignmentMapping
+from plone.portlets.interfaces import IPortletManager
 from z3c.relationfield import RelationValue
+from zope.annotation.interfaces import IAnnotations
 from zope.component import adapter
 from zope.component import getAdapters
 from zope.component import getMultiAdapter
+from zope.component import getSiteManager
 from zope.component import getUtility
 from zope.component.hooks import getSite
-from zope.interface import implementer
 from zope.interface import Interface
+from zope.interface import implementer
 from zope.intid.interfaces import IIntIds
 import logging
-
+import transaction
 logger = logging.getLogger(__name__)
 
 
@@ -128,7 +139,7 @@ def migrate_filefield(src_obj, dst_obj, src_fieldname, dst_fieldname):
     if safe_hasattr(old_file_data, 'data'):
         old_file_data = old_file_data.data
     namedblobfile = NamedBlobFile(data=old_file_data,
-                                    filename=filename)
+                                  filename=filename)
     setattr(dst_obj, dst_fieldname, namedblobfile)
     logger.info("Migrating file %s" % filename)
 
@@ -151,34 +162,66 @@ def migrate(portal, migrator):
     return walker
 
 
-def refs(obj):
-    intids = getUtility(IIntIds)
-    out = ''
+def migrate_portlets(src_obj, dst_obj):
+    """Copy portlets for all available portletmanagers from one object
+    to another.
+    Also takes blocked portlet settings into account, keeps hidden portlets
+    hidden and skips broken assignments.
+    """
 
+    # also take custom portlet managers into account
+    managers = [reg.name for reg in getSiteManager().registeredUtilities()
+                if reg.provided == IPortletManager]
+    # faster, but no custom managers
+    # managers = [u'plone.leftcolumn', u'plone.rightcolumn']
+
+    # copy information which categories are hidden for which manager
+    blacklist_status = IAnnotations(src_obj).get(
+        CONTEXT_BLACKLIST_STATUS_KEY, None)
+    if blacklist_status is not None:
+        IAnnotations(dst_obj)[CONTEXT_BLACKLIST_STATUS_KEY] = \
+            deepcopy(blacklist_status)
+
+    # copy all portlet assignments (visibilty is stored as annotation
+    # on the assignments and gets copied here too)
+    for manager in managers:
+        column = getUtility(IPortletManager, manager)
+        mappings = getMultiAdapter((src_obj, column),
+                                   IPortletAssignmentMapping)
+        for key, assignment in mappings.items():
+            # skip possibly broken portlets here
+            if not hasattr(assignment, '__Broken_state__'):
+                add_portlet(dst_obj, assignment, key, manager)
+            else:
+                logger.warn(u'skipping broken portlet assignment {0} '
+                            'for manager {1}'.format(key, manager))
+
+
+def restore_refs(obj):
+    """Restore references stored in the attribute _relatedItems.
+    """
+    intids = getUtility(IIntIds)
     try:
         if not getattr(obj, 'relatedItems', None):
             obj.relatedItems = PersistentList()
 
-        elif type(obj.relatedItems) != type(PersistentList()):
+        elif not isinstance(obj.relatedItems, PersistentList):
             obj.relatedItems = PersistentList(obj.relatedItems)
 
         for uuid in obj._relatedItems:
             to_obj = uuidToObject(uuid)
             to_id = intids.getId(to_obj)
             obj.relatedItems.append(RelationValue(to_id))
-            out += str('Restore Relation from %s to %s \n' % (obj, to_obj))
-        del obj._relatedItems
-
+            logger.info('Restored Relation from %s to %s' % (obj, to_obj))
     except AttributeError:
         pass
-    return out
 
 
-def backrefs(portal, obj):
+def restore_backrefs(portal, obj):
+    """Restore backreferences stored in the attribute _backrefs.
+    """
     intids = getUtility(IIntIds)
     uid_catalog = getToolByName(portal, 'uid_catalog')
-    out = ''
-
     try:
         backrefobjs = [uuidToObject(uuid) for uuid in obj._backrefs]
         for backrefobj in backrefobjs:
@@ -187,7 +230,7 @@ def backrefs(portal, obj):
                 relitems = getattr(backrefobj, 'relatedItems', None)
                 if not relitems:
                     backrefobj.relatedItems = PersistentList()
-                elif type(relitems) != type(PersistentList()):
+                elif not isinstance(obj.relatedItems, PersistentList):
                     backrefobj.relatedItems = PersistentList(
                         obj.relatedItems
                     )
@@ -200,53 +243,51 @@ def backrefs(portal, obj):
                 path = '/'.join(obj.getPhysicalPath())
                 uid_catalog.catalog_object(obj, path)
                 backrefobj.setRelatedItems(obj)
-            out += str(
-                'Restore BackRelation from %s to %s \n' % (
-                    backrefobj,
-                    obj
-                )
-            )
-        del obj._backrefs
+            logger.info(
+                'Restored BackRelation from %s to %s' % (backrefobj, obj))
     except AttributeError:
         pass
-    return out
 
 
-def order(obj):
-    out = ''
+def restore_reforder(obj):
+    """Restore order of references stored in the attribute _relatedItemsOrder.
+    """
     if not hasattr(obj, '_relatedItemsOrder'):
         # Nothing to do
-        return out
-
+        return
     relatedItemsOrder = obj._relatedItemsOrder
     uid_position_map = dict([(y, x) for x, y in enumerate(relatedItemsOrder)])
     key = lambda rel: uid_position_map.get(rel.to_object.UID(), 0)
     obj.relatedItems = sorted(obj.relatedItems, key=key)
-    out += str('%s ordered.' % obj)
-    del obj._relatedItemsOrder
-    return out
 
 
-def restoreReferences(portal):
-    """ iterate over all Dexterity Objs and restore as Dexterity Reference. """
-    out = ''
+def cleanup_stored_refs(obj):
+    """Cleanup new dx item."""
+    if safe_hasattr(obj, '_relatedItems'):
+        del obj._relatedItems
+    if safe_hasattr(obj, '_backrefs'):
+        del obj._backrefs
+    if safe_hasattr(obj, '_relatedItemsOrder'):
+        del obj._relatedItemsOrder
+
+
+def restoreReferences(portal,
+                      migrate_references=True,
+                      content_types=DEFAULT_TYPES):
+    """Iterate over new Dexterity items and restore Dexterity References.
+    """
     catalog = getToolByName(portal, "portal_catalog")
-    # Seems that these newly created objs are not reindexed
-    catalog.clearFindAndRebuild()
     results = catalog.searchResults(
-        object_provides=IDexterityContent.__identifier__)
+        object_provides=IDexterityContent.__identifier__,
+        portal_type=content_types)
 
     for brain in results:
         obj = brain.getObject()
-
-        # refs
-        out += refs(obj)
-        # backrefs
-        out += backrefs(portal, obj)
-        # order
-        out += order(obj)
-
-    return out
+        if migrate_references:
+            restore_refs(obj)
+            restore_backrefs(portal, obj)
+            restore_reforder(obj)
+        cleanup_stored_refs(obj)
 
 
 class ReferenceMigrator(object):
@@ -333,9 +374,15 @@ class ATCTContentMigrator(CMFItemMigrator, ReferenceMigrator):
     def __init__(self, *args, **kwargs):
         super(ATCTContentMigrator, self).__init__(*args, **kwargs)
         logger.info(
-            "Migrating object %s" %
-            '/'.join(self.old.getPhysicalPath())
-        )
+            "Migrating {0}".format(
+                '/'.join(self.old.getPhysicalPath())))
+
+    def beforeChange_store_comments_on_portal(self):
+        """Comments from plone.app.discussion are lost when the
+           old object is renamed...
+           We save the comments in a safe place..."""
+        portal = getToolByName(self.old, 'portal_url').getPortalObject()
+        move_comments(self.old, portal)
 
     def migrate_atctmetadata(self):
         field = self.old.getField('excludeFromNav')
@@ -344,9 +391,25 @@ def migrate_atctmetadata(self):
     def migrate_custom(self):
         """Get all ICustomMigrator registered migrators and run the migration.
         """
-        for _, migrator in getAdapters((self.old, ), ICustomMigrator):
+        for _, migrator in getAdapters((self.old,), ICustomMigrator):
             migrator.migrate(self.old, self.new)
 
+    def migrate_portlets(self):
+        migrate_portlets(self.old, self.new)
+
+    def migrate_contentrules(self):
+        copy_contentrules(self.old, self.new)
+
+    def migrate_leadimage(self):
+        migrate_leadimage(self.old, self.new)
+
+    def last_migrate_comments(self):
+        """Migrate the plone.app.discussion comments.
+           Comments were stored on the portal, get them and
+           Copy the conversations from old to new object."""
+        portal = getToolByName(self.old, 'portal_url').getPortalObject()
+        move_comments(portal, self.new)
+
 
 class ATCTFolderMigrator(CMFFolderMigrator, ReferenceMigrator):
     """Base for folderish ATCT
@@ -355,9 +418,14 @@ class ATCTFolderMigrator(CMFFolderMigrator, ReferenceMigrator):
     def __init__(self, *args, **kwargs):
         super(ATCTFolderMigrator, self).__init__(*args, **kwargs)
         logger.info(
-            "Migrating object %s" %
-            '/'.join(self.old.getPhysicalPath())
-        )
+            "Migrating {}".format('/'.join(self.old.getPhysicalPath())))
+
+    def beforeChange_store_comments_on_portal(self):
+        """Comments from plone.app.discussion are lost when the
+           old object is renamed...
+           We save the comments in a safe place..."""
+        portal = getToolByName(self.old, 'portal_url').getPortalObject()
+        move_comments(self.old, portal)
 
     def migrate_atctmetadata(self):
         field = self.old.getField('excludeFromNav')
@@ -366,9 +434,25 @@ def migrate_atctmetadata(self):
     def migrate_custom(self):
         """Get all ICustomMigrator registered migrators and run the migration.
         """
-        for _, migrator in getAdapters((self.old, ), ICustomMigrator):
+        for _, migrator in getAdapters((self.old,), ICustomMigrator):
             migrator.migrate(self.old, self.new)
 
+    def migrate_portlets(self):
+        migrate_portlets(self.old, self.new)
+
+    def migrate_contentrules(self):
+        copy_contentrules(self.old, self.new)
+
+    def migrate_leadimage(self):
+        migrate_leadimage(self.old, self.new)
+
+    def last_migrate_comments(self):
+        """Migrate the plone.app.discussion comments.
+           Comments were stored on the portal, get them and
+           Copy the conversations from old to new object."""
+        portal = getToolByName(self.old, 'portal_url').getPortalObject()
+        move_comments(portal, self.new)
+
 
 class DocumentMigrator(ATCTContentMigrator):
 
@@ -527,7 +611,7 @@ class FolderMigrator(ATCTFolderMigrator):
 
     def beforeChange_migrate_layout(self):
         if self.old.getLayout() == 'atct_album_view':
-            self.old.setLayout('folder_album_view')
+            self.old.setLayout('album_view')
 
 
 def migrate_folders(portal):
@@ -630,7 +714,14 @@ def migrate_events(portal):
     migrate(portal, DXEventMigrator)
 
 
-def makeCustomATMigrator(context, src_type, dst_type, fields_mapping, is_folderish=False, dry_run=False):
+def makeCustomATMigrator(
+    context,
+    src_type,
+    dst_type,
+    fields_mapping,
+    is_folderish=False,
+    dry_run=False
+):
     """ generate a migrator for the given at-based folderish portal type """
 
     base_class = ATCTContentMigrator
@@ -662,7 +753,8 @@ def last_migrate_check(self):
             if there is an error with the fields, an exception will be raised.
             """
             if self.dry_run_mode:
-                view = getMultiAdapter((self.new, self.new.REQUEST), name="view")
+                view = getMultiAdapter(
+                    (self.new, self.new.REQUEST), name="view")
                 view()
 
     return CustomATMigrator
@@ -670,8 +762,9 @@ def last_migrate_check(self):
 
 def migrateCustomAT(fields_mapping, src_type, dst_type, dry_run=False):
     """
-    Try to get types infos from archetype_tool, then set a migrator an pass it given values.
-    There is a dry_run mode that allows to check the success of a migration without committing.
+    Try to get types infos from archetype_tool, then set a migrator an pass it
+    given values. There is a dry_run mode that allows to check the success of
+    a migration without committing.
     """
     portal = getSite()
     archetype_tool = getToolByName(portal, 'archetype_tool', None)
diff --git a/plone/app/contenttypes/migration/patches.py b/plone/app/contenttypes/migration/patches.py
new file mode 100644
index 0000000..3c1ab0c
--- /dev/null
+++ b/plone/app/contenttypes/migration/patches.py
@@ -0,0 +1,23 @@
+# -*- coding: utf-8 -*-
+"""Patches used for migrations. These patches are applied before and removed
+after running the migration.
+"""
+from Products.PluginIndexes.common.UnIndex import _marker
+
+
+# Prevent UUID Error-Messages when migrating folders.
+# Products.PluginIndexes.UUIDIndex.UUIDIndex.UUIDIndex.insertForwardIndexEntry
+def patched_insertForwardIndexEntry(self, entry, documentId):
+    """Take the entry provided and put it in the correct place
+    in the forward index.
+    """
+    if entry is None:
+        return
+
+    old_docid = self._index.get(entry, _marker)
+    if old_docid is _marker:
+        self._index[entry] = documentId
+        self._length.change(1)
+    # elif old_docid != documentId:
+    #     logger.error("A different document with value '%s' already "
+    #         "exists in the index.'" % entry)
diff --git a/plone/app/contenttypes/migration/topics.py b/plone/app/contenttypes/migration/topics.py
new file mode 100644
index 0000000..575fe5f
--- /dev/null
+++ b/plone/app/contenttypes/migration/topics.py
@@ -0,0 +1,695 @@
+# -*- coding: utf-8 -*-
+""" Migrate Topic to DX-Collectons.
+
+Note on Subtopics:
+When a migration of Subtopics is needed, you can replace the default itemish
+Collection with a folderish Collection by creating a new type folderish
+type 'Collection' with the collection-behavior enabled. You can then use
+the default migration to migrate Topics with Subtopics.
+"""
+
+from DateTime import DateTime
+from Products.CMFCore.utils import getToolByName
+from Products.contentmigration.inplace import InplaceCMFFolderMigrator
+from Products.contentmigration.inplace import InplaceCMFItemMigrator
+from Products.contentmigration.walker import CustomQueryWalker
+from plone.app.contenttypes.behaviors.collection import ICollection
+from plone.app.contenttypes.migration.migration import ReferenceMigrator
+from plone.app.querystring.interfaces import IQuerystringRegistryReader
+from plone.registry.interfaces import IRegistry
+from plone.uuid.interfaces import IMutableUUID
+from zope.component import getUtility
+from zope.component import queryAdapter
+from zope.dottedname.resolve import resolve
+
+import logging
+
+logger = logging.getLogger(__name__)
+prefix = "plone.app.querystring"
+
+INVALID_OPERATION = 'Invalid operation %s for criterion: %s'
+
+
+# Converters
+class CriterionConverter(object):
+
+    # Last part of the code for the dotted operation method,
+    # e.g. 'string.contains'.
+    operator_code = ''
+    # alternative code, possibly used if the first code does not work.
+    alt_operator_code = ''
+
+    def get_query_value(self, value, index, criterion):
+        # value may contain a query and some parameters, but in the
+        # simple case it is simply a value.
+        return value
+
+    def get_operation(self, value, index, criterion):
+        # Get dotted operation method.  This may depend on value.
+        return "%s.operation.%s" % (prefix, self.operator_code)
+
+    def get_alt_operation(self, value, index, criterion):
+        # Get dotted operation method.  This may depend on value.
+        return "%s.operation.%s" % (prefix, self.alt_operator_code)
+
+    def is_index_known(self, registry, index):
+        # Is the index registered as criterion index?
+        key = '%s.field.%s' % (prefix, index)
+        try:
+            registry.get(key)
+        except KeyError:
+            logger.error("Index %s is no criterion index. Registry gives "
+                         "KeyError: %s", index, key)
+            return False
+        return True
+
+    def is_index_enabled(self, registry, index):
+        # Is the index enabled as criterion index?
+        key = '%s.field.%s' % (prefix, index)
+        index_data = registry.get(key)
+        if index_data.get('enabled'):
+            return True
+        logger.warn("Index %s is not enabled as criterion index. ", index)
+        return False
+
+    def switch_type_to_portal_type(self, value, criterion):
+        # 'portal_type' is the object id of the FTI in portal_types.
+        # 'Type' is the title of that object.
+        # For example:
+        # - portal_type 'Document' has Type 'Page'.
+        # - portal_type 'Topic' has Type 'Collection (old)'.
+        if isinstance(value, dict):
+            values = value.get('query', [])
+        else:
+            values = value
+        if not values:
+            return value
+        new_values = []
+        ttool = getToolByName(criterion, 'portal_types')
+        type_to_portal_type = {}
+        portal_types = ttool.objectIds()
+        for portal_type, Type in ttool.listTypeTitles().items():
+            type_to_portal_type[Type] = portal_type
+        for Type in values:
+            portal_type = type_to_portal_type.get(Type)
+            if not portal_type:
+                if Type in portal_types:
+                    portal_type = Type
+                else:
+                    logger.warn("Cannot switch Type %r to portal_type.", Type)
+                    continue
+            new_values.append(portal_type)
+        if isinstance(value, dict):
+            value['query'] = new_values
+        else:
+            value = new_values
+        return value
+
+    def is_operation_valid(self, registry, operation):
+        # Check that the operation exists.
+        op_info = registry.get(operation)
+        if op_info is None:
+            logger.error("Operation %r is not defined.", operation)
+            return False
+        op_function_name = op_info.get('operation')
+        try:
+            resolve(op_function_name)
+        except ImportError:
+            logger.error("ImportError for operation %r: %s",
+                         operation, op_function_name)
+            return False
+        return True
+
+    def get_valid_operation(self, registry, index, value, criterion):
+        key = '%s.field.%s.operations' % (prefix, index)
+        operations = registry.get(key)
+        operation = self.get_operation(value, index, criterion)
+        if operation not in operations:
+            operation = self.get_alt_operation(value, index, criterion)
+            if operation not in operations:
+                return
+        if self.is_operation_valid(registry, operation):
+            return operation
+
+    def add_to_formquery(self, formquery, index, operation, query_value):
+        row = {'i': index,
+               'o': operation}
+        if query_value is not None:
+            row['v'] = query_value
+        formquery.append(row)
+
+    def __call__(self, formquery, criterion, registry):
+        criteria = criterion.getCriteriaItems()
+        if not criteria:
+            logger.warn("Ignoring empty criterion %s.", criterion)
+            return
+        for index, value in criteria:
+            # Check if the index is known and enabled as criterion index.
+            if index == 'Type':
+                # Try to replace Type by portal_type
+                index = 'portal_type'
+                value = self.switch_type_to_portal_type(value, criterion)
+            if not self.is_index_known(registry, index):
+                logger.info("Index %s not known in registry.", index)
+                continue
+            self.is_index_enabled(registry, index)
+            # TODO: what do we do when this is False?  Raise an
+            # Exception?  Continue processing the index and value
+            # anyway, now that a warning is logged?  Continue with the
+            # next criteria item?
+
+            # Get the operation method.
+            operation = self.get_valid_operation(
+                registry,
+                index,
+                value,
+                criterion
+            )
+            if not operation:
+                logger.error(INVALID_OPERATION % (operation, criterion))
+                # TODO: raise an Exception?
+                continue
+
+            # Get the value that we will query for.
+            query_value = self.get_query_value(value, index, criterion)
+
+            # Add a row to the form query.
+            self.add_to_formquery(formquery, index, operation, query_value)
+
+
+class ATDateCriteriaConverter(CriterionConverter):
+    """Handle date criteria.
+
+    Note that there is also ATDateRangeCriterion, which is much
+    simpler as it just has two dates.
+
+    In our case we have these valid operations:
+
+    ['plone.app.querystring.operation.date.lessThan',
+     'plone.app.querystring.operation.date.largerThan',
+     'plone.app.querystring.operation.date.between',
+     'plone.app.querystring.operation.date.lessThanRelativeDate',
+     'plone.app.querystring.operation.date.largerThanRelativeDate',
+     'plone.app.querystring.operation.date.today',
+     'plone.app.querystring.operation.date.beforeToday',
+     'plone.app.querystring.operation.date.afterToday']
+
+    This code is based on the getCriteriaItems method from
+    Products/ATContentTypes/criteria/date.py.  We check the field
+    values ourselves instead of translating the values back and forth.
+    """
+
+    def __call__(self, formquery, criterion, registry):  # noqa
+        if criterion.value is None:
+            logger.warn("Ignoring empty criterion %s.", criterion)
+            return
+        field = criterion.Field()
+        value = criterion.Value()
+
+        # Check if the index is known and enabled as criterion index.
+        if not self.is_index_known(registry, field):
+            return
+        self.is_index_enabled(registry, field)
+
+        # Negate the value for 'old' days
+        if criterion.getDateRange() == '-':
+            value = -value
+
+        date = DateTime() + value
+
+        # Get the possible operation methods.
+        key = '%s.field.%s.operations' % (prefix, field)
+        operations = registry.get(key)
+
+        def add_row(operation, value=None):
+            if operation not in operations:
+                # TODO just ignore it?
+                raise ValueError(INVALID_OPERATION % (operation, criterion))
+            if not self.is_operation_valid(registry, operation):
+                # TODO just ignore it?
+                raise ValueError(INVALID_OPERATION % (operation, criterion))
+            # Add a row to the form query.
+            row = {'i': field,
+                   'o': operation}
+            if value is not None:
+                row['v'] = value
+            formquery.append(row)
+
+        operation = criterion.getOperation()
+        if operation == 'within_day':
+            if date.isCurrentDay():
+                new_operation = "%s.operation.date.today" % prefix
+                add_row(new_operation)
+                return
+            date_range = (date.earliestTime(), date.latestTime())
+            new_operation = "%s.operation.date.between" % prefix
+            add_row(new_operation, date_range)
+            return
+        if operation == 'more':
+            if value != 0:
+                new_operation = ("{0}.operation.date."
+                                 "largerThanRelativeDate".format(prefix))
+                add_row(new_operation, value)
+                return
+            else:
+                new_operation = "{0}.operation.date.afterToday".format(prefix)
+                add_row(new_operation)
+                return
+        if operation == 'less':
+            if value != 0:
+                new_operation = ("{0}.operation.date."
+                                 "lessThanRelativeDate".format(prefix))
+                add_row(new_operation, value)
+                return
+            else:
+                new_operation = "{0}.operation.date.beforeToday".format(prefix)
+                add_row(new_operation)
+                return
+
+
+class ATSimpleStringCriterionConverter(CriterionConverter):
+    operator_code = 'string.contains'
+    # review_state could be a string criterion, but should become a selection.
+    alt_operator_code = 'selection.is'
+
+
+class ATCurrentAuthorCriterionConverter(CriterionConverter):
+    operator_code = 'string.currentUser'
+
+
+class ATSelectionCriterionConverter(CriterionConverter):
+    operator_code = 'selection.is'
+
+    def get_query_value(self, value, index, criterion):
+        values = value['query']
+        if value.get('operator') == 'and' and len(values) > 1:
+            logger.warn("Cannot handle selection operator 'and'. Using 'or'. "
+                        "%r", value)
+        values = value['query']
+        # Special handling for portal_type=Topic.
+        if index == 'portal_type' and 'Topic' in values:
+            values = list(values)
+            values[values.index('Topic')] = 'Collection'
+            values = tuple(values)
+        return values
+
+
+class ATListCriterionConverter(ATSelectionCriterionConverter):
+    pass
+
+
+class ATReferenceCriterionConverter(ATSelectionCriterionConverter):
+    # Note: the new criterion is disabled by default.  Also, it
+    # needs the _referenceIs function in the plone.app.querystring
+    # queryparser and that function is not defined.
+    operator_code = 'reference.is'
+
+
+class ATPathCriterionConverter(CriterionConverter):
+    operator_code = 'string.path'
+
+    def get_query_value(self, value, index, criterion):
+        raw = criterion.getRawValue()
+        if not raw:
+            return
+        # Is this a recursive query?  Could check depth in the value
+        # actually, but Recurse is the canonical way.  Also, the only
+        # possible values for depth are -1 and 1.
+        if not criterion.Recurse():
+            for index, path in enumerate(raw):
+                raw[index] = path + '::1'
+        return raw
+
+    def add_to_formquery(self, formquery, index, operation, query_value):
+        if query_value is None:
+            return
+        for value in query_value:
+            row = {'i': index,
+                   'o': operation,
+                   'v': value}
+            formquery.append(row)
+
+
+class ATBooleanCriterionConverter(CriterionConverter):
+
+    def get_operation(self, value, index, criterion):
+        # Get dotted operation method.
+        # value is one of these beauties:
+        # value = [1, True, '1', 'True']
+        # value = [0, '', False, '0', 'False', None, (), [], {}, MV]
+        if True in value:
+            code = 'isTrue'
+        elif False in value:
+            code = 'isFalse'
+        else:
+            logger.warn("Unknown value for boolean criterion. "
+                        "Falling back to True. %r", value)
+            code = 'isTrue'
+        return "%s.operation.boolean.%s" % (prefix, code)
+
+    def __call__(self, formquery, criterion, registry):
+        criteria = criterion.getCriteriaItems()
+        if not criteria:
+            return
+        for index, value in criteria:
+            if index == 'is_folderish':
+                fieldname = 'isFolderish'
+            elif index == 'is_default_page':
+                fieldname = 'isDefaultPage'
+            else:
+                fieldname = index
+            # Check if the index is known and enabled as criterion index.
+            if not self.is_index_known(registry, fieldname):
+                continue
+            self.is_index_enabled(registry, fieldname)
+            # Get the operation method.
+            operation = self.get_valid_operation(
+                registry, fieldname, value, criterion)
+            if not operation:
+                logger.error(INVALID_OPERATION % (operation, criterion))
+                # TODO: raise an Exception?
+                continue
+            # Add a row to the form query.
+            row = {'i': index,
+                   'o': operation}
+            formquery.append(row)
+
+
+class ATDateRangeCriterionConverter(CriterionConverter):
+    operator_code = 'date.between'
+
+    def get_query_value(self, value, index, criterion):
+        return value['query']
+
+
+class ATPortalTypeCriterionConverter(CriterionConverter):
+    operator_code = 'selection.is'
+
+    def get_query_value(self, value, index, criterion):
+        # Special handling for portal_type=Topic.
+        if 'Topic' in value:
+            value = list(value)
+            value[value.index('Topic')] = 'Collection'
+            value = tuple(value)
+        return value
+
+
+class ATRelativePathCriterionConverter(CriterionConverter):
+    # We also have path.isWithinRelative, but its function is not defined.
+    operator_code = 'string.relativePath'
+
+    def get_query_value(self, value, index, criterion):
+        if not criterion.Recurse():
+            logger.warn("Cannot handle non-recursive path search. "
+                        "Allowing recursive search. %r", value)
+        return criterion.getRelativePath()
+
+
+class ATSimpleIntCriterionConverter(CriterionConverter):
+    # Also available: int.lessThan, int.largerThan.
+    operator_code = 'int.is'
+
+    def get_operation(self, value, index, criterion):
+        # Get dotted operation method.
+        direction = value.get('range')
+        if not direction:
+            code = 'is'
+        elif direction == 'min':
+            code = 'largerThan'
+        elif direction == 'max':
+            code = 'lessThan'
+        elif direction == 'min:max':
+            logger.warn("min:max direction not supported for integers. %r",
+                        value)
+            return
+        else:
+            logger.warn("Unknown direction for integers. %r", value)
+            return
+        return "{0}.operation.int.{1}".format(prefix, code)
+
+    def get_query_value(self, value, index, criterion):
+        if isinstance(value['query'], tuple):
+            logger.warn("More than one integer is not supported. %r", value)
+            return
+        return value['query']
+
+
+class TopicMigrator(InplaceCMFItemMigrator, ReferenceMigrator):
+    """Migrate Topics to Collections. Existing subtopics will be lost.
+
+    The only difference to the migration below is the base-class
+    (InplaceCMFItemMigrator instead of InplaceCMFFolderMigrator).
+    """
+    src_portal_type = 'Topic'
+    src_meta_type = 'ATTopic'
+    dst_portal_type = dst_meta_type = 'Collection'
+    view_methods_mapping = {
+        'folder_listing': 'listing_view',
+        'folder_summary_view': 'summary_view',
+        'folder_full_view': 'full_view',
+        'folder_tabular_view': 'tabular_view',
+        'atct_album_view': 'album_view',
+        'atct_topic_view': 'listing_view',
+    }
+
+    @property
+    def registry(self):
+        return self.kwargs['registry']
+
+    def last_migrate_layout(self):
+        """Migrate the layout (view method).
+
+        This needs to be done last, as otherwise our changes in
+        migrate_criteria may get overriden by a later call to
+        migrate_properties.
+        """
+        if self.old.getCustomView():
+            # Previously, the atct_topic_view had logic for showing
+            # the results in a list or in tabular form.  If
+            # getCustomView is True, this means the new object should
+            # use the tabular view.
+            self.new.setLayout('tabular_view')
+            return
+
+        old_layout = self.old.getLayout() or getattr(self.old, 'layout', None)
+        layout = self.view_methods_mapping.get(old_layout)
+        if layout:
+            self.new.setLayout(layout)
+
+    def beforeChange_criteria(self):
+        """Store the criteria of the old Topic.
+
+        Store the info on the migrator and restore the values in the
+        migrate_criteria method.
+        """
+        self._collection_sort_reversed = None
+        self._collection_sort_on = None
+        self._collection_query = None
+        path = '/'.join(self.old.getPhysicalPath())
+        logger.info("Migrating %s at %s", self.src_portal_type, path)
+        # Get the old criteria.
+        # See also Products.ATContentTypes.content.topic.buildQuery
+        criteria = self.old.listCriteria()
+        logger.debug("Old criteria for %s: %r", path,
+                     [(crit, crit.getCriteriaItems()) for crit in criteria])
+        formquery = []
+        for criterion in criteria:
+            type_ = criterion.__class__.__name__
+            if type_ == 'ATSortCriterion':
+                # Sort order and direction are now stored in the Collection.
+                self._collection_sort_reversed = criterion.getReversed()
+                self._collection_sort_on = criterion.Field()
+                logger.debug("Sort on %r, reverse: %s.",
+                             self._collection_sort_on,
+                             self._collection_sort_reversed)
+                continue
+
+            converter = CONVERTERS.get(type_)
+            if converter is None:
+                msg = 'Unsupported criterion %s' % type_
+                logger.error(msg)
+                raise ValueError(msg)
+            converter(formquery, criterion, self.registry)
+
+        logger.debug("New query for %s: %r", path, formquery)
+        self._collection_query = formquery
+
+    def migrate_criteria(self):
+        """Migrate old style to new style criteria.
+
+        Plus handling for some special fields.
+        """
+        # The old Topic has boolean limitNumber and integer itemCount,
+        # where the new Collection only has limit.
+        adapted = ICollection(self.new)
+        if self.old.getLimitNumber():
+            adapted.limit = self.old.getItemCount()
+        adapted.customViewFields = self.old.getCustomViewFields()
+
+        # Get the old data stored by the beforeChange_criteria method.
+        if self._collection_sort_reversed is not None:
+            adapted.sort_reversed = self._collection_sort_reversed
+        if self._collection_sort_on is not None:
+            adapted.sort_on = self._collection_sort_on
+        if self._collection_query is not None:
+            adapted.query = self._collection_query
+
+    def migrate_atctmetadata(self):
+        field = self.old.getField('excludeFromNav')
+        self.new.exclude_from_nav = field.get(self.old)
+
+    def migrate_at_uuid(self):
+        """Migrate AT universal uid
+        """
+        uid = self.UID
+        if uid and queryAdapter(self.new, IMutableUUID):
+            IMutableUUID(self.new).set(str(uid))
+
+
+class FolderishTopicMigrator(InplaceCMFFolderMigrator, ReferenceMigrator):
+    """Migrate Topics and Subtopics to folderish collections.
+
+    The only difference to the migration above is the base-class
+    (InplaceCMFFolderMigrator instead of InplaceCMFItemMigrator).
+    """
+    src_portal_type = 'Topic'
+    src_meta_type = 'ATTopic'
+    dst_portal_type = dst_meta_type = 'Collection'
+    view_methods_mapping = {
+        'folder_listing': 'listing_view',
+        'folder_summary_view': 'summary_view',
+        'folder_full_view': 'full_view',
+        'folder_tabular_view': 'tabular_view',
+        'atct_album_view': 'album_view',
+        'atct_topic_view': 'listing_view',
+    }
+
+    @property
+    def registry(self):
+        return self.kwargs['registry']
+
+    def last_migrate_layout(self):
+        """Migrate the layout (view method).
+
+        This needs to be done last, as otherwise our changes in
+        migrate_criteria may get overriden by a later call to
+        migrate_properties.
+        """
+        if self.old.getCustomView():
+            # Previously, the atct_topic_view had logic for showing
+            # the results in a list or in tabular form.  If
+            # getCustomView is True, this means the new object should
+            # use the tabular view.
+            self.new.setLayout('tabular_view')
+            return
+
+        old_layout = self.old.getLayout() or getattr(self.old, 'layout', None)
+        layout = self.view_methods_mapping.get(old_layout)
+        if layout:
+            self.new.setLayout(layout)
+
+    def beforeChange_criteria(self):
+        """Store the criteria of the old Topic.
+
+        Store the info on the migrator and restore the values in the
+        migrate_criteria method.
+        """
+        self._collection_sort_reversed = None
+        self._collection_sort_on = None
+        self._collection_query = None
+        path = '/'.join(self.old.getPhysicalPath())
+        logger.info("Migrating %s at %s", self.src_portal_type, path)
+        # Get the old criteria.
+        # See also Products.ATContentTypes.content.topic.buildQuery
+        criteria = self.old.listCriteria()
+        logger.debug("Old criteria for %s: %r", path,
+                     [(crit, crit.getCriteriaItems()) for crit in criteria])
+        formquery = []
+        for criterion in criteria:
+            type_ = criterion.__class__.__name__
+            if type_ == 'ATSortCriterion':
+                # Sort order and direction are now stored in the Collection.
+                self._collection_sort_reversed = criterion.getReversed()
+                self._collection_sort_on = criterion.Field()
+                logger.debug("Sort on %r, reverse: %s.",
+                             self._collection_sort_on,
+                             self._collection_sort_reversed)
+                continue
+
+            converter = CONVERTERS.get(type_)
+            if converter is None:
+                msg = 'Unsupported criterion %s' % type_
+                logger.error(msg)
+                raise ValueError(msg)
+            converter(formquery, criterion, self.registry)
+
+        logger.debug("New query for %s: %r", path, formquery)
+        self._collection_query = formquery
+
+    def migrate_criteria(self):
+        """Migrate old style to new style criteria.
+
+        Plus handling for some special fields.
+        """
+        # The old Topic has boolean limitNumber and integer itemCount,
+        # where the new Collection only has limit.
+        adapted = ICollection(self.new)
+        if self.old.getLimitNumber():
+            adapted.limit = self.old.getItemCount()
+        adapted.customViewFields = self.old.getCustomViewFields()
+
+        # Get the old data stored by the beforeChange_criteria method.
+        if self._collection_sort_reversed is not None:
+            adapted.sort_reversed = self._collection_sort_reversed
+        if self._collection_sort_on is not None:
+            adapted.sort_on = self._collection_sort_on
+        if self._collection_query is not None:
+            adapted.query = self._collection_query
+
+    def migrate_atctmetadata(self):
+        field = self.old.getField('excludeFromNav')
+        self.new.exclude_from_nav = field.get(self.old)
+
+    def migrate_at_uuid(self):
+        """Migrate AT universal uid
+        """
+        uid = self.UID
+        if uid and queryAdapter(self.new, IMutableUUID):
+            IMutableUUID(self.new).set(str(uid))
+
+
+def migrate_topics(portal):
+    """Migrate ATContentTypes Topics to plone.app.contenttypes Collections.
+
+    This could also be used as upgrade step.
+    """
+    # Parse the registry to get allowed operations and pass it to the
+    # migrator.
+    reg = getUtility(IRegistry)
+    reader = IQuerystringRegistryReader(reg)
+    registry = reader.parseRegistry()
+    # select migrator based on the base-class of collections
+    fti = portal.portal_types['Collection']
+    if fti.content_meta_type == "Dexterity Item":
+        migrator = TopicMigrator
+    elif fti.content_meta_type == "Dexterity Container":
+        migrator = FolderishTopicMigrator
+    walker = CustomQueryWalker(portal, migrator)(registry=registry)
+    return walker
+
+
+CONVERTERS = {
+    # Create an instance of each converter.
+    'ATBooleanCriterion': ATBooleanCriterionConverter(),
+    'ATCurrentAuthorCriterion': ATCurrentAuthorCriterionConverter(),
+    'ATDateCriteria': ATDateCriteriaConverter(),
+    'ATDateRangeCriterion': ATDateRangeCriterionConverter(),
+    'ATListCriterion': ATListCriterionConverter(),
+    'ATPathCriterion': ATPathCriterionConverter(),
+    'ATPortalTypeCriterion': ATPortalTypeCriterionConverter(),
+    'ATReferenceCriterion': ATReferenceCriterionConverter(),
+    'ATRelativePathCriterion': ATRelativePathCriterionConverter(),
+    'ATSelectionCriterion': ATSelectionCriterionConverter(),
+    'ATSimpleIntCriterion': ATSimpleIntCriterionConverter(),
+    'ATSimpleStringCriterion': ATSimpleStringCriterionConverter(),
+    }
diff --git a/plone/app/contenttypes/migration/utils.py b/plone/app/contenttypes/migration/utils.py
index a5c12c0..d283847 100644
--- a/plone/app/contenttypes/migration/utils.py
+++ b/plone/app/contenttypes/migration/utils.py
@@ -1,36 +1,35 @@
 # -*- coding: utf-8 -*-
-from Products.ATContentTypes.interfaces.document import IATDocument
-from Products.ATContentTypes.interfaces.event import IATEvent
-from Products.ATContentTypes.interfaces.file import IATFile
-from Products.ATContentTypes.interfaces.folder import IATFolder
-from Products.ATContentTypes.interfaces.image import IATImage
-from Products.ATContentTypes.interfaces.link import IATLink
-from Products.ATContentTypes.interfaces.news import IATNewsItem
 from Products.CMFCore.utils import getToolByName
+from Products.CMFPlone.interfaces import IPloneSiteRoot
+from Products.CMFPlone.utils import safe_unicode, safe_hasattr
 from Products.GenericSetup.context import DirectoryImportContext
 from Products.GenericSetup.utils import importObjects
 from archetypes.schemaextender.interfaces import IBrowserLayerAwareExtender
 from archetypes.schemaextender.interfaces import IOrderableSchemaExtender
 from archetypes.schemaextender.interfaces import ISchemaExtender
 from archetypes.schemaextender.interfaces import ISchemaModifier
-from plone.app.blob.interfaces import IATBlobFile
-from plone.app.blob.interfaces import IATBlobImage
-from plone.app.contenttypes.migration import migration
+from copy import deepcopy
+from plone.app.contentrules.api import assign_rule
+from plone.app.contenttypes.behaviors.leadimage import ILeadImage
 from plone.app.contenttypes.utils import DEFAULT_TYPES
+from plone.app.discussion.conversation import ANNOTATION_KEY as DISCUSSION_KEY
+from plone.app.discussion.interfaces import IConversation
+from plone.contentrules.engine.interfaces import IRuleAssignmentManager
 from plone.dexterity.interfaces import IDexterityFTI
+from plone.namedfile.file import NamedBlobImage
+from plone.portlets.interfaces import IPortletAssignmentMapping
+from plone.portlets.interfaces import IPortletManager
+from zope.annotation.interfaces import IAnnotations
 from zope.component import getGlobalSiteManager
+from zope.component import getMultiAdapter
+from zope.component import getUtility
 from zope.component.hooks import getSite
+
+import logging
 import os
 import pkg_resources
 
-try:
-    pkg_resources.get_distribution('plone.app.collection')
-except pkg_resources.DistributionNotFound:
-    ICollection = None
-    HAS_APP_COLLECTION = False
-else:
-    HAS_APP_COLLECTION = True
-    from plone.app.collection.interfaces import ICollection
+logger = logging.getLogger(__name__)
 
 # Is there a multilingual addon?
 try:
@@ -48,83 +47,6 @@
     else:
         HAS_MULTILINGUAL = True
 
-ATCT_LIST = {
-    "Folder": {
-        'iface': IATFolder,
-        'migrator': migration.migrate_folders,
-        'extended_fields': [],
-        'type_name': 'Folder',
-        'old_meta_type': 'ATFolder',
-    },
-    "Document": {
-        'iface': IATDocument,
-        'migrator': migration.migrate_documents,
-        'extended_fields': [],
-        'type_name': 'Document',
-        'old_meta_type': 'ATDocument',
-    },
-    # File without blobs
-    "File": {
-        'iface': IATFile,
-        'migrator': migration.migrate_files,
-        'extended_fields': [],
-        'type_name': 'File',
-        'old_meta_type': 'ATFile',
-    },
-    # Image without blobs
-    "Image": {
-        'iface': IATImage,
-        'migrator': migration.migrate_images,
-        'extended_fields': [],
-        'type_name': 'Image',
-        'old_meta_type': 'ATImage',
-    },
-    "News Item": {
-        'iface': IATNewsItem,
-        'migrator': migration.migrate_newsitems,
-        'extended_fields': [],
-        'type_name': 'News Item',
-        'old_meta_type': 'ATNewsItem',
-    },
-    "Link": {
-        'iface': IATLink,
-        'migrator': migration.migrate_links,
-        'extended_fields': [],
-        'type_name': 'Link',
-        'old_meta_type': 'ATLink',
-    },
-    "Event": {
-        'iface': IATEvent,
-        'migrator': migration.migrate_events,
-        'extended_fields': [],
-        'type_name': 'Event',
-        'old_meta_type': 'ATEvent',
-    },
-    "BlobImage": {
-        'iface': IATBlobImage,
-        'migrator': migration.migrate_blobimages,
-        'extended_fields': ['image'],
-        'type_name': 'Image',
-        'old_meta_type': 'ATBlob',
-    },
-    "BlobFile": {
-        'iface': IATBlobFile,
-        'migrator': migration.migrate_blobfiles,
-        'extended_fields': ['file'],
-        'type_name': 'File',
-        'old_meta_type': 'ATBlob',
-    },
-}
-
-if HAS_APP_COLLECTION:
-    ATCT_LIST["Collection"] = {
-        'iface': ICollection,
-        'migrator': migration.migrate_collections,
-        'extended_fields': [],
-        'type_name': 'Collection',
-        'old_meta_type': 'Collection',
-    }
-
 
 def isSchemaExtended(iface):
     """Return a list of fields added by archetypes.schemaextender
@@ -190,7 +112,8 @@ def installTypeIfNeeded(type_name):
     if IDexterityFTI.providedBy(fti):
         # the dx-type is already installed
         return
-    tt.manage_delObjects(type_name)
+    if fti:
+        tt.manage_delObjects(type_name)
     tt.manage_addTypeInformation('Dexterity FTI', id=type_name)
     dx_fti = tt.getTypeInfo(type_name)
     ps = getToolByName(portal, 'portal_setup')
@@ -199,3 +122,94 @@ def installTypeIfNeeded(type_name):
     environ = DirectoryImportContext(ps, profile_path)
     parent_path = 'types/'
     importObjects(dx_fti, parent_path, environ)
+
+
+def add_portlet(context, assignment, portlet_key, columnName):
+    column = getUtility(IPortletManager, columnName)
+    assignmentmapping = getMultiAdapter((context, column),
+                                        IPortletAssignmentMapping)
+    assignmentmapping[portlet_key] = assignment
+
+
+def move_comments(source_object, target_object):
+    """Move comments by copying the annotation to the target
+    and then removing the comments from the source (not the annotation).
+    """
+    source_annotations = IAnnotations(source_object)
+    comments = source_annotations.get(DISCUSSION_KEY, None)
+    if comments is not None:
+        target_annotations = IAnnotations(target_object)
+        if target_annotations.get(DISCUSSION_KEY, None) is not None:
+            logger.error('Comments exist on {0}').format(
+                target_object.absolute_url())
+        target_annotations[DISCUSSION_KEY] = deepcopy(comments)
+
+        # Delete comments from the portal where wthey were stored temporarily.
+        # Comments on the old objects will be removed with the objects.
+        if IPloneSiteRoot.providedBy(source_object):
+            source_conversation = IConversation(source_object)
+            for comment in source_conversation.getComments():
+                del source_conversation[comment.comment_id]
+            del source_annotations[DISCUSSION_KEY]
+
+
+def copy_contentrules(source_object, target_object):
+    """Copy contentrules.
+    """
+    source_assignable = IRuleAssignmentManager(source_object, None)
+    if source_assignable is not None:
+        try:
+            IRuleAssignmentManager(target_object)
+        except TypeError:
+            logger.info("Cound not assign contentrules to {0}".format(
+                target_object.absolute_url()))
+            return
+        for rule_id in source_assignable:
+            assign_rule(target_object, rule_id)
+
+
+def migrate_leadimage(source_object, target_object):
+    """ Migrate images added using collective.contentleadimage to the
+    ILeadImage-behavior of plone.app.contenttypes if it is enabled.
+    """
+    OLD_LEADIMAGE_FIELD_NAME = 'leadImage'
+    OLD_CAPTION_FIELD_NAME = 'leadImage_caption'
+    NEW_LEADIMAGE_FIELD_NAME = 'image'
+    NEW_CAPTION_FIELD_NAME = 'image_caption'
+
+    old_leadimage_field = source_object.getField(OLD_LEADIMAGE_FIELD_NAME)
+    if not old_leadimage_field:
+        # skip if old content has no field
+        return
+
+    if ILeadImage(target_object, None) is None:
+        # skip if new content does not have the LeadImage-behavior enabled
+        logger.info("Target does not have the behavior 'Lead Image' enabled. "
+                    "Could not migrate collective.leadimage fields.")
+        return
+
+    old_image = old_leadimage_field.get(source_object)
+    if not old_image:
+        # skip if image-field is empty
+        return
+
+    filename = safe_unicode(old_image.filename)
+    old_image_data = old_image.data
+    if safe_hasattr(old_image_data, 'data'):
+        # handle relstorage
+        old_image_data = old_image_data.data
+
+    # construct the new image
+    namedblobimage = NamedBlobImage(data=old_image_data,
+                                    filename=filename)
+
+    # set new field on destination object
+    setattr(target_object, NEW_LEADIMAGE_FIELD_NAME, namedblobimage)
+
+    # handle image caption field
+    caption_field = source_object.getField(OLD_CAPTION_FIELD_NAME, None)
+    if caption_field:
+        setattr(target_object,
+                (NEW_CAPTION_FIELD_NAME),
+                safe_unicode(caption_field.get(source_object)))
+    logger.info("Migrating contentlead image %s" % filename)
diff --git a/plone/app/contenttypes/migration/vocabularies.py b/plone/app/contenttypes/migration/vocabularies.py
index 9406106..279c46b 100644
--- a/plone/app/contenttypes/migration/vocabularies.py
+++ b/plone/app/contenttypes/migration/vocabularies.py
@@ -1,12 +1,118 @@
 # -*- coding: utf-8 -*-
+from Products.ATContentTypes.interfaces.document import IATDocument
+from Products.ATContentTypes.interfaces.event import IATEvent
+from Products.ATContentTypes.interfaces.file import IATFile
+from Products.ATContentTypes.interfaces.folder import IATFolder
+from Products.ATContentTypes.interfaces.image import IATImage
+from Products.ATContentTypes.interfaces.link import IATLink
+from Products.ATContentTypes.interfaces.news import IATNewsItem
+from Products.ATContentTypes.interfaces.topic import IATTopic
 from Products.CMFCore.utils import getToolByName
+from plone.app.blob.interfaces import IATBlobFile
+from plone.app.blob.interfaces import IATBlobImage
 from plone.app.contenttypes import _
-from plone.app.contenttypes.migration.utils import ATCT_LIST
+from plone.app.contenttypes.migration import migration
 from plone.app.contenttypes.migration.utils import isSchemaExtended
+from plone.app.contenttypes.migration.topics import migrate_topics
 from zope.interface import implements
 from zope.schema.interfaces import IVocabularyFactory
 from zope.schema.vocabulary import SimpleVocabulary
 
+import pkg_resources
+
+try:
+    pkg_resources.get_distribution('plone.app.collection')
+except pkg_resources.DistributionNotFound:
+    ICollection = None
+    HAS_APP_COLLECTION = False
+else:
+    HAS_APP_COLLECTION = True
+    from plone.app.collection.interfaces import ICollection
+
+ATCT_LIST = {
+    "Folder": {
+        'iface': IATFolder,
+        'migrator': migration.migrate_folders,
+        'extended_fields': [],
+        'type_name': 'Folder',
+        'old_meta_type': 'ATFolder',
+    },
+    "Document": {
+        'iface': IATDocument,
+        'migrator': migration.migrate_documents,
+        'extended_fields': [],
+        'type_name': 'Document',
+        'old_meta_type': 'ATDocument',
+    },
+    # File without blobs
+    "File": {
+        'iface': IATFile,
+        'migrator': migration.migrate_files,
+        'extended_fields': [],
+        'type_name': 'File',
+        'old_meta_type': 'ATFile',
+    },
+    # Image without blobs
+    "Image": {
+        'iface': IATImage,
+        'migrator': migration.migrate_images,
+        'extended_fields': [],
+        'type_name': 'Image',
+        'old_meta_type': 'ATImage',
+    },
+    "News Item": {
+        'iface': IATNewsItem,
+        'migrator': migration.migrate_newsitems,
+        'extended_fields': [],
+        'type_name': 'News Item',
+        'old_meta_type': 'ATNewsItem',
+    },
+    "Link": {
+        'iface': IATLink,
+        'migrator': migration.migrate_links,
+        'extended_fields': [],
+        'type_name': 'Link',
+        'old_meta_type': 'ATLink',
+    },
+    "Event": {
+        'iface': IATEvent,
+        'migrator': migration.migrate_events,
+        'extended_fields': [],
+        'type_name': 'Event',
+        'old_meta_type': 'ATEvent',
+    },
+    "BlobImage": {
+        'iface': IATBlobImage,
+        'migrator': migration.migrate_blobimages,
+        'extended_fields': ['image'],
+        'type_name': 'Image',
+        'old_meta_type': 'ATBlob',
+    },
+    "BlobFile": {
+        'iface': IATBlobFile,
+        'migrator': migration.migrate_blobfiles,
+        'extended_fields': ['file'],
+        'type_name': 'File',
+        'old_meta_type': 'ATBlob',
+    },
+    "Topic": {
+        'iface': IATTopic,
+        'migrator': migrate_topics,
+        'extended_fields': [],
+        'type_name': 'Collection',
+        'old_meta_type': 'ATTopic',
+    },
+}
+
+if HAS_APP_COLLECTION:
+    ATCT_LIST["Collection"] = {
+        'iface': ICollection,
+        'migrator': migration.migrate_collections,
+        'extended_fields': [],
+        'type_name': 'Collection',
+        'old_meta_type': 'Collection',
+    }
+
 
 def get_terms(context, counter, ext_dict, show_extended):
     """Takes dicts of types and their numbers and their extended fields
@@ -106,3 +212,20 @@ def __call__(self, context):
         extended fields.
         """
         return results(context, show_extended=True)
+
+
+class ChangedBaseClasses(object):
+    implements(IVocabularyFactory)
+
+    def __call__(self, context):
+        """Return a vocabulary with all changed base classes."""
+        from plone.app.contenttypes.migration.dxmigration import \
+            list_of_changed_base_class_names
+        list_of_class_names = list_of_changed_base_class_names(context) or {}
+        return SimpleVocabulary(
+            [SimpleVocabulary.createTerm(
+                class_name, class_name,
+                '{0} ({1})'.format(
+                    class_name, list_of_class_names[class_name]))
+             for class_name in list_of_class_names.keys()]
+        )
diff --git a/plone/app/contenttypes/profiles/default/metadata.xml b/plone/app/contenttypes/profiles/default/metadata.xml
index ad295f7..b687208 100644
--- a/plone/app/contenttypes/profiles/default/metadata.xml
+++ b/plone/app/contenttypes/profiles/default/metadata.xml
@@ -1,10 +1,11 @@
 <metadata>
- <version>1103</version>
+ <version>1104</version>
  <dependencies>
   <dependency>profile-plone.app.dexterity:default</dependency>
   <dependency>profile-plone.app.event:default</dependency>
   <dependency>profile-plone.app.relationfield:default</dependency>
   <dependency>profile-plone.app.versioningbehavior:default</dependency>
+  <dependency>profile-plone.app.z3cform:default</dependency>
   <!-- XXX: For some reason the p.a.d gs workflow is not applied correctly. -->
   <dependency>profile-plone.app.discussion:default</dependency>
  </dependencies>
diff --git a/plone/app/contenttypes/profiles/default/propertiestool.xml b/plone/app/contenttypes/profiles/default/propertiestool.xml
new file mode 100644
index 0000000..4442935
--- /dev/null
+++ b/plone/app/contenttypes/profiles/default/propertiestool.xml
@@ -0,0 +1,11 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<object name="portal_properties" meta_type="Plone Properties Tool">
+ <object name="site_properties" meta_type="Plone Property Sheet">
+  <property name="default_page_types" type="lines" purge="False">
+   <element value="Document"/>
+   <element value="Event"/>
+   <element value="News Item"/>
+   <element value="Collection"/>
+  </property>
+ </object>
+</object>
diff --git a/plone/app/contenttypes/profiles/default/types.xml b/plone/app/contenttypes/profiles/default/types.xml
index ac9b7eb..30011bd 100644
--- a/plone/app/contenttypes/profiles/default/types.xml
+++ b/plone/app/contenttypes/profiles/default/types.xml
@@ -4,15 +4,24 @@
  <!-- We remove old ATContentTypes if they exist.
       Instances of these types can still be looked at since the
       skin-templates in CMFPlone are there but they cannot be edited -->
- <object name="Collection" remove="True"/>
- <object name="Document" remove="True"/>
- <object name="Event" remove="True"/>
- <object name="File" remove="True"/>
- <object name="Folder" remove="True"/>
- <object name="Image" remove="True"/>
- <object name="Link" remove="True"/>
- <object name="News Item" remove="True"/>
- <object name="Topic" remove="True"/>
+ <object name="Collection" remove="True"
+    meta_type="Factory-based Type Information with dynamic views"/>
+ <object name="Document" remove="True"
+    meta_type="Factory-based Type Information with dynamic views"/>
+ <object name="Event" remove="True"
+    meta_type="Factory-based Type Information with dynamic views"/>
+ <object name="File" remove="True"
+    meta_type="Factory-based Type Information with dynamic views"/>
+ <object name="Folder" remove="True"
+    meta_type="Factory-based Type Information with dynamic views"/>
+ <object name="Image" remove="True"
+    meta_type="Factory-based Type Information with dynamic views"/>
+ <object name="Link" remove="True"
+    meta_type="Factory-based Type Information with dynamic views"/>
+ <object name="News Item" remove="True"
+    meta_type="Factory-based Type Information with dynamic views"/>
+ <object name="Topic" remove="True"
+    meta_type="Factory-based Type Information with dynamic views"/>
 
  <object meta_type="Dexterity FTI" name="Collection" />
  <object meta_type="Dexterity FTI" name="Document" />
@@ -22,5 +31,8 @@
  <object meta_type="Dexterity FTI" name="Image" />
  <object meta_type="Dexterity FTI" name="News Item" />
  <object meta_type="Dexterity FTI" name="Event" />
+ 
+ <object name="Plone Site"
+    meta_type="Factory-based Type Information with dynamic views"/>
 
 </object>
diff --git a/plone/app/contenttypes/profiles/default/types/Collection.xml b/plone/app/contenttypes/profiles/default/types/Collection.xml
index a525995..a4f822e 100644
--- a/plone/app/contenttypes/profiles/default/types/Collection.xml
+++ b/plone/app/contenttypes/profiles/default/types/Collection.xml
@@ -28,14 +28,15 @@
   </property>
 
   <!-- View information -->
-  <property name="default_view">standard_view</property>
+  <property name="default_view">listing_view</property>
   <property name="default_view_fallback">False</property>
   <property name="view_methods">
-    <element value="standard_view" />
-    <element value="summary_view" />
-    <element value="all_content" />
-    <element value="tabular_view" />
-    <element value="thumbnail_view" />
+    <element value="listing_view"/>
+    <element value="summary_view"/>
+    <element value="tabular_view"/>
+    <element value="full_view"/>
+    <element value="album_view"/>
+    <element value="event_listing"/>
   </property>
 
   <!-- Method aliases -->
diff --git a/plone/app/contenttypes/profiles/default/types/Folder.xml b/plone/app/contenttypes/profiles/default/types/Folder.xml
index 01a3166..ff9cb4c 100644
--- a/plone/app/contenttypes/profiles/default/types/Folder.xml
+++ b/plone/app/contenttypes/profiles/default/types/Folder.xml
@@ -12,13 +12,14 @@
  <property name="filter_content_types">False</property>
  <property name="allowed_content_types"/>
  <property name="allow_discussion">False</property>
- <property name="default_view">folder_listing</property>
+ <property name="default_view">listing_view</property>
  <property name="view_methods">
-  <element value="folder_summary_view"/>
-  <element value="folder_full_view"/>
-  <element value="folder_tabular_view"/>
-  <element value="folder_album_view"/>
-  <element value="folder_listing"/>
+  <element value="listing_view"/>
+  <element value="summary_view"/>
+  <element value="tabular_view"/>
+  <element value="full_view"/>
+  <element value="album_view"/>
+  <element value="event_listing"/>
  </property>
  <property name="default_view_fallback">False</property>
  <property name="add_permission">plone.app.contenttypes.addFolder</property>
diff --git a/plone/app/contenttypes/profiles/default/types/Plone_Site.xml b/plone/app/contenttypes/profiles/default/types/Plone_Site.xml
new file mode 100644
index 0000000..bd03b87
--- /dev/null
+++ b/plone/app/contenttypes/profiles/default/types/Plone_Site.xml
@@ -0,0 +1,13 @@
+<?xml version="1.0"?>
+<object name="Plone Site" meta_type="Factory-based Type Information with dynamic views" i18n:domain="plone" xmlns:i18n="http://xml.zope.org/namespaces/i18n">
+  <property name="immediate_view">listing_view</property>
+  <property name="default_view">listing_view</property>
+  <property name="view_methods">
+    <element value="listing_view" />
+    <element value="summary_view" />
+    <element value="tabular_view" />
+    <element value="full_view" />
+    <element value="album_view" />
+    <element value="event_listing" />
+  </property>
+</object>
diff --git a/plone/app/contenttypes/profiles/uninstall/types.xml b/plone/app/contenttypes/profiles/uninstall/types.xml
index fcd0b15..fca8606 100644
--- a/plone/app/contenttypes/profiles/uninstall/types.xml
+++ b/plone/app/contenttypes/profiles/uninstall/types.xml
@@ -24,4 +24,8 @@
     meta_type="Factory-based Type Information with dynamic views"/>
  <object name="News Item"
     meta_type="Factory-based Type Information with dynamic views"/>
+
+ <object name="Plone Site"
+    meta_type="Factory-based Type Information with dynamic views"/>
+
 </object>
diff --git a/plone/app/contenttypes/profiles/uninstall/types/Plone_Site.xml b/plone/app/contenttypes/profiles/uninstall/types/Plone_Site.xml
new file mode 100644
index 0000000..316c0c5
--- /dev/null
+++ b/plone/app/contenttypes/profiles/uninstall/types/Plone_Site.xml
@@ -0,0 +1,12 @@
+<?xml version="1.0"?>
+<object name="Plone Site" meta_type="Factory-based Type Information with dynamic views" i18n:domain="plone" xmlns:i18n="http://xml.zope.org/namespaces/i18n">
+  <property name="immediate_view">folder_listing</property>
+  <property name="default_view">folder_listing</property>
+  <property name="view_methods">
+    <element value="folder_listing" />
+    <element value="folder_summary_view" />
+    <element value="folder_full_view" />
+    <element value="folder_tabular_view" />
+    <element value="atct_album_view" />
+  </property>
+</object>
diff --git a/plone/app/contenttypes/schema/image.xml b/plone/app/contenttypes/schema/image.xml
index e16d516..4795d8d 100644
--- a/plone/app/contenttypes/schema/image.xml
+++ b/plone/app/contenttypes/schema/image.xml
@@ -16,7 +16,7 @@
     <field name="image" type="plone.namedfile.field.NamedBlobImage"
         marshal:primary="true">
       <description />
-      <title i18n:translate="Image">Image</title>
+      <title i18n:translate="label_image">Image</title>
     </field>
   </schema>
 </model>
diff --git a/plone/app/contenttypes/setuphandlers.py b/plone/app/contenttypes/setuphandlers.py
index 3246133..02ae12b 100644
--- a/plone/app/contenttypes/setuphandlers.py
+++ b/plone/app/contenttypes/setuphandlers.py
@@ -14,6 +14,7 @@
 from plone.i18n.normalizer.interfaces import IURLNormalizer
 from plone.portlets.interfaces import ILocalPortletAssignmentManager
 from plone.portlets.interfaces import IPortletManager
+from plone.registry.interfaces import IRegistry
 from zope.component import getMultiAdapter
 from zope.component import getUtility
 from zope.component import queryMultiAdapter
@@ -24,14 +25,6 @@
 from zope.i18n.locales import locales
 from zope.interface import implements
 
-import pkg_resources
-
-try:
-    pkg_resources.get_distribution('plone.multilingualbehavior')
-except pkg_resources.DistributionNotFound:
-    HAS_MULTILINGUAL = False
-else:
-    HAS_MULTILINGUAL = True
 
 try:
     DEXTERITY_WITH_CONSTRAINS = True
@@ -107,7 +100,8 @@ def addContentToContainer(container, object, checkConstraints=True):
 
 
 def _get_locales_info(portal):
-    language = portal.Language()
+    reg = queryUtility(IRegistry, context=portal)
+    language = reg['plone.default_language']
     parts = (language.split('-') + [None, None])[:3]
     locale = locales.getLocale(*parts)
 
@@ -118,15 +112,15 @@ def _get_locales_info(portal):
     return locale.id.language, False, locale
 
 
-def _set_language_settings(portal, uses_combined_lanagage):
-    """Set the portals language settings from the given lanage codes."""
-    language = portal.Language()
-    portal_languages = getToolByName(portal, 'portal_languages')
-    portal_languages.manage_setLanguageSettings(
-        language,
-        [language],
-        setUseCombinedLanguageCodes=uses_combined_lanagage,
-        startNeutral=False)
+# def _set_language_settings(portal, uses_combined_lanagage):
+#     """Set the portals language settings from the given lanage codes."""
+#     language = portal.Language()
+#     portal_languages = getToolByName(portal, 'portal_languages')
+#     portal_languages.manage_setLanguageSettings(
+#         language,
+#         [language],
+#         setUseCombinedLanguageCodes=uses_combined_lanagage,
+#         startNeutral=False)
 
 
 # ??? Why do we only do this calendar setup when content is created?
@@ -188,6 +182,7 @@ def create_frontpage(portal, target_language):
         content = createContent('Document', id=frontpage_id,
                                 title=title,
                                 description=description,
+                                language=target_language
                                 )
         content = addContentToContainer(portal, content)
         front_text = None
@@ -228,7 +223,8 @@ def create_news_topic(portal, target_language):
                                  u'Site News')
         container = createContent('Folder', id=news_id,
                                   title=title,
-                                  description=description)
+                                  description=description,
+                                  language=target_language)
         container = addContentToContainer(portal, container)
         _createObjectByType('Collection', container,
                             id='aggregator', title=title,
@@ -272,7 +268,8 @@ def create_events_topic(portal, target_language):
                                  u'Site Events')
         container = createContent('Folder', id=events_id,
                                   title=title,
-                                  description=description)
+                                  description=description,
+                                  language=target_language)
         container = addContentToContainer(portal, container)
         _createObjectByType('Collection', container,
                             id='aggregator', title=title,
@@ -319,7 +316,8 @@ def configure_members_folder(portal, target_language):
                                  u"Site Users")
         container = createContent('Folder', id=members_id,
                                   title=title,
-                                  description=description)
+                                  description=description,
+                                  language=target_language)
         container = addContentToContainer(portal, container)
         container.setOrdering('unordered')
         container.reindexObject()
@@ -350,7 +348,7 @@ def step_import_content(context):
     target_language, is_combined_language, locale = _get_locales_info(portal)
 
     # Set up Language specific information
-    _set_language_settings(portal, is_combined_language)
+    # _set_language_settings(portal, is_combined_language)
     _setup_calendar(locale)
     _setup_visible_ids(target_language, locale)
     _delete_at_example_content(portal)
@@ -398,20 +396,20 @@ def _delete_at_example_content(portal):
 def step_setup_various(context):
     if context.readDataFile('plone.app.contenttypes_default.txt') is None:
         return
-    portal = context.getSite()
-    enable_multilingual_behavior(portal)
-
-
-def enable_multilingual_behavior(portal):
-    if not HAS_MULTILINGUAL:
-        return
-    types_tool = portal.portal_types
-    all_ftis = types_tool.listTypeInfo()
-    dx_ftis = [x for x in all_ftis if getattr(x, 'behaviors', False)]
-    for fti in dx_ftis:
-        behaviors = [i for i in fti.behaviors]
-        behaviors.extend([
-            'plone.multilingualbehavior.interfaces.IDexterityTranslatable',
-        ])
-        behaviors = tuple(set(behaviors))
-        fti._updateProperty('behaviors', behaviors)
+#    portal = context.getSite()
+#     enable_multilingual_behavior(portal)
+
+
+# def enable_multilingual_behavior(portal):
+#     if not HAS_MULTILINGUAL:
+#         return
+#     types_tool = portal.portal_types
+#     all_ftis = types_tool.listTypeInfo()
+#     dx_ftis = [x for x in all_ftis if getattr(x, 'behaviors', False)]
+#     for fti in dx_ftis:
+#         behaviors = [i for i in fti.behaviors]
+#         behaviors.extend([
+#             'plone.app.multilingual.dx.interfaces.IDexterityTranslatable',
+#         ])
+#         behaviors = tuple(set(behaviors))
+#         fti._updateProperty('behaviors', behaviors)
diff --git a/plone/app/contenttypes/testing.py b/plone/app/contenttypes/testing.py
index 9e6d8ed..d312241 100644
--- a/plone/app/contenttypes/testing.py
+++ b/plone/app/contenttypes/testing.py
@@ -44,6 +44,15 @@ def setUpZope(self, app, configurationContext):
 
     def setUpPloneSite(self, portal):
         applyProfile(portal, 'plone.app.contenttypes:default')
+
+        # install and enable referenceablebehavior on Documents to be able to
+        # test controlpanel to enable plone.app.linkintegrity checks
+        # XXX Disabled as it is causing test errors in comments
+        # see https://github.com/plone/Products.CMFPlone/issues/255
+        # applyProfile(portal, 'plone.app.referenceablebehavior:default')
+        # portal.portal_types.Document.behaviors += \
+        #   ('plone.app.referenceablebehavior.referenceable.IReferenceable',)
+
         mtr = portal.mimetypes_registry
         mime_doc = mtr.lookup('application/msword')[0]
         mime_doc.icon_path = 'custom.png'
@@ -78,6 +87,7 @@ def setUpZope(self, app, configurationContext):
         z2.installProduct(app, 'Products.Archetypes')
         z2.installProduct(app, 'Products.ATContentTypes')
         z2.installProduct(app, 'plone.app.blob')
+
         # prepare installing plone.app.collection
         try:
             pkg_resources.get_distribution('plone.app.collection')
@@ -112,6 +122,9 @@ def setUpPloneSite(self, portal):
         if 'Products.ATContentTypes:default' in profiles:
             applyProfile(portal, 'Products.ATContentTypes:default')
 
+        # enable old Topic
+        portal.portal_types.Topic.global_allow = True
+
         # install plone.app.collections manually if profile is available
         # (this is only needed for Plone >= 5)
         if 'plone.app.collection:default' in profiles:
diff --git a/plone/app/contenttypes/tests/oldtypes.py b/plone/app/contenttypes/tests/oldtypes.py
index 63e9c2c..d4e652c 100644
--- a/plone/app/contenttypes/tests/oldtypes.py
+++ b/plone/app/contenttypes/tests/oldtypes.py
@@ -1,5 +1,14 @@
 # -*- coding: utf-8 -*-
 from plone.dexterity.fti import DexterityFTI
+from plone.dexterity.content import Item
+from plone.app.contenttypes.interfaces import IEvent
+from zope.interface import implementer
+
+
+@implementer(IEvent)
+class Event(Item):
+    """Dummy subclass for old ``Event`` portal type
+    """
 
 
 def create1_0EventType(portal):
@@ -20,7 +29,7 @@ def create1_0EventType(portal):
     fti.view_methods = ("event_view", )
     fti.default_view_fallback = False
     fti.add_permission = "plone.app.contenttypes.addEvent"
-    fti.klass = "plone.app.contenttypes.content.Event"
+    fti.klass = "plone.app.contenttypes.tests.oldtypes.Event"
     fti.behaviors = (
         "plone.app.contenttypes.interfaces.IEvent",
         "plone.app.dexterity.behaviors.metadata.IDublinCore",
diff --git a/plone/app/contenttypes/tests/robot/keywords.txt b/plone/app/contenttypes/tests/robot/keywords.txt
index 25de625..f61a9b7 100644
--- a/plone/app/contenttypes/tests/robot/keywords.txt
+++ b/plone/app/contenttypes/tests/robot/keywords.txt
@@ -20,31 +20,16 @@ a collection
   [Arguments]  ${title}
   [Return]  ${uid}
   ${uid} =  Create content  type=Collection  title=${title}
-# Go to  ${PLONE_URL}/++add++Collection
-# Wait until page contains  Add Collection
-# Input text  name=form.widgets.IDublinCore.title  ${title}
-# Click Button  Save
-# Wait until page contains  Item created
 
 a document
   [Arguments]  ${title}
   [Return]  ${uid}
   ${uid} =  Create content  type=Document  title=${title}
-# Go to  ${PLONE_URL}/++add++Document
-# Wait until page contains  Add Page
-# Input text  name=form.widgets.IDublinCore.title  ${title}
-# Click Button  Save
-# Wait until page contains  Item created
 
 a event
   [Arguments]  ${title}
   [Return]  ${uid}
   ${uid} =  Create content  type=Event  title=${title}
-# Go to  ${PLONE_URL}/++add++Event
-# Wait until page contains  Add Event
-# Input text  name=form.widgets.IDublinCore.title  ${title}
-# Click Button  Save
-# Wait until page contains  Item created
 
 a file
   [Arguments]  ${title}
@@ -59,11 +44,6 @@ a folder
   [Arguments]  ${title}
   [Return]  ${uid}
   ${uid} =  Create content  type=Folder  title=${title}
-# Go to  ${PLONE_URL}/++add++Folder
-# Wait until page contains  Add Folder
-# Input text  name=form.widgets.IDublinCore.title  ${title}
-# Click Button  Save
-# Wait until page contains  Item created
 
 a image
   [Arguments]  ${title}
@@ -78,18 +58,13 @@ a link
   [Arguments]  ${title}
   [Return]  ${uid}
   ${uid} =  Create content  type=Link  title=${title}
-# Go to  ${PLONE_URL}/++add++Link
-# Wait until page contains  Add Link
-# Input text  name=form.widgets.IDublinCore.title  ${title}
-# Click Button  Save
-# Wait until page contains  Item created
+
 
 a news item
   [Arguments]  ${title}
   Go to  ${PLONE_URL}/++add++News Item
   Wait until page contains  Add News Item
   Input text  name=form.widgets.IDublinCore.title  ${title}
-  fill in metadata
   Click Button  Save
   Wait until page contains  Item created
 
@@ -117,21 +92,6 @@ the collection should not contain
   Go to  ${PLONE_URL}/my-collection
   The content area should not contain  ${title}
 
-fill in metadata
-  Click Link  Categorization
-  Input text  name=form.widgets.IDublinCore.subjects  testcreated\nrobot
-  Click Link  Dates
-  ${currentyear}=  Get Time  year
-  fill date field  form.widgets.IDublinCore.effective  2009  January  1
-  fill date field  form.widgets.IDublinCore.expires  2017  December  12
-  Click Link  Ownership
-  Input text  name=form.widgets.IDublinCore.creators  another_creator
-  Input text  name=form.widgets.IDublinCore.contributors  contributor1\ncontributor2
-  Input text  name=form.widgets.IDublinCore.rights  Copyright\nstatement\nhere
-  Click Link  Settings
-  Select from List  name=form.widgets.IAllowDiscussion.allow_discussion:list  Yes
-  Select Checkbox  name=form.widgets.IExcludeFromNavigation.exclude_from_nav:list
-
 fill date field
   [Arguments]  ${fieldid}  ${year}=2012  ${month}=January  ${day}=10
   [Documentation]  Fill in the specified date field (such as effective/expiration date in the "dates" metadata tab) with the specified date.
@@ -145,9 +105,10 @@ I set the criteria ${type} in row ${number} to the option '${label}'
   ${criteria_row} =  Convert to String  .querystring-criteria-wrapper:nth-child(${number})
   Wait until page contains element  css=${criteria_row} .querystring-criteria-${type} .select2-choice
   Click Element  css=${criteria_row} .querystring-criteria-${type} .select2-choice
-  Wait until page contains element  css=.select2-input.select2-focused
-  Input text  css=.select2-input.select2-focused  ${label}\n
-# Click Element  xpath=//div[@class='select2-result-label']/descendant-or-self::*[contains(text(), '${label}')]
+  Wait until element is visible  css=#select2-drop input
+  Input Text  css=#select2-drop input  ${label}
+  Wait until element is visible  css=#select2-drop .select2-match
+  Click Element  css=#select2-drop .select2-match
 
 I set the criteria ${type} in row ${number} to the options '${label}'
   ${criteria_row} =  Convert to String  .querystring-criteria-wrapper:nth-child(${number})
diff --git a/plone/app/contenttypes/tests/robot/test_collection_creator_criterion.robot b/plone/app/contenttypes/tests/robot/test_collection_creator_criterion.robot
index 6135aca..e2dac77 100644
--- a/plone/app/contenttypes/tests/robot/test_collection_creator_criterion.robot
+++ b/plone/app/contenttypes/tests/robot/test_collection_creator_criterion.robot
@@ -1,3 +1,13 @@
+# ============================================================================
+# Tests for the Collection Creator Criterion
+# ============================================================================
+#
+# $ bin/robot-server --reload-path src/plone.app.contenttypes plone.app.contenttypes.testing.PLONE_APP_CONTENTTYPES_ROBOT_TESTING
+#
+# $ bin/robot src/plone.app.contenttypes/plone/app/contenttypes/tests/robot/test_collection_creator_criterion.robot
+#
+# ============================================================================
+
 *** Settings *****************************************************************
 
 Resource  plone/app/robotframework/keywords.robot
@@ -38,9 +48,9 @@ a test user document
 
 I set the collection's creator criterion to
     [Arguments]  ${criterion}
-    Go to  ${PLONE_URL}/my-collection
-    Click Edit
+    Go to  ${PLONE_URL}/my-collection/edit
     Wait until page contains  Edit Collection
+
     I set the criteria index in row 1 to the option 'Creator'
     I set the criteria operator in row 1 to the option 'Is'
     I set the criteria value in row 1 to the text '${criterion}'
diff --git a/plone/app/contenttypes/tests/robot/test_collection_location_criterion.robot b/plone/app/contenttypes/tests/robot/test_collection_location_criterion.robot
index 8259f7b..80ebfbd 100644
--- a/plone/app/contenttypes/tests/robot/test_collection_location_criterion.robot
+++ b/plone/app/contenttypes/tests/robot/test_collection_location_criterion.robot
@@ -1,4 +1,14 @@
-*** Settings ***
+# ============================================================================
+# Tests for the Collection Location Criterion
+# ============================================================================
+#
+# $ bin/robot-server --reload-path src/plone.app.contenttypes plone.app.contenttypes.testing.PLONE_APP_CONTENTTYPES_ROBOT_TESTING
+#
+# $ bin/robot src/plone.app.contenttypes/plone/app/contenttypes/tests/robot/test_collection_location_criterion.robot
+#
+# ============================================================================
+
+*** Settings *****************************************************************
 
 Resource  plone/app/robotframework/keywords.robot
 Resource  plone/app/contenttypes/tests/robot/keywords.txt
@@ -8,9 +18,8 @@ Variables  plone/app/contenttypes/tests/robot/variables.py
 Test Setup  Run keywords  Open test browser
 Test Teardown  Close all browsers
 
-*** Variables ***
 
-*** Test cases ***
+*** Test cases ***************************************************************
 
 Scenario: Test Relative Location Criterion
     Given I am logged in as site owner
@@ -32,7 +41,7 @@ Scenario: Test Absolute Location Criterion
       And the collection should not contain  Document outside Folder
 
 
-*** Keywords ***
+*** Keywords *****************************************************************
 
 a folder '${folder-id}' with a document '${document-title}'
     Go to  ${PLONE_URL}/++add++Folder
@@ -47,8 +56,8 @@ a folder '${folder-id}' with a document '${document-title}'
 
 I set the collection's relative location criterion to
     [Arguments]  ${criterion}
-    Go to  ${PLONE_URL}/my-collection
-    Click Edit
+    Go to  ${PLONE_URL}/my-collection/edit
+    Wait until page contains  Edit Collection
 
     I set the criteria index in row 1 to the option 'Location'
     I set the criteria operator in row 1 to the option 'Relative path'
@@ -59,8 +68,8 @@ I set the collection's relative location criterion to
 
 I set the collection's absolute location criterion to
     [Arguments]  ${criterion}
-    Go to  ${PLONE_URL}/my-collection
-    Click Edit
+    Go to  ${PLONE_URL}/my-collection/edit
+    Wait until page contains  Edit Collection
 
     I set the criteria index in row 1 to the option 'Location'
     I set the criteria operator in row 1 to the option 'Absolute path'
diff --git a/plone/app/contenttypes/tests/robot/test_collection_review_state_criterion.robot b/plone/app/contenttypes/tests/robot/test_collection_review_state_criterion.robot
index 8562f50..37c91d2 100644
--- a/plone/app/contenttypes/tests/robot/test_collection_review_state_criterion.robot
+++ b/plone/app/contenttypes/tests/robot/test_collection_review_state_criterion.robot
@@ -1,4 +1,14 @@
-*** Settings ***
+# ============================================================================
+# Tests for the Collection Type Criterion
+# ============================================================================
+#
+# $ bin/robot-server --reload-path src/plone.app.contenttypes plone.app.contenttypes.testing.PLONE_APP_CONTENTTYPES_ROBOT_TESTING
+#
+# $ bin/robot src/plone.app.contenttypes/plone/app/contenttypes/tests/robot/test_collection_review_state_criterion.robot
+#
+# ============================================================================
+
+*** Settings *****************************************************************
 
 Resource  plone/app/robotframework/keywords.robot
 Resource  plone/app/contenttypes/tests/robot/keywords.txt
@@ -6,9 +16,8 @@ Resource  plone/app/contenttypes/tests/robot/keywords.txt
 Test Setup  Run keywords  Open test browser
 Test Teardown  Close all browsers
 
-*** Variables ***
 
-*** Test cases ***
+*** Test cases ***************************************************************
 
 Scenario: Test Review state Criterion
     Given I am logged in as site owner
@@ -20,7 +29,7 @@ Scenario: Test Review state Criterion
       And the collection should not contain  Published Document
 
 
-*** Keywords ***
+*** Keywords *****************************************************************
 
 a published document
     [Arguments]  ${title}
@@ -33,8 +42,8 @@ a private document
 
 I set the collection's review state criterion to
     [Arguments]  ${criterion}
-    Go to  ${PLONE_URL}/my-collection
-    Click Edit
+    Go to  ${PLONE_URL}/my-collection/edit
+    Wait until page contains  Edit Collection
 
     I set the criteria index in row 1 to the option 'Review state'
     I set the criteria operator in row 1 to the option 'Is'
diff --git a/plone/app/contenttypes/tests/robot/test_collection_short_name_criterion.robot b/plone/app/contenttypes/tests/robot/test_collection_short_name_criterion.robot
index ab1e1b6..1c242c3 100644
--- a/plone/app/contenttypes/tests/robot/test_collection_short_name_criterion.robot
+++ b/plone/app/contenttypes/tests/robot/test_collection_short_name_criterion.robot
@@ -1,4 +1,14 @@
-*** Settings ***
+# ============================================================================
+# Tests for the Collection Short Name Criterion
+# ============================================================================
+#
+# $ bin/robot-server --reload-path src/plone.app.contenttypes plone.app.contenttypes.testing.PLONE_APP_CONTENTTYPES_ROBOT_TESTING
+#
+# $ bin/robot src/plone.app.contenttypes/plone/app/contenttypes/tests/robot/test_collection_short_name_criterion.robot
+#
+# ============================================================================
+
+*** Settings *****************************************************************
 
 Resource  plone/app/robotframework/keywords.robot
 Resource  plone/app/contenttypes/tests/robot/keywords.txt
@@ -6,9 +16,8 @@ Resource  plone/app/contenttypes/tests/robot/keywords.txt
 Test Setup  Run keywords  Open test browser
 Test Teardown  Close all browsers
 
-*** Variables ***
 
-*** Test cases ***
+*** Test cases ***************************************************************
 
 Test Short name (id) Criterion
     Given I am logged in as site owner
@@ -20,12 +29,12 @@ Test Short name (id) Criterion
       And the collection should not contain  Second Document
 
 
-*** Keywords ***
+*** Keywords *****************************************************************
 
 I set the collection short name (id) criterion to
     [Arguments]  ${criterion}
-    Go to  ${PLONE_URL}/my-collection
-    Click Edit
+    Go to  ${PLONE_URL}/my-collection/edit
+    Wait until page contains  Edit Collection
 
     I set the criteria index in row 1 to the option 'Short name'
     I set the criteria operator in row 1 to the option 'Is'
diff --git a/plone/app/contenttypes/tests/robot/test_collection_type_criterion.robot b/plone/app/contenttypes/tests/robot/test_collection_type_criterion.robot
index 2ac2c36..328a601 100644
--- a/plone/app/contenttypes/tests/robot/test_collection_type_criterion.robot
+++ b/plone/app/contenttypes/tests/robot/test_collection_type_criterion.robot
@@ -1,4 +1,14 @@
-*** Settings ***
+# ============================================================================
+# Tests for the Collection Type Criterion
+# ============================================================================
+#
+# $ bin/robot-server --reload-path src/plone.app.contenttypes plone.app.contenttypes.testing.PLONE_APP_CONTENTTYPES_ROBOT_TESTING
+#
+# $ bin/robot src/plone.app.contenttypes/plone/app/contenttypes/tests/robot/test_collection_type_criterion.robot
+#
+# ============================================================================
+
+*** Settings *****************************************************************
 
 Resource  plone/app/robotframework/keywords.robot
 Resource  plone/app/contenttypes/tests/robot/keywords.txt
@@ -6,9 +16,8 @@ Resource  plone/app/contenttypes/tests/robot/keywords.txt
 Test Setup  Run keywords  Open test browser
 Test Teardown  Close all browsers
 
-*** Variables ***
 
-*** Test cases ***
+*** Test cases ***************************************************************
 
 Test Type Criterion
     Given I am logged in as site owner
@@ -20,12 +29,12 @@ Test Type Criterion
       And the collection should not contain  Test Document
 
 
-*** Keywords ***
+*** Keywords *****************************************************************
 
 I set the collection's type criterion to
     [Arguments]  ${criterion}
-    Go to  ${PLONE_URL}/my-collection
-    Click Edit
+    Go to  ${PLONE_URL}/my-collection/edit
+    Wait until page contains  Edit Collection
 
     I set the criteria index in row 1 to the option 'Type'
     I set the criteria operator in row 1 to the option 'Is'
diff --git a/plone/app/contenttypes/tests/robot/test_folderlisting.robot b/plone/app/contenttypes/tests/robot/test_folderlisting.robot
index ff27d81..c15fed7 100644
--- a/plone/app/contenttypes/tests/robot/test_folderlisting.robot
+++ b/plone/app/contenttypes/tests/robot/test_folderlisting.robot
@@ -5,37 +5,194 @@ Resource  plone/app/contenttypes/tests/robot/keywords.txt
 
 Variables  plone/app/contenttypes/tests/robot/variables.py
 
-Test Setup  Run keywords  Open test browser
+Test Setup  Run keywords  Setup Testcontent  Open test browser
 Test Teardown  Close all browsers
 
 *** Variables ***
 
 *** Test cases ***
 
-# XXX: This test needs to be refactored. The test should use robot content
-# keywords and is way too long.
-Scenario: Test Folderlisting
+Scenario: Test listing views
     Given I am logged in as site owner
-      And a Folder  Test-Folder
-      And a File  Test-File
-      And a Image  Test-Image
-      And a Collection  Test-Collection
-      And a Link  Test-Link
-      And a News Item  Test-News
-      And a Document  Test-Document
-     When I Go to  ${PLONE_URL}/folder_contents
-     Then Page Should Contain  Test-Folder
-      And Page Should Contain  Test-File
-      And Page Should Contain  Test-Image
-      And Page Should Contain  Test-Collection
-      And Page Should Contain  Test-Link
-      And Page Should Contain  Test-News
-      And Page Should Contain  Test-Document
+
+    When I Go to  ${PLONE_URL}/${TEST_FOLDER_ID}/listing_view
+    Then Listing should list contained content
+
+    When I Go to  ${PLONE_URL}/${TEST_FOLDER_ID}/summary_view
+    Then Listing should list contained content
+
+    When I Go to  ${PLONE_URL}/${TEST_FOLDER_ID}/tabular_view
+    Then Listing should list contained content
+
+    When I Go to  ${PLONE_URL}/${TEST_FOLDER_ID}/full_view
+    Then Listing should list contained content in detail
+
+    When I Go to  ${PLONE_URL}/${TEST_FOLDER_ID}/test_album/album_view
+    Then Album should list contained images and albums
+
+
+    When I Go to  ${PLONE_URL}/${TEST_FOLDER_ID}/test_collection/listing_view
+    Then Listing should list all content
+
+    When I Go to  ${PLONE_URL}/${TEST_FOLDER_ID}/test_collection/summary_view
+    Then Listing should list all content
+
+    When I Go to  ${PLONE_URL}/${TEST_FOLDER_ID}/test_collection/tabular_view
+    Then Listing should list all content
+
+    When I Go to  ${PLONE_URL}/${TEST_FOLDER_ID}/test_collection/full_view
+    Then Listing should list all content in detail
+
+    When I Go to  ${PLONE_URL}/${TEST_FOLDER_ID}/test_collection/album_view
+    Then Album should list all images and albums
 
 
 *** Keywords ***
 
+Listing should list contained content
+  Page Should Contain  Test Document
+  Page Should Contain  Test News Item
+  Page Should Contain  Test Event
+  Page Should Contain  Test Collection
+  Page Should Contain  Test Link
+  Page Should Contain  Test File
+  Page Should Contain  Test Image
+  Page Should Contain  Test Album
+  Page Should Not Contain  Test Album Image 1
+  Page Should Not Contain  Test Album Image 2
+  Page Should Not Contain  Test Album Image 3
+  Page Should Not Contain  Test Sub Album
+  Page Should Not Contain  Test Sub Album Image 1
+  Page Should Not Contain  Test Sub Album Image 2
+  Page Should Not Contain  Test Sub Album Image 3
+
+Listing should list contained content in detail
+  Page Should Contain  Test Document
+  Page Should Contain  this is a test document
+  Page Should Contain  Test News Item
+  Page Should Contain  this is a test news item
+  Xpath Should Match X Times  //img[@title="Test News Item"]  1
+  Page Should Contain  Test Event
+  Page Should Contain  this is a test event
+  Page Should Contain  Test Collection
+  Page Should Contain  this is a test collection
+  Page Should Contain  Test Link
+  Page Should Contain  http://plone.org
+  Page Should Contain  Test File
+  Page Should Contain  file.pdf
+  Page Should Contain  Test Image
+  Xpath Should Match X Times  //img[@title="Test Image"]  1
+  Page Should Contain  Test Album
+  Page Should Contain  Test Album Image 1
+  Xpath Should Match X Times  //img[@title="Test Album Image 1"]  0
+  Page Should Contain  Test Album Image 2
+  Xpath Should Match X Times  //img[@title="Test Album Image 2"]  0
+  Page Should Contain  Test Album Image 3
+  Xpath Should Match X Times  //img[@title="Test Album Image 3"]  0
+  Page Should Contain  Test Sub Album
+  Page Should Contain  Test Sub Album Image 1
+  Xpath Should Match X Times  //img[@title="Test Sub Album Image 1"]  0
+  Page Should Contain  Test Sub Album Image 2
+  Xpath Should Match X Times  //img[@title="Test Sub Album Image 2"]  0
+  Page Should Contain  Test Sub Album Image 3
+  Xpath Should Match X Times  //img[@title="Test Sub Album Image 3"]  0
+
+Album should list contained images and albums
+  Page Should Contain  Test Album Image 1
+  Xpath Should Match X Times  //img[@title="Test Album Image 1"]  1
+  Page Should Contain  Test Album Image 2
+  Xpath Should Match X Times  //img[@title="Test Album Image 2"]  1
+  Page Should Contain  Test Album Image 3
+  Xpath Should Match X Times  //img[@title="Test Album Image 3"]  1
+  Page Should Contain  Test Sub Album
+
+
+Listing should list all content
+  Page Should Contain  Test Document
+  Page Should Contain  Test News Item
+  Page Should Contain  Test Event
+  Page Should Contain  Test Collection
+  Page Should Contain  Test Link
+  Page Should Contain  Test File
+  Page Should Contain  Test Image
+  Page Should Contain  Test Album
+  Page Should Contain  Test Album Image 1
+  Page Should Contain  Test Album Image 2
+  Page Should Contain  Test Album Image 3
+  Page Should Contain  Test Sub Album
+  Page Should Contain  Test Sub Album Image 1
+  Page Should Contain  Test Sub Album Image 2
+  Page Should Contain  Test Sub Album Image 3
+
+Listing should list all content in detail
+  Page Should Contain  Test Document
+  Page Should Contain  this is a test document
+  Page Should Contain  Test News Item
+  Page Should Contain  this is a test news item
+  Xpath Should Match X Times  //img[@title="Test News Item"]  1
+  Page Should Contain  Test Event
+  Page Should Contain  this is a test event
+  Page Should Contain  Test Collection
+  Page Should Contain  this is a test collection
+  Page Should Contain  Test Link
+  Page Should Contain  http://plone.org
+  Page Should Contain  Test File
+  Page Should Contain  file.pdf
+  Page Should Contain  Test Image
+  Xpath Should Match X Times  //img[@title="Test Image"]  1
+  Page Should Contain  Test Album
+  Page Should Contain  Test Album Image 1
+  Xpath Should Match X Times  //img[@title="Test Album Image 1"]  1
+  Page Should Contain  Test Album Image 2
+  Xpath Should Match X Times  //img[@title="Test Album Image 2"]  1
+  Page Should Contain  Test Album Image 3
+  Xpath Should Match X Times  //img[@title="Test Album Image 3"]  1
+  Page Should Contain  Test Sub Album
+  Page Should Contain  Test Sub Album Image 1
+  Xpath Should Match X Times  //img[@title="Test Sub Album Image 1"]  1
+  Page Should Contain  Test Sub Album Image 2
+  Xpath Should Match X Times  //img[@title="Test Sub Album Image 2"]  1
+  Page Should Contain  Test Sub Album Image 3
+  Xpath Should Match X Times  //img[@title="Test Sub Album Image 3"]  1
+
+Album should list all images and albums
+  Page Should Contain  Test Image
+  Xpath Should Match X Times  //img[@title="Test Image"]  2
+  Page Should Contain  Test Album Image 1
+  Xpath Should Match X Times  //div[@class="photoAlbumEntry" and not(@class="photoAlbumFolder")]//img[@title="Test Album Image 1"]  1
+  Page Should Contain  Test Album Image 2
+  Xpath Should Match X Times  //div[@class="photoAlbumEntry" and not(@class="photoAlbumFolder")]//img[@title="Test Album Image 2"]  1
+  Page Should Contain  Test Album Image 3
+  Xpath Should Match X Times  //div[@class="photoAlbumEntry" and not(@class="photoAlbumFolder")]//img[@title="Test Album Image 3"]  1
+  Page Should Contain  Test Sub Album Image 1
+  Xpath Should Match X Times  //div[@class="photoAlbumEntry" and not(@class="photoAlbumFolder")]//img[@title="Test Sub Album Image 1"]  1
+  Page Should Contain  Test Sub Album Image 2
+  Xpath Should Match X Times  //div[@class="photoAlbumEntry" and not(@class="photoAlbumFolder")]//img[@title="Test Sub Album Image 2"]  1
+  Page Should Contain  Test Sub Album Image 3
+  Xpath Should Match X Times  //div[@class="photoAlbumEntry" and not(@class="photoAlbumFolder")]//img[@title="Test Sub Album Image 3"]  1
+  Page Should Contain  Test Album
+  Page Should Contain  Test Sub Album
+
+
+
+Setup Testcontent
+  Given I am logged in as site owner
+  Create Content  type=Document  container=${PLONE_PATH}/${TEST_FOLDER_ID}  id=test_document  title=Test Document  text=this is a test document
+  Create Content  type=News Item  container=${PLONE_PATH}/${TEST_FOLDER_ID}  id=test_news_item  title=Test News Item  text=this is a test news item
+  Create Content  type=Event  container=${PLONE_PATH}/${TEST_FOLDER_ID}  id=test_event  title=Test Event  text=this is a test event
+  Create Content  type=Collection  container=${PLONE_PATH}/${TEST_FOLDER_ID}  id=test_collection  title=Test Collection  query=${COLLECTION_TEST_QUERY}  text=this is a test collection
+  Create Content  type=Link  container=${PLONE_PATH}/${TEST_FOLDER_ID}  id=test_link  title=Test Link  remoteUrl=http://plone.org
+  Create Content  type=File  container=${PLONE_PATH}/${TEST_FOLDER_ID}  id=test_file  title=Test File
+  Create Content  type=Image  container=${PLONE_PATH}/${TEST_FOLDER_ID}  id=test_image  title=Test Image
+  Create Content  type=Folder  container=${PLONE_PATH}/${TEST_FOLDER_ID}  id=test_album  title=Test Album
+  Create Content  type=Image  container=${PLONE_PATH}/${TEST_FOLDER_ID}/test_album  id=album_image_1  title=Test Album Image 1
+  Create Content  type=Image  container=${PLONE_PATH}/${TEST_FOLDER_ID}/test_album  id=album_image_2  title=Test Album Image 2
+  Create Content  type=Image  container=${PLONE_PATH}/${TEST_FOLDER_ID}/test_album  id=album_image_3  title=Test Album Image 3
+  Create Content  type=Folder  container=${PLONE_PATH}/${TEST_FOLDER_ID}/test_album  id=test_subalbum  title=Test Sub Album
+  Create Content  type=Image  container=${PLONE_PATH}/${TEST_FOLDER_ID}/test_album/test_subalbum  id=subalbum_image_1  title=Test Sub Album Image 1
+  Create Content  type=Image  container=${PLONE_PATH}/${TEST_FOLDER_ID}/test_album/test_subalbum  id=subalbum_image_2  title=Test Sub Album Image 2
+  Create Content  type=Image  container=${PLONE_PATH}/${TEST_FOLDER_ID}/test_album/test_subalbum  id=subalbum_image_3  title=Test Sub Album Image 3
+
 I go to
     [Arguments]  ${location}
     Go to  ${location}
-    Wait until page contains  Test-Document
diff --git a/plone/app/contenttypes/tests/robot/variables.py b/plone/app/contenttypes/tests/robot/variables.py
index 7310966..757ff22 100644
--- a/plone/app/contenttypes/tests/robot/variables.py
+++ b/plone/app/contenttypes/tests/robot/variables.py
@@ -2,4 +2,6 @@
 from pkg_resources import resource_filename
 
 TEST_FOLDER_ID = 'robot-test-folder'
+PLONE_PATH = '/plone'
+COLLECTION_TEST_QUERY = '[{"i": "path", "o": "plone.app.querystring.operation.string.path", "v": "%s/%s"}]' % (PLONE_PATH, TEST_FOLDER_ID)  # noqa
 PATH_TO_TEST_FILES = resource_filename("plone.app.contenttypes.tests", "")
diff --git a/plone/app/contenttypes/tests/test_behaviors_collection.py b/plone/app/contenttypes/tests/test_behaviors_collection.py
index 3354f25..2c2cadc 100644
--- a/plone/app/contenttypes/tests/test_behaviors_collection.py
+++ b/plone/app/contenttypes/tests/test_behaviors_collection.py
@@ -72,12 +72,13 @@ def _get_browser(self):
         )
         return browser
 
-    def test_collection_view(self):
+    def test_collection_default_dexterity_view(self):
+        # Test the default dexterity view
         browser = self._get_browser()
         browser.open(self.portal_url + '/collectioncontainer/view')
         self.assertTrue('"v": "Collection Test Page"' in browser.contents)
 
-    def test_tabular_view(self):
+    def test_collection_tabular_view(self):
         browser = self._get_browser()
         browser.open(self.portal_url + '/collectioncontainer/tabular_view')
         # search from here:
diff --git a/plone/app/contenttypes/tests/test_collection.py b/plone/app/contenttypes/tests/test_collection.py
index 3efdf42..30e0f1d 100644
--- a/plone/app/contenttypes/tests/test_collection.py
+++ b/plone/app/contenttypes/tests/test_collection.py
@@ -1,35 +1,28 @@
 # -*- coding: utf-8 -*-
 from Acquisition import aq_inner
 from DateTime import DateTime
-
-import unittest2 as unittest
-
-from zope.component import createObject
-from zope.component import queryUtility
-from zope.interface import alsoProvides
-from transaction import commit
-
-from plone.dexterity.interfaces import IDexterityFTI
-
-from plone.app.contenttypes.testing import \
-    PLONE_APP_CONTENTTYPES_INTEGRATION_TESTING
-from plone.app.contenttypes.testing import \
-    PLONE_APP_CONTENTTYPES_FUNCTIONAL_TESTING
-
-from plone.app.testing import SITE_OWNER_NAME
-from plone.app.testing import SITE_OWNER_PASSWORD
-
-from plone.testing.z2 import Browser
-from plone.app.testing import TEST_USER_ID, TEST_USER_NAME, \
-    setRoles, login, logout
-
+from plone.app.contenttypes.behaviors.collection import ICollection as ICollection_behavior  # noqa
 from plone.app.contenttypes.interfaces import ICollection
-from plone.app.contenttypes.behaviors.collection import ICollection as \
-    ICollection_behavior
-
+from plone.app.contenttypes.testing import PLONE_APP_CONTENTTYPES_FUNCTIONAL_TESTING  # noqa
+from plone.app.contenttypes.testing import PLONE_APP_CONTENTTYPES_INTEGRATION_TESTING  # noqa
+from plone.app.contenttypes.testing import set_browserlayer
 from plone.app.layout.navigation.interfaces import INavigationRoot
+from plone.app.testing import SITE_OWNER_NAME
+from plone.app.testing import SITE_OWNER_PASSWORD
+from plone.app.testing import TEST_USER_ID
+from plone.app.testing import TEST_USER_NAME
+from plone.app.testing import login
+from plone.app.testing import logout
+from plone.app.testing import setRoles
 from plone.app.textfield.value import RichTextValue
+from plone.dexterity.interfaces import IDexterityFTI
+from plone.testing.z2 import Browser
+from transaction import commit
+from zope.component import createObject
+from zope.component import queryUtility
+from zope.interface import alsoProvides
 import os.path
+import unittest2 as unittest
 
 query = [{
     'i': 'Title',
@@ -65,14 +58,15 @@ def test_results(self):
         pass
 
     def test_bbb_selectedViewFields(self):
-        self.assertEqual(self.collection.selectedViewFields(), [])
+        self.assertEqual(
+            self.collection.selectedViewFields(),
+            [('Title', 'Title'), ('Creator', 'Creator'),
+             ('Type', 'Type'), ('ModificationDate', 'ModificationDate')]
+        )
         self.collection.customViewFields = ['Title', 'Description']
         self.assertEqual(self.collection.selectedViewFields(),
                          [('Title', 'Title'), ('Description', 'Description')])
 
-    def test_getFoldersAndImages(self):
-        pass
-
     def test_bbb_setQuery(self):
         self.collection.setQuery(query)
         self.assertEqual(self.collection.query, query)
@@ -139,6 +133,7 @@ def setUp(self):
         self.browser = Browser(self.layer['app'])
         self.portal = self.layer['portal']
         self.request = self.layer['request']
+        set_browserlayer(self.request)
         setRoles(self.portal, TEST_USER_ID, ['Manager'])
         login(self.portal, TEST_USER_NAME)
         self.portal.invokeFactory('Folder', 'test-folder')
@@ -149,33 +144,33 @@ def setUp(self):
         self.request.set('URL', self.collection.absolute_url())
         self.request.set('ACTUAL_URL', self.collection.absolute_url())
 
-    def test_view(self):
+    def test_collection_view(self):
         view = self.collection.restrictedTraverse('@@view')
         self.assertTrue(view())
         self.assertEqual(view.request.response.status, 200)
 
-    def test_standard_view(self):
-        view = self.collection.restrictedTraverse('standard_view')
+    def test_collection_listing_view(self):
+        view = self.collection.restrictedTraverse('listing_view')
         self.assertTrue(view())
         self.assertEqual(view.request.response.status, 200)
 
-    def test_summary_view(self):
+    def test_collection_summary_view(self):
         view = self.collection.restrictedTraverse('summary_view')
         self.assertTrue(view())
         self.assertEqual(view.request.response.status, 200)
 
-    def test_all_content(self):
-        view = self.collection.restrictedTraverse('all_content')
+    def test_collection_full_view(self):
+        view = self.collection.restrictedTraverse('full_view')
         self.assertTrue(view())
         self.assertEqual(view.request.response.status, 200)
 
-    def test_tabular_view(self):
+    def test_collection_tabular_view(self):
         view = self.collection.restrictedTraverse('tabular_view')
         self.assertTrue(view())
         self.assertEqual(view.request.response.status, 200)
 
-    def test_thumbnail_view(self):
-        view = self.collection.restrictedTraverse('thumbnail_view')
+    def test_collection_album_view(self):
+        view = self.collection.restrictedTraverse('album_view')
         self.assertTrue(view())
         self.assertEqual(view.request.response.status, 200)
 
@@ -252,8 +247,8 @@ def test_collection_templates(self):
         self.assertTrue("Lorem collection ipsum" in browser.contents)
         self.assertTrue("Image example" in browser.contents)
 
-        # open all_content template
-        browser.open('%s/@@all_content' % url)
+        # open full_view template
+        browser.open('%s/@@full_view' % url)
         self.assertTrue("Lorem collection ipsum" in browser.contents)
         self.assertTrue("Image example" in browser.contents)
 
@@ -263,7 +258,7 @@ def test_collection_templates(self):
         self.assertTrue("Image example" in browser.contents)
 
         # open thumbnail_view template
-        browser.open('%s/@@thumbnail_view' % url)
+        browser.open('%s/@@album_view' % url)
         self.assertTrue("Lorem collection ipsum" in browser.contents)
         self.assertTrue("Image example" in browser.contents)
 
@@ -358,79 +353,6 @@ def test_custom_query(self):
                                                 'id': 'bla'})
         self.assertEqual(len(results), 0)
 
-    def test_getFoldersAndImages(self):
-        portal = self.layer['portal']
-        login(portal, 'admin')
-        # add a collection, so we can add a query to it
-        portal.invokeFactory("Collection",
-                             "collection",
-                             title="New Collection")
-
-        # add example folder and a subfolder to it, both with same id
-        portal.invokeFactory("Folder",
-                             "folder1",
-                             title="Folder1")
-        folder = portal['folder1']
-
-        folder.invokeFactory("Folder",
-                             "folder1",
-                             title="Folder1")
-        subfolder = folder['folder1']
-        # add example image into folder and its subfolder
-        folder.invokeFactory("Image",
-                             "image",
-                             title="Image example")
-
-        subfolder.invokeFactory("Image",
-                                "another_image",
-                                title="Image example")
-        query = [{
-            'i': 'Type',
-            'o': 'plone.app.querystring.operation.string.is',
-            'v': 'Folder',
-        }]
-        collection = portal['collection']
-        wrapped = ICollection_behavior(collection)
-        wrapped.query = query
-        imagecount = wrapped.getFoldersAndImages()['total_number_of_images']
-        # The current implementation for getFoldersAndImages will return
-        # another_image under subfolder and also under folder
-        self.assertEqual(imagecount, 3)
-
-    def test_getFoldersAndImages_returning_images(self):
-        portal = self.layer['portal']
-        login(portal, 'admin')
-        # add a collection, so we can add a query to it
-        portal.invokeFactory("Collection",
-                             "collection",
-                             title="New Collection")
-
-        # add example folder
-        portal.invokeFactory("Folder",
-                             "folder1",
-                             title="Folder1")
-        folder = portal['folder1']
-
-        # add example image into this folder
-        folder.invokeFactory("Image",
-                             "image",
-                             title="Image example")
-
-        # add another image into the portal root
-        portal.invokeFactory("Image",
-                             "image",
-                             title="Image example")
-        query = [{
-            'i': 'Type',
-            'o': 'plone.app.querystring.operation.string.is',
-            'v': 'Image',
-        }]
-        collection = portal['collection']
-        wrapped = ICollection_behavior(collection)
-        wrapped.query = query
-        imagecount = wrapped.getFoldersAndImages()['total_number_of_images']
-        self.assertEqual(imagecount, 2)
-
     def test_respect_navigation_root(self):
         portal = self.layer['portal']
         login(portal, 'admin')
@@ -480,6 +402,7 @@ class PloneAppCollectionEditViewsIntegrationTest(unittest.TestCase):
     def setUp(self):
         self.portal = self.layer['portal']
         self.request = self.layer['request']
+        set_browserlayer(self.request)
         setRoles(self.portal, TEST_USER_ID, ['Manager'])
         login(self.portal, TEST_USER_NAME)
         self.portal.invokeFactory('Folder', 'test-folder')
diff --git a/plone/app/contenttypes/tests/test_document.py b/plone/app/contenttypes/tests/test_document.py
index abe074d..947c531 100644
--- a/plone/app/contenttypes/tests/test_document.py
+++ b/plone/app/contenttypes/tests/test_document.py
@@ -1,27 +1,22 @@
 # -*- coding: utf-8 -*-
-import unittest2 as unittest
-
-from zope.interface import alsoProvides
-from zope.component import createObject
-from zope.component import queryUtility
-
-from plone.dexterity.interfaces import IDexterityFTI
-
-from plone.app.testing import SITE_OWNER_NAME
-from plone.app.testing import SITE_OWNER_PASSWORD
-from plone.testing.z2 import Browser
-
-from plone.app.textfield.value import RichTextValue
-
 from plone.app.contenttypes.interfaces import IDocument
-
-from plone.app.contenttypes.testing import (
-    PLONE_APP_CONTENTTYPES_INTEGRATION_TESTING,
+from plone.app.contenttypes.testing import \
     PLONE_APP_CONTENTTYPES_FUNCTIONAL_TESTING
-)
-
+from plone.app.contenttypes.testing import \
+    PLONE_APP_CONTENTTYPES_INTEGRATION_TESTING
+from plone.app.testing import SITE_OWNER_NAME
+from plone.app.testing import SITE_OWNER_PASSWORD
 from plone.app.testing import TEST_USER_ID, setRoles
+from plone.app.textfield.value import RichTextValue
 from plone.app.z3cform.interfaces import IPloneFormLayer
+from plone.dexterity.interfaces import IDexterityFTI
+from plone.testing.z2 import Browser
+from zope.component import createObject
+from zope.component import queryUtility
+from zope.interface import alsoProvides
+
+import transaction
+import unittest2 as unittest
 
 
 class DocumentIntegrationTest(unittest.TestCase):
@@ -78,12 +73,17 @@ def test_view(self):
         self.request.set('ACTUAL_URL', document.absolute_url())
         alsoProvides(self.request, IPloneFormLayer)
         view = document.restrictedTraverse('@@view')
-
-        self.assertTrue(view())
         self.assertEqual(view.request.response.status, 200)
-        self.assertTrue('My Document' in view())
-        self.assertTrue('This is my document.' in view())
-        self.assertTrue('Lorem ipsum' in view())
+        output = view()
+        self.assertTrue(output)
+        self.assertTrue('My Document' in output)
+        self.assertTrue('This is my document.' in output)
+        self.assertTrue('Lorem ipsum' in output)
+
+    def tearDown(self):
+        if 'document' in self.portal.objectIds():
+            self.portal.manage_delObjects(ids='document')
+            transaction.commit()
 
 
 class DocumentFunctionalTest(unittest.TestCase):
diff --git a/plone/app/contenttypes/tests/test_file.py b/plone/app/contenttypes/tests/test_file.py
index ca359e6..b31fd86 100644
--- a/plone/app/contenttypes/tests/test_file.py
+++ b/plone/app/contenttypes/tests/test_file.py
@@ -23,6 +23,9 @@
 from plone.app.testing import TEST_USER_ID, setRoles
 from plone.app.z3cform.interfaces import IPloneFormLayer
 
+from plone.namedfile.file import NamedFile
+from plone.app.contenttypes.interfaces import IPloneAppContenttypesLayer
+
 
 class FileIntegrationTest(unittest.TestCase):
 
@@ -79,6 +82,37 @@ def test_view(self):
         self.assertTrue('My File' in view())
         self.assertTrue('This is my file.' in view())
 
+    def test_view_no_video_audio_tag(self):
+        self.portal.invokeFactory('File', 'file')
+        file = self.portal['file']
+        file.file = NamedFile()
+        file.file.contentType = 'application/pdf'
+        alsoProvides(self.request, IPloneAppContenttypesLayer)
+        view = file.restrictedTraverse('@@file_view')
+        rendered = view()
+        self.assertTrue('</audio>' not in rendered)
+        self.assertTrue('</video>' not in rendered)
+
+    def test_view_video_tag(self):
+        self.portal.invokeFactory('File', 'file')
+        file = self.portal['file']
+        file.file = NamedFile()
+        file.file.contentType = 'audio/mp3'
+        alsoProvides(self.request, IPloneAppContenttypesLayer)
+        view = file.restrictedTraverse('@@file_view')
+        rendered = view()
+        self.assertTrue('</audio>' in rendered)
+
+    def test_view_audio_tag(self):
+        self.portal.invokeFactory('File', 'file')
+        file = self.portal['file']
+        file.file = NamedFile()
+        file.file.contentType = 'video/ogv'
+        alsoProvides(self.request, IPloneAppContenttypesLayer)
+        view = file.restrictedTraverse('@@file_view')
+        rendered = view()
+        self.assertTrue('</video>' in rendered)
+
 
 class FileFunctionalTest(unittest.TestCase):
 
diff --git a/plone/app/contenttypes/tests/test_folder.py b/plone/app/contenttypes/tests/test_folder.py
index a2d9208..424fbbe 100644
--- a/plone/app/contenttypes/tests/test_folder.py
+++ b/plone/app/contenttypes/tests/test_folder.py
@@ -16,6 +16,7 @@
     PLONE_APP_CONTENTTYPES_INTEGRATION_TESTING,
     PLONE_APP_CONTENTTYPES_FUNCTIONAL_TESTING
 )
+from plone.app.contenttypes.tests.test_image import dummy_image
 
 from plone.app.testing import TEST_USER_ID, setRoles
 
@@ -130,21 +131,28 @@ def test_folder_view(self):
         self.assertTrue('Document 1' in self.browser.contents)
 
     def test_folder_summary_view(self):
-        self.browser.open(self.folder_url + '/folder_summary_view')
+        self.browser.open(self.folder_url + '/summary_view')
         self.assertTrue('My Folder' in self.browser.contents)
         self.assertTrue('Document 1' in self.browser.contents)
 
     def test_folder_full_view(self):
-        self.browser.open(self.folder_url + '/folder_full_view')
+        self.browser.open(self.folder_url + '/full_view')
         self.assertTrue('My Folder' in self.browser.contents)
         self.assertTrue('Document 1' in self.browser.contents)
 
     def test_folder_tabular_view(self):
-        self.browser.open(self.folder_url + '/folder_tabular_view')
+        self.browser.open(self.folder_url + '/tabular_view')
         self.assertTrue('My Folder' in self.browser.contents)
         self.assertTrue('Document 1' in self.browser.contents)
 
     def test_folder_album_view(self):
-        self.browser.open(self.folder_url + '/folder_album_view')
+        self.folder.invokeFactory('Image', id='image1', title='Image 1')
+        img1 = self.folder['image1']
+        img1.image = dummy_image()
+        import transaction
+        transaction.commit()
+        self.browser.open(self.folder_url + '/album_view')
         self.assertTrue('My Folder' in self.browser.contents)
-        self.assertTrue('Document 1' in self.browser.contents)
+        self.assertIn(
+            '<img src="http://nohost/plone/folder/image1/@@images',
+            self.browser.contents)
diff --git a/plone/app/contenttypes/tests/test_link.py b/plone/app/contenttypes/tests/test_link.py
index 88d5b45..8a9ee45 100644
--- a/plone/app/contenttypes/tests/test_link.py
+++ b/plone/app/contenttypes/tests/test_link.py
@@ -1,31 +1,23 @@
 # -*- coding: utf-8 -*-
-import unittest2 as unittest
-
 from Products.CMFCore.utils import getToolByName
-
-from zope.interface import alsoProvides
-from zope.component import createObject
-from zope.component import queryUtility
-from zope.component import getMultiAdapter
-from zope.event import notify
-from zope.traversing.interfaces import BeforeTraverseEvent
-
-from plone.dexterity.interfaces import IDexterityFTI
-
+from datetime import datetime
+from plone.app.contenttypes.interfaces import ILink
+from plone.app.contenttypes.testing import PLONE_APP_CONTENTTYPES_FUNCTIONAL_TESTING  # noqa
+from plone.app.contenttypes.testing import PLONE_APP_CONTENTTYPES_INTEGRATION_TESTING  # noqa
 from plone.app.testing import SITE_OWNER_NAME
 from plone.app.testing import SITE_OWNER_PASSWORD
-from plone.app.testing import logout
-from plone.testing.z2 import Browser
-
-from plone.app.contenttypes.interfaces import ILink
-
-from plone.app.contenttypes.testing import (
-    PLONE_APP_CONTENTTYPES_INTEGRATION_TESTING,
-    PLONE_APP_CONTENTTYPES_FUNCTIONAL_TESTING
-)
-
 from plone.app.testing import TEST_USER_ID, setRoles
+from plone.app.testing import logout
 from plone.app.z3cform.interfaces import IPloneFormLayer
+from plone.dexterity.interfaces import IDexterityFTI
+from plone.testing.z2 import Browser
+from zope.component import createObject
+from zope.component import getMultiAdapter
+from zope.component import queryUtility
+from zope.event import notify
+from zope.interface import alsoProvides
+from zope.traversing.interfaces import BeforeTraverseEvent
+import unittest2 as unittest
 
 
 class LinkIntegrationTest(unittest.TestCase):
@@ -162,6 +154,69 @@ def test_link_redirect_view_path_with_variable(self):
         self.assertTrue(view())
         self._assert_redirect('http://nohost/plone/my-folder/my-item')
 
+    def test_mailto_type(self):
+        self.link.remoteUrl = 'mailto:stress@test.us'
+        view = self._get_link_redirect_view(self.link)
+        self._publish(self.link)
+        logout()
+        rendered = view()
+        self.assertTrue('href="mailto:stress@test.us"' in rendered)
+        self._assert_response_OK()
+
+    def test_tel_type(self):
+        self.link.remoteUrl = 'tel:123'
+        view = self._get_link_redirect_view(self.link)
+        self._publish(self.link)
+        logout()
+        rendered = view()
+        self.assertTrue('href="tel:123"' in rendered)
+        self._assert_response_OK()
+
+    def test_callto_type(self):
+        self.link.remoteUrl = 'callto:123'
+        view = self._get_link_redirect_view(self.link)
+        self._publish(self.link)
+        logout()
+        rendered = view()
+        self.assertTrue('href="callto:123"' in rendered)
+        self._assert_response_OK()
+
+    def test_webdav_type(self):
+        self.link.remoteUrl = 'webdav://web.site/resource'
+        view = self._get_link_redirect_view(self.link)
+        self._publish(self.link)
+        logout()
+        rendered = view()
+        self.assertTrue('href="webdav://web.site/resource"' in rendered)
+        self._assert_response_OK()
+
+    def test_caldav_type(self):
+        self.link.remoteUrl = 'caldav://calendar.site/resource'
+        view = self._get_link_redirect_view(self.link)
+        self._publish(self.link)
+        logout()
+        rendered = view()
+        self.assertTrue('href="caldav://calendar.site/resource"' in rendered)
+        self._assert_response_OK()
+
+    def test_file_type(self):
+        self.link.remoteUrl = 'file:///some/file/on/your/system'
+        view = self._get_link_redirect_view(self.link)
+        self._publish(self.link)
+        logout()
+        self.assertTrue(view())
+        self._assert_redirect(self.link.remoteUrl)
+
+    def test_ftp_type(self):
+        self.link.remoteUrl = 'ftp://thereIsNoSuchDomain.isThere{0}'.format(
+            datetime.now().isoformat()
+        )
+        view = self._get_link_redirect_view(self.link)
+        self._publish(self.link)
+        logout()
+        self.assertTrue(view())
+        self._assert_redirect(self.link.remoteUrl)
+
     def _publish(self, obj):
         portal_workflow = getToolByName(self.portal, "portal_workflow")
         portal_workflow.doActionFor(obj, 'publish')
@@ -170,6 +225,9 @@ def _assert_redirect(self, url):
         self.assertEqual(self.response.status, 302)
         self.assertEqual(self.response.headers['location'], url)
 
+    def _assert_response_OK(self):
+        self.assertEqual(self.response.status, 200)
+
     def _get_link_redirect_view(self, obj):
         return getMultiAdapter((obj, self.request), name='link_redirect_view')
 
diff --git a/plone/app/contenttypes/tests/test_migration.py b/plone/app/contenttypes/tests/test_migration.py
index 76e1ff8..b753239 100644
--- a/plone/app/contenttypes/tests/test_migration.py
+++ b/plone/app/contenttypes/tests/test_migration.py
@@ -2,16 +2,25 @@
 from Products.CMFCore.utils import getToolByName
 from five.intid.intid import IntIds
 from five.intid.site import addUtility
-from plone.app.contenttypes.testing import \
-    PLONE_APP_CONTENTTYPES_MIGRATION_TESTING
+from lxml import etree
+from plone.app.contenttypes.migration.utils import add_portlet
+from plone.app.contenttypes.testing import PLONE_APP_CONTENTTYPES_FUNCTIONAL_TESTING  # noqa
+from plone.app.contenttypes.testing import PLONE_APP_CONTENTTYPES_MIGRATION_TESTING  # noqa
 from plone.app.contenttypes.testing import set_browserlayer
+from plone.app.testing import SITE_OWNER_NAME
+from plone.app.testing import SITE_OWNER_PASSWORD
 from plone.app.testing import applyProfile
 from plone.app.testing import login
+from plone.app.z3cform.interfaces import IPloneFormLayer
+from plone.dexterity.content import Container
+from plone.dexterity.interfaces import IDexterityContent
 from plone.event.interfaces import IEventAccessor
+from plone.testing.z2 import Browser
 from zope.annotation.interfaces import IAnnotations
 from zope.component import getMultiAdapter
 from zope.component import getSiteManager
 from zope.component import getUtility
+from zope.interface import alsoProvides
 from zope.intid.interfaces import IIntIds
 from zope.schema.interfaces import IVocabularyFactory
 import os.path
@@ -913,7 +922,7 @@ def test_folder_is_migrated(self):
         dx_folder = self.portal['folder']
         self.assertTrue(IFolder.providedBy(dx_folder))
         self.assertTrue(at_folder is not dx_folder)
-        self.assertEqual(dx_folder.getLayout(), 'folder_album_view')
+        self.assertEqual(dx_folder.getLayout(), 'album_view')
 
     def test_folder_children_are_migrated(self):
         from plone.app.contenttypes.migration.migration import FolderMigrator
@@ -965,6 +974,10 @@ def test_relations_are_migrated(self):
         applyProfile(self.portal, 'plone.app.contenttypes:default')
         migrate_documents(self.portal)
         migrate_folders(self.portal)
+
+        # rebuild catalog
+        self.portal.portal_catalog.clearFindAndRebuild()
+
         dx_folder1 = self.portal['folder1']
         dx_folder2 = self.portal['folder2']
 
@@ -1120,7 +1133,7 @@ def test_migrate_function(self):
         applyProfile(self.portal, 'plone.app.contenttypes:default')
         migrate(self.portal, DocumentMigrator)
         dx_document = self.portal["document"]
-        self.assertEqual(dx_document.meta_type, 'Dexterity Item')
+        self.assertTrue(IDexterityContent.providedBy(dx_document))
 
     def test_migrate_xx_functions(self):
         from Products.ATContentTypes.content.image import ATImage
@@ -1138,6 +1151,7 @@ def test_migrate_xx_functions(self):
             migrate_folders,
             migrate_events,
         )
+        from plone.app.contenttypes.migration.topics import migrate_topics
 
         # create all content types
         self.portal.invokeFactory('Document', 'document')
@@ -1151,6 +1165,7 @@ def test_migrate_xx_functions(self):
         self.createATCTBlobNewsItem('blobnewsitem')
         self.portal.invokeFactory('Folder', 'folder')
         self.portal.invokeFactory('Event', 'event')
+        self.portal.invokeFactory('Topic', 'topic')
 
         # migrate all
         applyProfile(self.portal, 'plone.app.contenttypes:default')
@@ -1165,6 +1180,7 @@ def test_migrate_xx_functions(self):
         migrate_blobnewsitems(self.portal)
         migrate_folders(self.portal)
         migrate_events(self.portal)
+        migrate_topics(self.portal)
 
         # assertions
         cat = self.catalog
@@ -1173,7 +1189,7 @@ def test_migrate_xx_functions(self):
         dx_contents = cat(object_provides='plone.dexterity'
                           '.interfaces.IDexterityContent')
         self.assertEqual(len(at_contents), 0)
-        self.assertEqual(len(dx_contents), 11)
+        self.assertEqual(len(dx_contents), 12)
 
     def test_warning_for_uneditable_content(self):
         set_browserlayer(self.request)
@@ -1184,6 +1200,11 @@ def test_warning_for_uneditable_content(self):
         at_document = self.portal['document']
         at_newsitem = self.portal['newsitem']
         applyProfile(self.portal, 'plone.app.contenttypes:default')
+        # At this point plone.app.z3cform is installed including it's browser
+        # layer. But we have to annotate the request to provide it, since the
+        # request was constructed before. Otherwise, @@view cannot be render
+        # it's IRichText widget.
+        alsoProvides(self.request, IPloneFormLayer)
         at_document_view = at_document.restrictedTraverse('')
         self.assertTrue(
             'http://nohost/plone/@@atct_migrator' in at_document_view()
@@ -1280,3 +1301,268 @@ def test_migration_view_confirmation(self):
         )
         results = migration_view()
         self.assertIn('@@migrate_from_atct?migrate=1', results)
+
+    def test_portlets_are_migrated(self):
+        """add portlets and see if they're still available on the migrated
+        content including portlet settings.
+        """
+        from plone.app.contenttypes.migration.migration import DocumentMigrator
+        from plone.app.contenttypes.migration.migration import FolderMigrator
+        from plone.portlet.static.static import Assignment as StaticAssignment
+        from plone.portlets.constants import GROUP_CATEGORY
+        from plone.portlets.interfaces import ILocalPortletAssignmentManager
+        from plone.portlets.interfaces import IPortletAssignmentMapping
+        from plone.portlets.interfaces import IPortletAssignmentSettings
+        from plone.portlets.interfaces import IPortletManager
+
+        def get_portlets(context, columnName):
+            column = getUtility(IPortletManager, columnName)
+            mapping = getMultiAdapter((context, column),
+                                      IPortletAssignmentMapping)
+            return mapping
+
+        # create an ATDocument
+        self.portal.invokeFactory('Document', 'document')
+        at_document = self.portal['document']
+        at_document.setText(u'Ttensuppe with some portlet')
+        at_document.setContentType('chemical/x-gaussian-checkpoint')
+
+        # add a portlet
+        portlet = StaticAssignment(u"Sample Portlet",
+                                   "<p>Yay! I get migrated!</p>")
+        add_portlet(at_document, portlet, 'static-portlet',
+                    u'plone.leftcolumn')
+
+        # disable group portlets for right columns
+        right_column = getUtility(IPortletManager, u'plone.rightcolumn')
+        localsettings = getMultiAdapter((at_document, right_column),
+                                        ILocalPortletAssignmentManager)
+        localsettings.setBlacklistStatus(GROUP_CATEGORY, True)
+
+        # hide our portlet
+        settings = IPortletAssignmentSettings(portlet)
+        settings['visible'] = False
+
+        # add another portlet type that is not available when doing the
+        # migration and make sure it got ignored in the migration
+        broken = StaticAssignment(u"Fake broken portlet",
+                                  "<p>Ouch! I'm broken</p>")
+        # ZODB.broken will add an ___Broken_state__ attribute if a portlet's
+        # module is no longer available
+        broken.__Broken_state__ = True
+        add_portlet(at_document, broken, 'broken-portlet', u'plone.leftcolumn')
+
+        # add a folder
+        self.portal.invokeFactory('Folder', 'folder')
+        at_folder = self.portal['folder']
+
+        # add a portlet to the folder
+        portlet2 = StaticAssignment(u"Sample Folder Portlet",
+                                    "<p>Do I get migrated?</p>")
+        add_portlet(at_folder, portlet2, 'static-portlet',
+                    u'plone.rightcolumn')
+
+        # migrate
+        applyProfile(self.portal, 'plone.app.contenttypes:default')
+        migrator = self.get_migrator(at_document, DocumentMigrator)
+        migrator.migrate()
+        folder_migrator = self.get_migrator(at_folder, FolderMigrator)
+        folder_migrator.migrate()
+
+        # assertions
+        dx_document = self.portal['document']
+
+        # portlet is available
+        self.failUnless('static-portlet' in get_portlets(dx_document,
+                                                         u'plone.leftcolumn'))
+        # broken portlets don't get copied
+        self.failIf('broken-portlet' in get_portlets(dx_document,
+                                                     u'plone.leftcolumn'))
+
+        # block portlets settings copied
+        right_column = getUtility(IPortletManager, u'plone.rightcolumn')
+        localsettings = getMultiAdapter((dx_document, right_column),
+                                        ILocalPortletAssignmentManager)
+        self.assertTrue(localsettings.getBlacklistStatus(GROUP_CATEGORY))
+
+        # hide portlets settings survived
+        assignment = get_portlets(dx_document,
+                                  u'plone.leftcolumn')['static-portlet']
+        settings = IPortletAssignmentSettings(assignment)
+        self.assertFalse(settings['visible'])
+
+        dx_folder = self.portal['folder']
+        self.failUnless('static-portlet' in get_portlets(dx_folder,
+                                                         u'plone.rightcolumn'))
+
+    def test_comments_are_migrated(self):
+        """add some comments and check that it is correctly migrated.
+
+        XXX fixme : original comment id is not kept, comments are created
+        with new ids...
+        """
+        from zope.component import createObject
+        from plone.app.discussion.interfaces import IConversation
+        from plone.app.contenttypes.migration.migration import DocumentMigrator
+
+        # create an ATDocument
+        self.portal.invokeFactory('Document', 'document')
+        at_document = self.portal['document']
+        at_document.setText(u'Document with some comments')
+
+        # add some comments to the document
+        at_conversation = IConversation(at_document)
+        new_comment = createObject('plone.Comment')
+        new_comment.text = u"Hey Dude!  is not ascii."
+        at_conversation.addComment(new_comment)
+        at_comments = at_conversation.getComments()
+        at_comment = [i for i in at_comments][0]
+        at_plone_uuid = getattr(at_comment, '_plone.uuid')
+        at_comment_id = getattr(at_comment, 'comment_id')
+
+        # migrate
+        applyProfile(self.portal, 'plone.app.contenttypes:default')
+        migrator = self.get_migrator(at_document, DocumentMigrator)
+        migrator.migrate()
+
+        dx_document = self.portal['document']
+
+        # no more comments on the portal
+        portal_conversation = IConversation(self.portal)
+        self.failIf(portal_conversation)
+        # comments were migrated
+        dx_conversation = IConversation(dx_document)
+        self.failUnless(len(dx_conversation) == 1)
+        dx_comments = dx_conversation.getComments()
+        dx_comment = [i for i in dx_comments][0]
+        dx_comment_id = getattr(dx_comment, 'comment_id')
+        self.assertEqual(dx_comment_id, at_comment_id)
+        dx_plone_uuid = getattr(dx_comment, '_plone.uuid')
+        self.assertEqual(dx_plone_uuid, at_plone_uuid)
+        self.assertEqual(
+            dx_comment.getText(),
+            '<p>Hey Dude! \xc3\x84 is not ascii.</p>')
+
+
+class MigrateDexterityBaseClassIntegrationTest(unittest.TestCase):
+
+    layer = PLONE_APP_CONTENTTYPES_MIGRATION_TESTING
+
+    def setUp(self):
+        self.portal = self.layer['portal']
+
+        applyProfile(self.portal, 'plone.app.dexterity:testing')
+
+        self.portal.acl_users.userFolderAddUser('admin',
+                                                'secret',
+                                                ['Manager'],
+                                                [])
+        login(self.portal, 'admin')
+
+        # Add default content
+        self.portal.invokeFactory('Document', 'item')
+
+        # Change Document conent type to folderish
+        portal_types = getToolByName(self.portal, 'portal_types')
+        portal_types['Document'].klass = 'plone.dexterity.content.Container'
+        portal_types['Document'].allowed_content_types = ('Document',)
+
+    def test_dxmigration_migrate_item_to_container_class_is_changed(self):
+        """Check that base class was changed."""
+        from plone.app.contenttypes.migration.dxmigration import \
+            migrate_base_class_to_new_class
+        migrate_base_class_to_new_class(self.portal.item)
+        self.assertTrue(isinstance(self.portal.item, Container))
+
+    def test_dxmigration_migrate_item_to_container_add_object_inside(self):
+        """Check that after migrate base class it can add items inside object.
+        """
+        from plone.app.contenttypes.migration.dxmigration import \
+            migrate_base_class_to_new_class
+        migrate_base_class_to_new_class(self.portal.item)
+        self.portal.item.invokeFactory('Document', 'doc')
+        self.assertEqual(
+            len(self.portal.item.folderlistingFolderContents()), 1)
+
+    def test_dxmigration_migrate_list_of_objects_with_changed_base_class(self):
+        """Check list of objects with changed classes."""
+        from plone.app.contenttypes.migration.dxmigration import \
+            list_of_objects_with_changed_base_class
+        # We have already one changed object
+        objects = [i for i in
+                   list_of_objects_with_changed_base_class(self.portal)]
+        self.assertEqual(len(objects), 1)
+
+    def test_dxmigration_migrate_list_of_changed_base_class_names(self):
+        """Check list of changed base class names."""
+        from plone.app.contenttypes.migration.dxmigration import \
+            list_of_changed_base_class_names
+        # We have already one changed object
+        names = [i for i in list_of_changed_base_class_names(self.portal)]
+        self.assertEqual(len(names), 1)
+
+    def test_dxmigration_migrate_vocabulary_changed_base_classes(self):
+        """Check vocabulary of changed base class names."""
+        # We have already one changed object
+        name = 'plone.app.contenttypes.migration.changed_base_classes'
+        factory = getUtility(IVocabularyFactory, name)
+        vocabulary = factory(self.portal)
+        self.assertEqual(len(vocabulary), 1)
+
+
+class MigrateDexterityBaseClassFunctionalTest(unittest.TestCase):
+
+    layer = PLONE_APP_CONTENTTYPES_FUNCTIONAL_TESTING
+
+    def setUp(self):
+        app = self.layer['app']
+        self.portal = self.layer['portal']
+        self.request = self.layer['request']
+
+        self.portal_url = self.portal.absolute_url()
+        self.manage_document_url = '{0}/{1}/{2}/{3}'.format(
+            self.portal_url,
+            'portal_types',
+            'Document',
+            'manage_propertiesForm',
+        )
+
+        self.browser = Browser(app)
+        self.browser.handleErrors = False
+        self.browser.addHeader(
+            'Authorization',
+            'Basic %s:%s' % (SITE_OWNER_NAME, SITE_OWNER_PASSWORD,)
+        )
+
+        # Add default content
+        self.browser.open(self.portal_url)
+        self.browser.getLink('Page').click()
+        self.browser.getControl(name='form.widgets.IDublinCore.title')\
+            .value = "My item"
+        self.browser.getControl(name='form.widgets.IShortName.id')\
+            .value = "item"
+        self.browser.getControl('Save').click()
+
+        # Change Document conent type to folderish
+        self.browser.open(self.manage_document_url)
+        self.browser.getControl(name='klass:string') \
+            .value = 'plone.app.contenttypes.content.Collection'
+        self.browser.getControl('Save Changes').click()
+        self.browser.open(
+            '{0}/@@base_class_migrator_form'.format(self.portal_url))
+        self.good_info_message_template = 'There are {0} objects migrated.'
+
+    def test_dxmigration_migrate_check_migration_form_view(self):
+        """Check base class migrator view of changed base class names."""
+        html = etree.HTML(self.browser.contents)
+        checkboxes = html.xpath('//form//*[@name="{0}"]'.format(
+            'form.widgets.changed_base_classes:list'))
+        self.assertEqual(len(checkboxes), 1)
+
+    def test_dxmigration_migrate_check_migration_successful_message(self):
+        """Check base class migrator view of changed base class names."""
+        self.browser.getControl(
+            name='form.widgets.changed_base_classes:list').value = ['true']
+        self.browser.getControl('Update').click()
+        self.assertIn(
+            self.good_info_message_template.format(1), self.browser.contents)
diff --git a/plone/app/contenttypes/tests/test_migration_topic.py b/plone/app/contenttypes/tests/test_migration_topic.py
new file mode 100644
index 0000000..d2a3b8d
--- /dev/null
+++ b/plone/app/contenttypes/tests/test_migration_topic.py
@@ -0,0 +1,756 @@
+# -*- coding: utf-8 -*-
+from DateTime import DateTime
+from Products.CMFCore.utils import getToolByName
+from plone.app.contenttypes.behaviors.collection import ICollection
+from plone.app.contenttypes.migration.topics import migrate_topics
+from plone.app.contenttypes.testing import \
+    PLONE_APP_CONTENTTYPES_MIGRATION_TESTING
+from plone.app.querystring.queryparser import parseFormquery
+from plone.app.testing import applyProfile
+from plone.app.testing import login
+from plone.dexterity.content import Container
+from plone.dexterity.interfaces import IDexterityFTI
+from zope.component import queryUtility
+from zope.interface import implementer
+
+import unittest
+
+
+@implementer(ICollection)
+class FolderishCollection(Container):
+    """Test subclass for folderish ``Collections``.
+    """
+
+
+class MigrateTopicsIntegrationTest(unittest.TestCase):
+
+    layer = PLONE_APP_CONTENTTYPES_MIGRATION_TESTING
+
+    def setUp(self):
+        self.portal = self.layer['portal']
+        self.request = self.layer['request']
+        self.request['ACTUAL_URL'] = self.portal.absolute_url()
+        self.request['URL'] = self.portal.absolute_url()
+        self.catalog = getToolByName(self.portal, "portal_catalog")
+        self.portal.acl_users.userFolderAddUser('admin',
+                                                'secret',
+                                                ['Manager'],
+                                                [])
+        login(self.portal, 'admin')
+        self.portal.portal_workflow.setDefaultChain(
+            "simple_publication_workflow")
+        self.portal.invokeFactory("Topic", "topic", title="Topic")
+        self.portal.invokeFactory("Folder", "folder", title="Folder")
+
+    def run_migration(self):
+        migrate_topics(self.portal)
+
+    def add_criterion(self, index, criterion, value=None):
+        name = '%s_%s' % (index, criterion)
+        self.portal.topic.addCriterion(index, criterion)
+        crit = self.portal.topic.getCriterion(name)
+        if value is not None:
+            crit.setValue(value)
+        return crit
+
+    def test_migrate_simple_topic(self):
+        self.assertEqual(self.portal.topic.portal_type, 'Topic')
+        self.assertEqual(self.portal.topic.getLayout(), 'atct_topic_view')
+        self.assertEqual(self.portal.topic.getLimitNumber(), False)
+        self.assertEqual(self.portal.topic.getItemCount(), 0)
+        self.assertEqual(self.portal.topic.getCustomViewFields(), ('Title',))
+        applyProfile(self.portal, 'plone.app.contenttypes:default')
+        self.run_migration()
+        new = ICollection(self.portal.topic)
+        self.assertEqual(self.portal.topic.portal_type, 'Collection')
+        self.assertEqual(self.portal.topic.getLayout(), 'listing_view')
+        self.assertEqual(new.sort_on, None)
+        self.assertEqual(new.sort_reversed, None)
+        self.assertEqual(new.limit, 1000)
+        self.assertEqual(new.customViewFields, ('Title',))
+
+    def test_migrate_topic_fields(self):
+        self.portal.topic.setText('<p>Hello</p>')
+        self.portal.topic.setLimitNumber(True)
+        self.portal.topic.setItemCount(42)
+        self.portal.topic.setCustomViewFields(('Title', 'Type'))
+        applyProfile(self.portal, 'plone.app.contenttypes:default')
+        self.run_migration()
+        new = ICollection(self.portal.topic)
+        self.assertEqual(self.portal.topic.portal_type, 'Collection')
+        self.assertEqual(new.limit, 42)
+        self.assertEqual(new.customViewFields, ('Title', 'Type'))
+
+    def test_migrate_layout(self):
+        self.portal.topic.setLayout('folder_summary_view')
+        applyProfile(self.portal, 'plone.app.contenttypes:default')
+        self.run_migration()
+        self.assertEqual(self.portal.topic.getLayout(), 'summary_view')
+
+    def test_migrate_customView(self):
+        self.portal.topic.setCustomView(True)
+        applyProfile(self.portal, 'plone.app.contenttypes:default')
+        self.run_migration()
+        self.assertEqual(self.portal.topic.getLayout(), 'tabular_view')
+
+    def test_migrate_nested_topic(self):
+        self.portal.portal_types['Topic'].filter_content_types = False
+        self.portal.topic.invokeFactory("Topic", "subtopic", title="Sub Topic")
+        applyProfile(self.portal, 'plone.app.contenttypes:default')
+        fti = queryUtility(IDexterityFTI, name='Collection')
+        # switch our a custom folderish base-class for collections
+        # we need to use _updateProperty because this also refreshes
+        # the content_meta_type attribute when klass has changed
+        fti._updateProperty(
+            'klass',
+            'plone.app.contenttypes.tests.test_migration_topic.'
+            'FolderishCollection')
+        fti._updateProperty('allowed_content_types', ['Document', 'Folder'])
+        fti._updateProperty('filter_content_types', False)
+        self.run_migration()
+        self.assertEqual(self.portal.topic.portal_type, 'Collection')
+        self.assertEqual(self.portal.topic.subtopic.portal_type, 'Collection')
+
+    def test_ATSimpleStringCriterion(self):
+        self.add_criterion('SearchableText', 'ATSimpleStringCriterion', 'bar')
+        applyProfile(self.portal, 'plone.app.contenttypes:default')
+        self.run_migration()
+        self.assertEqual(
+            self.portal.topic.query,
+            [{'i': 'SearchableText',
+              'o': 'plone.app.querystring.operation.string.contains',
+              'v': 'bar'}]
+        )
+
+        # Check that the resulting query does not give an error.
+        self.portal.topic.getQuery()
+
+    def test_ATSimpleStringCriterionToSelection(self):
+        # Some string criterions really should be selection criterions.
+        self.add_criterion(
+            'review_state',
+            'ATSimpleStringCriterion', 'published'
+        )
+        applyProfile(self.portal, 'plone.app.contenttypes:default')
+        self.run_migration()
+        self.assertEqual(
+            self.portal.topic.query,
+            [{'i': 'review_state',
+              'o': 'plone.app.querystring.operation.selection.is',
+              'v': 'published'}]
+        )
+
+    def test_ATDateCriteriaPast(self):
+        # More than 5 days in the past:
+        crit = self.add_criterion('created', 'ATFriendlyDateCriteria', 5)
+        crit.setOperation('more')
+        crit.setDateRange('-')
+        # Less than 5 days in the past:
+        crit = self.add_criterion('effective', 'ATFriendlyDateCriteria', 5)
+        crit.setOperation('less')
+        crit.setDateRange('-')
+        # The next two are logically a bit weird.
+        # More than 0 days in the past is historically interpreted as: after
+        # today.
+        crit = self.add_criterion('expires', 'ATFriendlyDateCriteria', 0)
+        crit.setOperation('more')
+        crit.setDateRange('-')
+        # Less than 0 days in the past is historically interpreted as: before
+        # today.
+        crit = self.add_criterion('modified', 'ATFriendlyDateCriteria', 0)
+        crit.setOperation('less')
+        crit.setDateRange('-')
+
+        applyProfile(self.portal, 'plone.app.contenttypes:default')
+        self.run_migration()
+        query = self.portal.topic.query
+        self.assertEqual(len(query), 4)
+
+        self.assertEqual(query[0]['i'], 'created')
+        self.assertEqual(
+            query[0]['o'],
+            'plone.app.querystring.operation.date.largerThanRelativeDate'
+        )
+        self.assertEqual(query[0]['v'], -5)
+
+        self.assertEqual(query[1]['i'], 'effective')
+        self.assertEqual(
+            query[1]['o'],
+            'plone.app.querystring.operation.date.lessThanRelativeDate'
+        )
+        self.assertEqual(query[1]['v'], -5)
+
+        self.assertEqual(query[2]['i'], 'expires')
+        self.assertEqual(
+            query[2]['o'],
+            'plone.app.querystring.operation.date.afterToday'
+        )
+        self.assertTrue('v' not in query[2].keys())
+
+        self.assertEqual(query[3]['i'], 'modified')
+        self.assertEqual(
+            query[3]['o'],
+            'plone.app.querystring.operation.date.beforeToday'
+        )
+        self.assertTrue('v' not in query[3].keys())
+
+        # Check that the resulting query does not give an error.
+        self.portal.topic.getQuery()
+
+    def test_ATDateCriteriaFuture(self):
+        # More than 5 days in the future:
+        crit = self.add_criterion('created', 'ATFriendlyDateCriteria', 5)
+        crit.setOperation('more')
+        crit.setDateRange('+')
+        # Less than 5 days in the future:
+        crit = self.add_criterion('effective', 'ATFriendlyDateCriteria', 5)
+        crit.setOperation('less')
+        crit.setDateRange('+')
+        # More than 0 days in the future: after today.
+        crit = self.add_criterion('expires', 'ATFriendlyDateCriteria', 0)
+        crit.setOperation('more')
+        crit.setDateRange('+')
+        # Less than 0 days in the future: before today.
+        crit = self.add_criterion('modified', 'ATFriendlyDateCriteria', 0)
+        crit.setOperation('less')
+        crit.setDateRange('+')
+
+        applyProfile(self.portal, 'plone.app.contenttypes:default')
+        self.run_migration()
+        query = self.portal.topic.query
+        self.assertEqual(len(query), 4)
+
+        self.assertEqual(query[0]['i'], 'created')
+        self.assertEqual(
+            query[0]['o'],
+            'plone.app.querystring.operation.date.largerThanRelativeDate'
+        )
+        self.assertEqual(query[0]['v'], 5)
+
+        self.assertEqual(query[1]['i'], 'effective')
+        self.assertEqual(
+            query[1]['o'],
+            'plone.app.querystring.operation.date.lessThanRelativeDate'
+        )
+        self.assertTrue(query[1]['v'], 5)
+
+        self.assertEqual(query[2]['i'], 'expires')
+        self.assertEqual(
+            query[2]['o'],
+            'plone.app.querystring.operation.date.afterToday'
+        )
+        self.assertTrue('v' not in query[2].keys())
+
+        self.assertEqual(query[3]['i'], 'modified')
+        self.assertEqual(
+            query[3]['o'],
+            'plone.app.querystring.operation.date.beforeToday'
+        )
+        self.assertTrue('v' not in query[3].keys())
+
+        # Check that the resulting query does not give an error.
+        self.portal.topic.getQuery()
+
+    def test_ATDateCriteriaExactDay(self):
+        # 5 days ago:
+        crit = self.add_criterion('created', 'ATFriendlyDateCriteria', 5)
+        crit.setOperation('within_day')
+        crit.setDateRange('-')
+        # 5 days from now:
+        crit = self.add_criterion('effective', 'ATFriendlyDateCriteria', 5)
+        crit.setOperation('within_day')
+        crit.setDateRange('+')
+        # past or future does not matter if the day is today.
+        # today minus
+        crit = self.add_criterion('expires', 'ATFriendlyDateCriteria', 0)
+        crit.setOperation('within_day')
+        crit.setDateRange('-')
+        # today plus
+        crit = self.add_criterion('modified', 'ATFriendlyDateCriteria', 0)
+        crit.setOperation('within_day')
+        crit.setDateRange('+')
+
+        applyProfile(self.portal, 'plone.app.contenttypes:default')
+        self.run_migration()
+        query = self.portal.topic.query
+        time2 = DateTime()
+        self.assertEqual(len(query), 4)
+
+        self.assertEqual(query[0]['i'], 'created')
+        self.assertEqual(
+            query[0]['o'],
+            'plone.app.querystring.operation.date.between'
+        )
+        self.assertEqual(
+            query[0]['v'],
+            ((time2 - 5).earliestTime(), (time2 - 5).latestTime())
+        )
+
+        self.assertEqual(query[1]['i'], 'effective')
+        self.assertEqual(
+            query[1]['o'],
+            'plone.app.querystring.operation.date.between'
+        )
+        self.assertEqual(
+            query[1]['v'],
+            ((time2 + 5).earliestTime(), (time2 + 5).latestTime())
+        )
+
+        self.assertEqual(query[2]['i'], 'expires')
+        self.assertEqual(
+            query[2]['o'],
+            'plone.app.querystring.operation.date.today'
+        )
+        self.assertFalse('v' in query[2].keys())
+
+        self.assertEqual(query[3]['i'], 'modified')
+        self.assertEqual(
+            query[3]['o'],
+            'plone.app.querystring.operation.date.today'
+        )
+        self.assertFalse('v' in query[3].keys())
+
+        # Check that the resulting query does not give an error.
+        self.portal.topic.getQuery()
+
+    def test_ATCurrentAuthorCriterion(self):
+        self.add_criterion('Creator', 'ATCurrentAuthorCriterion')
+        applyProfile(self.portal, 'plone.app.contenttypes:default')
+        self.run_migration()
+        self.assertEqual(
+            self.portal.topic.query,
+            [{'i': 'Creator',
+              'o': 'plone.app.querystring.operation.string.currentUser',
+              'v': 'admin'}]
+        )
+
+        # Check that the resulting query does not give an error.
+        self.portal.topic.results
+
+    def test_ATListCriterion(self):
+        # The new-style queries do not currently offer the possibility
+        # to choose if the given values should be joined with 'or' or
+        # 'and'.  Default is 'or'.
+        crit = self.add_criterion('Subject', 'ATListCriterion', ('foo', 'bar'))
+        crit.setOperator('or')
+        # Note: this could have been an ATPortalTypeCriterion too:
+        crit = self.add_criterion(
+            'portal_type',
+            'ATListCriterion', ('Document', 'Folder')
+        )
+        crit.setOperator('and')
+
+        applyProfile(self.portal, 'plone.app.contenttypes:default')
+        self.run_migration()
+        query = self.portal.topic.query
+        self.assertEqual(len(query), 2)
+        self.assertEqual(query[0],
+                         {'i': 'Subject',
+                          'o': 'plone.app.querystring.operation.selection.is',
+                          'v': ('foo', 'bar')})
+        self.assertEqual(query[1],
+                         {'i': 'portal_type',
+                          'o': 'plone.app.querystring.operation.selection.is',
+                          'v': ('Document', 'Folder')})
+
+        # Check that the resulting query does not give an error.
+        self.portal.topic.results
+
+    def test_ATPathCriterion(self):
+        crit = self.add_criterion(
+            'path',
+            'ATPathCriterion', self.portal.folder.UID())
+        crit.setRecurse(True)
+        applyProfile(self.portal, 'plone.app.contenttypes:default')
+        self.run_migration()
+        self.assertEqual(self.portal.topic.query,
+                         [{'i': 'path',
+                           'o': 'plone.app.querystring.operation.string.path',
+                           'v': self.portal.folder.UID()}])
+        # check is the query is correct
+        self.assertEqual(
+            parseFormquery(self.portal, self.portal.topic.query),
+            {'path': {'query': ['/plone/folder']}})
+
+        # Check that the resulting query does not give an error.
+        self.portal.topic.results
+
+    def test_ATPathCriterionNonRecursive(self):
+        # Topics supported non recursive search, so search at a
+        # specific depth of 1.  At first, new Collections did not
+        # support it.  But since plone.app.querystring 1.1.0 it works.
+        crit = self.add_criterion(
+            'path',
+            'ATPathCriterion', self.portal.folder.UID()
+        )
+        crit.setRecurse(False)
+        applyProfile(self.portal, 'plone.app.contenttypes:default')
+        self.run_migration()
+        query = self.portal.topic.query
+        self.assertEqual(len(query), 1)
+        self.assertEqual(query,
+                         [{'i': 'path',
+                           'o': 'plone.app.querystring.operation.string.path',
+                           'v': self.portal.folder.UID() + '::1'}])
+
+        # Check that the resulting query does not give an error.
+        self.portal.topic.results
+
+    def test_ATPathCriterionMultiRecursive(self):
+        # Collections support multiple paths since
+        # plone.app.querystring 1.2.0.
+        login(self.portal, 'admin')
+        self.portal.invokeFactory("Folder", "folder2", title="Folder 2")
+        crit = self.add_criterion(
+            'path',
+            'ATPathCriterion',
+            [self.portal.folder.UID(), self.portal.folder2.UID()]
+        )
+        crit.setRecurse(True)
+        applyProfile(self.portal, 'plone.app.contenttypes:default')
+        self.run_migration()
+        query = self.portal.topic.query
+        self.assertEqual(len(query), 2)
+        self.assertEqual(query[0],
+                         {'i': 'path',
+                          'o': 'plone.app.querystring.operation.string.path',
+                          'v': self.portal.folder.UID()})
+        self.assertEqual(query[1],
+                         {'i': 'path',
+                          'o': 'plone.app.querystring.operation.string.path',
+                          'v': self.portal.folder2.UID()})
+
+        # Check that the resulting query does not give an error.
+        self.portal.topic.results
+
+    def test_ATPathCriterionMultiNonRecursive(self):
+        # Collections support multiple paths since
+        # plone.app.querystring 1.2.0.
+        login(self.portal, 'admin')
+        self.portal.invokeFactory("Folder", "folder2", title="Folder 2")
+        crit = self.add_criterion(
+            'path',
+            'ATPathCriterion',
+            [self.portal.folder.UID(), self.portal.folder2.UID()]
+        )
+        crit.setRecurse(False)
+        applyProfile(self.portal, 'plone.app.contenttypes:default')
+        self.run_migration()
+        query = self.portal.topic.query
+        self.assertEqual(len(query), 2)
+        self.assertEqual(query[0],
+                         {'i': 'path',
+                          'o': 'plone.app.querystring.operation.string.path',
+                          'v': self.portal.folder.UID() + '::1'})
+        self.assertEqual(query[1],
+                         {'i': 'path',
+                          'o': 'plone.app.querystring.operation.string.path',
+                          'v': self.portal.folder2.UID() + '::1'})
+
+        # Check that the resulting query does not give an error.
+        self.portal.topic.results
+
+    def test_ATBooleanCriterion(self):
+        # Note that in standard Plone the boolean criterion is only
+        # defined for is_folderish and is_default_page.
+        crit = self.add_criterion('is_folderish', 'ATBooleanCriterion')
+        crit.setBool(True)
+        crit = self.add_criterion('is_default_page', 'ATBooleanCriterion')
+        crit.setBool(False)
+        applyProfile(self.portal, 'plone.app.contenttypes:default')
+        self.run_migration()
+        query = self.portal.topic.query
+        self.assertEqual(len(query), 2)
+        self.assertEqual(
+            query[0],
+            {'i': 'is_folderish',
+             'o': 'plone.app.querystring.operation.boolean.isTrue'}
+        )
+        self.assertEqual(
+            query[1],
+            {'i': 'is_default_page',
+             'o': 'plone.app.querystring.operation.boolean.isFalse'}
+        )
+
+        # Check that the resulting query does not give an error.
+        self.portal.topic.results
+
+    def test_ATDateRangeCriteria(self):
+        time1 = DateTime()
+        # Days in the past:
+        crit = self.add_criterion('created', 'ATDateRangeCriterion')
+        crit.setStart(time1 - 5)
+        crit.setEnd(time1 - 3)
+        # Past and future:
+        crit = self.add_criterion('effective', 'ATDateRangeCriterion')
+        crit.setStart(time1 - 2)
+        crit.setEnd(time1 + 2)
+        # Days in the future:
+        crit = self.add_criterion('expires', 'ATDateRangeCriterion')
+        crit.setStart(time1 + 3)
+        crit.setEnd(time1 + 5)
+
+        applyProfile(self.portal, 'plone.app.contenttypes:default')
+        self.run_migration()
+        query = self.portal.topic.query
+        self.assertEqual(len(query), 3)
+
+        self.assertEqual(query[0]['i'], 'created')
+        self.assertEqual(
+            query[0]['o'],
+            'plone.app.querystring.operation.date.between'
+        )
+        self.assertEqual(query[0]['v'], (time1 - 5, time1 - 3))
+
+        self.assertEqual(query[1]['i'], 'effective')
+        self.assertEqual(
+            query[1]['o'],
+            'plone.app.querystring.operation.date.between'
+        )
+        self.assertEqual(query[1]['v'], (time1 - 2, time1 + 2))
+
+        self.assertEqual(query[2]['i'], 'expires')
+        self.assertEqual(
+            query[2]['o'],
+            'plone.app.querystring.operation.date.between'
+        )
+        self.assertEqual(query[2]['v'], (time1 + 3, time1 + 5))
+
+        # Check that the resulting query does not give an error.
+        self.portal.topic.results
+
+    def test_ATPortalTypeCriterion(self):
+        self.add_criterion(
+            'portal_type',
+            'ATPortalTypeCriterion', ('Document', 'Folder')
+        )
+        applyProfile(self.portal, 'plone.app.contenttypes:default')
+        self.run_migration()
+        query = self.portal.topic.query
+        self.assertEqual(
+            query,
+            [{'i': 'portal_type',
+              'o': 'plone.app.querystring.operation.selection.is',
+              'v': ('Document', 'Folder')}]
+        )
+
+        # Check that the resulting query does not give an error.
+        self.portal.topic.results
+
+    def test_ATPortalTypeCriterionOfTopic(self):
+        # We migrate Topics to Collections, so we should update
+        # criterions that search for Topics.
+        self.add_criterion(
+            'portal_type',
+            'ATPortalTypeCriterion', ('Topic',)
+        )
+        applyProfile(self.portal, 'plone.app.contenttypes:default')
+        self.run_migration()
+        query = self.portal.topic.query
+        self.assertEqual(query,
+                         [{'i': 'portal_type',
+                           'o': 'plone.app.querystring.operation.selection.is',
+                           'v': ('Collection',)}])
+
+        # Check that the resulting query does not give an error.
+        self.portal.topic.results
+
+    def test_ATSelectionCriterion(self):
+        # The new-style queries do not currently offer the possibility
+        # to choose if the given values should be joined with 'or' or
+        # 'and'.  Default is 'or'.
+        crit = self.add_criterion(
+            'Subject',
+            'ATSelectionCriterion',
+            ('foo', 'bar')
+        )
+        crit.setOperator('or')
+        # Note: this could have been an ATPortalTypeCriterion too:
+        # Note that we check that Topic is turned into Collection too.
+        crit = self.add_criterion(
+            'portal_type',
+            'ATSelectionCriterion',
+            ('Document', 'Topic')
+        )
+        crit.setOperator('and')
+
+        applyProfile(self.portal, 'plone.app.contenttypes:default')
+        self.run_migration()
+        query = self.portal.topic.query
+        self.assertEqual(len(query), 2)
+        self.assertEqual(query[0],
+                         {'i': 'Subject',
+                          'o': 'plone.app.querystring.operation.selection.is',
+                          'v': ('foo', 'bar')})
+        self.assertEqual(query[1],
+                         {'i': 'portal_type',
+                          'o': 'plone.app.querystring.operation.selection.is',
+                          'v': ('Document', 'Collection')})
+
+        # Check that the resulting query does not give an error.
+        self.portal.topic.results
+
+    def test_ATSelectionCriterionForTypeTitle(self):
+        # 'portal_type' is the object id of the FTI in portal_types.
+        # 'Type' is the title of that object.
+        # For example:
+        # - portal_type 'Document' has Type 'Page'.
+        # - portal_type 'Topic' has Type 'Collection (old)'.
+        # Type is not enabled as criterion index by default, so we
+        # want to migrate to a portal_type criterion instead.
+        self.add_criterion('Type', 'ATSelectionCriterion', ('Page', 'Folder'))
+        applyProfile(self.portal, 'plone.app.contenttypes:default')
+        self.run_migration()
+        query = self.portal.topic.query
+        self.assertEqual(query,
+                         [{'i': 'portal_type',
+                           'o': 'plone.app.querystring.operation.selection.is',
+                           'v': ['Document', 'Folder']}])
+
+        # Check that the resulting query does not give an error.
+        self.portal.topic.results
+
+    def test_ATReferenceCriterion(self):
+        # Note: the new criterion is disabled by default.  Also, it
+        # needs the _referenceIs function in the plone.app.querystring
+        # queryparser and that function is not defined.
+        self.add_criterion(
+            'getRawRelatedItems',
+            'ATReferenceCriterion',
+            self.portal.folder.UID()
+        )
+        applyProfile(self.portal, 'plone.app.contenttypes:default')
+        self.run_migration()
+        # TODO re-enable this check when the queryparser works.
+        # self.assertEqual(
+        #     self.portal.topic.query,
+        #     [{'i': 'getRawRelatedItems',
+        #       'o': 'plone.app.querystring.operation.reference.is',
+        #       'v': (portal.folder.UID(),)}]
+        # )
+
+        # Check that the resulting query does not give an error.
+        # self.portal.topic.results
+
+    def test_ATRelativePathCriterion(self):
+        crit = self.add_criterion(
+            'path',
+            'ATRelativePathCriterion'
+        )
+        crit.setRelativePath('../folder')
+        applyProfile(self.portal, 'plone.app.contenttypes:default')
+        self.run_migration()
+        self.assertEqual(
+            self.portal.topic.query,
+            [{'i': 'path',
+              'o': 'plone.app.querystring.operation.string.relativePath',
+              'v': '../folder'}]
+        )
+
+        # Check that the resulting query does not give an error.
+        self.portal.topic.results
+
+    def test_ATRelativePathCriterionNonRecursive(self):
+        # Topics supported non recursive search, so search at a specific
+        # depth.  New Collections do not support it.
+        crit = self.add_criterion('path', 'ATRelativePathCriterion')
+        crit.setRelativePath('../folder')
+        crit.setRecurse(True)
+        applyProfile(self.portal, 'plone.app.contenttypes:default')
+        self.run_migration()
+        self.assertEqual(
+            self.portal.topic.query,
+            [{'i': 'path',
+              'o': 'plone.app.querystring.operation.string.relativePath',
+              'v': '../folder'}])
+
+        # Check that the resulting query does not give an error.
+        self.portal.topic.results
+
+    def test_ATSimpleIntCriterion(self):
+        self.add_criterion('getObjPositionInParent', 'ATSimpleIntCriterion', 7)
+        applyProfile(self.portal, 'plone.app.contenttypes:default')
+        self.run_migration()
+        self.assertEqual(self.portal.topic.query,
+                         [{'i': 'getObjPositionInParent',
+                           'o': 'plone.app.querystring.operation.int.is',
+                           'v': 7}])
+
+        # Check that the resulting query does not give an error.
+        self.portal.topic.results
+
+    def test_ATSimpleIntCriterionMinimum(self):
+        crit = self.add_criterion(
+            'getObjPositionInParent',
+            'ATSimpleIntCriterion', 6
+        )
+        crit.setDirection('min')
+        applyProfile(self.portal, 'plone.app.contenttypes:default')
+        self.run_migration()
+        self.assertEqual(
+            self.portal.topic.query,
+            [{'i': 'getObjPositionInParent',
+              'o': 'plone.app.querystring.operation.int.largerThan',
+              'v': 6}]
+        )
+
+        # Check that the resulting query does not give an error.
+        self.portal.topic.getQuery()
+
+    def test_ATSimpleIntCriterionMaximum(self):
+        crit = self.add_criterion(
+            'getObjPositionInParent',
+            'ATSimpleIntCriterion',
+            5
+        )
+        crit.setDirection('max')
+        applyProfile(self.portal, 'plone.app.contenttypes:default')
+        self.run_migration()
+        self.assertEqual(
+            self.portal.topic.query,
+            [{'i': 'getObjPositionInParent',
+              'o': 'plone.app.querystring.operation.int.lessThan',
+              'v': 5}]
+        )
+
+        # Check that the resulting query does not give an error.
+        self.portal.topic.getQuery()
+
+    def test_ATSimpleIntCriterionBetween(self):
+        # This is not supported.
+        crit = self.add_criterion(
+            'getObjPositionInParent',
+            'ATSimpleIntCriterion',
+            4
+        )
+        crit.setDirection('min:max')
+        crit.setValue2(8)
+        applyProfile(self.portal, 'plone.app.contenttypes:default')
+        self.run_migration()
+        self.assertEqual(self.portal.topic.query, [])
+
+        # Check that the resulting query does not give an error.
+        self.portal.topic.getQuery()
+
+    def test_ATSortCriterion(self):
+        self.add_criterion('modified', 'ATSortCriterion')
+        applyProfile(self.portal, 'plone.app.contenttypes:default')
+        self.run_migration()
+        self.assertEqual(self.portal.topic.sort_on, 'modified')
+        self.assertEqual(self.portal.topic.sort_reversed, False)
+        self.assertEqual(self.portal.topic.query, [])
+
+        # Check that the resulting query does not give an error.
+        self.portal.topic.getQuery()
+
+    def test_ATSortCriterionReversed(self):
+        crit = self.add_criterion('created', 'ATSortCriterion')
+        crit.setReversed(True)
+        applyProfile(self.portal, 'plone.app.contenttypes:default')
+        self.run_migration()
+        self.assertEqual(self.portal.topic.sort_on, 'created')
+        self.assertEqual(self.portal.topic.sort_reversed, True)
+        self.assertEqual(self.portal.topic.query, [])
+
+        # Check that the resulting query does not give an error.
+        self.portal.topic.getQuery()
diff --git a/plone/app/contenttypes/tests/test_setup.py b/plone/app/contenttypes/tests/test_setup.py
index 650c92b..e224560 100644
--- a/plone/app/contenttypes/tests/test_setup.py
+++ b/plone/app/contenttypes/tests/test_setup.py
@@ -41,6 +41,7 @@ def test_browserlayer_available(self):
     def test_css_registered(self):
         resreg = getattr(self.portal, 'portal_registry')
         from Products.CMFPlone.interfaces import IResourceRegistry
-        resources_ids = resreg.collectionOfInterface(IResourceRegistry, prefix="plone.resources").keys()
+        resources_ids = resreg.collectionOfInterface(
+            IResourceRegistry, prefix="plone.resources").keys()
         self.assertTrue(
             'resource-collection-css' in resources_ids)
diff --git a/plone/app/contenttypes/tests/test_upgrades_migrate_to_pa_event.py b/plone/app/contenttypes/tests/test_upgrades_migrate_to_pa_event.py
index 4215095..6b269e8 100644
--- a/plone/app/contenttypes/tests/test_upgrades_migrate_to_pa_event.py
+++ b/plone/app/contenttypes/tests/test_upgrades_migrate_to_pa_event.py
@@ -42,7 +42,7 @@ def doUpgradeStep(self, source, dest,
         ps = getToolByName(self.portal, 'portal_setup')
         upgrades = [
             u for u
-            in ps.listUpgrades(profile)
+            in ps.listUpgrades(profile, show_old=True)
             if u['ssource'] == source and u['sdest'] == dest
         ]
         self.assertEqual(len(upgrades), 1)
diff --git a/plone/app/contenttypes/upgrades.py b/plone/app/contenttypes/upgrades.py
index 5615b06..64c3f57 100644
--- a/plone/app/contenttypes/upgrades.py
+++ b/plone/app/contenttypes/upgrades.py
@@ -3,6 +3,8 @@
 from plone.app.contenttypes.utils import DEFAULT_TYPES
 from plone.dexterity.interfaces import IDexterityFTI
 from zope.component import queryUtility
+import logging
+logger = logging.getLogger(name="plone.app.contenttypes upgrade")
 
 
 def update_fti(context):
@@ -87,7 +89,7 @@ def migrate_to_richtext(context):
 
 
 def migrate_album_view(context):
-    """Migrate atct_album_view to folder_album_view."""
+    """Migrate atct_album_view to album_view."""
 
     # TODO: Don't reload the profile. Only change the settings.
     context.runImportStepFromProfile(
@@ -100,7 +102,7 @@ def migrate_album_view(context):
         obj = brain.getObject()
         current = context.getLayout()
         if current == 'atct_album_view':
-            obj.setLayout('folder_album_view')
+            obj.setLayout('album_view')
 
 
 def enable_shortname_behavior(context):
@@ -121,3 +123,44 @@ def enable_shortname_behavior(context):
         behaviors.append(behavior)
         behaviors = tuple(behaviors)
         fti._updateProperty('behaviors', behaviors)
+
+
+def use_new_view_names(context):
+    """Migrate old view names to new view names."""
+
+    # TODO: Don't reload the profile. Only change the settings.
+    context.runImportStepFromProfile(
+        'profile-plone.app.contenttypes:default',
+        'typeinfo',
+    )
+    catalog = getToolByName(context, 'portal_catalog')
+    search = catalog.unrestrictedSearchResults
+
+    def _fixup(portal_type, view_map):
+        for brain in search(portal_type=portal_type):
+            obj = brain.getObject()
+            current = context.getLayout()
+            if current in view_map.keys():
+                obj.setLayout(view_map[current])
+                logger.info("Set view to {} for {}".format(
+                    view_map[current], obj.absolute_url()
+                ))
+
+    folder_view_map = {  # OLD : NEW
+        'folder_listing': 'listing_view',
+        'folder_full_view': 'full_view',
+        'folder_summary_view': 'summary_view',
+        'folder_tabular_view': 'tabular_view',
+        'folder_album_view': 'album_view',
+        'atct_album_view': 'album_view',
+    }
+    collection_view_map = {  # OLD : NEW
+        'view': 'listing_view',
+        'standard_view': 'listing_view',
+        'collection_view': 'listing_view',
+        'all_content': 'full_view',
+        'thumbnail_view': 'album_view',
+    }
+    _fixup('Folder', folder_view_map)
+    _fixup('Plone Site', folder_view_map)
+    _fixup('Collection', collection_view_map)
diff --git a/plone/app/contenttypes/upgrades.zcml b/plone/app/contenttypes/upgrades.zcml
index 53803c1..7dc4a79 100644
--- a/plone/app/contenttypes/upgrades.zcml
+++ b/plone/app/contenttypes/upgrades.zcml
@@ -23,6 +23,7 @@
 
   <!-- We still need Archetypes to use Products.contentmigrator -->
   <configure zcml:condition="installed Products.Archetypes">
+  <configure zcml:condition="installed archetypes.schemaextender">
   <genericsetup:upgradeStep
       source="1001"
       destination="1100"
@@ -32,6 +33,7 @@
       handler=".migration.dxmigration.migrate_to_pa_event"
       />
   </configure>
+  </configure>
 
   <genericsetup:upgradeStep
       source="1100"
@@ -60,4 +62,13 @@
       handler=".upgrades.enable_shortname_behavior"
       />
 
+  <genericsetup:upgradeStep
+      source="1103"
+      destination="1104"
+      title="Use new view names"
+      description=""
+      profile="plone.app.contenttypes:default"
+      handler=".upgrades.use_new_view_names"
+      />
+
 </configure>
diff --git a/setup.py b/setup.py
index 76da20a..64365dd 100644
--- a/setup.py
+++ b/setup.py
@@ -2,14 +2,14 @@
 
 import os
 
-version = '1.2a5.dev0'
+version = '1.2a8.dev0'
 
 
 def read(*rnames):
     return open(os.path.join(os.path.dirname(__file__), *rnames)).read()
 
 long_description = \
-    read('docs', 'README.rst') + \
+    read('docs', 'README.rst') + '\n\n' + \
     read('docs', 'CHANGES.rst')
 
 setup(name='plone.app.contenttypes',
@@ -47,13 +47,15 @@ def read(*rnames):
           'plone.namedfile [blobs]',
           'plone.app.versioningbehavior',
           'pytz',
+          'plone.app.z3cform>=1.1.0.dev0'
       ],
       extras_require={
           'test': [
               'archetypes.schemaextender',
               'lxml',
-              'plone.app.robotframework',
+              'plone.app.robotframework [debug, reload] > 0.9.8',  # create image and file content for Image, File and News Item if not given.  # noqa
               'plone.app.testing [robot] >= 4.2.4',  # we need ROBOT_TEST_LEVEL
+              # 'plone.dexterity >= 2.3.0',  # fixes setting default values # NOT RELEASED YET. # noqa
               'Products.ATContentTypes',
               'Products.contentmigration >= 2.1.8.dev0',
           ],
diff --git a/sphinx.cfg b/sphinx.cfg
deleted file mode 100644
index f2ae811..0000000
--- a/sphinx.cfg
+++ /dev/null
@@ -1,20 +0,0 @@
-[buildout]
-parts +=
-    sphinxbuilder
-    sphinxupload
-
-[sphinxbuilder]
-recipe = collective.recipe.sphinxbuilder
-eggs = sphinxcontrib-robotdoc
-#outputs =
-#    html
-#    latex
-#    pdf
-
-[sphinxupload]
-recipe = collective.recipe.template
-input = inline:
-    #!/bin/sh
-    bin/zopepy setup.py upload_sphinx
-output = ${buildout:directory}/bin/sphinxupload
-mode = 755
diff --git a/test-plone-4.3.x.cfg b/test-plone-4.3.x.cfg
deleted file mode 100644
index 39683d3..0000000
--- a/test-plone-4.3.x.cfg
+++ /dev/null
@@ -1,138 +0,0 @@
-[buildout]
-extends =
-    http://dist.plone.org/release/4.3-latest/versions.cfg
-    sphinx.cfg
-extensions = mr.developer
-develop = .
-always-checkout = force
-auto-checkout =
-     Products.contentmigration
-#    plone.app.event
-parts +=
-    instance
-    test
-    coverage
-    test-coverage
-    code-analysis
-    omelette
-    autopep8
-    releaser
-    zopepy
-    robot
-versions = versions
-
-[instance]
-recipe = plone.recipe.zope2instance
-http-address = 8080
-user = admin:admin
-eggs =
-    Plone
-    plone.app.contenttypes [test]
-
-[test]
-recipe = zc.recipe.testrunner
-defaults = ['--auto-color', '--auto-progress']
-eggs =
-    plone.app.contenttypes [test]
-
-[coverage]
-recipe = zc.recipe.egg
-eggs = coverage
-
-[test-coverage]
-recipe = collective.recipe.template
-input = inline:
-    #!/bin/bash
-    ${buildout:directory}/bin/coverage run --source=${buildout:directory}/plone/app/contenttypes bin/test --all
-    ${buildout:directory}/bin/coverage report -m
-output = ${buildout:directory}/bin/test-coverage
-mode = 755
-
-[code-analysis]
-recipe = plone.recipe.codeanalysis
-directory = ${buildout:directory}/plone/app/contenttypes
-flake8-max-complexity = 10
-zptlint = True
-utf8-header = True
-
-[omelette]
-recipe = collective.recipe.omelette
-eggs = ${instance:eggs}
-packages = ${instance:location}/lib/python ./
-
-[releaser]
-recipe = zc.recipe.egg
-eggs = jarn.mkrelease
-
-[autopep8]
-recipe = zc.recipe.egg
-eggs = autopep8
-
-[zopepy]
-recipe = zc.recipe.egg
-eggs = ${instance:eggs}
-interpreter = zopepy
-scripts = zopepy
-
-[sources]
-collective.i18nreport = git https://github.com/collective/collective.i18nreport.git
-collective.xmltestreport = git https://github.com/collective/collective.xmltestreport.git pushurl=git@github.com:collective/collective.xmltestreport.git
-plone.app.dexterity = git https://github.com/plone/plone.app.dexterity.git pushurl=git@github.com:plone/plone.app.dexterity.git
-plone.dexterity = git https://github.com/plone/plone.dexterity.git pushurl=git@github.com:plone/plone.dexterity.git
-Products.CMFPlone = git https://github.com/plone/Products.CMFPlone.git pushurl=git@github.com:plone/Products.CMFPlone.git branch=plip-12344-plone.app.contenttypes
-Products.ATContentTypes = git https://github.com/plone/Products.ATContentTypes.git pushurl=git@github.com:plone/Products.ATContentTypes.git branch=davisagli-optional-archetypes
-Products.contentmigration = git https://github.com/plone/Products.contentmigration pushurl=git@github.com:plone/Products.contentmigration.git
-plone.app.collection = git https://github.com/plone/plone.app.collection.git pushurl=git@github.com:plone/plone.app.collection.git
-plone.app.discussion = git https://github.com/plone/plone.app.discussion.git pushurl=git@github.com:plone/plone.app.discussion.git
-plone.app.event = git https://github.com/plone/plone.app.event.git pushurl=git@github.com:plone/plone.app.event.git
-plone.event = git https://github.com/plone/plone.event.git pushurl=git@github.com:plone/plone.event.git
-plone.formwidget.datetime = git https://github.com/plone/plone.formwidget.datetime.git pushurl=git@github.com:plone/plone.formwidget.datetime.git
-plone.app.querystring = git https://github.com/plone/plone.app.querystring.git pushurl=git@github.com:plone/plone.app.querystring.git
-# Points to a fork until the pull request is reviewed and merged
-plone.app.testing = git https://github.com/do3cc/plone.app.testing.git pushurl=git@github.com:do3cc/plone.app.testing.git branch=4.2.x
-plone.formwidget.querystring = git https://github.com/plone/plone.formwidget.querystring.git pushurl=git@github.com:plone/plone.formwidget.querystring.git
-plone.app.relationfield = git https://github.com/plone/plone.app.relationfield.git pushurl=git@github.com:plone/plone.app.relationfield.git
-Products.contentmigration = git git://github.com/plone/Products.contentmigration.git pushurl=git@github.com:plone/Products.contentmigration.git
-plone.app.versioningbehavior = git https://github.com/plone/plone.app.versioningbehavior.git pushurl=git@github.com:plone/plone.app.versioningbehavior.git
-plone.app.referenceablebehavior = git https://github.com/plone/plone.app.referenceablebehavior.git pushurl=git@github.com:plone/plone.app.referenceablebehavior.git
-collective.dexteritydiff = git https://github.com/collective/collective.dexteritydiff.git pushurl=git@github.com:collective/collective.dexteritydiff.git
-plone.app.layout = git https://github.com/plone/plone.app.layout.git pushurl=git@github.com:plone/plone.app.layout.git branch=2.3.x
-plone.recipe.codeanalysis = git git@github.com:plone/plone.recipe.codeanalysis.git
-
-[versions]
-# dexterity support
-plone.app.layout = 2.3.10
-plone.dexterity = 2.2.1
-plone.app.dexterity = 2.0.11
-plone.schemaeditor = 1.3.5
-plone.app.querystring = 1.1.0
-plone.app.vocabularies = 2.1.12
-
-# event
-plone.app.portlets = 2.5a1
-plone.app.event = 1.1b1
-plone.app.jquery = 1.8.3
-
-# testing
-plone.app.testing = 4.2.4
-plone.app.robotframework = 0.9.5
-robotframework = 2.8.4
-robotframework-selenium2library = 1.5.0
-robotsuite = 1.4.3
-selenium = 2.43.0
-robotframework-selenium2screenshots = 0.4.0
-sphinxcontrib-robotframework = 0.4.3
-Pygments = 1.6
-
-# misc
-pytz = 2013.9
-
-[robot]
-recipe = zc.recipe.egg
-eggs =
-    Pillow
-    ${test:eggs}
-    plone.app.robotframework
-scripts =
-    robot-server
-    robot
diff --git a/travis.cfg b/travis.cfg
index d712fe3..1c8726a 100644
--- a/travis.cfg
+++ b/travis.cfg
@@ -1,17 +1,11 @@
 [buildout]
-extends = test-plone-4.3.x.cfg
-parts +=
-   download
-   install
-   test
-eggs-directory = buildout-cache/eggs
-download-cache = buildout-cache/downloads
+extends =
+    https://raw.github.com/collective/buildout.plonetest/master/travis-5.x.cfg
+    buildout.d/base.cfg
 
-[download]
-recipe = hexagonit.recipe.download
-url = https://launchpad.net/plone/4.3/4.3.2/+download/Plone-4.3.2-UnifiedInstaller.tgz
-
-[install]
-recipe = collective.recipe.cmd
-on_install = true
-cmds = tar jxvf ${download:location}/Plone-4.3.2-UnifiedInstaller/packages/buildout-cache.tar.bz2 1>/dev/null
+parts =
+    download
+    install
+    test
+    createcoverage
+    code-analysis


Repository: plone.app.contenttypes
Branch: refs/heads/master
Date: 2015-04-07T23:26:22+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.app.contenttypes/commit/8e25073b72ebd2ac1ff38f715bb25a7c9ed01703

pep8 and fix test

Files changed:
M plone/app/contenttypes/migration/custom_migration.py
M plone/app/contenttypes/tests/test_migration_custom.py

diff --git a/plone/app/contenttypes/migration/custom_migration.py b/plone/app/contenttypes/migration/custom_migration.py
index ed18a66..3a618b6 100644
--- a/plone/app/contenttypes/migration/custom_migration.py
+++ b/plone/app/contenttypes/migration/custom_migration.py
@@ -30,11 +30,12 @@ class CustomMigrationForm(BrowserView):
     dx_metadata_fields.append('exclude_from_nav')
 
     def __call__(self):
-        # check that we can actually access this form, aka the current user has an advice to add or edit
+        # check that we can actually access this form,
+        # aka the current user has an advice to add or edit
         form = self.request.form
         cancelled = form.get('form.button.Cancel', False)
         submitted = form.get('form.button.Migrate', False)
-        test = form.get('form.button.Test', False)
+        # test = form.get('form.button.Test', False)
         if submitted:
             # proceed, call the migration methdd
             results = self.migrate()
@@ -43,11 +44,15 @@ def __call__(self):
                 res_type = migration_result.get('type')
                 res_infos = migration_result.get('infos')
                 if res_infos.get('errors'):
-                    messages.add(u'Error when migrating "%s" type. Check the log for other informations.' % res_type, type=u"error")
+                    messages.add(
+                        u'Error when migrating "%s" type. Check the '
+                        u'log for other informations.'
+                        % res_type, type=u"error")
                 else:
-                    msg = translate('Migration applied succesfully for %s "%s" items.' % (res_infos.get('counter'),
-                                                                                          res_type),
-                                domain='plone.app.contenttypes')
+                    msg = translate(
+                        'Migration applied succesfully for %s "%s" items.'
+                        % (res_infos.get('counter'), res_type),
+                        domain='plone.app.contenttypes')
                     messages.add(msg, type=u"info")
         elif cancelled:
             self.request.response.redirect(form.get('form.HTTP_REFERER'))
@@ -59,16 +64,20 @@ def getAllArchetypeTypes(self):
         return at_types
 
     def getATFTIs(self):
-        '''Returns a list of all AT types with existing instances (including default-types).'''
+        '''Returns a list of all AT types with existing instances
+        (including default-types).
+        '''
         results = []
         archetype_tool = getToolByName(self.context, 'archetype_tool', None)
-        # if we do not have archetype_tool, it means that we have no registered AT types
+        # if we do not have archetype_tool, it means that we have
+        # no registered AT types
         if not archetype_tool:
             return results
 
         typesTool = getToolByName(self.context, 'portal_types')
         catalog = getToolByName(self.context, 'portal_catalog')
-        registeredTypeNames = [registered['name'] for registered in archetype_tool.listRegisteredTypes()]
+        registeredTypeNames = [registered['name'] for registered
+                               in archetype_tool.listRegisteredTypes()]
         for fti in typesTool.listTypeInfo():
             ftiId = fti.getId()
             if hasattr(fti, 'content_meta_type') and \
@@ -137,9 +146,10 @@ def getFieldsForATTypeWithFTI(self, typename):
         for field in schema.fields():
             if not field.getName() in self.at_metadata_fields:
                 translated_label = translate(field.widget.label)
-                results.append({'id': field.getName(),
-                                'title': '%s (%s)' % (translated_label, field.getType()),
-                                'type': field.getType()})
+                results.append(
+                    {'id': field.getName(),
+                     'title': '%s (%s)' % (translated_label, field.getType()),
+                     'type': field.getType()})
         return results
 
     def getFieldsForATTypeWithoutFTI(self, typename):
@@ -157,9 +167,10 @@ def getFieldsForATTypeWithoutFTI(self, typename):
             field = obj.schema._fields[field_name]
             if not field.getName() in self.at_metadata_fields:
                 translated_label = translate(field.widget.label)
-                results.append({'id': field.getName(),
-                                'title': '%s (%s)' % (translated_label, field.getType()),
-                                'type': field.getType()})
+                results.append(
+                    {'id': field.getName(),
+                     'title': '%s (%s)' % (translated_label, field.getType()),
+                     'type': field.getType()})
         return results
 
     def getFieldsForDXType(self, typename):
@@ -176,9 +187,11 @@ def getFieldsForDXType(self, typename):
                 if fieldName in self.dx_metadata_fields:
                     continue
                 translated_title = translate(field.title)
-                results.append({'id': fieldName,
-                                'title': '%s (%s)' % (translated_title, field.__class__.__name__),
-                                'type': field.__class__.__name__})
+                class_name = field.__class__.__name__
+                results.append(
+                    {'id': fieldName,
+                     'title': '%s (%s)' % (translated_title, class_name),
+                     'type': field.__class__.__name__})
         return results
 
     def getPossibleTargetField(self, fieldtype):
@@ -189,35 +202,39 @@ def isFolderish(self):
 
     def migrate(self, dry_run=False):
         '''Build data from self.request.form, we will build something like :
-           {'MyATPortalType': {'MyDXPortalType': ({'AT_field_name': 'fieldname1',
-                                                   'AT_field_type': 'TextField',
-                                                   'DX_field_name': 'field_name1',
-                                                   'DX_field_type': 'RichText'}, )
-                                                   }}
-           Call the migrateCustomAT migrator for each AT content_type we choose to migrate.'''
+           {'MyATPortalType':
+                {'MyDXPortalType': ({'AT_field_name': 'fieldname1',
+                                     'AT_field_type': 'TextField',
+                                     'DX_field_name': 'field_name1',
+                                     'DX_field_type': 'RichText'}, )}}
+           Call the migrateCustomAT migrator for each AT content_type
+           we choose to migrate.
+        '''
         data = {}
         form = self.request.form
         # manipulate what we receive in the form and build a useable data dict
         for k in self.request.form.keys():
             if k.startswith('dx_select_'):
-                # we found select where we choose a DX type regarding an AT type
-                # the selelect name is like 'dx_select_MyATPortalType'
+                # we found select where we choose a DX type regarding an AT
+                # type the selelect name is like 'dx_select_MyATPortalType'
                 if not form[k] or (dry_run and k != form.get('tested_type')):
                     # nothing selected in this select, continue
                     continue
                 at_typename = k[10:]
                 dx_typename = form[k]
                 data[at_typename] = {dx_typename: {}}
-                # now handle fields mapping for found DX/AT type migration definition
-                # we have 2 keys we relevant mappings, first key is the AT typename
-                # second key is a particular key like 'dx_DXPortalType__for__MyATPortalType
+                # now handle fields mapping for found DX/AT type migration
+                # definition we have 2 keys we relevant mappings, first key
+                # is the AT typename second key is a particular key like
+                # 'dx_DXPortalType__for__MyATPortalType
                 dx_key = 'dx_%s__for__%s' % (dx_typename, at_typename)
                 for at_field in form[at_typename]:
                     dx_field = form[dx_key][form[at_typename].index(at_field)]
                     if not dx_field:
                         continue
                     at_field_name, at_field_type = at_field.split('__type__')
-                    if not hasattr(data[at_typename][dx_typename], at_field_name):
+                    if not hasattr(
+                            data[at_typename][dx_typename], at_field_name):
                         data[at_typename][dx_typename] = []
 
                     dx_field_name, dx_field_type = dx_field.split('__type__')
@@ -227,11 +244,16 @@ def migrate(self, dry_run=False):
                                   'DX_field_type': dx_field_type, }
                     data[at_typename][dx_typename].append(field_data)
 
-        # now that the data dict contains relevant information, we can call the custom migrator
+        # now that the data dict contains relevant information, we can call
+        # the custom migrator
         migration_results = []
         for at_typename, dx_mappings in data.items():
             for k, v in dx_mappings.items():
-                res = migrateCustomAT(fields_mapping=v, src_type=at_typename, dst_type=dx_typename, dry_run=dry_run)
+                res = migrateCustomAT(
+                    fields_mapping=v,
+                    src_type=at_typename,
+                    dst_type=dx_typename,
+                    dry_run=dry_run)
                 migration_results.append({'type': at_typename,
                                           'infos': res})
         return migration_results
@@ -251,6 +273,7 @@ def __call__(self):
         '''
         return self.index()
 
+
 class TestMigration(CustomMigrationForm):
 
     def __call__(self):
@@ -266,10 +289,11 @@ def __call__(self):
             res_infos = migration_result.get('infos')
             if res_infos.get('errors'):
                 response['status'] = 'error'
-                response['message'] = "Impossible migrating to this content type with this configuration"
+                response['message'] = "Migrating to this content type is impossible with this configuration"  # noqa
             else:
                 response['status'] = 'success'
                 response['message'] = "Testing migration succesful"
-        #i need to fix the response header because in case of success, it is set to text/html
+        # I need to fix the response header because in case of success,
+        # it is set to text/html
         self.request.response.setHeader("Content-type", "application/json")
         return json.dumps(response)
diff --git a/plone/app/contenttypes/tests/test_migration_custom.py b/plone/app/contenttypes/tests/test_migration_custom.py
index a0e09e5..a3dca9c 100644
--- a/plone/app/contenttypes/tests/test_migration_custom.py
+++ b/plone/app/contenttypes/tests/test_migration_custom.py
@@ -90,15 +90,17 @@ def test_migrate_listfield(self):
 
     def test_migrate_imagefield(self):
         test_image_data = self.get_test_image_data()
-        at_newsitem_id = self.portal.invokeFactory('News Item',
-                                                'foo',
-                                                title="Foo news",
-                                                image=test_image_data)
+        at_newsitem_id = self.portal.invokeFactory(
+            'News Item',
+            'foo',
+            title="Foo news",
+            image=test_image_data)
         # register p.a.contenttypes profile
         applyProfile(self.portal, 'plone.app.contenttypes:default')
-        dx_newsitem_id = self.portal.invokeFactory('News Item',
-                                                'bar',
-                                                title="Bar news")
+        dx_newsitem_id = self.portal.invokeFactory(
+            'News Item',
+            'bar',
+            title="Bar news")
         at_newsitem = self.portal[at_newsitem_id]
         dx_newsitem = self.portal[dx_newsitem_id]
         self.assertEqual(dx_newsitem.image, None)
@@ -116,7 +118,7 @@ def test_migrate_filefield(self):
         applyProfile(self.portal, 'plone.app.contenttypes:default')
         dx_file_id = self.portal.invokeFactory('File',
                                                'bar',
-                                                title="Bar file")
+                                               title="Bar file")
         at_file = self.portal[at_file_id]
         dx_file = self.portal[dx_file_id]
         self.assertEqual(dx_file.file, None)
@@ -187,8 +189,7 @@ def getFields(self):
         return at_document
 
     def test_migrate_extended_document(self):
-        from plone.app.contenttypes.migration.migration import\
-            migrateCustomAT
+        from plone.app.contenttypes.migration.migration import migrateCustomAT
         from plone.app.contenttypes.interfaces import INewsItem
         at_document = self.createCustomATDocument('foo-document')
         qi = self.portal.portal_quickinstaller
@@ -198,16 +199,19 @@ def test_migrate_extended_document(self):
             profile='plone.app.contenttypes:default',
             blacklistedSteps=['typeinfo'])
         installTypeIfNeeded("News Item")
-        fields_mapping = ({'AT_field_name': 'textExtended',
-                           'AT_field_type': 'TextField',
-                           'DX_field_name': 'text',
-                           'DX_field_type': 'TextField', },
-                           {'AT_field_name': 'stringExtended',
-                           'AT_field_type': 'StringField',
-                           'DX_field_name': 'title',
-                           'DX_field_type': 'StringField', },)
+        fields_mapping = (
+            {'AT_field_name': 'textExtended',
+             'AT_field_type': 'Products.Archetypes.Field.TextField',
+             'DX_field_name': 'text',
+             'DX_field_type': 'TextField', },
+            {'AT_field_name': 'stringExtended',
+             'AT_field_type': 'StringField',
+             'DX_field_name': 'title',
+             'DX_field_type': 'StringField', },
+        )
         # migrate extended AT Document to default DX News Item
-        migrateCustomAT(fields_mapping, src_type='Document', dst_type='News Item')
+        migrateCustomAT(
+            fields_mapping, src_type='Document', dst_type='News Item')
         dx_newsitem = self.portal['foo-document']
         self.assertTrue(INewsItem.providedBy(dx_newsitem))
         self.assertTrue(dx_newsitem is not at_document)


Repository: plone.app.contenttypes
Branch: refs/heads/master
Date: 2015-04-12T15:39:52+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.app.contenttypes/commit/b570877547c6634209b21fd921d3a1950d50c536

make migration method depend on target-field, not source-field

Files changed:
M plone/app/contenttypes/migration/migration.py

diff --git a/plone/app/contenttypes/migration/migration.py b/plone/app/contenttypes/migration/migration.py
index 9f19d85..5149d22 100644
--- a/plone/app/contenttypes/migration/migration.py
+++ b/plone/app/contenttypes/migration/migration.py
@@ -145,14 +145,13 @@ def migrate_filefield(src_obj, dst_obj, src_fieldname, dst_fieldname):
 
 
 # this mapping is needed to use the right migration method
-# we use the full field type path as it is retrieved from the field
+# we use the full field type path as it is retrieved from the target-field
 # (field.getType()), to avoid conflict.
 # TODO In the __future__ we should have a more dynamic way to configure this
 # mapping
-FIELDS_MAPPING = {'Products.Archetypes.Field.TextField': migrate_richtextfield,
-                  'Products.Archetypes.Field.FileField': migrate_filefield,
-                  'plone.app.blob.field.FileField': migrate_filefield,
-                  'Products.Archetypes.Field.ImageField': migrate_imagefield}
+FIELDS_MAPPING = {'RichText': migrate_richtextfield,
+                  'NamedBlobFile': migrate_filefield,
+                  'NamedBlobImage': migrate_imagefield}
 
 
 def migrate(portal, migrator):
@@ -739,9 +738,11 @@ def migrate_schema_fields(self):
                 at_fieldname = fields_dict.get('AT_field_name')
                 at_fieldtype = fields_dict.get('AT_field_type')
                 dx_fieldname = fields_dict.get('DX_field_name')
+                dx_fieldtype = fields_dict.get('DX_field_type')
                 migration_field_method = migrate_simplefield
-                if at_fieldtype in FIELDS_MAPPING:
-                    migration_field_method = FIELDS_MAPPING[at_fieldtype]
+                if dx_fieldtype in FIELDS_MAPPING:
+                    # Richtext, Image and File have custom migraton_methods
+                    migration_field_method = FIELDS_MAPPING[dx_fieldtype]
                 migration_field_method(src_obj=self.old,
                                        dst_obj=self.new,
                                        src_fieldname=at_fieldname,


Repository: plone.app.contenttypes
Branch: refs/heads/master
Date: 2015-04-23T13:16:40+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.app.contenttypes/commit/86ef1db65ad5337085f6dca2ff4095c79dccdc16

fix issue with custom migration where only one field was migrated

Files changed:
M plone/app/contenttypes/migration/custom_migration.py

diff --git a/plone/app/contenttypes/migration/custom_migration.py b/plone/app/contenttypes/migration/custom_migration.py
index 3a618b6..46fa0a4 100644
--- a/plone/app/contenttypes/migration/custom_migration.py
+++ b/plone/app/contenttypes/migration/custom_migration.py
@@ -201,14 +201,15 @@ def isFolderish(self):
         ''' decide which base-class we use for the migrator'''
 
     def migrate(self, dry_run=False):
-        '''Build data from self.request.form, we will build something like :
+        '''Build data from the migration form. We will build a dict like :
            {'MyATPortalType':
-                {'MyDXPortalType': ({'AT_field_name': 'fieldname1',
-                                     'AT_field_type': 'TextField',
+                {'MyDXPortalType': (
+                    {'AT_field_name': 'fieldname1',
+                     'AT_field_type': 'Products.Archetypes.Field.TextField',
                                      'DX_field_name': 'field_name1',
                                      'DX_field_type': 'RichText'}, )}}
-           Call the migrateCustomAT migrator for each AT content_type
-           we choose to migrate.
+        Call the migrateCustomAT migrator for each AT content_type we choose
+        to migrate.
         '''
         data = {}
         form = self.request.form
@@ -222,7 +223,8 @@ def migrate(self, dry_run=False):
                     continue
                 at_typename = k[10:]
                 dx_typename = form[k]
-                data[at_typename] = {dx_typename: {}}
+                data[at_typename] = {'target_type': dx_typename,
+                                     'field_mapping': []}
                 # now handle fields mapping for found DX/AT type migration
                 # definition we have 2 keys we relevant mappings, first key
                 # is the AT typename second key is a particular key like
@@ -233,26 +235,22 @@ def migrate(self, dry_run=False):
                     if not dx_field:
                         continue
                     at_field_name, at_field_type = at_field.split('__type__')
-                    if not hasattr(
-                            data[at_typename][dx_typename], at_field_name):
-                        data[at_typename][dx_typename] = []
-
                     dx_field_name, dx_field_type = dx_field.split('__type__')
                     field_data = {'AT_field_name': at_field_name,
                                   'AT_field_type': at_field_type,
                                   'DX_field_name': dx_field_name,
                                   'DX_field_type': dx_field_type, }
-                    data[at_typename][dx_typename].append(field_data)
+                    data[at_typename]['field_mapping'].append(field_data)
 
         # now that the data dict contains relevant information, we can call
         # the custom migrator
         migration_results = []
-        for at_typename, dx_mappings in data.items():
-            for k, v in dx_mappings.items():
+        for at_typename in data:
+            fields_mapping = data[at_typename]['field_mapping']
                 res = migrateCustomAT(
-                    fields_mapping=v,
+                fields_mapping=fields_mapping,
                     src_type=at_typename,
-                    dst_type=dx_typename,
+                dst_type=data[at_typename]['target_type'],
                     dry_run=dry_run)
                 migration_results.append({'type': at_typename,
                                           'infos': res})


Repository: plone.app.contenttypes
Branch: refs/heads/master
Date: 2015-04-23T13:18:10+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.app.contenttypes/commit/a48cce24fca7d58a73b8e60a532707018c77ae88

wrap test-migration in try&amp;except to allow returning the error-message in son

Files changed:
M plone/app/contenttypes/migration/custom_migration.py

diff --git a/plone/app/contenttypes/migration/custom_migration.py b/plone/app/contenttypes/migration/custom_migration.py
index 46fa0a4..dfdca51 100644
--- a/plone/app/contenttypes/migration/custom_migration.py
+++ b/plone/app/contenttypes/migration/custom_migration.py
@@ -1,15 +1,20 @@
 # -*- coding: UTF-8 -*-
-from zope.i18n import translate
-from Products.Five.browser import BrowserView
-from plone.dexterity.interfaces import IDexterityContent
-from plone.dexterity.interfaces import IDexterityFTI
-from plone.dexterity.utils import iterSchemataForType
+from Products.ATContentTypes.content.schemata import ATContentTypeSchema
 from Products.CMFCore.utils import getToolByName
+from Products.Five.browser import BrowserView
 from Products.Five.browser.pagetemplatefile import ViewPageTemplateFile
-from Products.ATContentTypes.content.schemata import ATContentTypeSchema
 from Products.statusmessages.interfaces import IStatusMessage
+from plone.app.contenttypes import _
 from plone.app.contenttypes.migration.migration import migrateCustomAT
+from plone.dexterity.interfaces import IDexterityContent
+from plone.dexterity.interfaces import IDexterityFTI
+from plone.dexterity.utils import iterSchemataForType
+from zope.i18n import translate
 import json
+import logging
+import traceback
+
+logger = logging.getLogger(__name__)
 
 HAS_EXTENDER = True
 try:
@@ -206,8 +211,8 @@ def migrate(self, dry_run=False):
                 {'MyDXPortalType': (
                     {'AT_field_name': 'fieldname1',
                      'AT_field_type': 'Products.Archetypes.Field.TextField',
-                                     'DX_field_name': 'field_name1',
-                                     'DX_field_type': 'RichText'}, )}}
+                     'DX_field_name': 'field_name1',
+                     'DX_field_type': 'RichText'}, )}}
         Call the migrateCustomAT migrator for each AT content_type we choose
         to migrate.
         '''
@@ -247,13 +252,13 @@ def migrate(self, dry_run=False):
         migration_results = []
         for at_typename in data:
             fields_mapping = data[at_typename]['field_mapping']
-                res = migrateCustomAT(
+            res = migrateCustomAT(
                 fields_mapping=fields_mapping,
-                    src_type=at_typename,
+                src_type=at_typename,
                 dst_type=data[at_typename]['target_type'],
-                    dry_run=dry_run)
-                migration_results.append({'type': at_typename,
-                                          'infos': res})
+                dry_run=dry_run)
+            migration_results.append({'type': at_typename,
+                                      'infos': res})
         return migration_results
 
 
@@ -280,18 +285,26 @@ def __call__(self):
         Returns a json response with the result.
         This view is called by a js.
         '''
-        results = self.migrate(dry_run=True)
         response = {}
-        if results:
-            migration_result = results[0]
-            res_infos = migration_result.get('infos')
-            if res_infos.get('errors'):
-                response['status'] = 'error'
-                response['message'] = "Migrating to this content type is impossible with this configuration"  # noqa
-            else:
-                response['status'] = 'success'
-                response['message'] = "Testing migration succesful"
-        # I need to fix the response header because in case of success,
-        # it is set to text/html
-        self.request.response.setHeader("Content-type", "application/json")
+        error_msg = _(u'Migrating to this content type is impossible with '
+                      u'this configuration')
+        try:
+            results = self.migrate(dry_run=True)
+        except Exception, e:
+            trace = traceback.format_exc()
+            msg = "Test-Migration failed: %s\n%s\n" % (e, trace)
+            logger.error(msg)
+            response['status'] = 'error'
+            response['message'] = msg
+            return json.dumps(response)
+
+        migration_result = results[0]
+        res_infos = migration_result.get('infos')
+        if res_infos.get('errors'):
+            response['status'] = 'error'
+            response['message'] = error_msg
+        else:
+            response['status'] = 'success'
+            response['message'] = 'Testing migration succesful'
+        self.request.response.setHeader('Content-type', 'application/json')
         return json.dumps(response)


Repository: plone.app.contenttypes
Branch: refs/heads/master
Date: 2015-04-23T13:18:59+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.app.contenttypes/commit/6ee87ebbdac3ba5e32e38294b4611846f9a68d9a

fallback for missing classes, fix tests

Files changed:
M plone/app/contenttypes/migration/custom_migration.pt
M plone/app/contenttypes/migration/migration.py
M plone/app/contenttypes/tests/test_migration_custom.py

diff --git a/plone/app/contenttypes/migration/custom_migration.pt b/plone/app/contenttypes/migration/custom_migration.pt
index a648c93..db21bae 100644
--- a/plone/app/contenttypes/migration/custom_migration.pt
+++ b/plone/app/contenttypes/migration/custom_migration.pt
@@ -44,7 +44,7 @@
           $.ajax({
             url: '@@display_dx_fields',
             dataType: 'html',
-            data: {at_typename:at_typename,
+            data: {at_typename: at_typename,
                    dx_typename: dx_typename},
             cache: false,
             success: function(data) {
diff --git a/plone/app/contenttypes/migration/migration.py b/plone/app/contenttypes/migration/migration.py
index 5149d22..fab5f03 100644
--- a/plone/app/contenttypes/migration/migration.py
+++ b/plone/app/contenttypes/migration/migration.py
@@ -780,7 +780,8 @@ def migrateCustomAT(fields_mapping, src_type, dst_type, dry_run=False):
     for info in archetype_tool.listRegisteredTypes():
         if info.get('meta_type') == src_meta_type:
             src_type_infos = info
-    is_folderish = src_type_infos.get('klass').isPrincipiaFolderish
+    klass = src_type_infos.get('klass', None)
+    is_folderish = klass.isPrincipiaFolderish if klass else False
     migrator = makeCustomATMigrator(context=portal,
                                     src_type=src_type,
                                     dst_type=dst_type,
diff --git a/plone/app/contenttypes/tests/test_migration_custom.py b/plone/app/contenttypes/tests/test_migration_custom.py
index a3dca9c..f85008c 100644
--- a/plone/app/contenttypes/tests/test_migration_custom.py
+++ b/plone/app/contenttypes/tests/test_migration_custom.py
@@ -203,7 +203,7 @@ def test_migrate_extended_document(self):
             {'AT_field_name': 'textExtended',
              'AT_field_type': 'Products.Archetypes.Field.TextField',
              'DX_field_name': 'text',
-             'DX_field_type': 'TextField', },
+             'DX_field_type': 'RichText', },
             {'AT_field_name': 'stringExtended',
              'AT_field_type': 'StringField',
              'DX_field_name': 'title',


Repository: plone.app.contenttypes
Branch: refs/heads/master
Date: 2015-04-23T17:54:54+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.app.contenttypes/commit/9388c2cb41ae9ccc1ad7cb5423d8d87878b8e6e5

add method to migrate Datetime-Fields

Files changed:
M plone/app/contenttypes/migration/migration.py

diff --git a/plone/app/contenttypes/migration/migration.py b/plone/app/contenttypes/migration/migration.py
index fab5f03..b732659 100644
--- a/plone/app/contenttypes/migration/migration.py
+++ b/plone/app/contenttypes/migration/migration.py
@@ -144,6 +144,19 @@ def migrate_filefield(src_obj, dst_obj, src_fieldname, dst_fieldname):
     logger.info("Migrating file %s" % filename)
 
 
+def migrate_datetimefield(src_obj, dst_obj, src_fieldname, dst_fieldname):
+    """Migrate a datefield."""
+    old_value = src_obj.getField(src_fieldname).get(src_obj)
+    if old_value == '':
+        return
+    if src_obj.getField('timezone', None) is not None:
+        old_timezone = src_obj.getField('timezone').get(src_obj)
+    else:
+        old_timezone = default_timezone(fallback='UTC')
+    new_value = datetime_fixer(old_value.asdatetime(), old_timezone)
+    setattr(dst_obj, dst_fieldname, new_value)
+
+
 # this mapping is needed to use the right migration method
 # we use the full field type path as it is retrieved from the target-field
 # (field.getType()), to avoid conflict.
@@ -151,7 +164,9 @@ def migrate_filefield(src_obj, dst_obj, src_fieldname, dst_fieldname):
 # mapping
 FIELDS_MAPPING = {'RichText': migrate_richtextfield,
                   'NamedBlobFile': migrate_filefield,
-                  'NamedBlobImage': migrate_imagefield}
+                  'NamedBlobImage': migrate_imagefield,
+                  'Datetime': migrate_datetimefield,
+                  'Date': migrate_datetimefield}
 
 
 def migrate(portal, migrator):


Repository: plone.app.contenttypes
Branch: refs/heads/master
Date: 2015-04-23T17:55:49+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.app.contenttypes/commit/0d217397d81691c81af186f32e0cd467f3f8737e

add safe_unicode to migrate_simplefield

Files changed:
M plone/app/contenttypes/migration/migration.py

diff --git a/plone/app/contenttypes/migration/migration.py b/plone/app/contenttypes/migration/migration.py
index b732659..6dd1dcf 100644
--- a/plone/app/contenttypes/migration/migration.py
+++ b/plone/app/contenttypes/migration/migration.py
@@ -63,8 +63,12 @@ def migrate_simplefield(src_obj, dst_obj, src_fieldname, dst_fieldname):
         at_value = getattr(src_obj, src_fieldname, None)
         if at_value and hasattr(at_value, '__call__'):
             at_value = at_value()
+    if isinstance(at_value, tuple):
+        at_value = tuple(safe_unicode(i) for i in at_value)
+    if isinstance(at_value, list):
+        at_value = [safe_unicode(i) for i in at_value]
     if at_value:
-        setattr(dst_obj, dst_fieldname, at_value)
+        setattr(dst_obj, dst_fieldname, safe_unicode(at_value))
 
 
 def migrate_richtextfield(src_obj, dst_obj, src_fieldname, dst_fieldname):


Repository: plone.app.contenttypes
Branch: refs/heads/master
Date: 2015-04-23T17:57:04+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.app.contenttypes/commit/773671362774c68613ba6cdeac874cfb23ff6bc5

allow custom migrations of instances of removed or replaced types

Files changed:
M plone/app/contenttypes/migration/migration.py

diff --git a/plone/app/contenttypes/migration/migration.py b/plone/app/contenttypes/migration/migration.py
index 6dd1dcf..d66a2ab 100644
--- a/plone/app/contenttypes/migration/migration.py
+++ b/plone/app/contenttypes/migration/migration.py
@@ -30,6 +30,7 @@
 from plone.app.textfield.value import RichTextValue
 from plone.app.uuid.utils import uuidToObject
 from plone.dexterity.interfaces import IDexterityContent
+from plone.dexterity.interfaces import IDexterityFTI
 from plone.event.utils import default_timezone
 from plone.namedfile.file import NamedBlobFile
 from plone.namedfile.file import NamedBlobImage
@@ -787,20 +788,32 @@ def migrateCustomAT(fields_mapping, src_type, dst_type, dry_run=False):
     a migration without committing.
     """
     portal = getSite()
-    archetype_tool = getToolByName(portal, 'archetype_tool', None)
-    src_type_infos = None
-    if not archetype_tool:
-        return
-    # get the src meta_type from the portal_type
+
+    # if the type still exists get the src_meta_type from the portal_type
     portal_types = getToolByName(portal, 'portal_types')
-    src_meta_type = getattr(portal_types, src_type).content_meta_type
-    # lookup registered type in archetype_tool with
-    # meta_type because several portal_types can use same meta_type
-    for info in archetype_tool.listRegisteredTypes():
-        if info.get('meta_type') == src_meta_type:
-            src_type_infos = info
-    klass = src_type_infos.get('klass', None)
-    is_folderish = klass.isPrincipiaFolderish if klass else False
+    fti = portal_types.get(src_type, None)
+    # Check if the fti was removed or replaced by a DX-implementation
+    if fti is None or IDexterityFTI.providedBy(fti):
+        # Get the needed info from an instance of the type
+        catalog = portal.portal_catalog
+        brain = catalog(portal_type=src_type, sort_limit=1)[0]
+        src_obj = brain.getObject()
+        if IDexterityContent.providedBy(src_obj):
+            logger.error(
+                '%s should not be dexterity object!' % src_obj.absolute_url())
+        is_folderish = getattr(src_obj, 'isPrincipiaFolderish', False)
+        src_meta_type = src_obj.meta_type
+    else:
+        # Get info from at-fti
+        src_meta_type = fti.content_meta_type
+        archetype_tool = getToolByName(portal, 'archetype_tool', None)
+        for info in archetype_tool.listRegisteredTypes():
+            # lookup registered type in archetype_tool with meta_type
+            # because several portal_types can use same meta_type
+            if info.get('meta_type') == src_meta_type:
+                klass = info.get('klass', None)
+                is_folderish = klass.isPrincipiaFolderish
+
     migrator = makeCustomATMigrator(context=portal,
                                     src_type=src_type,
                                     dst_type=dst_type,


Repository: plone.app.contenttypes
Branch: refs/heads/master
Date: 2015-04-23T17:57:13+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.app.contenttypes/commit/119d47c1c8fe9edf7c893f2d5fae98d851c0d445

DRY

Files changed:
M plone/app/contenttypes/migration/custom_migration.py

diff --git a/plone/app/contenttypes/migration/custom_migration.py b/plone/app/contenttypes/migration/custom_migration.py
index dfdca51..24f5bf4 100644
--- a/plone/app/contenttypes/migration/custom_migration.py
+++ b/plone/app/contenttypes/migration/custom_migration.py
@@ -196,7 +196,7 @@ def getFieldsForDXType(self, typename):
                 results.append(
                     {'id': fieldName,
                      'title': '%s (%s)' % (translated_title, class_name),
-                     'type': field.__class__.__name__})
+                     'type': class_name})
         return results
 
     def getPossibleTargetField(self, fieldtype):


Repository: plone.app.contenttypes
Branch: refs/heads/master
Date: 2015-04-23T17:57:27+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.app.contenttypes/commit/4201e4d411ed2652ddafb8e07283e33977dbecf7

test custom migrations

Files changed:
M plone/app/contenttypes/tests/test_migration_custom.py

diff --git a/plone/app/contenttypes/tests/test_migration_custom.py b/plone/app/contenttypes/tests/test_migration_custom.py
index f85008c..e137d28 100644
--- a/plone/app/contenttypes/tests/test_migration_custom.py
+++ b/plone/app/contenttypes/tests/test_migration_custom.py
@@ -1,6 +1,8 @@
 # -*- coding: utf-8 -*-
-from plone.app.contenttypes.migration.migration import migrate_imagefield
+from Products.CMFPlone.utils import safe_unicode
+from datetime import datetime
 from plone.app.contenttypes.migration.migration import migrate_filefield
+from plone.app.contenttypes.migration.migration import migrate_imagefield
 from plone.app.contenttypes.migration.migration import migrate_simplefield
 from plone.app.contenttypes.migration.utils import installTypeIfNeeded
 from plone.app.contenttypes.testing import \
@@ -9,6 +11,7 @@
 from plone.app.testing import applyProfile
 from plone.app.testing import setRoles
 
+import pytz
 import os.path
 import unittest2 as unittest
 
@@ -217,3 +220,165 @@ def test_migrate_extended_document(self):
         self.assertTrue(dx_newsitem is not at_document)
         self.assertEquals(at_document.textExtended(), dx_newsitem.text.raw)
         self.assertEquals(at_document.stringExtended, dx_newsitem.title)
+
+    def test_migrate_atevent_to_dxnewsitem(self):
+        """Tests the custom migration by migrating a default type. It is not
+        meant to be used this way but is a nice way to test the migrations.
+        During this migration the old event fti is still present.
+        """
+        from DateTime import DateTime
+        from plone.app.contenttypes.migration.migration import migrateCustomAT
+        from plone.app.contenttypes.interfaces import INewsItem
+
+        # create an ATEvent
+        self.portal.invokeFactory('Event', 'event')
+        at_event = self.portal['event']
+
+        # Date
+        at_event.getField('startDate') \
+                .set(at_event, DateTime('2013-02-03 12:00'))
+        at_event.getField('endDate') \
+                .set(at_event, DateTime('2013-04-05 13:00'))
+
+        # Contact
+        at_event.getField('contactPhone').set(at_event, '123456789')
+        at_event.getField('contactEmail').set(at_event, 'dummy@email.com')
+        at_event.getField('contactName').set(at_event, u'Nme')
+
+        # URL
+        at_event.getField('eventUrl').set(at_event, 'http://www.plone.org')
+
+        # Attendees
+        at_event.getField('attendees').set(at_event, ('You', 'Me'))
+
+        # Text
+        at_event.setText('Ttensuppe')
+        at_event.setContentType('text/plain')
+
+        oldTZ = os.environ.get('TZ', None)
+        os.environ['TZ'] = 'Asia/Tbilisi'
+
+        qi = self.portal.portal_quickinstaller
+        # install pac but only install News Items
+        qi.installProduct(
+            'plone.app.contenttypes',
+            profile='plone.app.contenttypes:default',
+            blacklistedSteps=['typeinfo'])
+        installTypeIfNeeded("News Item")
+        fields_mapping = (
+            {'AT_field_name': 'text',
+             'AT_field_type': 'Products.Archetypes.Field.TextField',
+             'DX_field_name': 'text',
+             'DX_field_type': 'RichText', },
+            {'AT_field_name': 'contactName',
+             'AT_field_type': 'StringField',
+             'DX_field_name': 'image_caption',
+             'DX_field_type': 'StringField', },
+        )
+        # migrate ATCTEvent to default DX News Item
+        migrateCustomAT(fields_mapping, src_type='Event', dst_type='News Item')
+        dx_newsitem = self.portal['event']
+        self.assertTrue(INewsItem.providedBy(dx_newsitem))
+        self.assertTrue(dx_newsitem is not at_event)
+        self.assertEquals(
+            safe_unicode(at_event.getText()),
+            dx_newsitem.text.output)
+        self.assertEquals(
+            at_event.contactName,
+            dx_newsitem.image_caption)
+
+    def test_migrate_atevent_to_dxevent(self):
+        """Tests the custom migration by migrating a default type. It is not
+        meant to be used this way but is a nice way to test the migrations.
+        During this migration the event fti is already replaced by the dx one.
+        """
+        from DateTime import DateTime
+        from plone.app.contenttypes.migration.migration import migrateCustomAT
+        from plone.app.contenttypes.interfaces import IEvent
+
+        # create an ATEvent
+        self.portal.invokeFactory('Event', 'event')
+        at_event = self.portal['event']
+
+        # Date
+        FORMAT = '%Y-%m-%d %H:%M'
+        start = '2013-02-03 12:15'
+        end = '2013-04-05 13:45'
+        at_event.getField('startDate').set(at_event, DateTime(start))
+        at_event.getField('endDate').set(at_event, DateTime(end))
+
+        # Contact
+        at_event.getField('contactPhone').set(at_event, '123456789')
+        at_event.getField('contactEmail').set(at_event, 'dummy@email.com')
+        at_event.getField('contactName').set(at_event, u'Nme')
+
+        # URL
+        at_event.getField('eventUrl').set(at_event, 'http://www.plone.org')
+
+        # Attendees
+        at_event.getField('attendees').set(at_event, ('Yu', 'Me'))
+
+        # Text
+        at_event.setText('Ttensuppe')
+        at_event.setContentType('text/plain')
+
+        TZ = 'Asia/Tbilisi'
+        os.environ['TZ'] = TZ
+        timezone = pytz.timezone(TZ)
+
+        qi = self.portal.portal_quickinstaller
+        # install pac but only install Event
+        qi.installProduct(
+            'plone.app.contenttypes',
+            profile='plone.app.contenttypes:default',
+            blacklistedSteps=['typeinfo'])
+        installTypeIfNeeded("Event")
+        fields_mapping = (
+            {'AT_field_name': 'startDate',
+             'AT_field_type': 'Products.Archetypes.Field.DateTimeField',
+             'DX_field_name': 'start',
+             'DX_field_type': 'Datetime', },
+            {'AT_field_name': 'endDate',
+             'AT_field_type': 'Products.Archetypes.Field.DateTimeField',
+             'DX_field_name': 'end',
+             'DX_field_type': 'Datetime', },
+            {'AT_field_name': 'text',
+             'AT_field_type': 'Products.Archetypes.Field.TextField',
+             'DX_field_name': 'text',
+             'DX_field_type': 'RichText', },
+            {'AT_field_name': 'eventUrl',
+             'AT_field_type': 'Products.Archetypes.Field.StringField',
+             'DX_field_name': 'event_url',
+             'DX_field_type': 'StringField', },
+            {'AT_field_name': 'contactEmail',
+             'AT_field_type': 'Products.Archetypes.Field.StringField',
+             'DX_field_name': 'contact_email',
+             'DX_field_type': 'StringField', },
+            {'AT_field_name': 'contactName',
+             'AT_field_type': 'Products.Archetypes.Field.StringField',
+             'DX_field_name': 'contact_name',
+             'DX_field_type': 'StringField', },
+            {'AT_field_name': 'contactPhone',
+             'AT_field_type': 'Products.Archetypes.Field.StringField',
+             'DX_field_name': 'contact_phone',
+             'DX_field_type': 'StringField', },
+            {'AT_field_name': 'attendees',
+             'AT_field_type': 'Products.Archetypes.Field.LinesField',
+             'DX_field_name': 'attendees',
+             'DX_field_type': 'Tuple', },
+        )
+        # migrate ATEvent to new default Event
+        migrateCustomAT(fields_mapping, src_type='Event', dst_type='Event')
+        dx_event = self.portal['event']
+        self.assertTrue(IEvent.providedBy(dx_event))
+        self.assertTrue(dx_event is not at_event)
+        self.assertEquals(safe_unicode(at_event.getText()), dx_event.text.output)
+        self.assertEquals(at_event.eventUrl, dx_event.event_url)
+        self.assertEquals(at_event.contactEmail, dx_event.contact_email)
+        self.assertEquals(at_event.contactName, dx_event.contact_name)
+        self.assertEquals(at_event.contactPhone, dx_event.contact_phone)
+        self.assertEquals(at_event.attendees, dx_event.attendees)
+        self.assertEquals(
+            dx_event.start, timezone.localize(datetime.strptime(start, FORMAT)))
+        self.assertEquals(
+            dx_event.end, timezone.localize(datetime.strptime(end, FORMAT)))


Repository: plone.app.contenttypes
Branch: refs/heads/master
Date: 2015-04-23T18:42:18+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.app.contenttypes/commit/87633e66c5b4ab5e0d3670991a07202299f635c7

pep8

Files changed:
M plone/app/contenttypes/migration/migration.py
M plone/app/contenttypes/tests/test_migration_custom.py

diff --git a/plone/app/contenttypes/migration/migration.py b/plone/app/contenttypes/migration/migration.py
index d66a2ab..84cf63b 100644
--- a/plone/app/contenttypes/migration/migration.py
+++ b/plone/app/contenttypes/migration/migration.py
@@ -10,8 +10,8 @@
 from Products.ATContentTypes.interfaces.interfaces import IATContentType
 from Products.Archetypes.config import REFERENCE_CATALOG
 from Products.CMFCore.utils import getToolByName
-from Products.CMFPlone.utils import safe_unicode
 from Products.CMFPlone.utils import safe_hasattr
+from Products.CMFPlone.utils import safe_unicode
 from Products.contentmigration.basemigrator.migrator import CMFFolderMigrator
 from Products.contentmigration.basemigrator.migrator import CMFItemMigrator
 from Products.contentmigration.basemigrator.walker import CatalogWalker
@@ -756,7 +756,6 @@ class CustomATMigrator(base_class):
         def migrate_schema_fields(self):
             for fields_dict in fields_mapping:
                 at_fieldname = fields_dict.get('AT_field_name')
-                at_fieldtype = fields_dict.get('AT_field_type')
                 dx_fieldname = fields_dict.get('DX_field_name')
                 dx_fieldtype = fields_dict.get('DX_field_type')
                 migration_field_method = migrate_simplefield
diff --git a/plone/app/contenttypes/tests/test_migration_custom.py b/plone/app/contenttypes/tests/test_migration_custom.py
index e137d28..28863a8 100644
--- a/plone/app/contenttypes/tests/test_migration_custom.py
+++ b/plone/app/contenttypes/tests/test_migration_custom.py
@@ -255,7 +255,6 @@ def test_migrate_atevent_to_dxnewsitem(self):
         at_event.setText('Ttensuppe')
         at_event.setContentType('text/plain')
 
-        oldTZ = os.environ.get('TZ', None)
         os.environ['TZ'] = 'Asia/Tbilisi'
 
         qi = self.portal.portal_quickinstaller
@@ -372,13 +371,15 @@ def test_migrate_atevent_to_dxevent(self):
         dx_event = self.portal['event']
         self.assertTrue(IEvent.providedBy(dx_event))
         self.assertTrue(dx_event is not at_event)
-        self.assertEquals(safe_unicode(at_event.getText()), dx_event.text.output)
+        self.assertEquals(safe_unicode(
+            at_event.getText()), dx_event.text.output)
         self.assertEquals(at_event.eventUrl, dx_event.event_url)
         self.assertEquals(at_event.contactEmail, dx_event.contact_email)
         self.assertEquals(at_event.contactName, dx_event.contact_name)
         self.assertEquals(at_event.contactPhone, dx_event.contact_phone)
         self.assertEquals(at_event.attendees, dx_event.attendees)
         self.assertEquals(
-            dx_event.start, timezone.localize(datetime.strptime(start, FORMAT)))
+            dx_event.start,
+            timezone.localize(datetime.strptime(start, FORMAT)))
         self.assertEquals(
             dx_event.end, timezone.localize(datetime.strptime(end, FORMAT)))


Repository: plone.app.contenttypes
Branch: refs/heads/master
Date: 2015-04-23T19:04:03+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.app.contenttypes/commit/13692249356c21e06a476e09908d642ec8661e93

document custom migrations

Files changed:
M docs/README.rst

diff --git a/docs/README.rst b/docs/README.rst
index 8728a01..5aae5c7 100644
--- a/docs/README.rst
+++ b/docs/README.rst
@@ -248,11 +248,13 @@ The old types that use leadimages are listed in the navigation-form with the com
 Migrating custom content
 ^^^^^^^^^^^^^^^^^^^^^^^^
 
-Custom content-types will not be touched by the migration plone.app.contenttypes and will continue to work as expected.
+During normal migrations with ``/@@atct_migrator`` custom content-types will not be migrated and will continue to work as expected.
 
-Future versions of plone.app.contenttypes will have with a form that allows you to migrate old custom Archetypes-content to Dexterity (you'll still have to create the Dexterity-types before migrating).
+To migrate these to Dexterity plone.app.contenttypes contains a migration form (``/@@custom_migration``) that allows you to migrate any (custom or default) Archetypes-type to any (custom or default) Dexterity-type. The only requirement is that the Dexterity-type you want to migrate to has to exist. It makes no difference if the type you are migrating is still registered in portal_types or is already removed or replaced.
 
-If you want to migrate your custom types to Dexterity before this feature is completed you might want to have a look at the code of plone.app.contenttypes.migration.migration.NewsItemMigrator as a blueprint for a migration.
+In the form ``/@@custom_migration`` you can select a Dexterity-type for any Archetypes-types that exists in the portal. You can then map the source-types fields to the targets fields. You can also choose to ignore fields. You have to take care that the values can be migrated (since there is no validation for that), e.g. it would make no sense to migrate a ImageField to a TextField. There are build-in methods for most field-types, custom or rarely used fields might not migrate properly (you can create a issue if you miss a migration that is not yet supported).
+
+After you map the fields you can then test the configuration. During a test one item will be test-migrated and Plone checks if the migrated item will be accessible without throwing a errors.
 
 
 Widgets


Repository: plone.app.contenttypes
Branch: refs/heads/master
Date: 2015-04-23T19:17:55+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.app.contenttypes/commit/6bf37acfb388a167d3a5bb7921c30f24c83d81ad

ammend contributors

Files changed:
M docs/README.rst

diff --git a/docs/README.rst b/docs/README.rst
index 5aae5c7..64b1313 100644
--- a/docs/README.rst
+++ b/docs/README.rst
@@ -500,3 +500,4 @@ Contributors
 * Andrea Cecchi <andrea.cecchi@redturtle.it>
 * Bogdan Girman <bogdan.girman@gmail.com>
 * Martin Opstad Reistadbakk <martin@blaastolen.com>
+* Florent Michon <fmichon@atreal.fr>


Repository: plone.app.contenttypes
Branch: refs/heads/master
Date: 2015-04-23T20:27:15+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.app.contenttypes/commit/161e52fcae7460d0d33d9e179e264d4fb29c45ea

wording

Files changed:
M docs/README.rst

diff --git a/docs/README.rst b/docs/README.rst
index 64b1313..9e47cec 100644
--- a/docs/README.rst
+++ b/docs/README.rst
@@ -248,13 +248,13 @@ The old types that use leadimages are listed in the navigation-form with the com
 Migrating custom content
 ^^^^^^^^^^^^^^^^^^^^^^^^
 
-During normal migrations with ``/@@atct_migrator`` custom content-types will not be migrated and will continue to work as expected.
+During migrations of the default types any custom content-types will not be migrated and will continue to work as expected.
 
-To migrate these to Dexterity plone.app.contenttypes contains a migration form (``/@@custom_migration``) that allows you to migrate any (custom or default) Archetypes-type to any (custom or default) Dexterity-type. The only requirement is that the Dexterity-type you want to migrate to has to exist. It makes no difference if the type you are migrating is still registered in portal_types or is already removed or replaced.
+To help you migrating these to Dexterity plone.app.contenttypes contains a migration form (``/@@custom_migration``) that allows you to migrate any (custom or default) Archetypes-type to any (custom or default) Dexterity-type. The only requirement is that the Dexterity-type you want to migrate to has to exist and that the class of a old type are still present. It makes no difference if the type you are migrating is still registered in portal_types or is already removed or replaced by a dexterity-version using the same name.
 
 In the form ``/@@custom_migration`` you can select a Dexterity-type for any Archetypes-types that exists in the portal. You can then map the source-types fields to the targets fields. You can also choose to ignore fields. You have to take care that the values can be migrated (since there is no validation for that), e.g. it would make no sense to migrate a ImageField to a TextField. There are build-in methods for most field-types, custom or rarely used fields might not migrate properly (you can create a issue if you miss a migration that is not yet supported).
 
-After you map the fields you can then test the configuration. During a test one item will be test-migrated and Plone checks if the migrated item will be accessible without throwing a errors.
+After you map the fields you can test the configuration. During a test one item will be test-migrated and Plone checks if the migrated item will be accessible without throwing a errors. After the test any changes will be rolled back.
 
 
 Widgets


Repository: plone.app.contenttypes
Branch: refs/heads/master
Date: 2015-05-04T17:29:12+02:00
Author: Philip Bauer (pbauer) <bauer@starzel.de>
Commit: https://github.com/plone/plone.app.contenttypes/commit/7fd3a4c05e8ac259ec4f85c3049937a6cc64ae93

Merge pull request #224 from plone/issue133_custom_types_migration

custom types migration

Files changed:
A plone/app/contenttypes/migration/custom_migration.pt
A plone/app/contenttypes/migration/custom_migration.py
A plone/app/contenttypes/migration/custom_migration_display_dx_fields.pt
A plone/app/contenttypes/tests/test_migration_custom.py
M docs/CHANGES.rst
M docs/README.rst
M plone/app/contenttypes/migration/configure.zcml
M plone/app/contenttypes/migration/migration.py
M plone/app/contenttypes/migration/migrator.css
D README.rst

diff --git a/README.rst b/README.rst
deleted file mode 120000
index cffceba..0000000
--- a/README.rst
+++ /dev/null
@@ -1 +0,0 @@
-docs/README.rst
\ No newline at end of file
diff --git a/docs/CHANGES.rst b/docs/CHANGES.rst
index d3c0d42..d548685 100644
--- a/docs/CHANGES.rst
+++ b/docs/CHANGES.rst
@@ -109,6 +109,13 @@ Changelog
 1.2a5 (2014-10-23)
 ------------------
 
+- Add custom migration for AT-Types that were removed from portal_types.
+  [pbauer]
+
+- Added helper view for migration custom AT types to available DX types,
+  see issue #133.
+  [gbastien]
+
 - Code modernization: sorted imports, use decorators, utf8 headers.
   [jensens]
 
@@ -162,6 +169,9 @@ Changelog
   sort order correctly.
   [maurits]
 
+- Added migration method that allows to migrate custom AT types to
+  available DX types (#133)
+  [cekk]
 
 1.2a3 (2014-04-19)
 ------------------
diff --git a/docs/README.rst b/docs/README.rst
index b560657..9e47cec 100644
--- a/docs/README.rst
+++ b/docs/README.rst
@@ -248,11 +248,13 @@ The old types that use leadimages are listed in the navigation-form with the com
 Migrating custom content
 ^^^^^^^^^^^^^^^^^^^^^^^^
 
-Custom content-types will not be touched by the migration plone.app.contenttypes and will continue to work as expected.
+During migrations of the default types any custom content-types will not be migrated and will continue to work as expected.
 
-Future versions of plone.app.contenttypes will have with a form that allows you to migrate old custom Archetypes-content to Dexterity (you'll still have to create the Dexterity-types before migrating).
+To help you migrating these to Dexterity plone.app.contenttypes contains a migration form (``/@@custom_migration``) that allows you to migrate any (custom or default) Archetypes-type to any (custom or default) Dexterity-type. The only requirement is that the Dexterity-type you want to migrate to has to exist and that the class of a old type are still present. It makes no difference if the type you are migrating is still registered in portal_types or is already removed or replaced by a dexterity-version using the same name.
 
-If you want to migrate your custom types to Dexterity before this feature is completed you might want to have a look at the code of plone.app.contenttypes.migration.migration.NewsItemMigrator as a blueprint for a migration.
+In the form ``/@@custom_migration`` you can select a Dexterity-type for any Archetypes-types that exists in the portal. You can then map the source-types fields to the targets fields. You can also choose to ignore fields. You have to take care that the values can be migrated (since there is no validation for that), e.g. it would make no sense to migrate a ImageField to a TextField. There are build-in methods for most field-types, custom or rarely used fields might not migrate properly (you can create a issue if you miss a migration that is not yet supported).
+
+After you map the fields you can test the configuration. During a test one item will be test-migrated and Plone checks if the migrated item will be accessible without throwing a errors. After the test any changes will be rolled back.
 
 
 Widgets
@@ -494,5 +496,8 @@ Contributors
 * David Glick <david@glicksoftware.com>
 * Kees Hink <keeshink@gmail.com>
 * Roman Kozlovskyi <krzroman@gmail.com>
+* Gauthier Bastien <gauthier.bastien@imio.be>
+* Andrea Cecchi <andrea.cecchi@redturtle.it>
 * Bogdan Girman <bogdan.girman@gmail.com>
 * Martin Opstad Reistadbakk <martin@blaastolen.com>
+* Florent Michon <fmichon@atreal.fr>
diff --git a/plone/app/contenttypes/migration/configure.zcml b/plone/app/contenttypes/migration/configure.zcml
index 9881860..78288f8 100644
--- a/plone/app/contenttypes/migration/configure.zcml
+++ b/plone/app/contenttypes/migration/configure.zcml
@@ -67,6 +67,32 @@
     permission="cmf.ManagePortal"
     />
 
+  <browser:page
+    name="custom_migration"
+    for="Products.CMFPlone.interfaces.IPloneSiteRoot"
+    class=".custom_migration.CustomMigrationForm"
+    layer="..interfaces.IPloneAppContenttypesLayer"
+    permission="cmf.ManagePortal"
+    template="custom_migration.pt"
+    />
+
+  <browser:page
+    name="display_dx_fields"
+    for="Products.CMFPlone.interfaces.IPloneSiteRoot"
+    class=".custom_migration.DisplayDXFields"
+    layer="..interfaces.IPloneAppContenttypesLayer"
+    permission="cmf.ManagePortal"
+    template="custom_migration_display_dx_fields.pt"
+    />
+
+  <browser:page
+    name="test_migration"
+    for="Products.CMFPlone.interfaces.IPloneSiteRoot"
+    class=".custom_migration.TestMigration"
+    layer="..interfaces.IPloneAppContenttypesLayer"
+    permission="cmf.ManagePortal"
+    />
+
   <utility
       factory=".vocabularies.ATCTypesVocabulary"
       name="plone.app.contenttypes.migration.atctypes"
diff --git a/plone/app/contenttypes/migration/custom_migration.pt b/plone/app/contenttypes/migration/custom_migration.pt
new file mode 100644
index 0000000..db21bae
--- /dev/null
+++ b/plone/app/contenttypes/migration/custom_migration.pt
@@ -0,0 +1,149 @@
+<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"
+      xmlns:tal="http://xml.zope.org/namespaces/tal"
+      xmlns:metal="http://xml.zope.org/namespaces/metal"
+      xmlns:i18n="http://xml.zope.org/namespaces/i18n"
+      lang="en"
+      metal:use-macro="context/main_template/macros/master"
+      i18n:domain="plone">
+
+<metal:block fill-slot="top_slot"
+    tal:define="dummy python:request.set('disable_border', 1);
+                disable_column_two python:request.set('disable_plone.rightcolumn', 1);
+                disable_column_two python:request.set('disable_plone.leftcolumn', 1);
+                portal_state context/@@plone_portal_state;
+                portal_url portal_state/portal_url">
+  <link rel="stylesheet" type="text/css" href="" media="screen" tal:attributes="href string:${portal_url}/++resource++pac_migrator.css">
+</metal:block>
+
+<body>
+
+<metal:custom_title fill-slot="content-title">
+  <h1 class="documentFirstHeading" i18n:translate="">Custom types migration control panel</h1>
+</metal:custom_title>
+<metal:custom_desc fill-slot="content-description">
+  <div class="documentDescription" i18n:translate="">Migrate custom Archetypes content types to any available Dexterity content types.</div>
+</metal:custom_desc>
+
+<metal:content-core fill-slot="content-core">
+<metal:block define-macro="content-core"
+             tal:define="at_types view/getAllArchetypeTypes">
+  <div class="important">
+    <h2 i18n:translate="">Important</h2>
+    <p i18n:translate="">Before migrating your content please read the <a href="https://github.com/plone/plone.app.contenttypes#migration">migration-section in the documentation of plone.app.contenttypes</a></p>
+
+
+    <h3>Migrating content that is translated with LinguaPlone</h3>
+    <p i18n:translate="">Since LinguaPlone does not support Dexterity you need to migrate from LinguaPlone to <a href="http://pypi.python.org/pypi/plone.app.multilingual">plone.app.multilingual</a>. The migration from Products.LinguaPlone to plone.app.multilingual should happen before the migration from Archetypes to plone.app.contenttypes. For details on the migration see the <a href="http://pypi.python.org/pypi/plone.app.multilingual#linguaplone-migration">documentation</a></p>
+    <h3 i18n:translate="">Note about how long it might take</h3>
+    <p i18n:translate="">Depending of the number of archetypes in your portal, it may take a <span class="strong">really</span> long time for the migration to be done.
+      Stay calm and be patient.</p>
+    </div>
+    <script type="text/javascript">
+        // function that toggle an icon by calling the p_viewName view
+        function getDXFields(at_typename, dx_typename) {
+          $.ajax({
+            url: '@@display_dx_fields',
+            dataType: 'html',
+            data: {at_typename: at_typename,
+                   dx_typename: dx_typename},
+            cache: false,
+            success: function(data) {
+                var $div = $('#hook_at_fti_' + at_typename);
+                $div.empty();
+                $div.html(data);
+              },
+            error: function(jqXHR, textStatus, errorThrown) {
+              }
+            });
+        }
+        $(document).ready(function () {
+            $('input[name="form.button.Test"]').on( "click", function(e) {
+                e.preventDefault();
+                var $this = $(this);
+                var tested_type = $this.parent().siblings('select.selectedType');
+                $this.parent().removeClass('error');
+                $this.parent().siblings('.fieldsMapping').removeClass('error');
+                $this.parent().removeClass('success');
+                $this.parent().addClass('testing');
+                $.ajax({
+                    url: '@@test_migration?' + $(this).parents('form').serialize() + '&tested_type=' + tested_type.attr('name'),
+                    dataType: 'json',
+                    success: function(data) {
+                        $this.parent().removeClass('testing');
+                        if(data.status === 'error') {
+                            $this.parent().addClass('error');
+                            $this.parent().siblings('.fieldsMapping').addClass('error');
+                        }
+                        else{
+                            $this.parent().addClass('success');
+                        }
+                    },
+                    error: function(jqXHR, textStatus, errorThrown) {
+                        $this.parent().removeClass('testing');
+                        $this.parent().addClass('error');
+                        $this.parent().siblings('.fieldsMapping').addClass('error');
+                    }
+                });
+            });
+        });
+    </script>
+    <tal:block condition="at_types">
+        <div id="migration-options">
+          <h2 i18n:translate="">Migrate contents</h2>
+          <div i18n:translate=""
+            class="documentDescription">
+            <p>You can select which AT content type you want to migrate to an existing DX content type.</p>
+            <form id="migrateCustomATForm" method="post"
+                  tal:attributes="action python:context.absolute_url() + '/@@custom_migration'">
+            <table>
+                <tr tal:repeat="at_type at_types">
+                <p tal:content="at_type"></p>
+                    <td valign="top">
+                        <p tal:content="at_type/title" style="font-weight: bold;">AT content type title</p>
+                        <tal:block repeat="field python: view.getFieldsForATType(at_type)">
+                            <p tal:content="field/title">Field name</p>
+                            <input type="hidden" tal:attributes="name string:${at_type/id}:list;
+                                                                 value string:${field/id}__type__${field/type};" />
+                        </tal:block>
+                    </td>
+                    <td valign="top">
+                        <select tal:attributes="onChange string:javascript:getDXFields(at_typename='${at_type/id}', this.value);
+                                                name string:dx_select_${at_type/id};"
+                                class="selectedType">
+                            <option value="" selected="selected">Do not migrate</option>
+                            <option tal:repeat="dx_type view/getDXFTIs"
+                                    tal:attributes="value dx_type/id"
+                                    tal:content="dx_type/title">DX type name</option>
+                        </select>
+                        <div id="hook_at_fti" class="field fieldsMapping" tal:attributes="id string:hook_at_fti_${at_type/id}" />
+                        <br />
+                        <div class="testConfig">
+                            <input type="submit"
+                                   name="form.button.Test"
+                                   class="context"
+                                   value="Test configuration"
+                                   i18n:attributes="value"
+                                   i18n:domain="plone"/>&nbsp;
+                        </div>
+                    </td>
+                </tr>
+            </table>
+            <div>
+              <br />
+              <input type="submit" name="form.button.Migrate" class="context" value="Migrate" i18n:attributes="value" i18n:domain="plone"/>&nbsp;
+              <input type="submit" name="form.button.Cancel" class="standalone" value="Cancel" i18n:attributes="value" i18n:domain="plone"/>
+            </div>
+            </form>
+          </div>
+        </div>
+    </tal:block>
+  <tal:block condition="not:at_types">
+    <div class="important">
+      <h2 i18n:translate="">Warning</h2>
+      <p i18n:translate="" class="strong">No content to migrate.</p>
+  </tal:block>
+
+</metal:block>
+</metal:content-core>
+</body>
+</html>
diff --git a/plone/app/contenttypes/migration/custom_migration.py b/plone/app/contenttypes/migration/custom_migration.py
new file mode 100644
index 0000000..24f5bf4
--- /dev/null
+++ b/plone/app/contenttypes/migration/custom_migration.py
@@ -0,0 +1,310 @@
+# -*- coding: UTF-8 -*-
+from Products.ATContentTypes.content.schemata import ATContentTypeSchema
+from Products.CMFCore.utils import getToolByName
+from Products.Five.browser import BrowserView
+from Products.Five.browser.pagetemplatefile import ViewPageTemplateFile
+from Products.statusmessages.interfaces import IStatusMessage
+from plone.app.contenttypes import _
+from plone.app.contenttypes.migration.migration import migrateCustomAT
+from plone.dexterity.interfaces import IDexterityContent
+from plone.dexterity.interfaces import IDexterityFTI
+from plone.dexterity.utils import iterSchemataForType
+from zope.i18n import translate
+import json
+import logging
+import traceback
+
+logger = logging.getLogger(__name__)
+
+HAS_EXTENDER = True
+try:
+    from archetypes.schemaextender.extender import instanceSchemaFactory
+except ImportError:
+    HAS_EXTENDER = False
+
+
+class CustomMigrationForm(BrowserView):
+
+    template = ViewPageTemplateFile('custom_migration.pt')
+    at_metadata_fields = ATContentTypeSchema.keys()
+    dx_metadata_fields = list(at_metadata_fields)
+    # some metadata names are different between AT and DX...
+    dx_metadata_fields.remove('allowDiscussion')
+    dx_metadata_fields.remove('excludeFromNav')
+    dx_metadata_fields.append('allow_discussion')
+    dx_metadata_fields.append('exclude_from_nav')
+
+    def __call__(self):
+        # check that we can actually access this form,
+        # aka the current user has an advice to add or edit
+        form = self.request.form
+        cancelled = form.get('form.button.Cancel', False)
+        submitted = form.get('form.button.Migrate', False)
+        # test = form.get('form.button.Test', False)
+        if submitted:
+            # proceed, call the migration methdd
+            results = self.migrate()
+            messages = IStatusMessage(self.request)
+            for migration_result in results:
+                res_type = migration_result.get('type')
+                res_infos = migration_result.get('infos')
+                if res_infos.get('errors'):
+                    messages.add(
+                        u'Error when migrating "%s" type. Check the '
+                        u'log for other informations.'
+                        % res_type, type=u"error")
+                else:
+                    msg = translate(
+                        'Migration applied succesfully for %s "%s" items.'
+                        % (res_infos.get('counter'), res_type),
+                        domain='plone.app.contenttypes')
+                    messages.add(msg, type=u"info")
+        elif cancelled:
+            self.request.response.redirect(form.get('form.HTTP_REFERER'))
+        return self.index()
+
+    def getAllArchetypeTypes(self):
+        at_types = self.getATFTIs()
+        at_types.extend(self.getATTypesWithoutFTI())
+        return at_types
+
+    def getATFTIs(self):
+        '''Returns a list of all AT types with existing instances
+        (including default-types).
+        '''
+        results = []
+        archetype_tool = getToolByName(self.context, 'archetype_tool', None)
+        # if we do not have archetype_tool, it means that we have
+        # no registered AT types
+        if not archetype_tool:
+            return results
+
+        typesTool = getToolByName(self.context, 'portal_types')
+        catalog = getToolByName(self.context, 'portal_catalog')
+        registeredTypeNames = [registered['name'] for registered
+                               in archetype_tool.listRegisteredTypes()]
+        for fti in typesTool.listTypeInfo():
+            ftiId = fti.getId()
+            if hasattr(fti, 'content_meta_type') and \
+               fti.content_meta_type in registeredTypeNames and \
+               catalog(portal_type=ftiId):
+                results.append({'id': ftiId,
+                                'title': fti.Title(),
+                                'removed': False})
+        return results
+
+    def getATTypesWithoutFTI(self):
+        """Returns a list of the id's of archetypes-types that are
+           not registered in portal_types but still have instances.
+        """
+        results = []
+        all_registered_types = [i['id'] for i in self.getATFTIs()]
+        catalog = getToolByName(self.context, 'portal_catalog')
+        for meta_type in catalog.uniqueValuesFor('meta_type'):
+            # querying for meta_type will only return at-types
+            brain = catalog(meta_type=meta_type, sort_limit=1)[0]
+            if IDexterityContent.providedBy(brain.getObject()):
+                continue
+            typename = brain.portal_type
+            if typename not in all_registered_types:
+                    results.append({'id': typename,
+                                    'title': typename,
+                                    'removed': True})
+        return results
+
+    def getDXFTIs(self):
+        '''Returns the FTI's of all DX-Types (including default-types).'''
+        results = []
+        portal = self.context
+        ttool = getToolByName(portal, 'portal_types')
+        for fti in ttool.listTypeInfo():
+            if IDexterityFTI.providedBy(fti):
+                results.append({'id': fti.getId(),
+                                'title': fti.Title()})
+        return results
+
+    def getFieldsForATType(self, typeinfo):
+        '''Returns schema fields (name and type) for the given AT typename.'''
+        if typeinfo['removed']:
+            return self.getFieldsForATTypeWithoutFTI(typeinfo['id'])
+        return self.getFieldsForATTypeWithFTI(typeinfo['id'])
+
+    def getFieldsForATTypeWithFTI(self, typename):
+        '''Returns schema fields (name and type) from the fti.'''
+        results = []
+        typesTool = getToolByName(self.context, 'portal_types')
+        fti = typesTool.getTypeInfo(typename)
+        archetype_tool = getToolByName(self.context, 'archetype_tool', None)
+        if not fti or not archetype_tool:
+            return results
+        schema = None
+        # a schema instance is stored in the archetype_tool
+        for regType in archetype_tool.listRegisteredTypes():
+            if regType['meta_type'] == fti.content_meta_type:
+                if HAS_EXTENDER:
+                    schema = instanceSchemaFactory(regType['klass'])
+                else:
+                    schema = regType['schema']
+                break
+        if not schema:
+            return results
+        for field in schema.fields():
+            if not field.getName() in self.at_metadata_fields:
+                translated_label = translate(field.widget.label)
+                results.append(
+                    {'id': field.getName(),
+                     'title': '%s (%s)' % (translated_label, field.getType()),
+                     'type': field.getType()})
+        return results
+
+    def getFieldsForATTypeWithoutFTI(self, typename):
+        """Returns a list of fields for archetypes-types without a fti.
+           Instead of iterating over the schema in the fti it takes one
+           instance and gets the schema from that.
+        """
+        catalog = getToolByName(self.context, 'portal_catalog')
+        results = []
+        brains = catalog(portal_type=typename, sort_limit=1)
+        if not brains:
+            return results
+        obj = brains[0].getObject()
+        for field_name in obj.schema._fields:
+            field = obj.schema._fields[field_name]
+            if not field.getName() in self.at_metadata_fields:
+                translated_label = translate(field.widget.label)
+                results.append(
+                    {'id': field.getName(),
+                     'title': '%s (%s)' % (translated_label, field.getType()),
+                     'type': field.getType()})
+        return results
+
+    def getFieldsForDXType(self, typename):
+        '''Returns schema fields (name and type) for the given DX typename.'''
+        results = []
+        typesTool = getToolByName(self.context, 'portal_types')
+        fti = typesTool.getTypeInfo(typename)
+        if not fti:
+            return results
+
+        for schemata in iterSchemataForType(typename):
+            for fieldName, field in schemata.namesAndDescriptions():
+                # ignore Dublin Core fields
+                if fieldName in self.dx_metadata_fields:
+                    continue
+                translated_title = translate(field.title)
+                class_name = field.__class__.__name__
+                results.append(
+                    {'id': fieldName,
+                     'title': '%s (%s)' % (translated_title, class_name),
+                     'type': class_name})
+        return results
+
+    def getPossibleTargetField(self, fieldtype):
+        ''' a list of DX-field types'''
+
+    def isFolderish(self):
+        ''' decide which base-class we use for the migrator'''
+
+    def migrate(self, dry_run=False):
+        '''Build data from the migration form. We will build a dict like :
+           {'MyATPortalType':
+                {'MyDXPortalType': (
+                    {'AT_field_name': 'fieldname1',
+                     'AT_field_type': 'Products.Archetypes.Field.TextField',
+                     'DX_field_name': 'field_name1',
+                     'DX_field_type': 'RichText'}, )}}
+        Call the migrateCustomAT migrator for each AT content_type we choose
+        to migrate.
+        '''
+        data = {}
+        form = self.request.form
+        # manipulate what we receive in the form and build a useable data dict
+        for k in self.request.form.keys():
+            if k.startswith('dx_select_'):
+                # we found select where we choose a DX type regarding an AT
+                # type the selelect name is like 'dx_select_MyATPortalType'
+                if not form[k] or (dry_run and k != form.get('tested_type')):
+                    # nothing selected in this select, continue
+                    continue
+                at_typename = k[10:]
+                dx_typename = form[k]
+                data[at_typename] = {'target_type': dx_typename,
+                                     'field_mapping': []}
+                # now handle fields mapping for found DX/AT type migration
+                # definition we have 2 keys we relevant mappings, first key
+                # is the AT typename second key is a particular key like
+                # 'dx_DXPortalType__for__MyATPortalType
+                dx_key = 'dx_%s__for__%s' % (dx_typename, at_typename)
+                for at_field in form[at_typename]:
+                    dx_field = form[dx_key][form[at_typename].index(at_field)]
+                    if not dx_field:
+                        continue
+                    at_field_name, at_field_type = at_field.split('__type__')
+                    dx_field_name, dx_field_type = dx_field.split('__type__')
+                    field_data = {'AT_field_name': at_field_name,
+                                  'AT_field_type': at_field_type,
+                                  'DX_field_name': dx_field_name,
+                                  'DX_field_type': dx_field_type, }
+                    data[at_typename]['field_mapping'].append(field_data)
+
+        # now that the data dict contains relevant information, we can call
+        # the custom migrator
+        migration_results = []
+        for at_typename in data:
+            fields_mapping = data[at_typename]['field_mapping']
+            res = migrateCustomAT(
+                fields_mapping=fields_mapping,
+                src_type=at_typename,
+                dst_type=data[at_typename]['target_type'],
+                dry_run=dry_run)
+            migration_results.append({'type': at_typename,
+                                      'infos': res})
+        return migration_results
+
+
+class DisplayDXFields(CustomMigrationForm):
+
+    template = ViewPageTemplateFile('custom_migration_display_dx_fields.pt')
+
+    def __init__(self, context, request):
+        CustomMigrationForm.__init__(self, context, request)
+        self.at_typename = request.get('at_typename')
+        self.dx_typename = request.get('dx_typename')
+
+    def __call__(self):
+        '''
+        '''
+        return self.index()
+
+
+class TestMigration(CustomMigrationForm):
+
+    def __call__(self):
+        '''
+        View that call migrate method with dry_run mode set.
+        Returns a json response with the result.
+        This view is called by a js.
+        '''
+        response = {}
+        error_msg = _(u'Migrating to this content type is impossible with '
+                      u'this configuration')
+        try:
+            results = self.migrate(dry_run=True)
+        except Exception, e:
+            trace = traceback.format_exc()
+            msg = "Test-Migration failed: %s\n%s\n" % (e, trace)
+            logger.error(msg)
+            response['status'] = 'error'
+            response['message'] = msg
+            return json.dumps(response)
+
+        migration_result = results[0]
+        res_infos = migration_result.get('infos')
+        if res_infos.get('errors'):
+            response['status'] = 'error'
+            response['message'] = error_msg
+        else:
+            response['status'] = 'success'
+            response['message'] = 'Testing migration succesful'
+        self.request.response.setHeader('Content-type', 'application/json')
+        return json.dumps(response)
diff --git a/plone/app/contenttypes/migration/custom_migration_display_dx_fields.pt b/plone/app/contenttypes/migration/custom_migration_display_dx_fields.pt
new file mode 100644
index 0000000..775f40a
--- /dev/null
+++ b/plone/app/contenttypes/migration/custom_migration_display_dx_fields.pt
@@ -0,0 +1,8 @@
+<tal:loop repeat="at_field python: view.getFieldsForATTypeWithoutFTI(view.at_typename)">
+    <select tal:attributes="name string:dx_${view/dx_typename}__for__${view/at_typename}:list;">
+        <option value="">Do not migrate</option>
+        <option tal:repeat="dx_field python: view.getFieldsForDXType(view.dx_typename)"
+                tal:attributes="value string:${dx_field/id}__type__${dx_field/type};"
+                tal:content="string:${dx_field/title}">DX field name</option>
+    </select>
+</tal:loop>
diff --git a/plone/app/contenttypes/migration/migration.py b/plone/app/contenttypes/migration/migration.py
index 798f897..84cf63b 100644
--- a/plone/app/contenttypes/migration/migration.py
+++ b/plone/app/contenttypes/migration/migration.py
@@ -10,10 +10,12 @@
 from Products.ATContentTypes.interfaces.interfaces import IATContentType
 from Products.Archetypes.config import REFERENCE_CATALOG
 from Products.CMFCore.utils import getToolByName
-from Products.CMFPlone.utils import safe_unicode, safe_hasattr
+from Products.CMFPlone.utils import safe_hasattr
+from Products.CMFPlone.utils import safe_unicode
 from Products.contentmigration.basemigrator.migrator import CMFFolderMigrator
 from Products.contentmigration.basemigrator.migrator import CMFItemMigrator
 from Products.contentmigration.basemigrator.walker import CatalogWalker
+from Products.contentmigration.walker import CustomQueryWalker
 from copy import deepcopy
 from persistent.list import PersistentList
 from plone.app.contenttypes.behaviors.collection import ICollection
@@ -22,12 +24,13 @@
 from plone.app.contenttypes.migration.dxmigration import DXOldEventMigrator
 from plone.app.contenttypes.migration.utils import add_portlet
 from plone.app.contenttypes.migration.utils import copy_contentrules
-from plone.app.contenttypes.migration.utils import move_comments
 from plone.app.contenttypes.migration.utils import migrate_leadimage
+from plone.app.contenttypes.migration.utils import move_comments
 from plone.app.contenttypes.utils import DEFAULT_TYPES
 from plone.app.textfield.value import RichTextValue
 from plone.app.uuid.utils import uuidToObject
 from plone.dexterity.interfaces import IDexterityContent
+from plone.dexterity.interfaces import IDexterityFTI
 from plone.event.utils import default_timezone
 from plone.namedfile.file import NamedBlobFile
 from plone.namedfile.file import NamedBlobImage
@@ -41,14 +44,136 @@
 from zope.component import getMultiAdapter
 from zope.component import getSiteManager
 from zope.component import getUtility
+from zope.component.hooks import getSite
 from zope.interface import Interface
 from zope.interface import implementer
 from zope.intid.interfaces import IIntIds
-
 import logging
+import transaction
 logger = logging.getLogger(__name__)
 
 
+def migrate_simplefield(src_obj, dst_obj, src_fieldname, dst_fieldname):
+    """
+    migrate a generic simple field (like a string field or a date field)
+    """
+    field = src_obj.getField(src_fieldname)
+    if field:
+        at_value = field.get(src_obj)
+    else:
+        at_value = getattr(src_obj, src_fieldname, None)
+        if at_value and hasattr(at_value, '__call__'):
+            at_value = at_value()
+    if isinstance(at_value, tuple):
+        at_value = tuple(safe_unicode(i) for i in at_value)
+    if isinstance(at_value, list):
+        at_value = [safe_unicode(i) for i in at_value]
+    if at_value:
+        setattr(dst_obj, dst_fieldname, safe_unicode(at_value))
+
+
+def migrate_richtextfield(src_obj, dst_obj, src_fieldname, dst_fieldname):
+    """
+    migrate a rich text field.
+    This field needs some extra stuffs like keep the same mimetype.
+    """
+    field = src_obj.getField(src_fieldname)
+    raw_text = ''
+    if field:
+        mime_type = field.getContentType(src_obj)
+        raw_text = safe_unicode(field.getRaw(src_obj))
+    else:
+        at_value = getattr(src_obj, src_fieldname, None)
+        if at_value:
+            mime_type = at_value.mimetype
+            raw_text = safe_unicode(at_value.raw)
+
+    if raw_text.strip() == '':
+            return
+    richtext = RichTextValue(raw=raw_text, mimeType=mime_type,
+                             outputMimeType='text/x-html-safe')
+    setattr(dst_obj, dst_fieldname, richtext)
+
+
+def migrate_imagefield(src_obj, dst_obj, src_fieldname, dst_fieldname):
+    """
+    migrate an image field.
+    This field needs to be migrated with an NamedBlobImage instance.
+    """
+    # get old image data and filename
+    old_image = src_obj.getField(src_fieldname).get(src_obj)
+    if old_image == '':
+        return
+    filename = safe_unicode(old_image.filename)
+    old_image_data = old_image.data
+    if safe_hasattr(old_image_data, 'data'):
+        old_image_data = old_image_data.data
+
+    # create the new image field
+    namedblobimage = NamedBlobImage(data=old_image_data,
+                                    filename=filename)
+
+    # set new field on destination object
+    setattr(dst_obj, dst_fieldname, namedblobimage)
+
+    # handle a possible image caption field
+    # postulate is the old caption field name is ending by 'Caption'
+    # and the new field name is ending by '_caption'
+    # is this postulate correct ?
+    # should this field not be handle by itself because it will appear in the
+    # old field list ?
+    caption_field = src_obj.getField('%sCaption' % src_fieldname, None)
+    if caption_field:
+        setattr(dst_obj,
+                ('%s_caption' % dst_fieldname),
+                safe_unicode(caption_field.get(src_obj)))
+
+    logger.info("Migrating image %s" % filename)
+
+
+def migrate_filefield(src_obj, dst_obj, src_fieldname, dst_fieldname):
+    """
+    migrate a file field.
+    This field needs to be migrated with an NamedBlobFile instance.
+    """
+    old_file = src_obj.getField(src_fieldname).get(src_obj)
+    if old_file == '':
+        return
+    filename = safe_unicode(old_file.filename)
+    old_file_data = old_file.data
+    if safe_hasattr(old_file_data, 'data'):
+        old_file_data = old_file_data.data
+    namedblobfile = NamedBlobFile(data=old_file_data,
+                                  filename=filename)
+    setattr(dst_obj, dst_fieldname, namedblobfile)
+    logger.info("Migrating file %s" % filename)
+
+
+def migrate_datetimefield(src_obj, dst_obj, src_fieldname, dst_fieldname):
+    """Migrate a datefield."""
+    old_value = src_obj.getField(src_fieldname).get(src_obj)
+    if old_value == '':
+        return
+    if src_obj.getField('timezone', None) is not None:
+        old_timezone = src_obj.getField('timezone').get(src_obj)
+    else:
+        old_timezone = default_timezone(fallback='UTC')
+    new_value = datetime_fixer(old_value.asdatetime(), old_timezone)
+    setattr(dst_obj, dst_fieldname, new_value)
+
+
+# this mapping is needed to use the right migration method
+# we use the full field type path as it is retrieved from the target-field
+# (field.getType()), to avoid conflict.
+# TODO In the __future__ we should have a more dynamic way to configure this
+# mapping
+FIELDS_MAPPING = {'RichText': migrate_richtextfield,
+                  'NamedBlobFile': migrate_filefield,
+                  'NamedBlobImage': migrate_imagefield,
+                  'Datetime': migrate_datetimefield,
+                  'Date': migrate_datetimefield}
+
+
 def migrate(portal, migrator):
     """return a CatalogWalker instance in order
     to have its output after migration"""
@@ -606,3 +731,113 @@ def migrate_events(portal):
     migrate(portal, DXOldEventMigrator)
     migrate(portal, EventMigrator)
     migrate(portal, DXEventMigrator)
+
+
+def makeCustomATMigrator(
+    context,
+    src_type,
+    dst_type,
+    fields_mapping,
+    is_folderish=False,
+    dry_run=False
+):
+    """ generate a migrator for the given at-based folderish portal type """
+
+    base_class = ATCTContentMigrator
+    if is_folderish:
+        base_class = ATCTFolderMigrator
+
+    class CustomATMigrator(base_class):
+
+        src_portal_type = src_type
+        dst_portal_type = dst_type
+        dry_run_mode = dry_run
+
+        def migrate_schema_fields(self):
+            for fields_dict in fields_mapping:
+                at_fieldname = fields_dict.get('AT_field_name')
+                dx_fieldname = fields_dict.get('DX_field_name')
+                dx_fieldtype = fields_dict.get('DX_field_type')
+                migration_field_method = migrate_simplefield
+                if dx_fieldtype in FIELDS_MAPPING:
+                    # Richtext, Image and File have custom migraton_methods
+                    migration_field_method = FIELDS_MAPPING[dx_fieldtype]
+                migration_field_method(src_obj=self.old,
+                                       dst_obj=self.new,
+                                       src_fieldname=at_fieldname,
+                                       dst_fieldname=dx_fieldname)
+
+        def last_migrate_check(self):
+            """
+            BBB to be checked
+            if there is an error with the fields, an exception will be raised.
+            """
+            if self.dry_run_mode:
+                view = getMultiAdapter(
+                    (self.new, self.new.REQUEST), name="view")
+                view()
+
+    return CustomATMigrator
+
+
+def migrateCustomAT(fields_mapping, src_type, dst_type, dry_run=False):
+    """
+    Try to get types infos from archetype_tool, then set a migrator an pass it
+    given values. There is a dry_run mode that allows to check the success of
+    a migration without committing.
+    """
+    portal = getSite()
+
+    # if the type still exists get the src_meta_type from the portal_type
+    portal_types = getToolByName(portal, 'portal_types')
+    fti = portal_types.get(src_type, None)
+    # Check if the fti was removed or replaced by a DX-implementation
+    if fti is None or IDexterityFTI.providedBy(fti):
+        # Get the needed info from an instance of the type
+        catalog = portal.portal_catalog
+        brain = catalog(portal_type=src_type, sort_limit=1)[0]
+        src_obj = brain.getObject()
+        if IDexterityContent.providedBy(src_obj):
+            logger.error(
+                '%s should not be dexterity object!' % src_obj.absolute_url())
+        is_folderish = getattr(src_obj, 'isPrincipiaFolderish', False)
+        src_meta_type = src_obj.meta_type
+    else:
+        # Get info from at-fti
+        src_meta_type = fti.content_meta_type
+        archetype_tool = getToolByName(portal, 'archetype_tool', None)
+        for info in archetype_tool.listRegisteredTypes():
+            # lookup registered type in archetype_tool with meta_type
+            # because several portal_types can use same meta_type
+            if info.get('meta_type') == src_meta_type:
+                klass = info.get('klass', None)
+                is_folderish = klass.isPrincipiaFolderish
+
+    migrator = makeCustomATMigrator(context=portal,
+                                    src_type=src_type,
+                                    dst_type=dst_type,
+                                    fields_mapping=fields_mapping,
+                                    is_folderish=is_folderish,
+                                    dry_run=dry_run)
+    if migrator:
+        migrator.src_meta_type = src_meta_type
+        migrator.dst_meta_type = ''
+        walker_settings = {'portal': portal,
+                           'migrator': migrator,
+                           'src_portal_type': src_type,
+                           'dst_portal_type': dst_type,
+                           'src_meta_type': src_meta_type,
+                           'dst_meta_type': '',
+                           'use_savepoint': True}
+        if dry_run:
+            walker_settings['limit'] = 1
+        walker = CustomQueryWalker(**walker_settings)
+        walker.go()
+        walker_infos = {'errors': walker.errors,
+                        'msg': walker.getOutput().splitlines(),
+                        'counter': walker.counter}
+        for error in walker.errors:
+            logger.error(error.get('message'))
+        if dry_run:
+            transaction.abort()
+        return walker_infos
diff --git a/plone/app/contenttypes/migration/migrator.css b/plone/app/contenttypes/migration/migrator.css
index ed6e42d..53cdf51 100644
--- a/plone/app/contenttypes/migration/migrator.css
+++ b/plone/app/contenttypes/migration/migrator.css
@@ -68,3 +68,21 @@ table th {
     text-align: center;
     font-weight: normal;
 }
+
+.testConfig.error {
+    padding-right: 30px;
+    background: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAClklEQVR42q3VX0gUQRwH8N/M3N7tnXe3Z4IiESc9FBaBWHg99VSET0F/HxIKKg1FK4gK8grUoB59UaEetKAwoojAsCgIIsw/ROSRhCFpecVpd7d6f/Zmd6fZJY2ebmHu97Asw373w/x2ZhaBg1IPH78JNRsuMxeGQoFCYmbh1raRZ1ecZFGxB3JHm/pJY+1Z5JcBGAOEMdB0BmIP3/XsGn0eFQa0S+0M1VUDFIz1MeJ2wfe3nyHcd7dovjhwsZWh2koAw1wfwy4CP8ZnITxwrwTAhVYGW8o5wP4DFqe+Qvj2fXEgf66FobACYHIAYd4fYrco/mkeNvUPlgBoPs3Q1hB/sQQs8QtYbBqIqsLYh/jKnmQ6KAzkzjSPoY0oYo6MAkuqAC4XuPlyfT2bHN+f0yLCQCayewoSs/VgfQJM7ISbIHgzn/q4N5evEwZUr/8FrvLtg3/fGGQO9M0tRTuY0SMMpH3BKAl5uqxNtlZejGAgnuxqM/XrpQA6id/dvQZYAcZX1FBKPd9m6L0lAJSdWMYTCJD9rHXN6CY8Wc3Uthh0RhhI+RQJS1jlL5bXAjnTLDzOZKs4kBIG7FkEQnO87TXWPeFSnNL0K00rbzYoK5Z1BPwuU3rdCHVY9xIHYlSbrs9ndzjJOgJ+likVfJkmKDNRlpkQM/SGg1SbKBkgUo6AJX/oDiLolJdgUHUK8wX9UUM+e6QkQNobPIED0iDmu9c+LXhCpyYMLasn2019SBhQQ6EuUilH7eP6b3k49vJbqrsxn78mDKTKlB73duUq45vLngJPyBKBB5OLN5oM2ineIjnYQDYH35Nqn/3bxPyoXl1QYfjLcqSV0XFhwKq4J3jAVeEZRgHJk0lq2uTSyrFDZuGpk+wfCfYGKNjXCTAAAAAASUVORK5CYII=') no-repeat right center;
+}
+.testConfig.success {
+    padding-right: 30px;
+    background: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAC9ElEQVR42u2UW0gUURjH/7Pj7tIqhu5tvK/aRS3K7KGHepAQ7SJBEBaESmAXqAeJKDQQipKgEiPEiCAzLE2CLlCQREVvIhEopuaq7a6aI67rXp3ZnTnNDrZYupqXeuqDMwNzzvn95nznO4fCXw7qv+CfC5hXTEV+ek5116gZn3J7qVUVbHqbRrYnZuBq6g2UdB7BiG1q9VYwG37ZVgErZ8HXz+OrIwjCq3ecQ44qV4ZbuG9wu3lYexwrF/wOH/QNwc+LGOyaAK8VK1ckyGpLJQ931cFAm2S42TOAYN0Mddvh9vJgj7HL3+S4pwy5U1AV+vN+txk0TcPa78DkuA9sGSuz5Ufca4YIrChPZEvZRaVMM0MqC0pRFHUc5UMnMeL9DpUyAmNWt9RcIbgsYF4wpGBjDs4mnMFd9j5aP34IK2GeMZToEcWSvD04H3sJF63l6HH2Qq1Uwz4+jeE+B8ZOjP0yl8p4YyKnthSi3dmBC/FVONx5GvY+z7wSQ5OB5O3MRk1CPerY63jHvpfgKkw5eQx3T2K0bGzOHCqzLY1sSzFAE6GGN8CFlRhbjCRraxLXmNaoful4gsejLVDSEXA6/eBcfnQWmOddNcU8Z0iyPsa/2ahTTgt+BKSPu2P2ora/ISQxPDCQpGwtmjMb0OFqR72tHgqFAm5XAKzZCUvxSNh9o4J3B/yoXmfUwqRbC14UEZBavna/LEFw7xVAU85tTEx7cc1yReoX4PUIsNvcGCiyLVgUcqckIZSPQqZJD310JLhAQFqJiELdAVgjvuDgmqOwcz7cGq6Bk3fC5xXhtnPoKRxctOJCA4LVpPLTyEjXIVKjliUCEZCiScah2GLUDt+U4dNesmDOwwpmypCoBBqZ6/WglQoIgiilLABO4KCgVBJcSo2DR/e+gT8+oHMGMq0MiaSVSN+glZJEIIoEgtQ8Xv+S4fMKgmF8ZCQx0RokmqKlNBG4XPyy4GEFwTDcMxBdfNRMDWFZ8AUFPyXB9+y7ZanxA2o0cjyUQuVrAAAAAElFTkSuQmCC') no-repeat right center;
+}
+
+.testConfig.testing {
+  background: #ffffff url('++plone++static/components//select2/select2-spinner.gif') no-repeat 100% right center;
+  background: url('++plone++static/components//select2/select2-spinner.gif') no-repeat 100%, -webkit-gradient(linear, left bottom, left top, color-stop(0.85, #ffffff), color-stop(0.99, #eeeeee));
+  background: url('++plone++static/components//select2/select2-spinner.gif') no-repeat 100%, -webkit-linear-gradient(center bottom, #ffffff 85%, #eeeeee 99%);
+  background: url('++plone++static/components//select2/select2-spinner.gif') no-repeat 100%, -moz-linear-gradient(center bottom, #ffffff 85%, #eeeeee 99%);
+  background: url('++plone++static/components//select2/select2-spinner.gif') no-repeat 100%, linear-gradient(to bottom, #ffffff 85%, #eeeeee 99%) right center;
+  padding-right: 30px;
+}
diff --git a/plone/app/contenttypes/tests/test_migration_custom.py b/plone/app/contenttypes/tests/test_migration_custom.py
new file mode 100644
index 0000000..28863a8
--- /dev/null
+++ b/plone/app/contenttypes/tests/test_migration_custom.py
@@ -0,0 +1,385 @@
+# -*- coding: utf-8 -*-
+from Products.CMFPlone.utils import safe_unicode
+from datetime import datetime
+from plone.app.contenttypes.migration.migration import migrate_filefield
+from plone.app.contenttypes.migration.migration import migrate_imagefield
+from plone.app.contenttypes.migration.migration import migrate_simplefield
+from plone.app.contenttypes.migration.utils import installTypeIfNeeded
+from plone.app.contenttypes.testing import \
+    PLONE_APP_CONTENTTYPES_MIGRATION_TESTING
+from plone.app.testing import TEST_USER_ID
+from plone.app.testing import applyProfile
+from plone.app.testing import setRoles
+
+import pytz
+import os.path
+import unittest2 as unittest
+
+
+class MigrateFieldsTest(unittest.TestCase):
+
+    layer = PLONE_APP_CONTENTTYPES_MIGRATION_TESTING
+
+    def setUp(self):
+        self.portal = self.layer['portal']
+        self.request = self.layer['request']
+        setRoles(self.portal, TEST_USER_ID, ['Manager'])
+
+    def tearDown(self):
+        try:
+            applyProfile(self.portal, 'plone.app.contenttypes:uninstall')
+        except KeyError:
+            pass
+
+    def get_test_image_data(self):
+        test_image_path = os.path.join(os.path.dirname(__file__), 'image.png')
+        with open(test_image_path, 'rb') as test_image_file:
+            test_image_data = test_image_file.read()
+        return test_image_data
+
+    def get_test_file_data(self):
+        test_file_path = os.path.join(os.path.dirname(__file__), 'file.pdf')
+        with open(test_file_path, 'rb') as test_file:
+            test_file_data = test_file.read()
+        return test_file_data
+
+    def test_migrate_stringfield(self):
+        # create content
+        at_document_id = self.portal.invokeFactory('Document',
+                                                   'foo',
+                                                   title="Foo document")
+        # register p.a.contenttypes profile
+        applyProfile(self.portal, 'plone.app.contenttypes:default')
+        dx_document_id = self.portal.invokeFactory('Document',
+                                                   'bar',
+                                                   title="Bar document")
+        at_document = self.portal[at_document_id]
+        dx_document = self.portal[dx_document_id]
+        migrate_simplefield(at_document, dx_document, 'title', 'title')
+        self.assertEqual(dx_document.Title(), at_document.Title())
+
+    def test_migrate_richtextfield(self):
+        # create content
+        at_document_id = self.portal.invokeFactory('Document',
+                                                   'foo',
+                                                   title="Foo document",
+                                                   text="Some foo html text")
+        # register p.a.contenttypes profile
+        applyProfile(self.portal, 'plone.app.contenttypes:default')
+        dx_document_id = self.portal.invokeFactory('Document',
+                                                   'bar',
+                                                   title="Bar document")
+        at_document = self.portal[at_document_id]
+        dx_document = self.portal[dx_document_id]
+        self.assertEqual(dx_document.text, None)
+        migrate_simplefield(at_document, dx_document, 'text', 'text')
+        self.assertEqual(dx_document.text, at_document.getText())
+
+    def test_migrate_listfield(self):
+        # create content
+        at_document_id = self.portal.invokeFactory('Document',
+                                                   'foo',
+                                                   title="Foo document",
+                                                   subject=['aaa', 'bbb'])
+        # register p.a.contenttypes profile
+        applyProfile(self.portal, 'plone.app.contenttypes:default')
+        dx_document_id = self.portal.invokeFactory('Document',
+                                                   'bar',
+                                                   title="Bar document")
+        at_document = self.portal[at_document_id]
+        dx_document = self.portal[dx_document_id]
+        migrate_simplefield(at_document, dx_document, 'subject', 'subject',)
+        self.assertEqual(dx_document.Subject(), at_document.Subject())
+
+    def test_migrate_imagefield(self):
+        test_image_data = self.get_test_image_data()
+        at_newsitem_id = self.portal.invokeFactory(
+            'News Item',
+            'foo',
+            title="Foo news",
+            image=test_image_data)
+        # register p.a.contenttypes profile
+        applyProfile(self.portal, 'plone.app.contenttypes:default')
+        dx_newsitem_id = self.portal.invokeFactory(
+            'News Item',
+            'bar',
+            title="Bar news")
+        at_newsitem = self.portal[at_newsitem_id]
+        dx_newsitem = self.portal[dx_newsitem_id]
+        self.assertEqual(dx_newsitem.image, None)
+        migrate_imagefield(at_newsitem, dx_newsitem, 'image', 'image')
+        self.assertEqual(dx_newsitem.image.contentType, 'image/png')
+        self.assertEqual(dx_newsitem.image.data, test_image_data)
+
+    def test_migrate_filefield(self):
+        test_file_data = self.get_test_file_data()
+        at_file_id = self.portal.invokeFactory('File',
+                                               'foo',
+                                               title="Foo file",
+                                               file=test_file_data)
+        # register p.a.contenttypes profile
+        applyProfile(self.portal, 'plone.app.contenttypes:default')
+        dx_file_id = self.portal.invokeFactory('File',
+                                               'bar',
+                                               title="Bar file")
+        at_file = self.portal[at_file_id]
+        dx_file = self.portal[dx_file_id]
+        self.assertEqual(dx_file.file, None)
+        migrate_filefield(at_file, dx_file, 'file', 'file')
+        self.assertEqual(dx_file.file.data, test_file_data)
+
+
+class MigrateCustomATTest(unittest.TestCase):
+
+    layer = PLONE_APP_CONTENTTYPES_MIGRATION_TESTING
+
+    def setUp(self):
+        self.portal = self.layer['portal']
+        self.request = self.layer['request']
+        setRoles(self.portal, TEST_USER_ID, ['Manager'])
+
+    def tearDown(self):
+        try:
+            applyProfile(self.portal, 'plone.app.contenttypes:uninstall')
+        except KeyError:
+            pass
+
+    def createCustomATDocument(self, id, parent=None):
+        from Products.Archetypes.atapi import StringField, TextField
+        from Products.ATContentTypes.interface import IATDocument
+        from archetypes.schemaextender.interfaces import ISchemaExtender
+        from archetypes.schemaextender.field import ExtensionField
+        from zope.component import getGlobalSiteManager
+        from zope.interface import implements
+
+        # create schema extension
+        class ExtensionTextField(ExtensionField, TextField):
+            """ derivative of text for extending schemas """
+
+        class ExtensionStringField(ExtensionField, StringField):
+            """ derivative of text for extending schemas """
+
+        class SchemaExtender(object):
+            implements(ISchemaExtender)
+            fields = [
+                ExtensionTextField('textExtended',
+                                   ),
+                ExtensionStringField('stringExtended',
+                                     ),
+            ]
+
+            def __init__(self, context):
+                self.context = context
+
+            def getFields(self):
+                return self.fields
+
+        # register adapter
+        gsm = getGlobalSiteManager()
+        gsm.registerAdapter(SchemaExtender, (IATDocument,), ISchemaExtender)
+
+        # create content
+        container = parent or self.portal
+        container.invokeFactory('Document', id,
+                                title="Foo document",
+                                stringExtended="foo text",
+                                textExtended='foo extended rich text')
+        at_document = container[id]
+
+        # unregister adapter assure test isolation
+        gsm.unregisterAdapter(required=[IATDocument], provided=ISchemaExtender)
+
+        return at_document
+
+    def test_migrate_extended_document(self):
+        from plone.app.contenttypes.migration.migration import migrateCustomAT
+        from plone.app.contenttypes.interfaces import INewsItem
+        at_document = self.createCustomATDocument('foo-document')
+        qi = self.portal.portal_quickinstaller
+        # install pac but only install News Items
+        qi.installProduct(
+            'plone.app.contenttypes',
+            profile='plone.app.contenttypes:default',
+            blacklistedSteps=['typeinfo'])
+        installTypeIfNeeded("News Item")
+        fields_mapping = (
+            {'AT_field_name': 'textExtended',
+             'AT_field_type': 'Products.Archetypes.Field.TextField',
+             'DX_field_name': 'text',
+             'DX_field_type': 'RichText', },
+            {'AT_field_name': 'stringExtended',
+             'AT_field_type': 'StringField',
+             'DX_field_name': 'title',
+             'DX_field_type': 'StringField', },
+        )
+        # migrate extended AT Document to default DX News Item
+        migrateCustomAT(
+            fields_mapping, src_type='Document', dst_type='News Item')
+        dx_newsitem = self.portal['foo-document']
+        self.assertTrue(INewsItem.providedBy(dx_newsitem))
+        self.assertTrue(dx_newsitem is not at_document)
+        self.assertEquals(at_document.textExtended(), dx_newsitem.text.raw)
+        self.assertEquals(at_document.stringExtended, dx_newsitem.title)
+
+    def test_migrate_atevent_to_dxnewsitem(self):
+        """Tests the custom migration by migrating a default type. It is not
+        meant to be used this way but is a nice way to test the migrations.
+        During this migration the old event fti is still present.
+        """
+        from DateTime import DateTime
+        from plone.app.contenttypes.migration.migration import migrateCustomAT
+        from plone.app.contenttypes.interfaces import INewsItem
+
+        # create an ATEvent
+        self.portal.invokeFactory('Event', 'event')
+        at_event = self.portal['event']
+
+        # Date
+        at_event.getField('startDate') \
+                .set(at_event, DateTime('2013-02-03 12:00'))
+        at_event.getField('endDate') \
+                .set(at_event, DateTime('2013-04-05 13:00'))
+
+        # Contact
+        at_event.getField('contactPhone').set(at_event, '123456789')
+        at_event.getField('contactEmail').set(at_event, 'dummy@email.com')
+        at_event.getField('contactName').set(at_event, u'Nme')
+
+        # URL
+        at_event.getField('eventUrl').set(at_event, 'http://www.plone.org')
+
+        # Attendees
+        at_event.getField('attendees').set(at_event, ('You', 'Me'))
+
+        # Text
+        at_event.setText('Ttensuppe')
+        at_event.setContentType('text/plain')
+
+        os.environ['TZ'] = 'Asia/Tbilisi'
+
+        qi = self.portal.portal_quickinstaller
+        # install pac but only install News Items
+        qi.installProduct(
+            'plone.app.contenttypes',
+            profile='plone.app.contenttypes:default',
+            blacklistedSteps=['typeinfo'])
+        installTypeIfNeeded("News Item")
+        fields_mapping = (
+            {'AT_field_name': 'text',
+             'AT_field_type': 'Products.Archetypes.Field.TextField',
+             'DX_field_name': 'text',
+             'DX_field_type': 'RichText', },
+            {'AT_field_name': 'contactName',
+             'AT_field_type': 'StringField',
+             'DX_field_name': 'image_caption',
+             'DX_field_type': 'StringField', },
+        )
+        # migrate ATCTEvent to default DX News Item
+        migrateCustomAT(fields_mapping, src_type='Event', dst_type='News Item')
+        dx_newsitem = self.portal['event']
+        self.assertTrue(INewsItem.providedBy(dx_newsitem))
+        self.assertTrue(dx_newsitem is not at_event)
+        self.assertEquals(
+            safe_unicode(at_event.getText()),
+            dx_newsitem.text.output)
+        self.assertEquals(
+            at_event.contactName,
+            dx_newsitem.image_caption)
+
+    def test_migrate_atevent_to_dxevent(self):
+        """Tests the custom migration by migrating a default type. It is not
+        meant to be used this way but is a nice way to test the migrations.
+        During this migration the event fti is already replaced by the dx one.
+        """
+        from DateTime import DateTime
+        from plone.app.contenttypes.migration.migration import migrateCustomAT
+        from plone.app.contenttypes.interfaces import IEvent
+
+        # create an ATEvent
+        self.portal.invokeFactory('Event', 'event')
+        at_event = self.portal['event']
+
+        # Date
+        FORMAT = '%Y-%m-%d %H:%M'
+        start = '2013-02-03 12:15'
+        end = '2013-04-05 13:45'
+        at_event.getField('startDate').set(at_event, DateTime(start))
+        at_event.getField('endDate').set(at_event, DateTime(end))
+
+        # Contact
+        at_event.getField('contactPhone').set(at_event, '123456789')
+        at_event.getField('contactEmail').set(at_event, 'dummy@email.com')
+        at_event.getField('contactName').set(at_event, u'Nme')
+
+        # URL
+        at_event.getField('eventUrl').set(at_event, 'http://www.plone.org')
+
+        # Attendees
+        at_event.getField('attendees').set(at_event, ('Yu', 'Me'))
+
+        # Text
+        at_event.setText('Ttensuppe')
+        at_event.setContentType('text/plain')
+
+        TZ = 'Asia/Tbilisi'
+        os.environ['TZ'] = TZ
+        timezone = pytz.timezone(TZ)
+
+        qi = self.portal.portal_quickinstaller
+        # install pac but only install Event
+        qi.installProduct(
+            'plone.app.contenttypes',
+            profile='plone.app.contenttypes:default',
+            blacklistedSteps=['typeinfo'])
+        installTypeIfNeeded("Event")
+        fields_mapping = (
+            {'AT_field_name': 'startDate',
+             'AT_field_type': 'Products.Archetypes.Field.DateTimeField',
+             'DX_field_name': 'start',
+             'DX_field_type': 'Datetime', },
+            {'AT_field_name': 'endDate',
+             'AT_field_type': 'Products.Archetypes.Field.DateTimeField',
+             'DX_field_name': 'end',
+             'DX_field_type': 'Datetime', },
+            {'AT_field_name': 'text',
+             'AT_field_type': 'Products.Archetypes.Field.TextField',
+             'DX_field_name': 'text',
+             'DX_field_type': 'RichText', },
+            {'AT_field_name': 'eventUrl',
+             'AT_field_type': 'Products.Archetypes.Field.StringField',
+             'DX_field_name': 'event_url',
+             'DX_field_type': 'StringField', },
+            {'AT_field_name': 'contactEmail',
+             'AT_field_type': 'Products.Archetypes.Field.StringField',
+             'DX_field_name': 'contact_email',
+             'DX_field_type': 'StringField', },
+            {'AT_field_name': 'contactName',
+             'AT_field_type': 'Products.Archetypes.Field.StringField',
+             'DX_field_name': 'contact_name',
+             'DX_field_type': 'StringField', },
+            {'AT_field_name': 'contactPhone',
+             'AT_field_type': 'Products.Archetypes.Field.StringField',
+             'DX_field_name': 'contact_phone',
+             'DX_field_type': 'StringField', },
+            {'AT_field_name': 'attendees',
+             'AT_field_type': 'Products.Archetypes.Field.LinesField',
+             'DX_field_name': 'attendees',
+             'DX_field_type': 'Tuple', },
+        )
+        # migrate ATEvent to new default Event
+        migrateCustomAT(fields_mapping, src_type='Event', dst_type='Event')
+        dx_event = self.portal['event']
+        self.assertTrue(IEvent.providedBy(dx_event))
+        self.assertTrue(dx_event is not at_event)
+        self.assertEquals(safe_unicode(
+            at_event.getText()), dx_event.text.output)
+        self.assertEquals(at_event.eventUrl, dx_event.event_url)
+        self.assertEquals(at_event.contactEmail, dx_event.contact_email)
+        self.assertEquals(at_event.contactName, dx_event.contact_name)
+        self.assertEquals(at_event.contactPhone, dx_event.contact_phone)
+        self.assertEquals(at_event.attendees, dx_event.attendees)
+        self.assertEquals(
+            dx_event.start,
+            timezone.localize(datetime.strptime(start, FORMAT)))
+        self.assertEquals(
+            dx_event.end, timezone.localize(datetime.strptime(end, FORMAT)))


