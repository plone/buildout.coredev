Repository: Products.CMFPlone


Branch: refs/heads/5.2.x
Date: 2021-06-18T23:46:13+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/Products.CMFPlone/commit/9cd5dacad82a4ea6ae6c6ef4f364b385bc9ce917

Removed the docstring from various methods to avoid making them available via a url.

From [Products.PloneHotfix20210518](https://plone.org/security/hotfix/20210518/reflected-xss-in-various-spots).

Files changed:
A news/3274.bugfix
M Products/CMFPlone/PloneTool.py
M Products/CMFPlone/patches/publishing.py
M Products/CMFPlone/tests/testSecurity.py

b'diff --git a/Products/CMFPlone/PloneTool.py b/Products/CMFPlone/PloneTool.py\nindex f9503125d4..8deb7e2b52 100644\n--- a/Products/CMFPlone/PloneTool.py\n+++ b/Products/CMFPlone/PloneTool.py\n@@ -119,12 +119,14 @@ def getSiteEncoding(self):\n \n     @security.public\n     def portal_utf8(self, str, errors=\'strict\'):\n-        """Transforms an string in portal encoding to utf8."""\n+        # Transforms an string in portal encoding to utf8.\n+        # Note: no docstring please, to avoid reflected XSS.\n         return utils.portal_utf8(self, str, errors)\n \n     @security.public\n     def utf8_portal(self, str, errors=\'strict\'):\n-        """Transforms an utf8 string to portal encoding."""\n+        # Transforms an utf8 string to portal encoding.\n+        # Note: no docstring please, to avoid reflected XSS.\n         return utils.utf8_portal(self, str, errors)\n \n     @security.private\n@@ -336,11 +338,9 @@ def getIconFor(self, category, id, default=_marker, context=None):\n \n     @security.protected(View)\n     def getReviewStateTitleFor(self, obj):\n-        """Utility method that gets the workflow state title for the\n-        object\'s review_state.\n-\n-        Returns None if no review_state found.\n-        """\n+        # Utility method that gets the workflow state title for the\n+        # object\'s review_state.\n+        # Returns None if no review_state found.\n         wf_tool = getToolByName(self, \'portal_workflow\')\n         wfs = ()\n         objstate = None\n@@ -407,18 +407,17 @@ def fixOwnerRole(object, user_id):\n \n     @security.public\n     def urlparse(self, url):\n-        """Returns the pieces of url in a six-part tuple.\n-\n-        Since Python 2.6: urlparse now returns a ParseResult object.\n-        We just need the tuple form which is tuple(result).\n-        """\n+        # Returns the pieces of url in a six-part tuple.\n+        # Since Python 2.6: urlparse now returns a ParseResult object.\n+        # We just need the tuple form which is tuple(result).\n+        # Note: no docstring please, to avoid reflected XSS.\n         return tuple(parse.urlparse(url))\n \n     @security.public\n     def urlunparse(self, url_tuple):\n-        """Puts a url back together again, in the manner that\n-        urlparse breaks it.\n-        """\n+        # Puts a url back together again, in the manner that\n+        # urlparse breaks it.\n+        # Note: no docstring please, to avoid reflected XSS.\n         return parse.urlunparse(url_tuple)\n \n     # Enable scripts to get the string value of an exception even if the\n@@ -551,30 +550,32 @@ def getDefaultPage(self, obj, request=None):\n \n     @security.public\n     def addPortalMessage(self, message, type=\'info\', request=None):\n-        """\\\n-        Call this once or more to add messages to be displayed at the\n-        top of the web page.\n-\n-        The arguments are:\n-            message:   a string, with the text message you want to show,\n-                       or a HTML fragment (see type=\'structure\' below)\n-            type:      optional, defaults to \'info\'. The type determines how\n-                       the message will be rendered, as it is used to select\n-                       the CSS class for the message. Predefined types are:\n-                       \'info\' - for informational messages\n-                       \'warning\' - for warning messages\n-                       \'error\' - for messages about restricted access or\n-                                 errors.\n-\n-        Portal messages are by default rendered by the global_statusmessage.pt\n-        page template.\n-\n-        It is also possible to add messages from page templates, as\n-        long as they are processed before the portal_message macro is\n-        called by the main template. Example:\n-\n-          <tal:block tal:define="temp python:context.plone_utils.addPortalMessage(\'A random info message\')" />  # noqa\n-        """\n+        # Call this once or more to add messages to be displayed at the\n+        # top of the web page.\n+\n+        # Note: no docstring please, to avoid reflected XSS.\n+        # This might not be possible, but type="structure" below sounds dangerous,\n+        # although I find no support for it in code.\n+\n+        # The arguments are:\n+        #     message:   a string, with the text message you want to show,\n+        #                or a HTML fragment (see type=\'structure\' below)\n+        #     type:      optional, defaults to \'info\'. The type determines how\n+        #                the message will be rendered, as it is used to select\n+        #                the CSS class for the message. Predefined types are:\n+        #                \'info\' - for informational messages\n+        #                \'warning\' - for warning messages\n+        #                \'error\' - for messages about restricted access or\n+        #                          errors.\n+\n+        # Portal messages are by default rendered by the global_statusmessage.pt\n+        # page template.\n+\n+        # It is also possible to add messages from page templates, as\n+        # long as they are processed before the portal_message macro is\n+        # called by the main template. Example:\n+\n+        #   <tal:block tal:define="temp python:context.plone_utils.addPortalMessage(\'A random info message\')" />  # noqa\n         if request is None:\n             request = self.REQUEST\n         IStatusMessage(request).add(message, type=type)\n@@ -592,42 +593,43 @@ def showPortalMessages(self, request=None):\n \n     @security.public\n     def browserDefault(self, obj):\n-        """Sets default so we can return whatever we want instead of index_html.\n-\n-        This method is complex, and interacts with mechanisms such as\n-        IBrowserDefault (implemented in CMFDynamicViewFTI), LinguaPlone and\n-        various mechanisms for setting the default page.\n-\n-        The method returns a tuple (obj, [path]) where path is a path to\n-        a template or other object to be acquired and displayed on the object.\n-        The path is determined as follows:\n-\n-        0. If we\'re c oming from WebDAV, make sure we don\'t return a contained\n-            object "default page" ever\n-        1. If there is an index_html attribute (either a contained object or\n-            an explicit attribute) on the object, return that as the\n-            "default page". Note that this may be used by things like\n-            File and Image to return the contents of the file, for example,\n-            not just content-space objects created by the user.\n-        2. If the object implements IBrowserDefault, query this for the\n-            default page.\n-        3. If the object has a property default_page set and this gives a list\n-            of, or single, object id, and that object is is found in the\n-            folder or is the name of a skin template, return that id\n-        4. If the property default_page is set in site_properties and that\n-            property contains a list of ids of which one id is found in the\n-            folder, return that id\n-        5. If the object implements IBrowserDefault, try to get the selected\n-            layout.\n-        6. If the type has a \'folderlisting\' action and no default page is\n-            set, use this action. This permits folders to have the default\n-            \'view\' action be \'string:${object_url}/\' and hence default to\n-            a default page when clicking the \'view\' tab, whilst allowing the\n-            fallback action to be specified TTW in portal_types (this action\n-            is typically hidden)\n-        7. If nothing else is found, fall back on the object\'s \'view\' action.\n-        8. If this is not found, raise an AttributeError\n-        """\n+        # Sets default so we can return whatever we want instead of index_html.\n+\n+        # Note: no docstring please, to avoid reflected XSS.\n+\n+        # This method is complex, and interacts with mechanisms such as\n+        # IBrowserDefault (implemented in CMFDynamicViewFTI), LinguaPlone and\n+        # various mechanisms for setting the default page.\n+\n+        # The method returns a tuple (obj, [path]) where path is a path to\n+        # a template or other object to be acquired and displayed on the object.\n+        # The path is determined as follows:\n+\n+        # 0. If we\'re c oming from WebDAV, make sure we don\'t return a contained\n+        #     object "default page" ever\n+        # 1. If there is an index_html attribute (either a contained object or\n+        #     an explicit attribute) on the object, return that as the\n+        #     "default page". Note that this may be used by things like\n+        #     File and Image to return the contents of the file, for example,\n+        #     not just content-space objects created by the user.\n+        # 2. If the object implements IBrowserDefault, query this for the\n+        #     default page.\n+        # 3. If the object has a property default_page set and this gives a list\n+        #     of, or single, object id, and that object is is found in the\n+        #     folder or is the name of a skin template, return that id\n+        # 4. If the property default_page is set in site_properties and that\n+        #     property contains a list of ids of which one id is found in the\n+        #     folder, return that id\n+        # 5. If the object implements IBrowserDefault, try to get the selected\n+        #     layout.\n+        # 6. If the type has a \'folderlisting\' action and no default page is\n+        #     set, use this action. This permits folders to have the default\n+        #     \'view\' action be \'string:${object_url}/\' and hence default to\n+        #     a default page when clicking the \'view\' tab, whilst allowing the\n+        #     fallback action to be specified TTW in portal_types (this action\n+        #     is typically hidden)\n+        # 7. If nothing else is found, fall back on the object\'s \'view\' action.\n+        # 8. If this is not found, raise an AttributeError\n \n         # WebDAV in Zope is odd it takes the incoming verb eg: PROPFIND\n         # and then requests that object, for example for: /, with verb PROPFIND\n@@ -789,7 +791,8 @@ def isLocalRoleAcquired(self, obj):\n \n     @security.public\n     def getOwnerName(self, obj):\n-        """ Returns the userid of the owner of an object."""\n+        # Returns the userid of the owner of an object.\n+        # Note: no docstring please, to avoid reflected XSS.\n         mt = getToolByName(self, \'portal_membership\')\n         if not mt.checkPermission(View, obj):\n             raise Unauthorized\n@@ -797,14 +800,14 @@ def getOwnerName(self, obj):\n \n     @security.public\n     def normalizeString(self, text):\n-        """Normalizes a title to an id.\n+        # Normalizes a title to an id.\n+        # Note: no docstring please, to avoid reflected XSS.\n \n-        The relaxed mode was removed in Plone 4.0. You should use either the\n-        url or file name normalizer from the plone.i18n package instead.\n+        # The relaxed mode was removed in Plone 4.0. You should use either the\n+        # url or file name normalizer from the plone.i18n package instead.\n \n-        normalizeString() converts a whole string to a normalized form that\n-        should be safe to use as in a url, as a css id, etc.\n-        """\n+        # normalizeString() converts a whole string to a normalized form that\n+        # should be safe to use as in a url, as a css id, etc.\n         return utils.normalizeString(text, context=self)\n \n     @security.public\n@@ -963,7 +966,8 @@ def isIDAutoGenerated(self, id):\n \n     @security.public\n     def getEmptyTitle(self, translated=True):\n-        """Returns string to be used for objects with no title or id."""\n+        # Returns string to be used for objects with no title or id.\n+        # Note: no docstring please, to avoid reflected XSS.\n         return utils.getEmptyTitle(self, translated)\n \n     @security.public\ndiff --git a/Products/CMFPlone/patches/publishing.py b/Products/CMFPlone/patches/publishing.py\nindex 1bf50f6e62..598a6c38eb 100644\n--- a/Products/CMFPlone/patches/publishing.py\n+++ b/Products/CMFPlone/patches/publishing.py\n@@ -1,6 +1,7 @@\n # -*- coding: utf-8 -*-\n # From Products.PloneHotfix20160419\n # Plus extras for properties.\n+# Plus Products.PloneHotfix20210518.\n from OFS.PropertyManager import PropertyManager\n #from OFS.ZDOM import Document\n #from OFS.ZDOM import Node\n@@ -29,6 +30,25 @@ class ATCTBTreeFolder(object):\n         pass\n \n \n+def delete_method_docstring(klass, method_name):\n+    # Delete the docstring from the class method.\n+    # Objects must have a docstring to be published.\n+    # So this avoids them getting published.\n+    method = getattr(klass, method_name, None)\n+    if method is None:\n+        return\n+    if hasattr(method, "im_func"):\n+        # Only Python 2 has im_func.\n+        # Python 3 has __func__, but only on methods of instances, not classes.\n+        if hasattr(method.im_func, "__doc__"):\n+            del method.im_func.__doc__\n+    else:\n+        # This would fail on Python 2 with an AttributeError:\n+        # "attribute \'__doc__\' of \'instancemethod\' objects is not writable"\n+        if hasattr(method, "__doc__"):\n+            del method.__doc__\n+\n+\n klasses = (\n #    Node,\n #    Document,\n@@ -61,10 +81,7 @@ class ATCTBTreeFolder(object):\n \n for klass in klasses:\n     for method_name in methods:\n-        method = getattr(klass, method_name, None)\n-        if (method is not None and hasattr(method, \'im_func\') and\n-                hasattr(method.im_func, \'__doc__\')):\n-            del method.im_func.__doc__\n+        delete_method_docstring(klass, method_name)\n \n property_methods = (\n     \'getProperty\',\n@@ -79,7 +96,4 @@ class ATCTBTreeFolder(object):\n )\n \n for method_name in property_methods:\n-    method = getattr(PropertyManager, method_name, None)\n-    if (method is not None and hasattr(method, \'im_func\') and\n-            hasattr(method.im_func, \'__doc__\')):\n-        del method.im_func.__doc__\n+    delete_method_docstring(PropertyManager, method_name)\ndiff --git a/Products/CMFPlone/tests/testSecurity.py b/Products/CMFPlone/tests/testSecurity.py\nindex 45ae145396..6d8ae3008c 100644\n--- a/Products/CMFPlone/tests/testSecurity.py\n+++ b/Products/CMFPlone/tests/testSecurity.py\n@@ -1,12 +1,19 @@\n # -*- coding: utf-8 -*-\n-from Products.CMFPlone.tests.PloneTestCase import PloneTestCase\n-from Testing.makerequest import makerequest\n+from plone.app.testing import login\n+from plone.app.testing import logout\n from plone.app.testing import SITE_OWNER_NAME\n from plone.app.testing import SITE_OWNER_PASSWORD\n+from plone.testing.zope import Browser\n+from Products.CMFCore.utils import getToolByName\n+from Products.CMFPlone.testing import PRODUCTS_CMFPLONE_FUNCTIONAL_TESTING\n+from Products.CMFPlone.tests.PloneTestCase import PloneTestCase\n+from Testing.makerequest import makerequest\n+from zExceptions import NotFound\n from zExceptions import Unauthorized\n \n import re\n import six\n+import transaction\n import unittest\n \n \n@@ -202,3 +209,120 @@ def test_formatColumns(self):\n         # formatColumns is unused and was removed\n         res = self.publish(\'/plone/formatColumns?items:list=\')\n         self.assertIn(res.status, [403, 404])\n+\n+\n+class TestFunctional(unittest.TestCase):\n+    # The class above is rather old-style.\n+    # Let\'s try a more modern approach, with a layer.\n+    layer = PRODUCTS_CMFPLONE_FUNCTIONAL_TESTING\n+\n+    def get_admin_browser(self):\n+        browser = Browser(self.layer["app"])\n+        browser.handleErrors = False\n+        browser.addHeader(\n+            "Authorization",\n+            "Basic {0}:{1}".format(SITE_OWNER_NAME, SITE_OWNER_PASSWORD),\n+        )\n+        return browser\n+\n+    def test_plonetool(self):\n+        base_url = self.layer["portal"].absolute_url() + "/plone_utils"\n+        browser = self.get_admin_browser()\n+        method_names = (\n+            "addPortalMessage",\n+            "browserDefault",\n+            "getReviewStateTitleFor",\n+            "portal_utf8",\n+            "urlparse",\n+            "urlunparse",\n+            "utf8_portal",\n+            "getOwnerName",\n+            "normalizeString",\n+            "getEmptyTitle",\n+        )\n+        for method_name in method_names:\n+            with self.assertRaises(NotFound):\n+                browser.open(base_url + "/" + method_name)\n+\n+    def test_hotfix_20160419(self):\n+        """Test old hotfix.\n+\n+        CMFPlone has patches/publishing.py, containing\n+        the publishing patch from Products.PloneHotfix20160419.\n+        This avoids publishing some methods inherited from Zope or CMF,\n+        which upstream does not want to fix, considering it no problem\n+        to have these methods available.  I can imagine that.\n+        But in Plone we have decided otherwise.\n+\n+        Problem: the patch did not work on Python 3.\n+        This was fixed in hotfix 20210518.\n+        """\n+        portal = self.layer["portal"]\n+        portal.invokeFactory("Document", "doc")\n+        transaction.commit()\n+        portal_url = portal.absolute_url()\n+        doc_url = portal.doc.absolute_url()\n+        browser = self.get_admin_browser()\n+        method_names = (\n+            "EffectiveDate",\n+            "ExpirationDate",\n+            "getAttributes",\n+            "getChildNodes",\n+            "getFirstChild",\n+            "getLastChild",\n+            "getLayout",\n+            "getNextSibling",\n+            "getNodeName",\n+            "getNodeType",\n+            "getNodeValue",\n+            "getOwnerDocument",\n+            "getParentNode",\n+            "getPhysicalPath",\n+            "getPreviousSibling",\n+            "getTagName",\n+            "hasChildNodes",\n+            "Type",\n+            # From PropertyManager:\n+            "getProperty",\n+            "propertyValues",\n+            "propertyItems",\n+            "propertyMap",\n+            "hasProperty",\n+            "getPropertyType",\n+            "propertyIds",\n+            "propertyLabel",\n+            "propertyDescription",\n+        )\n+        for method_name in method_names:\n+            with self.assertRaises(NotFound):\n+                browser.open(portal_url + "/" + method_name)\n+            with self.assertRaises(NotFound):\n+                browser.open(doc_url + "/" + method_name)\n+\n+    def test_quick_installer_security(self):\n+        # Products.CMFQuickInstallerTool has a fix.\n+        # But CMFPlone overrides the tool class, so let\'s check.\n+        portal = self.layer["portal"]\n+        qi = getToolByName(portal, "portal_quickinstaller", None)\n+        if qi is None:\n+            return\n+\n+        # Make sure we are anonymous.\n+        logout()\n+        logout()\n+        # Unrestricted traversal should work, restricted not.\n+        qi = portal.unrestrictedTraverse("portal_quickinstaller")\n+        with self.assertRaises(Unauthorized):\n+            portal.restrictedTraverse("portal_quickinstaller")\n+        for obj_id in qi.objectIds():\n+            qi.unrestrictedTraverse(obj_id)\n+            with self.assertRaises(Unauthorized):\n+                qi.restrictedTraverse(obj_id)\n+\n+        # Authenticated with role Manager, we can view whatever we want.\n+        login(portal, SITE_OWNER_NAME)\n+        qi = portal.unrestrictedTraverse("portal_quickinstaller")\n+        qi = portal.restrictedTraverse("portal_quickinstaller")\n+        for obj_id in qi.objectIds():\n+            qi.unrestrictedTraverse(obj_id)\n+            qi.restrictedTraverse(obj_id)\ndiff --git a/news/3274.bugfix b/news/3274.bugfix\nnew file mode 100644\nindex 0000000000..7d9f538d12\n--- /dev/null\n+++ b/news/3274.bugfix\n@@ -0,0 +1,3 @@\n+Removed the docstring from various methods to avoid making them available via a url.\n+From `Products.PloneHotfix20210518 <https://plone.org/security/hotfix/20210518/reflected-xss-in-various-spots>`_.\n+[maurits]\n'

Repository: Products.CMFPlone


Branch: refs/heads/5.2.x
Date: 2021-06-21T22:22:55+02:00
Author: Maurits van Rees (mauritsvanrees) <m.van.rees@zestsoftware.nl>
Commit: https://github.com/plone/Products.CMFPlone/commit/789f210601f7de5f6819178960b7018b6f4df0dc

Merge pull request #3281 from plone/hotfix-20210518

Removed the docstring from methods to avoid publishing them [5.2]

Files changed:
A news/3274.bugfix
M Products/CMFPlone/PloneTool.py
M Products/CMFPlone/patches/publishing.py
M Products/CMFPlone/tests/testSecurity.py

b'diff --git a/Products/CMFPlone/PloneTool.py b/Products/CMFPlone/PloneTool.py\nindex f9503125d4..8deb7e2b52 100644\n--- a/Products/CMFPlone/PloneTool.py\n+++ b/Products/CMFPlone/PloneTool.py\n@@ -119,12 +119,14 @@ def getSiteEncoding(self):\n \n     @security.public\n     def portal_utf8(self, str, errors=\'strict\'):\n-        """Transforms an string in portal encoding to utf8."""\n+        # Transforms an string in portal encoding to utf8.\n+        # Note: no docstring please, to avoid reflected XSS.\n         return utils.portal_utf8(self, str, errors)\n \n     @security.public\n     def utf8_portal(self, str, errors=\'strict\'):\n-        """Transforms an utf8 string to portal encoding."""\n+        # Transforms an utf8 string to portal encoding.\n+        # Note: no docstring please, to avoid reflected XSS.\n         return utils.utf8_portal(self, str, errors)\n \n     @security.private\n@@ -336,11 +338,9 @@ def getIconFor(self, category, id, default=_marker, context=None):\n \n     @security.protected(View)\n     def getReviewStateTitleFor(self, obj):\n-        """Utility method that gets the workflow state title for the\n-        object\'s review_state.\n-\n-        Returns None if no review_state found.\n-        """\n+        # Utility method that gets the workflow state title for the\n+        # object\'s review_state.\n+        # Returns None if no review_state found.\n         wf_tool = getToolByName(self, \'portal_workflow\')\n         wfs = ()\n         objstate = None\n@@ -407,18 +407,17 @@ def fixOwnerRole(object, user_id):\n \n     @security.public\n     def urlparse(self, url):\n-        """Returns the pieces of url in a six-part tuple.\n-\n-        Since Python 2.6: urlparse now returns a ParseResult object.\n-        We just need the tuple form which is tuple(result).\n-        """\n+        # Returns the pieces of url in a six-part tuple.\n+        # Since Python 2.6: urlparse now returns a ParseResult object.\n+        # We just need the tuple form which is tuple(result).\n+        # Note: no docstring please, to avoid reflected XSS.\n         return tuple(parse.urlparse(url))\n \n     @security.public\n     def urlunparse(self, url_tuple):\n-        """Puts a url back together again, in the manner that\n-        urlparse breaks it.\n-        """\n+        # Puts a url back together again, in the manner that\n+        # urlparse breaks it.\n+        # Note: no docstring please, to avoid reflected XSS.\n         return parse.urlunparse(url_tuple)\n \n     # Enable scripts to get the string value of an exception even if the\n@@ -551,30 +550,32 @@ def getDefaultPage(self, obj, request=None):\n \n     @security.public\n     def addPortalMessage(self, message, type=\'info\', request=None):\n-        """\\\n-        Call this once or more to add messages to be displayed at the\n-        top of the web page.\n-\n-        The arguments are:\n-            message:   a string, with the text message you want to show,\n-                       or a HTML fragment (see type=\'structure\' below)\n-            type:      optional, defaults to \'info\'. The type determines how\n-                       the message will be rendered, as it is used to select\n-                       the CSS class for the message. Predefined types are:\n-                       \'info\' - for informational messages\n-                       \'warning\' - for warning messages\n-                       \'error\' - for messages about restricted access or\n-                                 errors.\n-\n-        Portal messages are by default rendered by the global_statusmessage.pt\n-        page template.\n-\n-        It is also possible to add messages from page templates, as\n-        long as they are processed before the portal_message macro is\n-        called by the main template. Example:\n-\n-          <tal:block tal:define="temp python:context.plone_utils.addPortalMessage(\'A random info message\')" />  # noqa\n-        """\n+        # Call this once or more to add messages to be displayed at the\n+        # top of the web page.\n+\n+        # Note: no docstring please, to avoid reflected XSS.\n+        # This might not be possible, but type="structure" below sounds dangerous,\n+        # although I find no support for it in code.\n+\n+        # The arguments are:\n+        #     message:   a string, with the text message you want to show,\n+        #                or a HTML fragment (see type=\'structure\' below)\n+        #     type:      optional, defaults to \'info\'. The type determines how\n+        #                the message will be rendered, as it is used to select\n+        #                the CSS class for the message. Predefined types are:\n+        #                \'info\' - for informational messages\n+        #                \'warning\' - for warning messages\n+        #                \'error\' - for messages about restricted access or\n+        #                          errors.\n+\n+        # Portal messages are by default rendered by the global_statusmessage.pt\n+        # page template.\n+\n+        # It is also possible to add messages from page templates, as\n+        # long as they are processed before the portal_message macro is\n+        # called by the main template. Example:\n+\n+        #   <tal:block tal:define="temp python:context.plone_utils.addPortalMessage(\'A random info message\')" />  # noqa\n         if request is None:\n             request = self.REQUEST\n         IStatusMessage(request).add(message, type=type)\n@@ -592,42 +593,43 @@ def showPortalMessages(self, request=None):\n \n     @security.public\n     def browserDefault(self, obj):\n-        """Sets default so we can return whatever we want instead of index_html.\n-\n-        This method is complex, and interacts with mechanisms such as\n-        IBrowserDefault (implemented in CMFDynamicViewFTI), LinguaPlone and\n-        various mechanisms for setting the default page.\n-\n-        The method returns a tuple (obj, [path]) where path is a path to\n-        a template or other object to be acquired and displayed on the object.\n-        The path is determined as follows:\n-\n-        0. If we\'re c oming from WebDAV, make sure we don\'t return a contained\n-            object "default page" ever\n-        1. If there is an index_html attribute (either a contained object or\n-            an explicit attribute) on the object, return that as the\n-            "default page". Note that this may be used by things like\n-            File and Image to return the contents of the file, for example,\n-            not just content-space objects created by the user.\n-        2. If the object implements IBrowserDefault, query this for the\n-            default page.\n-        3. If the object has a property default_page set and this gives a list\n-            of, or single, object id, and that object is is found in the\n-            folder or is the name of a skin template, return that id\n-        4. If the property default_page is set in site_properties and that\n-            property contains a list of ids of which one id is found in the\n-            folder, return that id\n-        5. If the object implements IBrowserDefault, try to get the selected\n-            layout.\n-        6. If the type has a \'folderlisting\' action and no default page is\n-            set, use this action. This permits folders to have the default\n-            \'view\' action be \'string:${object_url}/\' and hence default to\n-            a default page when clicking the \'view\' tab, whilst allowing the\n-            fallback action to be specified TTW in portal_types (this action\n-            is typically hidden)\n-        7. If nothing else is found, fall back on the object\'s \'view\' action.\n-        8. If this is not found, raise an AttributeError\n-        """\n+        # Sets default so we can return whatever we want instead of index_html.\n+\n+        # Note: no docstring please, to avoid reflected XSS.\n+\n+        # This method is complex, and interacts with mechanisms such as\n+        # IBrowserDefault (implemented in CMFDynamicViewFTI), LinguaPlone and\n+        # various mechanisms for setting the default page.\n+\n+        # The method returns a tuple (obj, [path]) where path is a path to\n+        # a template or other object to be acquired and displayed on the object.\n+        # The path is determined as follows:\n+\n+        # 0. If we\'re c oming from WebDAV, make sure we don\'t return a contained\n+        #     object "default page" ever\n+        # 1. If there is an index_html attribute (either a contained object or\n+        #     an explicit attribute) on the object, return that as the\n+        #     "default page". Note that this may be used by things like\n+        #     File and Image to return the contents of the file, for example,\n+        #     not just content-space objects created by the user.\n+        # 2. If the object implements IBrowserDefault, query this for the\n+        #     default page.\n+        # 3. If the object has a property default_page set and this gives a list\n+        #     of, or single, object id, and that object is is found in the\n+        #     folder or is the name of a skin template, return that id\n+        # 4. If the property default_page is set in site_properties and that\n+        #     property contains a list of ids of which one id is found in the\n+        #     folder, return that id\n+        # 5. If the object implements IBrowserDefault, try to get the selected\n+        #     layout.\n+        # 6. If the type has a \'folderlisting\' action and no default page is\n+        #     set, use this action. This permits folders to have the default\n+        #     \'view\' action be \'string:${object_url}/\' and hence default to\n+        #     a default page when clicking the \'view\' tab, whilst allowing the\n+        #     fallback action to be specified TTW in portal_types (this action\n+        #     is typically hidden)\n+        # 7. If nothing else is found, fall back on the object\'s \'view\' action.\n+        # 8. If this is not found, raise an AttributeError\n \n         # WebDAV in Zope is odd it takes the incoming verb eg: PROPFIND\n         # and then requests that object, for example for: /, with verb PROPFIND\n@@ -789,7 +791,8 @@ def isLocalRoleAcquired(self, obj):\n \n     @security.public\n     def getOwnerName(self, obj):\n-        """ Returns the userid of the owner of an object."""\n+        # Returns the userid of the owner of an object.\n+        # Note: no docstring please, to avoid reflected XSS.\n         mt = getToolByName(self, \'portal_membership\')\n         if not mt.checkPermission(View, obj):\n             raise Unauthorized\n@@ -797,14 +800,14 @@ def getOwnerName(self, obj):\n \n     @security.public\n     def normalizeString(self, text):\n-        """Normalizes a title to an id.\n+        # Normalizes a title to an id.\n+        # Note: no docstring please, to avoid reflected XSS.\n \n-        The relaxed mode was removed in Plone 4.0. You should use either the\n-        url or file name normalizer from the plone.i18n package instead.\n+        # The relaxed mode was removed in Plone 4.0. You should use either the\n+        # url or file name normalizer from the plone.i18n package instead.\n \n-        normalizeString() converts a whole string to a normalized form that\n-        should be safe to use as in a url, as a css id, etc.\n-        """\n+        # normalizeString() converts a whole string to a normalized form that\n+        # should be safe to use as in a url, as a css id, etc.\n         return utils.normalizeString(text, context=self)\n \n     @security.public\n@@ -963,7 +966,8 @@ def isIDAutoGenerated(self, id):\n \n     @security.public\n     def getEmptyTitle(self, translated=True):\n-        """Returns string to be used for objects with no title or id."""\n+        # Returns string to be used for objects with no title or id.\n+        # Note: no docstring please, to avoid reflected XSS.\n         return utils.getEmptyTitle(self, translated)\n \n     @security.public\ndiff --git a/Products/CMFPlone/patches/publishing.py b/Products/CMFPlone/patches/publishing.py\nindex 1bf50f6e62..598a6c38eb 100644\n--- a/Products/CMFPlone/patches/publishing.py\n+++ b/Products/CMFPlone/patches/publishing.py\n@@ -1,6 +1,7 @@\n # -*- coding: utf-8 -*-\n # From Products.PloneHotfix20160419\n # Plus extras for properties.\n+# Plus Products.PloneHotfix20210518.\n from OFS.PropertyManager import PropertyManager\n #from OFS.ZDOM import Document\n #from OFS.ZDOM import Node\n@@ -29,6 +30,25 @@ class ATCTBTreeFolder(object):\n         pass\n \n \n+def delete_method_docstring(klass, method_name):\n+    # Delete the docstring from the class method.\n+    # Objects must have a docstring to be published.\n+    # So this avoids them getting published.\n+    method = getattr(klass, method_name, None)\n+    if method is None:\n+        return\n+    if hasattr(method, "im_func"):\n+        # Only Python 2 has im_func.\n+        # Python 3 has __func__, but only on methods of instances, not classes.\n+        if hasattr(method.im_func, "__doc__"):\n+            del method.im_func.__doc__\n+    else:\n+        # This would fail on Python 2 with an AttributeError:\n+        # "attribute \'__doc__\' of \'instancemethod\' objects is not writable"\n+        if hasattr(method, "__doc__"):\n+            del method.__doc__\n+\n+\n klasses = (\n #    Node,\n #    Document,\n@@ -61,10 +81,7 @@ class ATCTBTreeFolder(object):\n \n for klass in klasses:\n     for method_name in methods:\n-        method = getattr(klass, method_name, None)\n-        if (method is not None and hasattr(method, \'im_func\') and\n-                hasattr(method.im_func, \'__doc__\')):\n-            del method.im_func.__doc__\n+        delete_method_docstring(klass, method_name)\n \n property_methods = (\n     \'getProperty\',\n@@ -79,7 +96,4 @@ class ATCTBTreeFolder(object):\n )\n \n for method_name in property_methods:\n-    method = getattr(PropertyManager, method_name, None)\n-    if (method is not None and hasattr(method, \'im_func\') and\n-            hasattr(method.im_func, \'__doc__\')):\n-        del method.im_func.__doc__\n+    delete_method_docstring(PropertyManager, method_name)\ndiff --git a/Products/CMFPlone/tests/testSecurity.py b/Products/CMFPlone/tests/testSecurity.py\nindex 45ae145396..6d8ae3008c 100644\n--- a/Products/CMFPlone/tests/testSecurity.py\n+++ b/Products/CMFPlone/tests/testSecurity.py\n@@ -1,12 +1,19 @@\n # -*- coding: utf-8 -*-\n-from Products.CMFPlone.tests.PloneTestCase import PloneTestCase\n-from Testing.makerequest import makerequest\n+from plone.app.testing import login\n+from plone.app.testing import logout\n from plone.app.testing import SITE_OWNER_NAME\n from plone.app.testing import SITE_OWNER_PASSWORD\n+from plone.testing.zope import Browser\n+from Products.CMFCore.utils import getToolByName\n+from Products.CMFPlone.testing import PRODUCTS_CMFPLONE_FUNCTIONAL_TESTING\n+from Products.CMFPlone.tests.PloneTestCase import PloneTestCase\n+from Testing.makerequest import makerequest\n+from zExceptions import NotFound\n from zExceptions import Unauthorized\n \n import re\n import six\n+import transaction\n import unittest\n \n \n@@ -202,3 +209,120 @@ def test_formatColumns(self):\n         # formatColumns is unused and was removed\n         res = self.publish(\'/plone/formatColumns?items:list=\')\n         self.assertIn(res.status, [403, 404])\n+\n+\n+class TestFunctional(unittest.TestCase):\n+    # The class above is rather old-style.\n+    # Let\'s try a more modern approach, with a layer.\n+    layer = PRODUCTS_CMFPLONE_FUNCTIONAL_TESTING\n+\n+    def get_admin_browser(self):\n+        browser = Browser(self.layer["app"])\n+        browser.handleErrors = False\n+        browser.addHeader(\n+            "Authorization",\n+            "Basic {0}:{1}".format(SITE_OWNER_NAME, SITE_OWNER_PASSWORD),\n+        )\n+        return browser\n+\n+    def test_plonetool(self):\n+        base_url = self.layer["portal"].absolute_url() + "/plone_utils"\n+        browser = self.get_admin_browser()\n+        method_names = (\n+            "addPortalMessage",\n+            "browserDefault",\n+            "getReviewStateTitleFor",\n+            "portal_utf8",\n+            "urlparse",\n+            "urlunparse",\n+            "utf8_portal",\n+            "getOwnerName",\n+            "normalizeString",\n+            "getEmptyTitle",\n+        )\n+        for method_name in method_names:\n+            with self.assertRaises(NotFound):\n+                browser.open(base_url + "/" + method_name)\n+\n+    def test_hotfix_20160419(self):\n+        """Test old hotfix.\n+\n+        CMFPlone has patches/publishing.py, containing\n+        the publishing patch from Products.PloneHotfix20160419.\n+        This avoids publishing some methods inherited from Zope or CMF,\n+        which upstream does not want to fix, considering it no problem\n+        to have these methods available.  I can imagine that.\n+        But in Plone we have decided otherwise.\n+\n+        Problem: the patch did not work on Python 3.\n+        This was fixed in hotfix 20210518.\n+        """\n+        portal = self.layer["portal"]\n+        portal.invokeFactory("Document", "doc")\n+        transaction.commit()\n+        portal_url = portal.absolute_url()\n+        doc_url = portal.doc.absolute_url()\n+        browser = self.get_admin_browser()\n+        method_names = (\n+            "EffectiveDate",\n+            "ExpirationDate",\n+            "getAttributes",\n+            "getChildNodes",\n+            "getFirstChild",\n+            "getLastChild",\n+            "getLayout",\n+            "getNextSibling",\n+            "getNodeName",\n+            "getNodeType",\n+            "getNodeValue",\n+            "getOwnerDocument",\n+            "getParentNode",\n+            "getPhysicalPath",\n+            "getPreviousSibling",\n+            "getTagName",\n+            "hasChildNodes",\n+            "Type",\n+            # From PropertyManager:\n+            "getProperty",\n+            "propertyValues",\n+            "propertyItems",\n+            "propertyMap",\n+            "hasProperty",\n+            "getPropertyType",\n+            "propertyIds",\n+            "propertyLabel",\n+            "propertyDescription",\n+        )\n+        for method_name in method_names:\n+            with self.assertRaises(NotFound):\n+                browser.open(portal_url + "/" + method_name)\n+            with self.assertRaises(NotFound):\n+                browser.open(doc_url + "/" + method_name)\n+\n+    def test_quick_installer_security(self):\n+        # Products.CMFQuickInstallerTool has a fix.\n+        # But CMFPlone overrides the tool class, so let\'s check.\n+        portal = self.layer["portal"]\n+        qi = getToolByName(portal, "portal_quickinstaller", None)\n+        if qi is None:\n+            return\n+\n+        # Make sure we are anonymous.\n+        logout()\n+        logout()\n+        # Unrestricted traversal should work, restricted not.\n+        qi = portal.unrestrictedTraverse("portal_quickinstaller")\n+        with self.assertRaises(Unauthorized):\n+            portal.restrictedTraverse("portal_quickinstaller")\n+        for obj_id in qi.objectIds():\n+            qi.unrestrictedTraverse(obj_id)\n+            with self.assertRaises(Unauthorized):\n+                qi.restrictedTraverse(obj_id)\n+\n+        # Authenticated with role Manager, we can view whatever we want.\n+        login(portal, SITE_OWNER_NAME)\n+        qi = portal.unrestrictedTraverse("portal_quickinstaller")\n+        qi = portal.restrictedTraverse("portal_quickinstaller")\n+        for obj_id in qi.objectIds():\n+            qi.unrestrictedTraverse(obj_id)\n+            qi.restrictedTraverse(obj_id)\ndiff --git a/news/3274.bugfix b/news/3274.bugfix\nnew file mode 100644\nindex 0000000000..7d9f538d12\n--- /dev/null\n+++ b/news/3274.bugfix\n@@ -0,0 +1,3 @@\n+Removed the docstring from various methods to avoid making them available via a url.\n+From `Products.PloneHotfix20210518 <https://plone.org/security/hotfix/20210518/reflected-xss-in-various-spots>`_.\n+[maurits]\n'

