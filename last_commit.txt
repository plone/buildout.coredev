Repository: plone.app.redirector


Branch: refs/heads/master
Date: 2022-04-07T17:48:12+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.app.redirector/commit/4c2b760f23923c9c388321fd9d35155a023ad306

prepare plone 6 only

Files changed:
M setup.cfg
M setup.py

b'diff --git a/setup.cfg b/setup.cfg\nindex 2a9acf1..1fd488e 100644\n--- a/setup.cfg\n+++ b/setup.cfg\n@@ -1,2 +1,10 @@\n [bdist_wheel]\n universal = 1\n+\n+\n+[isort]\n+# black compatible Plone isort rules:\n+profile = black\n+force_alphabetical_sort = True\n+force_single_line = True\n+lines_after_imports = 2\ndiff --git a/setup.py b/setup.py\nindex 337205f..1106260 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -1,49 +1,40 @@\n-# -*- coding: utf-8 -*-\n-from setuptools import setup, find_packages\n+from setuptools import find_packages\n+from setuptools import setup\n \n-version = \'2.2.2.dev0\'\n \n-setup(name=\'plone.app.redirector\',\n-      version=version,\n-      description="redirection tool",\n-      long_description=(open("README.rst").read() + "\\n" +\n-                        open("CHANGES.rst").read()),\n-      classifiers=[\n-          "Development Status :: 5 - Production/Stable",\n-          "Environment :: Web Environment",\n-          "Framework :: Plone",\n-          "Framework :: Plone :: 5.0",\n-          "Framework :: Plone :: 5.1",\n-          "Framework :: Plone :: 5.2",\n-          "Framework :: Plone :: Core",\n-          "Framework :: Zope2",\n-          "Framework :: Zope :: 4",\n-          "License :: OSI Approved :: GNU General Public License v2 (GPLv2)",\n-          "Operating System :: OS Independent",\n-          "Programming Language :: Python",\n-          "Programming Language :: Python :: 2.7",\n-          "Programming Language :: Python :: 3.6",\n-          "Programming Language :: Python :: 3.7",\n-          "Programming Language :: Python :: 3.8",\n-      ],\n-      keywords=\'links redirect\',\n-      author=\'Plone Foundation\',\n-      author_email=\'plone-developers@lists.sourceforge.net\',\n-      url=\'https://pypi.org/project/plone.app.redirector\',\n-      license=\'GPL version 2\',\n-      packages=find_packages(),\n-      namespace_packages=[\'plone\', \'plone.app\'],\n-      include_package_data=True,\n-      zip_safe=False,\n-      install_requires=[\n-          \'setuptools\',\n-          \'plone.memoize\',\n-          \'six\',\n-      ],\n-      extras_require={\n-          \'test\': [\n-              \'plone.app.testing\',\n-              \'plone.app.contenttypes\'\n-          ]\n-      },\n-      )\n+version = "3.0.0.dev0"\n+\n+setup(\n+    name="plone.app.redirector",\n+    version=version,\n+    description="redirection tool",\n+    long_description=(open("README.rst").read() + "\\n" + open("CHANGES.rst").read()),\n+    classifiers=[\n+        "Development Status :: 5 - Production/Stable",\n+        "Environment :: Web Environment",\n+        "Framework :: Plone",\n+        "Framework :: Plone :: 6.0",\n+        "Framework :: Plone :: Core",\n+        "Framework :: Zope :: 5",\n+        "License :: OSI Approved :: GNU General Public License v2 (GPLv2)",\n+        "Operating System :: OS Independent",\n+        "Programming Language :: Python",\n+        "Programming Language :: Python :: 3.7",\n+        "Programming Language :: Python :: 3.8",\n+        "Programming Language :: Python :: 3.9",\n+    ],\n+    keywords="links redirect",\n+    author="Plone Foundation",\n+    author_email="plone-developers@lists.sourceforge.net",\n+    url="https://pypi.org/project/plone.app.redirector",\n+    license="GPL version 2",\n+    packages=find_packages(),\n+    namespace_packages=["plone", "plone.app"],\n+    include_package_data=True,\n+    zip_safe=False,\n+    install_requires=[\n+        "setuptools",\n+        "plone.memoize",\n+    ],\n+    extras_require={"test": ["plone.app.testing", "plone.app.contenttypes"]},\n+)\n'

Repository: plone.app.redirector


Branch: refs/heads/master
Date: 2022-04-07T17:48:29+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.app.redirector/commit/2659178fd35999b23aa64872a33dc38f07bb2406

black

Files changed:
M plone/__init__.py
M plone/app/__init__.py
M plone/app/redirector/browser.py
M plone/app/redirector/interfaces.py
M plone/app/redirector/policy.py
M plone/app/redirector/storage.py
M plone/app/redirector/subscribers.py
M plone/app/redirector/testing.py
M plone/app/redirector/tests/test_browser.py
M plone/app/redirector/tests/test_events.py
M plone/app/redirector/tests/test_performance.py
M plone/app/redirector/tests/test_setup.py
M plone/app/redirector/tests/test_storage.py
M plone/app/redirector/tests/test_view.py

b'diff --git a/plone/__init__.py b/plone/__init__.py\nindex 85880ef..ca12a73 100644\n--- a/plone/__init__.py\n+++ b/plone/__init__.py\n@@ -1,7 +1,8 @@\n # -*- coding: utf-8 -*-\n # See http://peak.telecommunity.com/DevCenter/setuptools#namespace-packages\n try:\n-    __import__(\'pkg_resources\').declare_namespace(__name__)\n+    __import__("pkg_resources").declare_namespace(__name__)\n except ImportError:\n     from pkgutil import extend_path\n+\n     __path__ = extend_path(__path__, __name__)\ndiff --git a/plone/app/__init__.py b/plone/app/__init__.py\nindex 85880ef..ca12a73 100644\n--- a/plone/app/__init__.py\n+++ b/plone/app/__init__.py\n@@ -1,7 +1,8 @@\n # -*- coding: utf-8 -*-\n # See http://peak.telecommunity.com/DevCenter/setuptools#namespace-packages\n try:\n-    __import__(\'pkg_resources\').declare_namespace(__name__)\n+    __import__("pkg_resources").declare_namespace(__name__)\n except ImportError:\n     from pkgutil import extend_path\n+\n     __path__ = extend_path(__path__, __name__)\ndiff --git a/plone/app/redirector/browser.py b/plone/app/redirector/browser.py\nindex bf782ec..29b40f4 100644\n--- a/plone/app/redirector/browser.py\n+++ b/plone/app/redirector/browser.py\n@@ -21,12 +21,11 @@\n import logging\n \n \n-logger = logging.getLogger(\'plone.app.redirector\')\n+logger = logging.getLogger("plone.app.redirector")\n \n \n @implementer(IFourOhFourView)\n class FourOhFourView(BrowserView):\n-\n     def attempt_redirect(self):\n         url = self._url()\n         if not url:\n@@ -41,7 +40,7 @@ def attempt_redirect(self):\n         if storage is None:\n             return False\n \n-        old_path = \'/\'.join(old_path_elements)\n+        old_path = "/".join(old_path_elements)\n \n         # First lets try with query string in cases or content migration\n \n@@ -53,7 +52,7 @@ def attempt_redirect(self):\n             # if we matched on the query_string we don\'t want to include it\n             # in redirect\n             if new_path:\n-                query_string = \'\'\n+                query_string = ""\n \n         if not new_path:\n             new_path = storage.get(old_path)\n@@ -62,10 +61,7 @@ def attempt_redirect(self):\n             new_path = self.find_redirect_if_view(old_path_elements, storage)\n \n         if not new_path:\n-            new_path = self.find_redirect_if_template(\n-                url,\n-                old_path_elements,\n-                storage)\n+            new_path = self.find_redirect_if_template(url, old_path_elements, storage)\n \n         if not new_path:\n             return False\n@@ -76,8 +72,7 @@ def attempt_redirect(self):\n             # avoid double quoting\n             url_path = unquote(url.path)\n             url_path = quote(url_path)\n-            url = urllib.parse.SplitResult(\n-                *(url[:2] + (url_path, ) + url[3:])).geturl()\n+            url = urllib.parse.SplitResult(*(url[:2] + (url_path,) + url[3:])).geturl()\n         else:\n             url = self.request.physicalPathToURL(new_path)\n \n@@ -98,60 +93,62 @@ def attempt_redirect(self):\n         return True\n \n     def find_redirect_if_view(self, old_path_elements, storage):\n-        """ find redirect for urls like http://example.com/object/@@view/part.\n-        """\n+        """find redirect for urls like http://example.com/object/@@view/part."""\n         if len(old_path_elements) <= 1:\n             return None\n \n         object_id_hiearchy = []\n         view_parts = []\n         for element in old_path_elements:\n-            if element.startswith(\'@@\') or view_parts:\n+            if element.startswith("@@") or view_parts:\n                 view_parts.append(element)\n             else:\n                 object_id_hiearchy.append(element)\n         if not view_parts:\n             return None\n \n-        old_path_parent = \'/\'.join(object_id_hiearchy)\n+        old_path_parent = "/".join(object_id_hiearchy)\n         new_path_parent = storage.get(old_path_parent)\n         if not new_path_parent or (new_path_parent == old_path_parent):\n             return None\n \n-        return new_path_parent + \'/\' + \'/\'.join(view_parts)\n+        return new_path_parent + "/" + "/".join(view_parts)\n \n     def find_redirect_if_template(self, url, old_path_elements, storage):\n         if len(old_path_elements) <= 1:\n             return None\n         # If the last part of the URL was a template name, say, look for\n         # the parent\n-        old_path_parent = \'/\'.join(old_path_elements[:-1])\n-        template_id = unquote(url.split(\'/\')[-1])\n+        old_path_parent = "/".join(old_path_elements[:-1])\n+        template_id = unquote(url.split("/")[-1])\n         new_path_parent = storage.get(old_path_parent)\n \n         if new_path_parent == old_path_parent:\n+            logger.warning("source and target are equal : [%s]" % new_path_parent)\n             logger.warning(\n-                "source and target are equal : [%s]" % new_path_parent)\n-            logger.warning("for more info, see "\n-                "http://dev.plone.org/plone/ticket/8840")\n+                "for more info, see " "http://dev.plone.org/plone/ticket/8840"\n+            )\n         if not new_path_parent or (new_path_parent == old_path_parent):\n             return None\n \n-        return new_path_parent + \'/\' + template_id\n+        return new_path_parent + "/" + template_id\n \n     def find_first_parent(self):\n         path_elements = self._path_elements()\n         if not path_elements:\n             return None\n-        portal_state = getMultiAdapter((aq_inner(self.context), self.request),\n-             name=\'plone_portal_state\')\n+        portal_state = getMultiAdapter(\n+            (aq_inner(self.context), self.request), name="plone_portal_state"\n+        )\n         portal = portal_state.portal()\n         for i in range(len(path_elements) - 1, 0, -1):\n-            obj = portal.restrictedTraverse(\'/\'.join(path_elements[:i]), None)\n+            obj = portal.restrictedTraverse("/".join(path_elements[:i]), None)\n             if obj is not None:\n                 # Skin objects acquire portal_type from the Plone site\n-                if getattr(aq_base(obj), \'portal_type\', None) \\\n-                   in portal_state.friendly_types():\n+                if (\n+                    getattr(aq_base(obj), "portal_type", None)\n+                    in portal_state.friendly_types()\n+                ):\n                     return obj\n         return None\n \n@@ -163,19 +160,22 @@ def search_for_similar(self):\n         policy = IRedirectionPolicy(self.context)\n         ignore_ids = policy.ignore_ids\n         portal_catalog = getToolByName(self.context, "portal_catalog")\n-        portal_state = getMultiAdapter((aq_inner(self.context), self.request),\n-             name=\'plone_portal_state\')\n+        portal_state = getMultiAdapter(\n+            (aq_inner(self.context), self.request), name="plone_portal_state"\n+        )\n         navroot = portal_state.navigation_root_path()\n         for element in path_elements:\n             # Prevent parens being interpreted\n-            element = element.replace(\'(\', \'"("\')\n-            element = element.replace(\')\', \'")"\')\n+            element = element.replace("(", \'"("\')\n+            element = element.replace(")", \'")"\')\n             if element not in ignore_ids:\n                 try:\n-                    result_set = portal_catalog(SearchableText=element,\n+                    result_set = portal_catalog(\n+                        SearchableText=element,\n                         path=navroot,\n                         portal_type=portal_state.friendly_types(),\n-                        sort_limit=10)\n+                        sort_limit=10,\n+                    )\n                     if result_set:\n                         return result_set[:10]\n                 except (QueryError, ParseError):\n@@ -185,12 +185,10 @@ def search_for_similar(self):\n \n     @memoize\n     def _url(self):\n-        """Get the current, canonical URL\n-        """\n-        return self.request.get(\'ACTUAL_URL\',\n-                 self.request.get(\'VIRTUAL_URL\',\n-                   self.request.get(\'URL\',\n-                     None)))\n+        """Get the current, canonical URL"""\n+        return self.request.get(\n+            "ACTUAL_URL", self.request.get("VIRTUAL_URL", self.request.get("URL", None))\n+        )\n \n     @memoize\n     def _path_elements(self):\n@@ -203,14 +201,15 @@ def _path_elements(self):\n             return None\n \n         try:\n-            path = \'/\'.join(self.request.physicalPathFromURL(url))\n+            path = "/".join(self.request.physicalPathFromURL(url))\n         except ValueError:\n             return None\n \n-        portal_state = getMultiAdapter((aq_inner(self.context), self.request),\n-            name=\'plone_portal_state\')\n-        portal_path = \'/\'.join(portal_state.portal().getPhysicalPath())\n+        portal_state = getMultiAdapter(\n+            (aq_inner(self.context), self.request), name="plone_portal_state"\n+        )\n+        portal_path = "/".join(portal_state.portal().getPhysicalPath())\n         if not path.startswith(portal_path):\n             return None\n \n-        return path.split(\'/\')\n+        return path.split("/")\ndiff --git a/plone/app/redirector/interfaces.py b/plone/app/redirector/interfaces.py\nindex 35e3321..1e1ad8f 100644\n--- a/plone/app/redirector/interfaces.py\n+++ b/plone/app/redirector/interfaces.py\n@@ -3,16 +3,15 @@\n \n \n class IRedirectionPolicy(Interface):\n-    """An adapters that provides some policy about how redirects are performed\n-    """\n+    """An adapters that provides some policy about how redirects are performed"""\n \n-    ignore_ids = Attribute("A list of ids to ignore when examining a URL "\n-                            "for a potential redirection")\n+    ignore_ids = Attribute(\n+        "A list of ids to ignore when examining a URL " "for a potential redirection"\n+    )\n \n \n class IFourOhFourView(Interface):\n-    """A view that supports a useful 404 page\n-    """\n+    """A view that supports a useful 404 page"""\n \n     def attempt_redirect():\n         """Attempt to find a single appropriate redirection target by\n@@ -54,8 +53,7 @@ def add(old_path, new_path):\n         """\n \n     def remove(old_path):\n-        """Forget all redirects from old_path to any new path\n-        """\n+        """Forget all redirects from old_path to any new path"""\n \n     def destroy(new_path):\n         """Forget all redirects to new_path.\n@@ -64,8 +62,7 @@ def destroy(new_path):\n         """\n \n     def has_path(old_path):\n-        """Determine if there are any redirects from old_path in effect.\n-        """\n+        """Determine if there are any redirects from old_path in effect."""\n \n     def get(old_path, default=None):\n         """Get the new path to the object that used to be at old_path.\ndiff --git a/plone/app/redirector/policy.py b/plone/app/redirector/policy.py\nindex e0caf12..a6aa79c 100644\n--- a/plone/app/redirector/policy.py\n+++ b/plone/app/redirector/policy.py\n@@ -15,13 +15,14 @@ def __init__(self, context):\n     # The following ids are ignored when looking for parts of a URL to\n     # consider part of a path - see browser.py.\n \n-    ignore_ids = (\'index_html\',\n-                  \'FrontPage\',\n-                  \'folder_listing\',\n-                  \'folder_contents\',\n-                  \'view\',\n-                  \'edit\',\n-                  \'properties\',\n-                  \'sharing\',\n-                  \'+\', # IAdding view\n-                  )\n+    ignore_ids = (\n+        "index_html",\n+        "FrontPage",\n+        "folder_listing",\n+        "folder_contents",\n+        "view",\n+        "edit",\n+        "properties",\n+        "sharing",\n+        "+",  # IAdding view\n+    )\ndiff --git a/plone/app/redirector/storage.py b/plone/app/redirector/storage.py\nindex dbb2d97..e3786a6 100644\n--- a/plone/app/redirector/storage.py\n+++ b/plone/app/redirector/storage.py\n@@ -140,9 +140,7 @@ def _rebuild(self):\n \n         # Look for inconsistenties and fix them:\n         # paths that are both in paths and in rpaths.\n-        bads = [\n-            new_path for new_path in self._rpaths if new_path in self._paths\n-        ]\n+        bads = [new_path for new_path in self._rpaths if new_path in self._paths]\n         for new_path in bads:\n             newer_path = self._paths[new_path][0]\n             for old_path in self._rpaths[new_path]:\n@@ -198,7 +196,7 @@ def redirects(self, new_path):\n         return [a for a in self._rpaths.get(new_path, [])]\n \n     def _canonical(self, path):\n-        if path.endswith(\'/\'):\n+        if path.endswith("/"):\n             path = path[:-1]\n         return path\n \ndiff --git a/plone/app/redirector/subscribers.py b/plone/app/redirector/subscribers.py\nindex d934667..0105c03 100644\n--- a/plone/app/redirector/subscribers.py\n+++ b/plone/app/redirector/subscribers.py\n@@ -7,44 +7,49 @@\n \n \n def objectMoved(obj, event):\n-    """Tell the redirection storage that an object moved\n-    """\n+    """Tell the redirection storage that an object moved"""\n \n     # Unfortunately, IObjectMoved is a rather generic event...\n-    if event.oldParent is not None and event.newParent is not None and event.oldName is not None:\n+    if (\n+        event.oldParent is not None\n+        and event.newParent is not None\n+        and event.oldName is not None\n+    ):\n         storage = queryUtility(IRedirectionStorage)\n         if storage is not None:\n-            old_path = "%s/%s" % (\'/\'.join(event.oldParent.getPhysicalPath()), event.oldName)\n-            new_path = \'/\'.join(obj.getPhysicalPath())\n+            old_path = "%s/%s" % (\n+                "/".join(event.oldParent.getPhysicalPath()),\n+                event.oldName,\n+            )\n+            new_path = "/".join(obj.getPhysicalPath())\n \n             # This event gets redispatched to children, and we should keep track of them as well\n             # In this case, event.object is not the same as obj, and the old_path should actually\n             # include obj.id\n \n             if aq_base(event.object) is not aq_base(obj):\n-                new_path_of_moved = \'/\'.join(event.object.getPhysicalPath())\n-                old_path = old_path + new_path[len(new_path_of_moved):]\n+                new_path_of_moved = "/".join(event.object.getPhysicalPath())\n+                old_path = old_path + new_path[len(new_path_of_moved) :]\n \n             # XXX: Special case - don\'t remember anything happening inside portal_factory\n-            if \'/portal_factory/\' in old_path:\n+            if "/portal_factory/" in old_path:\n                 return\n \n             # Special case: don\'t remember object when it was just created...\n-            putils = getToolByName(obj, \'plone_utils\')\n+            putils = getToolByName(obj, "plone_utils")\n             if putils is not None and putils.isIDAutoGenerated(event.oldName):\n-                request = getattr(obj, \'REQUEST\', None)\n-                if request is not None and \'ACTUAL_URL\' in request:\n-                    url = request[\'ACTUAL_URL\'].split(\'/\')\n-                    if \'portal_factory\' in url and event.oldName in url:\n+                request = getattr(obj, "REQUEST", None)\n+                if request is not None and "ACTUAL_URL" in request:\n+                    url = request["ACTUAL_URL"].split("/")\n+                    if "portal_factory" in url and event.oldName in url:\n                         return\n \n             storage.add(old_path, new_path)\n \n \n def objectRemoved(obj, event):\n-    """Tell the redirection storage that the object was removed\n-    """\n+    """Tell the redirection storage that the object was removed"""\n     storage = queryUtility(IRedirectionStorage)\n     if storage is not None:\n-        path = \'/\'.join(obj.getPhysicalPath())\n+        path = "/".join(obj.getPhysicalPath())\n         storage.destroy(path)\ndiff --git a/plone/app/redirector/testing.py b/plone/app/redirector/testing.py\nindex 60115fb..3cc7771 100644\n--- a/plone/app/redirector/testing.py\n+++ b/plone/app/redirector/testing.py\n@@ -13,16 +13,16 @@ class PloneAppRedirector(PloneSandboxLayer):\n \n     def setUpZope(self, app, configurationContext):\n         import plone.app.redirector\n+\n         xmlconfig.file(\n-            \'configure.zcml\',\n-            plone.app.redirector,\n-            context=configurationContext)\n+            "configure.zcml", plone.app.redirector, context=configurationContext\n+        )\n \n \n PLONE_APP_REDIRECTOR_FIXTURE = PloneAppRedirector()\n PLONE_APP_REDIRECTOR_INTEGRATION_TESTING = IntegrationTesting(\n-    bases=(PLONE_APP_REDIRECTOR_FIXTURE,),\n-    name="PloneAppRedirector:Integration")\n+    bases=(PLONE_APP_REDIRECTOR_FIXTURE,), name="PloneAppRedirector:Integration"\n+)\n PLONE_APP_REDIRECTOR_FUNCTIONAL_TESTING = FunctionalTesting(\n-    bases=(PLONE_APP_REDIRECTOR_FIXTURE,),\n-    name="PloneAppRedirector:Functional")\n+    bases=(PLONE_APP_REDIRECTOR_FIXTURE,), name="PloneAppRedirector:Functional"\n+)\ndiff --git a/plone/app/redirector/tests/test_browser.py b/plone/app/redirector/tests/test_browser.py\nindex bf5b3f1..9a6992b 100644\n--- a/plone/app/redirector/tests/test_browser.py\n+++ b/plone/app/redirector/tests/test_browser.py\n@@ -24,14 +24,14 @@ class TestBrowser(unittest.TestCase):\n     layer = PLONE_APP_REDIRECTOR_FUNCTIONAL_TESTING\n \n     def setUp(self):\n-        app = self.layer[\'app\']\n+        app = self.layer["app"]\n         self.browser = Browser(app)\n         self.browser.handleErrors = False\n         self.browser.addHeader(\n-            \'Authorization\',\n-            \'Basic {0}:{1}\'.format(SITE_OWNER_NAME, SITE_OWNER_PASSWORD),\n+            "Authorization",\n+            "Basic {0}:{1}".format(SITE_OWNER_NAME, SITE_OWNER_PASSWORD),\n         )\n-        portal = self.layer[\'portal\']\n+        portal = self.layer["portal"]\n         self.portal_url = portal.absolute_url()\n \n     def test_no_redirect_on_creation(self):\n@@ -41,19 +41,17 @@ def test_no_redirect_on_creation(self):\n \n         # Let\'s create an object and check again:\n         self.browser.open(self.portal_url)\n-        self.browser.getLink(url=\'++add++Document\').click()\n-        self.browser.getControl(\n-            name=\'form.widgets.IDublinCore.title\'\n-        ).value = \'Foo\'\n-        self.browser.getControl(\'Save\').click()\n-        self.assertIn(\'Item created\', self.browser.contents)\n+        self.browser.getLink(url="++add++Document").click()\n+        self.browser.getControl(name="form.widgets.IDublinCore.title").value = "Foo"\n+        self.browser.getControl("Save").click()\n+        self.assertIn("Item created", self.browser.contents)\n         self.assertListEqual(list(storage), [])\n \n         # However, if this object is renamed in a normal manner,\n         # an entry should be created, of course:\n-        self.browser.getLink(\'Rename\').click()\n-        self.browser.getControl(\'New Short Name\').value = \'bar\'\n-        self.browser.getControl(\'New Title\').value = \'Bar\'\n-        self.browser.getControl(\'Rename\').click()\n-        self.assertListEqual(list(storage), [\'/plone/foo\'])\n-        self.assertEqual(storage.get(\'/plone/foo\'), \'/plone/bar\')\n+        self.browser.getLink("Rename").click()\n+        self.browser.getControl("New Short Name").value = "bar"\n+        self.browser.getControl("New Title").value = "Bar"\n+        self.browser.getControl("Rename").click()\n+        self.assertListEqual(list(storage), ["/plone/foo"])\n+        self.assertEqual(storage.get("/plone/foo"), "/plone/bar")\ndiff --git a/plone/app/redirector/tests/test_events.py b/plone/app/redirector/tests/test_events.py\nindex a17cec8..4e44b45 100644\n--- a/plone/app/redirector/tests/test_events.py\n+++ b/plone/app/redirector/tests/test_events.py\n@@ -6,19 +6,17 @@\n \n from zope.component import getUtility\n from plone.app.redirector.interfaces import IRedirectionStorage\n-from plone.app.redirector.testing import \\\n-    PLONE_APP_REDIRECTOR_INTEGRATION_TESTING\n+from plone.app.redirector.testing import PLONE_APP_REDIRECTOR_INTEGRATION_TESTING\n \n \n class TestRedirectorEvents(unittest.TestCase):\n-    """Ensure that the redirector event subscribers behave as expected.\n-    """\n+    """Ensure that the redirector event subscribers behave as expected."""\n \n     layer = PLONE_APP_REDIRECTOR_INTEGRATION_TESTING\n \n     def setUp(self):\n-        self.portal = self.layer[\'portal\']\n-        setRoles(self.portal, TEST_USER_ID, [\'Manager\'])\n+        self.portal = self.layer["portal"]\n+        setRoles(self.portal, TEST_USER_ID, ["Manager"])\n         self.portal.invokeFactory("Folder", "folder")\n         self.folder = self.portal.folder\n \n@@ -27,130 +25,126 @@ def storage(self):\n         return getUtility(IRedirectionStorage)\n \n     def test_rename_updates_storage(self):\n-        self.folder.invokeFactory(\'Document\', \'p1\')\n+        self.folder.invokeFactory("Document", "p1")\n         transaction.savepoint(1)\n-        self.folder.manage_renameObject(\'p1\', \'p2\')\n+        self.folder.manage_renameObject("p1", "p2")\n \n-        fp = \'/\'.join(self.folder.getPhysicalPath())\n-        self.assertEqual(self.storage.get(fp + \'/p1\'), fp + \'/p2\')\n+        fp = "/".join(self.folder.getPhysicalPath())\n+        self.assertEqual(self.storage.get(fp + "/p1"), fp + "/p2")\n \n     def test_cut_paste_updates_storage(self):\n-        self.folder.invokeFactory(\'Folder\', \'f1\')\n-        self.folder.invokeFactory(\'Document\', \'p1\')\n-        self.folder.invokeFactory(\'Document\', \'p2\')\n+        self.folder.invokeFactory("Folder", "f1")\n+        self.folder.invokeFactory("Document", "p1")\n+        self.folder.invokeFactory("Document", "p2")\n         transaction.savepoint(1)\n-        cp = self.folder.manage_cutObjects(ids=(\'p1\', \'p2\'))\n+        cp = self.folder.manage_cutObjects(ids=("p1", "p2"))\n         self.folder.f1.manage_pasteObjects(cp)\n \n-        fp = \'/\'.join(self.folder.getPhysicalPath())\n-        self.assertEqual(self.storage.get(fp + \'/p1\'), fp + \'/f1/p1\')\n-        self.assertEqual(self.storage.get(fp + \'/p2\'), fp + \'/f1/p2\')\n+        fp = "/".join(self.folder.getPhysicalPath())\n+        self.assertEqual(self.storage.get(fp + "/p1"), fp + "/f1/p1")\n+        self.assertEqual(self.storage.get(fp + "/p2"), fp + "/f1/p2")\n \n     def test_cut_paste_rename_updates_storage(self):\n-        self.folder.invokeFactory(\'Folder\', \'f1\')\n-        self.folder.invokeFactory(\'Document\', \'p1\')\n-        self.folder.invokeFactory(\'Document\', \'p2\')\n+        self.folder.invokeFactory("Folder", "f1")\n+        self.folder.invokeFactory("Document", "p1")\n+        self.folder.invokeFactory("Document", "p2")\n         transaction.savepoint(1)\n-        cp = self.folder.manage_cutObjects(ids=(\'p1\', \'p2\'))\n+        cp = self.folder.manage_cutObjects(ids=("p1", "p2"))\n         self.folder.f1.manage_pasteObjects(cp)\n         transaction.savepoint(1)\n-        self.folder.f1.manage_renameObject(\'p2\', \'p3\')\n+        self.folder.f1.manage_renameObject("p2", "p3")\n \n-        fp = \'/\'.join(self.folder.getPhysicalPath())\n-        self.assertEqual(self.storage.get(fp + \'/p1\'), fp + \'/f1/p1\')\n-        self.assertEqual(self.storage.get(fp + \'/p2\'), fp + \'/f1/p3\')\n-        self.assertEqual(self.storage.get(fp + \'/f1/p2\'), fp + \'/f1/p3\')\n+        fp = "/".join(self.folder.getPhysicalPath())\n+        self.assertEqual(self.storage.get(fp + "/p1"), fp + "/f1/p1")\n+        self.assertEqual(self.storage.get(fp + "/p2"), fp + "/f1/p3")\n+        self.assertEqual(self.storage.get(fp + "/f1/p2"), fp + "/f1/p3")\n \n     def test_delete_destroys_reference(self):\n-        self.folder.invokeFactory(\'Document\', \'p1\')\n+        self.folder.invokeFactory("Document", "p1")\n         transaction.savepoint(1)\n-        self.folder.manage_renameObject(\'p1\', \'p2\')\n+        self.folder.manage_renameObject("p1", "p2")\n         transaction.savepoint(1)\n \n-        fp = \'/\'.join(self.folder.getPhysicalPath())\n-        self.assertEqual(self.storage.get(fp + \'/p1\'), fp + \'/p2\')\n+        fp = "/".join(self.folder.getPhysicalPath())\n+        self.assertEqual(self.storage.get(fp + "/p1"), fp + "/p2")\n \n-        self.folder._delObject(\'p2\')\n+        self.folder._delObject("p2")\n \n-        self.assertEqual(self.storage.get(fp + \'/p1\'), None)\n+        self.assertEqual(self.storage.get(fp + "/p1"), None)\n \n     def test_delete_destroys_child_reference(self):\n-        self.folder.invokeFactory(\'Folder\', \'f1\')\n-        self.folder.f1.invokeFactory(\'Document\', \'p1\')\n+        self.folder.invokeFactory("Folder", "f1")\n+        self.folder.f1.invokeFactory("Document", "p1")\n         transaction.savepoint(1)\n-        self.folder.f1.manage_renameObject(\'p1\', \'p2\')\n+        self.folder.f1.manage_renameObject("p1", "p2")\n         transaction.savepoint(1)\n \n-        fp = \'/\'.join(self.folder.getPhysicalPath())\n-        self.assertEqual(self.storage.get(fp + \'/f1/p1\'), fp + \'/f1/p2\')\n+        fp = "/".join(self.folder.getPhysicalPath())\n+        self.assertEqual(self.storage.get(fp + "/f1/p1"), fp + "/f1/p2")\n \n-        self.folder._delObject(\'f1\')\n+        self.folder._delObject("f1")\n \n-        self.assertEqual(self.storage.get(fp + \'/f1/p1\'), None)\n+        self.assertEqual(self.storage.get(fp + "/f1/p1"), None)\n \n     def test_rename_updates_parent_and_children(self):\n-        self.folder.invokeFactory(\'Folder\', \'f1\')\n-        self.folder.f1.invokeFactory(\'Document\', \'p1\')\n-        self.folder.f1.invokeFactory(\'Document\', \'p2\')\n+        self.folder.invokeFactory("Folder", "f1")\n+        self.folder.f1.invokeFactory("Document", "p1")\n+        self.folder.f1.invokeFactory("Document", "p2")\n         transaction.savepoint(1)\n-        self.folder.manage_renameObject(\'f1\', \'f2\')\n+        self.folder.manage_renameObject("f1", "f2")\n \n-        fp = \'/\'.join(self.folder.getPhysicalPath())\n-        self.assertEqual(self.storage.get(fp + \'/f1\'), fp + \'/f2\')\n-        self.assertEqual(self.storage.get(fp + \'/f1/p1\'), fp + \'/f2/p1\')\n-        self.assertEqual(self.storage.get(fp + \'/f1/p2\'), fp + \'/f2/p2\')\n+        fp = "/".join(self.folder.getPhysicalPath())\n+        self.assertEqual(self.storage.get(fp + "/f1"), fp + "/f2")\n+        self.assertEqual(self.storage.get(fp + "/f1/p1"), fp + "/f2/p1")\n+        self.assertEqual(self.storage.get(fp + "/f1/p2"), fp + "/f2/p2")\n \n     def test_cut_paste_updates_parent_and_children(self):\n-        self.folder.invokeFactory(\'Folder\', \'f1\')\n-        self.folder.invokeFactory(\'Folder\', \'f2\')\n-        self.folder.f1.invokeFactory(\'Document\', \'p1\')\n-        self.folder.f1.invokeFactory(\'Document\', \'p2\')\n+        self.folder.invokeFactory("Folder", "f1")\n+        self.folder.invokeFactory("Folder", "f2")\n+        self.folder.f1.invokeFactory("Document", "p1")\n+        self.folder.f1.invokeFactory("Document", "p2")\n         transaction.savepoint(1)\n-        cp = self.folder.manage_cutObjects(ids=(\'f1\', ))\n+        cp = self.folder.manage_cutObjects(ids=("f1",))\n         self.folder.f2.manage_pasteObjects(cp)\n \n-        fp = \'/\'.join(self.folder.getPhysicalPath())\n-        self.assertEqual(self.storage.get(fp + \'/f1\'), fp + \'/f2/f1\')\n-        self.assertEqual(self.storage.get(fp + \'/f1/p1\'), fp + \'/f2/f1/p1\')\n-        self.assertEqual(self.storage.get(fp + \'/f1/p2\'), fp + \'/f2/f1/p2\')\n+        fp = "/".join(self.folder.getPhysicalPath())\n+        self.assertEqual(self.storage.get(fp + "/f1"), fp + "/f2/f1")\n+        self.assertEqual(self.storage.get(fp + "/f1/p1"), fp + "/f2/f1/p1")\n+        self.assertEqual(self.storage.get(fp + "/f1/p2"), fp + "/f2/f1/p2")\n \n     def test_rename_updates_parent_and_children_deep(self):\n-        self.folder.invokeFactory(\'Folder\', \'f1\')\n-        self.folder.f1.invokeFactory(\'Folder\', \'f11\')\n-        self.folder.f1.f11.invokeFactory(\'Document\', \'p1\')\n-        self.folder.f1.f11.invokeFactory(\'Document\', \'p2\')\n+        self.folder.invokeFactory("Folder", "f1")\n+        self.folder.f1.invokeFactory("Folder", "f11")\n+        self.folder.f1.f11.invokeFactory("Document", "p1")\n+        self.folder.f1.f11.invokeFactory("Document", "p2")\n         transaction.savepoint(1)\n-        self.folder.manage_renameObject(\'f1\', \'f2a\')\n+        self.folder.manage_renameObject("f1", "f2a")\n \n-        fp = \'/\'.join(self.folder.getPhysicalPath())\n-        self.assertEqual(self.storage.get(fp + \'/f1\'), fp + \'/f2a\')\n-        self.assertEqual(self.storage.get(fp + \'/f1/f11\'), fp + \'/f2a/f11\')\n-        self.assertEqual(\n-            self.storage.get(fp + \'/f1/f11/p1\'), fp + \'/f2a/f11/p1\')\n-        self.assertEqual(\n-            self.storage.get(fp + \'/f1/f11/p2\'), fp + \'/f2a/f11/p2\')\n+        fp = "/".join(self.folder.getPhysicalPath())\n+        self.assertEqual(self.storage.get(fp + "/f1"), fp + "/f2a")\n+        self.assertEqual(self.storage.get(fp + "/f1/f11"), fp + "/f2a/f11")\n+        self.assertEqual(self.storage.get(fp + "/f1/f11/p1"), fp + "/f2a/f11/p1")\n+        self.assertEqual(self.storage.get(fp + "/f1/f11/p2"), fp + "/f2a/f11/p2")\n \n     def test_cut_paste_updates_parent_and_children_deep(self):\n-        self.folder.invokeFactory(\'Folder\', \'f1\')\n-        self.folder.invokeFactory(\'Folder\', \'f2a\')\n-        self.folder.f1.invokeFactory(\'Folder\', \'f11\')\n-        self.folder.f1.f11.invokeFactory(\'Document\', \'p1\')\n-        self.folder.f1.f11.invokeFactory(\'Document\', \'p2\')\n+        self.folder.invokeFactory("Folder", "f1")\n+        self.folder.invokeFactory("Folder", "f2a")\n+        self.folder.f1.invokeFactory("Folder", "f11")\n+        self.folder.f1.f11.invokeFactory("Document", "p1")\n+        self.folder.f1.f11.invokeFactory("Document", "p2")\n         transaction.savepoint(1)\n-        cp = self.folder.manage_cutObjects(ids=(\'f1\', ))\n+        cp = self.folder.manage_cutObjects(ids=("f1",))\n         self.folder.f2a.manage_pasteObjects(cp)\n \n-        fp = \'/\'.join(self.folder.getPhysicalPath())\n-        self.assertEqual(self.storage.get(fp + \'/f1\'), fp + \'/f2a/f1\')\n-        self.assertEqual(self.storage.get(fp + \'/f1/f11\'), fp + \'/f2a/f1/f11\')\n-        self.assertEqual(self.storage.get(\n-            fp + \'/f1/f11/p1\'), fp + \'/f2a/f1/f11/p1\')\n-        self.assertEqual(self.storage.get(\n-            fp + \'/f1/f11/p2\'), fp + \'/f2a/f1/f11/p2\')\n+        fp = "/".join(self.folder.getPhysicalPath())\n+        self.assertEqual(self.storage.get(fp + "/f1"), fp + "/f2a/f1")\n+        self.assertEqual(self.storage.get(fp + "/f1/f11"), fp + "/f2a/f1/f11")\n+        self.assertEqual(self.storage.get(fp + "/f1/f11/p1"), fp + "/f2a/f1/f11/p1")\n+        self.assertEqual(self.storage.get(fp + "/f1/f11/p2"), fp + "/f2a/f1/f11/p2")\n \n     def test_add_doesnt_create_storage_entry(self):\n-        """ refers https://dev.plone.org/plone/ticket/8260 """\n+        """refers https://dev.plone.org/plone/ticket/8260"""\n         orig_len = len(list(self.storage))\n-        self.folder.invokeFactory(\'Document\', \'p1\')\n+        self.folder.invokeFactory("Document", "p1")\n         transaction.savepoint(1)\n         self.assertEqual(0, len(list(self.storage)) - orig_len)\ndiff --git a/plone/app/redirector/tests/test_performance.py b/plone/app/redirector/tests/test_performance.py\nindex 09497fd..bcd6844 100644\n--- a/plone/app/redirector/tests/test_performance.py\n+++ b/plone/app/redirector/tests/test_performance.py\n@@ -7,7 +7,7 @@\n import unittest\n \n \n-env_name = \'PLONE_APP_REDIRECTOR_PERFORMANCE_NUMBER\'\n+env_name = "PLONE_APP_REDIRECTOR_PERFORMANCE_NUMBER"\n if env_name in os.environ:\n     # This could fail with a ValueError, but that seems a fine error message.\n     NUMBER = max(int(os.getenv(env_name)), 1)\n@@ -26,14 +26,13 @@ def pretty_number(num):\n         return num\n     num = int(num / 1000)\n     if num < 1000:\n-        return \'{0} thousand\'.format(num)\n+        return "{0} thousand".format(num)\n     num = int(num / 1000)\n-    return \'{0} million\'.format(num)\n+    return "{0} million".format(num)\n \n \n class TestStoragePerformance(unittest.TestCase):\n-    """Test the performance of the RedirectionStorage class.\n-    """\n+    """Test the performance of the RedirectionStorage class."""\n \n     @contextmanager\n     def timeit(self, message, limit=0):\n@@ -48,14 +47,12 @@ def timeit(self, message, limit=0):\n         limit = max(limit, 0.3)\n         if total > limit:\n             self.fail(\n-                \'{0} takes too long: {1:.2f} seconds (max {2})\'.format(\n+                "{0} takes too long: {1:.2f} seconds (max {2})".format(\n                     message, total, limit\n                 )\n             )\n         elif VERBOSE:\n-            print(\n-                \'{0}: {1:.2f} seconds (max {2})\'.format(message, total, limit)\n-            )\n+            print("{0}: {1:.2f} seconds (max {2})".format(message, total, limit))\n \n     def test_storage_performance(self):\n         """Test the performance of some of the code.\n@@ -76,70 +73,59 @@ def test_storage_performance(self):\n         """\n         st = RedirectionStorage()\n         if VERBOSE:\n-            print(\'\\nRunning plone.app.redirector storage performance tests.\')\n+            print("\\nRunning plone.app.redirector storage performance tests.")\n \n         # Can take long.  But 10.000 per second should be no problem.\n         # Take one tenth of the items at first.\n         num = max(int(NUMBER / 10), 1)\n         with self.timeit(\n-            \'Inserting {0} individual items\'.format(pretty_number(num)),\n+            "Inserting {0} individual items".format(pretty_number(num)),\n             num / 10000.0,\n         ):\n             for i in range(num):\n-                st[\'/old/{0}\'.format(i)] = \'/new/{0}\'.format(i)\n+                st["/old/{0}".format(i)] = "/new/{0}".format(i)\n \n         # I expected this to be almost instantaneous because we replace\n         # the data with new OOBTrees, but it still takes time:\n         # for ten million items it take 0.3 seconds.\n-        with self.timeit(\'Clearing storage\', num / 1000000.0):\n+        with self.timeit("Clearing storage", num / 1000000.0):\n             st.clear()\n \n         # Should be fairly quick.\n         with self.timeit(\n-            \'Preparing {0} items for bulk import\'.format(\n-                pretty_number(NUMBER)\n-            ),\n+            "Preparing {0} items for bulk import".format(pretty_number(NUMBER)),\n             NUMBER / 100000.0,\n         ):\n-            info = {\n-                \'/old/{0}\'.format(i): \'/new/{0}\'.format(i)\n-                for i in range(NUMBER)\n-            }\n+            info = {"/old/{0}".format(i): "/new/{0}".format(i) for i in range(NUMBER)}\n \n         # Can take long.  But 10.000 per second should be no problem.\n         with self.timeit(\n-            \'Inserting {0} prepared items in bulk\'.format(\n-                pretty_number(NUMBER)\n-            ),\n+            "Inserting {0} prepared items in bulk".format(pretty_number(NUMBER)),\n             NUMBER / 10000.0,\n         ):\n             # Prepare input:\n             info = {}\n             for i in range(NUMBER):\n-                info[\'/old/{0}\'.format(i)] = \'/new/{0}\'.format(i)\n+                info["/old/{0}".format(i)] = "/new/{0}".format(i)\n             st.update(info)\n \n         # Should be almost instantaneous.\n-        with self.timeit(\'Getting length\'):\n+        with self.timeit("Getting length"):\n             self.assertEqual(len(st), NUMBER)\n \n         # Should be almost instantaneous.\n-        with self.timeit(\'Getting iterator\'):\n+        with self.timeit("Getting iterator"):\n             iter(st)\n \n         # Should be fairly quick.\n-        with self.timeit(\'Listing all\', NUMBER / 1000000.0):\n+        with self.timeit("Listing all", NUMBER / 1000000.0):\n             list(st)\n \n         # Should be reasonably quick, but the time is noticeable.\n-        with self.timeit(\n-            \'Listing and getting each single one\', NUMBER / 100000.0\n-        ):\n+        with self.timeit("Listing and getting each single one", NUMBER / 100000.0):\n             for key in st:\n                 st[key]\n \n         # Can take long.  But 10.000 per second should be no problem.\n-        with self.timeit(\n-            \'Rebuilding the structure for migration\', NUMBER / 100000.0\n-        ):\n+        with self.timeit("Rebuilding the structure for migration", NUMBER / 100000.0):\n             st._rebuild()\ndiff --git a/plone/app/redirector/tests/test_setup.py b/plone/app/redirector/tests/test_setup.py\nindex 8c28836..64ad331 100644\n--- a/plone/app/redirector/tests/test_setup.py\n+++ b/plone/app/redirector/tests/test_setup.py\n@@ -4,23 +4,21 @@\n from zope.component import queryUtility\n \n from plone.app.redirector.interfaces import IRedirectionStorage\n-from plone.app.redirector.testing import \\\n-    PLONE_APP_REDIRECTOR_INTEGRATION_TESTING\n+from plone.app.redirector.testing import PLONE_APP_REDIRECTOR_INTEGRATION_TESTING\n \n \n class TestRedirectorSetup(unittest.TestCase):\n-    """Ensure that the basic redirector setup is successful.\n-    """\n+    """Ensure that the basic redirector setup is successful."""\n \n     layer = PLONE_APP_REDIRECTOR_INTEGRATION_TESTING\n \n     def setUp(self):\n-        self.portal = self.layer[\'portal\']\n+        self.portal = self.layer["portal"]\n \n     def test_utility(self):\n         utility = queryUtility(IRedirectionStorage)\n         self.assertNotEqual(None, utility)\n \n     def test_view(self):\n-        view = self.portal.restrictedTraverse(\'@@plone_redirector_view\')\n+        view = self.portal.restrictedTraverse("@@plone_redirector_view")\n         self.assertNotEqual(None, view)\ndiff --git a/plone/app/redirector/tests/test_storage.py b/plone/app/redirector/tests/test_storage.py\nindex 7000d9b..cc092df 100644\n--- a/plone/app/redirector/tests/test_storage.py\n+++ b/plone/app/redirector/tests/test_storage.py\n@@ -14,27 +14,27 @@ class TestStorage(unittest.TestCase):\n     def test_storage_one_redirect(self):\n         # Add one redirect\n         st = RedirectionStorage()\n-        self.assertFalse(st.has_path(\'/foo\'))\n-        st.add(\'/foo\', \'/bar\')\n-        self.assertTrue(st.has_path(\'/foo\'))\n-        self.assertEqual(st.get(\'/foo\'), \'/bar\')\n-        self.assertFalse(st.has_path(\'/bar\'))\n-        self.assertListEqual(st.redirects(\'/bar\'), [\'/foo\'])\n-        self.assertIn(\'/foo\', st)\n-        self.assertNotIn(\'/bar\', st)\n-        self.assertEqual(st[\'/foo\'], \'/bar\')\n+        self.assertFalse(st.has_path("/foo"))\n+        st.add("/foo", "/bar")\n+        self.assertTrue(st.has_path("/foo"))\n+        self.assertEqual(st.get("/foo"), "/bar")\n+        self.assertFalse(st.has_path("/bar"))\n+        self.assertListEqual(st.redirects("/bar"), ["/foo"])\n+        self.assertIn("/foo", st)\n+        self.assertNotIn("/bar", st)\n+        self.assertEqual(st["/foo"], "/bar")\n         with self.assertRaises(KeyError):\n-            st[\'/bar\']\n+            st["/bar"]\n \n     def test_storage_get_full_standard(self):\n         # get_full gets the full tuple instead of only the path\n         st = RedirectionStorage()\n         time1 = DateTime()\n-        st.add(\'/foo\', \'/bar\', now=time1, manual=False)\n-        full = st.get_full(\'/foo\')\n+        st.add("/foo", "/bar", now=time1, manual=False)\n+        full = st.get_full("/foo")\n         self.assertIsInstance(full, tuple)\n-        self.assertEqual(full, st._paths[\'/foo\'])\n-        self.assertEqual(full[0], \'/bar\')\n+        self.assertEqual(full, st._paths["/foo"])\n+        self.assertEqual(full[0], "/bar")\n         self.assertEqual(full[1], time1)\n         self.assertFalse(full[2])  # manual\n \n@@ -42,11 +42,11 @@ def test_storage_get_full_fallback(self):\n         # get_full gets the full tuple,\n         # even if the unmigrated data only has the path\n         st = RedirectionStorage()\n-        st._paths[\'/foo\'] = \'/bar\'\n-        self.assertEqual(st._paths[\'/foo\'], \'/bar\')\n-        full = st.get_full(\'/foo\')\n+        st._paths["/foo"] = "/bar"\n+        self.assertEqual(st._paths["/foo"], "/bar")\n+        full = st.get_full("/foo")\n         self.assertIsInstance(full, tuple)\n-        self.assertEqual(full[0], \'/bar\')\n+        self.assertEqual(full[0], "/bar")\n         # Instead of a DateTime, we get None in the fallback\n         self.assertIsNone(full[1])\n         self.assertTrue(full[2])  # manual\n@@ -56,115 +56,115 @@ def test_storage_no_slash(self):\n         # /plone-site-id/some/path.\n         # But a slash at the beginning is not mandatory.\n         st = RedirectionStorage()\n-        self.assertFalse(st.has_path(\'foo\'))\n-        st.add(\'foo\', \'bar\')\n-        self.assertTrue(st.has_path(\'foo\'))\n-        self.assertEqual(st.get(\'foo\'), \'bar\')\n-        self.assertFalse(st.has_path(\'bar\'))\n-        self.assertListEqual(st.redirects(\'bar\'), [\'foo\'])\n-        self.assertIn(\'foo\', st)\n-        self.assertNotIn(\'bar\', st)\n-        self.assertEqual(st[\'foo\'], \'bar\')\n+        self.assertFalse(st.has_path("foo"))\n+        st.add("foo", "bar")\n+        self.assertTrue(st.has_path("foo"))\n+        self.assertEqual(st.get("foo"), "bar")\n+        self.assertFalse(st.has_path("bar"))\n+        self.assertListEqual(st.redirects("bar"), ["foo"])\n+        self.assertIn("foo", st)\n+        self.assertNotIn("bar", st)\n+        self.assertEqual(st["foo"], "bar")\n         with self.assertRaises(KeyError):\n-            st[\'bar\']\n+            st["bar"]\n \n     def test_storage_nested(self):\n         # Since Plone will created redirects with key\n         # /plone-site-id/some/path, testing with multiple slashes seems wise.\n         st = RedirectionStorage()\n-        self.assertFalse(st.has_path(\'/plone/some/path\'))\n-        st.add(\'/plone/some/path\', \'/plone/a/different/path\')\n-        self.assertTrue(st.has_path(\'/plone/some/path\'))\n-        self.assertEqual(st.get(\'/plone/some/path\'), \'/plone/a/different/path\')\n-        self.assertFalse(st.has_path(\'/plone/a/different/path\'))\n+        self.assertFalse(st.has_path("/plone/some/path"))\n+        st.add("/plone/some/path", "/plone/a/different/path")\n+        self.assertTrue(st.has_path("/plone/some/path"))\n+        self.assertEqual(st.get("/plone/some/path"), "/plone/a/different/path")\n+        self.assertFalse(st.has_path("/plone/a/different/path"))\n         self.assertListEqual(\n-            st.redirects(\'/plone/a/different/path\'), [\'/plone/some/path\']\n+            st.redirects("/plone/a/different/path"), ["/plone/some/path"]\n         )\n-        self.assertIn(\'/plone/some/path\', st)\n-        self.assertNotIn(\'/plone/a/different/path\', st)\n-        self.assertEqual(st[\'/plone/some/path\'], \'/plone/a/different/path\')\n+        self.assertIn("/plone/some/path", st)\n+        self.assertNotIn("/plone/a/different/path", st)\n+        self.assertEqual(st["/plone/some/path"], "/plone/a/different/path")\n         with self.assertRaises(KeyError):\n-            st[\'/plone/a/different/path\']\n+            st["/plone/a/different/path"]\n \n     def test_storage_trailing_slash(self):\n         # trailing slashes are ignored\n         st = RedirectionStorage()\n-        self.assertFalse(st.has_path(\'/foo/\'))\n-        st.add(\'/foo\', \'/bar\')\n-        self.assertTrue(st.has_path(\'/foo/\'))\n-        self.assertEqual(st.get(\'/foo/\'), \'/bar\')\n-        self.assertListEqual(st.redirects(\'/bar/\'), [\'/foo\'])\n-        self.assertIn(\'/foo/\', st)\n-        self.assertNotIn(\'/bar/\', st)\n-        self.assertEqual(st[\'/foo/\'], \'/bar\')\n+        self.assertFalse(st.has_path("/foo/"))\n+        st.add("/foo", "/bar")\n+        self.assertTrue(st.has_path("/foo/"))\n+        self.assertEqual(st.get("/foo/"), "/bar")\n+        self.assertListEqual(st.redirects("/bar/"), ["/foo"])\n+        self.assertIn("/foo/", st)\n+        self.assertNotIn("/bar/", st)\n+        self.assertEqual(st["/foo/"], "/bar")\n         with self.assertRaises(KeyError):\n-            st[\'/bar/\']\n+            st["/bar/"]\n \n         # This goes the other way around too\n-        self.assertFalse(st.has_path(\'/quux\'))\n-        st.add(\'/quux/\', \'/baaz/\')\n-        self.assertTrue(st.has_path(\'/quux\'))\n-        self.assertEqual(st.get(\'/quux\'), \'/baaz\')\n-        self.assertListEqual(st.redirects(\'/baaz\'), [\'/quux\'])\n-        self.assertIn(\'/quux\', st)\n-        self.assertNotIn(\'/baaz\', st)\n-        self.assertEqual(st[\'/quux\'], \'/baaz\')\n+        self.assertFalse(st.has_path("/quux"))\n+        st.add("/quux/", "/baaz/")\n+        self.assertTrue(st.has_path("/quux"))\n+        self.assertEqual(st.get("/quux"), "/baaz")\n+        self.assertListEqual(st.redirects("/baaz"), ["/quux"])\n+        self.assertIn("/quux", st)\n+        self.assertNotIn("/baaz", st)\n+        self.assertEqual(st["/quux"], "/baaz")\n         with self.assertRaises(KeyError):\n-            st[\'/baaz\']\n+            st["/baaz"]\n \n     def test_storage_date(self):\n         # Add one redirect\n         st = RedirectionStorage()\n         time1 = DateTime()\n-        st.add(\'/foo\', \'/bar\')\n+        st.add("/foo", "/bar")\n         time2 = DateTime()\n         # Check the internals: we now store a date (and manual True/False).\n-        info = st._paths[\'/foo\']\n+        info = st._paths["/foo"]\n         self.assertIsInstance(info, tuple)\n         self.assertTrue(time1 < info[1] < time2)\n         # Use an explicit date.\n         now = DateTime(2000, 12, 31)\n-        st.add(\'/exp\', \'/bar\', now=now)\n-        info = st._paths[\'/exp\']\n+        st.add("/exp", "/bar", now=now)\n+        info = st._paths["/exp"]\n         self.assertIsInstance(info, tuple)\n         self.assertEqual(info[1], now)\n         # Update with a different date.\n-        st.add(\'/exp\', \'/bar\', now=time1)\n-        info = st._paths[\'/exp\']\n+        st.add("/exp", "/bar", now=time1)\n+        info = st._paths["/exp"]\n         self.assertIsInstance(info, tuple)\n         self.assertEqual(info[1], time1)\n         # Update with an implicit date.\n-        st.add(\'/exp\', \'/bar\')\n+        st.add("/exp", "/bar")\n         time3 = DateTime()\n-        info = st._paths[\'/exp\']\n+        info = st._paths["/exp"]\n         self.assertIsInstance(info, tuple)\n         self.assertTrue(time2 < info[1] < time3)\n \n     def test_storage_manual(self):\n         # Add one redirect\n         st = RedirectionStorage()\n-        st.add(\'/foo\', \'/bar\')\n+        st.add("/foo", "/bar")\n         # Check the internals: we now store manual True/False (and a date).\n-        info = st._paths[\'/foo\']\n+        info = st._paths["/foo"]\n         self.assertIsInstance(info, tuple)\n         self.assertIsInstance(info[2], bool)\n         self.assertFalse(info[2])\n         # Store a manual one.\n-        st.add(\'/exp\', \'/bar\', manual=True)\n-        info = st._paths[\'/exp\']\n+        st.add("/exp", "/bar", manual=True)\n+        info = st._paths["/exp"]\n         self.assertIsInstance(info, tuple)\n         self.assertIsInstance(info[2], bool)\n         self.assertTrue(info[2])\n         # Update to non-manual (the default).\n-        st.add(\'/exp\', \'/bar\')\n-        info = st._paths[\'/exp\']\n+        st.add("/exp", "/bar")\n+        info = st._paths["/exp"]\n         self.assertIsInstance(info, tuple)\n         self.assertIsInstance(info[2], bool)\n         self.assertFalse(info[2])\n         # Make the original non-manual one manual.\n-        st.add(\'/foo\', \'/bar\', manual=True)\n+        st.add("/foo", "/bar", manual=True)\n         # Check the internals: we now store manual True/False (and a date).\n-        info = st._paths[\'/foo\']\n+        info = st._paths["/foo"]\n         self.assertIsInstance(info, tuple)\n         self.assertIsInstance(info[2], bool)\n         self.assertTrue(info[2])\n@@ -172,36 +172,36 @@ def test_storage_manual(self):\n     def test_storage_two_redirects_plain(self):\n         # Add multiple redirects.\n         st = RedirectionStorage()\n-        st.add(\'/foo\', \'/bar\')\n-        st.add(\'/baz\', \'/bar\')\n-        self.assertTrue(st.has_path(\'/baz\'))\n-        self.assertEqual(st.get(\'/baz\'), \'/bar\')\n-        self.assertListEqual(sorted(st.redirects(\'/bar\')), [\'/baz\', \'/foo\'])\n-        self.assertIn(\'/foo\', st)\n-        self.assertIn(\'/baz\', st)\n-        self.assertNotIn(\'/bar\', st)\n+        st.add("/foo", "/bar")\n+        st.add("/baz", "/bar")\n+        self.assertTrue(st.has_path("/baz"))\n+        self.assertEqual(st.get("/baz"), "/bar")\n+        self.assertListEqual(sorted(st.redirects("/bar")), ["/baz", "/foo"])\n+        self.assertIn("/foo", st)\n+        self.assertIn("/baz", st)\n+        self.assertNotIn("/bar", st)\n \n     def test_storage_two_redirects_pythonic(self):\n         # Add multiple redirects.\n         st = RedirectionStorage()\n-        st[\'/foo\'] = \'/bar\'\n-        st[\'/baz\'] = \'/bar\'\n-        self.assertTrue(st.has_path(\'/baz\'))\n-        self.assertEqual(st.get(\'/baz\'), \'/bar\')\n-        self.assertListEqual(sorted(st.redirects(\'/bar\')), [\'/baz\', \'/foo\'])\n-        self.assertIn(\'/foo\', st)\n-        self.assertIn(\'/baz\', st)\n-        self.assertNotIn(\'/bar\', st)\n+        st["/foo"] = "/bar"\n+        st["/baz"] = "/bar"\n+        self.assertTrue(st.has_path("/baz"))\n+        self.assertEqual(st.get("/baz"), "/bar")\n+        self.assertListEqual(sorted(st.redirects("/bar")), ["/baz", "/foo"])\n+        self.assertIn("/foo", st)\n+        self.assertIn("/baz", st)\n+        self.assertNotIn("/bar", st)\n \n     def test_storage_clear(self):\n         # Clear all information.\n         st = RedirectionStorage()\n-        st[\'/foo\'] = \'/bar\'\n-        st[\'/baz\'] = \'/bar\'\n+        st["/foo"] = "/bar"\n+        st["/baz"] = "/bar"\n         st.clear()\n-        self.assertNotIn(\'/foo\', st)\n-        self.assertNotIn(\'/baz\', st)\n-        self.assertEqual(len(st.redirects(\'/bar\')), 0)\n+        self.assertNotIn("/foo", st)\n+        self.assertNotIn("/baz", st)\n+        self.assertEqual(len(st.redirects("/bar")), 0)\n         # Test the internal structures directly\n         self.assertEqual(len(st._paths), 0)\n         self.assertEqual(len(st._rpaths), 0)\n@@ -209,80 +209,78 @@ def test_storage_clear(self):\n     def test_storage_update_redirect(self):\n         # Update a redirect\n         st = RedirectionStorage()\n-        st.add(\'/foo\', \'/bar\')\n-        st.add(\'/baz\', \'/bar\')\n-        st.add(\'/foo\', \'/quux\')\n-        self.assertTrue(st.has_path(\'/foo\'))\n-        self.assertEqual(st.get(\'/foo\'), \'/quux\')\n-        self.assertListEqual(st.redirects(\'/bar\'), [\'/baz\'])\n-        self.assertListEqual(st.redirects(\'/quux\'), [\'/foo\'])\n-        self.assertIn(\'/foo\', st)\n+        st.add("/foo", "/bar")\n+        st.add("/baz", "/bar")\n+        st.add("/foo", "/quux")\n+        self.assertTrue(st.has_path("/foo"))\n+        self.assertEqual(st.get("/foo"), "/quux")\n+        self.assertListEqual(st.redirects("/bar"), ["/baz"])\n+        self.assertListEqual(st.redirects("/quux"), ["/foo"])\n+        self.assertIn("/foo", st)\n \n     def test_storage_remove_redirect_plain(self):\n         # Remove a redirect\n         st = RedirectionStorage()\n-        st.add(\'/foo\', \'/bar\')\n-        st.remove(\'/foo\')\n-        self.assertFalse(st.has_path(\'/foo\'))\n-        self.assertEqual(st.get(\'/foo\', default=\'_notfound_\'), \'_notfound_\')\n-        self.assertListEqual(st.redirects(\'/bar\'), [])\n-        self.assertNotIn(\'/foo\', st)\n+        st.add("/foo", "/bar")\n+        st.remove("/foo")\n+        self.assertFalse(st.has_path("/foo"))\n+        self.assertEqual(st.get("/foo", default="_notfound_"), "_notfound_")\n+        self.assertListEqual(st.redirects("/bar"), [])\n+        self.assertNotIn("/foo", st)\n         with self.assertRaises(KeyError):\n-            st.remove(\'/foo\')\n+            st.remove("/foo")\n \n     def test_storage_remove_redirect_pythonic(self):\n         # Remove a redirect\n         st = RedirectionStorage()\n-        st[\'/foo\'] = \'/bar\'\n-        self.assertIn(\'/foo\', st)\n-        del st[\'/foo\']\n-        self.assertNotIn(\'/foo\', st)\n+        st["/foo"] = "/bar"\n+        self.assertIn("/foo", st)\n+        del st["/foo"]\n+        self.assertNotIn("/foo", st)\n         with self.assertRaises(KeyError):\n-            st[\'/foo\']\n-        self.assertListEqual(st.redirects(\'/bar\'), [])\n+            st["/foo"]\n+        self.assertListEqual(st.redirects("/bar"), [])\n \n         # test with extra slash\n-        st[\'/foo\'] = \'/bar\'\n-        self.assertIn(\'/foo\', st)\n-        del st[\'/foo/\']\n-        self.assertNotIn(\'/foo\', st)\n+        st["/foo"] = "/bar"\n+        self.assertIn("/foo", st)\n+        del st["/foo/"]\n+        self.assertNotIn("/foo", st)\n         with self.assertRaises(KeyError):\n-            st[\'/foo/\']\n-        self.assertListEqual(st.redirects(\'/bar\'), [])\n+            st["/foo/"]\n+        self.assertListEqual(st.redirects("/bar"), [])\n \n     def test_storage_chain(self):\n         # Update a redirect in a chain\n         st = RedirectionStorage()\n-        st.add(\'/fred\', \'/foo\')\n-        self.assertEqual(st.get(\'/fred\'), \'/foo\')\n-        self.assertListEqual(sorted(st.redirects(\'/foo\')), [\'/fred\'])\n-\n-        st.add(\'/fred\', \'/barney\')\n-        self.assertEqual(st.get(\'/fred\'), \'/barney\')\n-        self.assertListEqual(sorted(st.redirects(\'/foo\')), [])\n-        self.assertListEqual(sorted(st.redirects(\'/barney\')), [\'/fred\'])\n-\n-        st.add(\'/barney\', \'/wilma\')\n-        self.assertEqual(st.get(\'/fred\'), \'/wilma\')\n-        self.assertEqual(st.get(\'/barney\'), \'/wilma\')\n-        self.assertListEqual(\n-            sorted(st.redirects(\'/wilma\')), [\'/barney\', \'/fred\']\n-        )\n-        self.assertListEqual(sorted(st.redirects(\'/barney\')), [])\n-        self.assertIn(\'/fred\', st)\n-        self.assertIn(\'/barney\', st)\n+        st.add("/fred", "/foo")\n+        self.assertEqual(st.get("/fred"), "/foo")\n+        self.assertListEqual(sorted(st.redirects("/foo")), ["/fred"])\n+\n+        st.add("/fred", "/barney")\n+        self.assertEqual(st.get("/fred"), "/barney")\n+        self.assertListEqual(sorted(st.redirects("/foo")), [])\n+        self.assertListEqual(sorted(st.redirects("/barney")), ["/fred"])\n+\n+        st.add("/barney", "/wilma")\n+        self.assertEqual(st.get("/fred"), "/wilma")\n+        self.assertEqual(st.get("/barney"), "/wilma")\n+        self.assertListEqual(sorted(st.redirects("/wilma")), ["/barney", "/fred"])\n+        self.assertListEqual(sorted(st.redirects("/barney")), [])\n+        self.assertIn("/fred", st)\n+        self.assertIn("/barney", st)\n \n     def test_storage_destroy_target(self):\n         # Destroy the target of a redirect\n         st = RedirectionStorage()\n-        st.add(\'/fred\', \'/barney\')\n-        st.add(\'/barney\', \'/wilma\')\n-        st.destroy(\'/wilma\')\n-        self.assertFalse(st.has_path(\'/barney\'))\n-        self.assertFalse(st.has_path(\'/fred\'))\n-        self.assertListEqual(st.redirects(\'/wilma\'), [])\n-        self.assertNotIn(\'/fred\', st)\n-        self.assertNotIn(\'/barney\', st)\n+        st.add("/fred", "/barney")\n+        st.add("/barney", "/wilma")\n+        st.destroy("/wilma")\n+        self.assertFalse(st.has_path("/barney"))\n+        self.assertFalse(st.has_path("/fred"))\n+        self.assertListEqual(st.redirects("/wilma"), [])\n+        self.assertNotIn("/fred", st)\n+        self.assertNotIn("/barney", st)\n \n     def test_storage_iterator(self):\n         # We can get an iterator over all existing paths\n@@ -290,13 +288,13 @@ def test_storage_iterator(self):\n         self.assertListEqual(sorted(iter(st)), [])\n \n         # Add one\n-        st.add(\'/baz\', \'/bar\')\n-        self.assertListEqual(sorted(iter(st)), [\'/baz\'])\n+        st.add("/baz", "/bar")\n+        self.assertListEqual(sorted(iter(st)), ["/baz"])\n \n         # Now add some more\n-        st.add(\'/foo\', \'/bar\')\n-        st.add(\'/barney\', \'/wilma\')\n-        self.assertListEqual(sorted(st), [\'/barney\', \'/baz\', \'/foo\'])\n+        st.add("/foo", "/bar")\n+        st.add("/barney", "/wilma")\n+        self.assertListEqual(sorted(st), ["/barney", "/baz", "/foo"])\n \n     def test_storage_len(self):\n         # We can get the length of the storage (number of old paths).\n@@ -304,181 +302,177 @@ def test_storage_len(self):\n         self.assertEqual(len(st), 0)\n \n         # Add one\n-        st[\'/baz\'] = \'/bar\'\n+        st["/baz"] = "/bar"\n         self.assertEqual(len(st), 1)\n \n         # Now add some more\n-        st[\'/foo\'] = \'/bar\'\n-        st[\'/barney\'] = \'/wilma\'\n+        st["/foo"] = "/bar"\n+        st["/barney"] = "/wilma"\n         self.assertEqual(len(st), 3)\n \n     def test_storage_no_circular(self):\n         # Circular references are ignored\n         st = RedirectionStorage()\n-        st.add(\'/circle\', \'/circle\')\n-        self.assertFalse(st.has_path(\'/circle\'))\n-        self.assertEqual(st.get(\'/circle\', \'_marker_\'), \'_marker_\')\n-        self.assertListEqual(st.redirects(\'/circle\'), [])\n-        self.assertNotIn(\'/circle\', st)\n+        st.add("/circle", "/circle")\n+        self.assertFalse(st.has_path("/circle"))\n+        self.assertEqual(st.get("/circle", "_marker_"), "_marker_")\n+        self.assertListEqual(st.redirects("/circle"), [])\n+        self.assertNotIn("/circle", st)\n \n     def test_storage_three_step_circular_rename(self):\n         # What about three step circular rename ?\n         st = RedirectionStorage()\n \n         # Add first redirect.\n-        st.add(\'first\', \'second\')\n+        st.add("first", "second")\n \n         # There is only one redirect.\n \n-        self.assertEqual(st.get(\'first\'), \'second\')\n-        self.assertIsNone(st.get(\'second\'))\n-        self.assertIsNone(st.get(\'third\'))\n+        self.assertEqual(st.get("first"), "second")\n+        self.assertIsNone(st.get("second"))\n+        self.assertIsNone(st.get("third"))\n \n         # There is one back reference.\n \n-        self.assertListEqual(st.redirects(\'first\'), [])\n-        self.assertListEqual(st.redirects(\'second\'), [\'first\'])\n-        self.assertListEqual(st.redirects(\'third\'), [])\n+        self.assertListEqual(st.redirects("first"), [])\n+        self.assertListEqual(st.redirects("second"), ["first"])\n+        self.assertListEqual(st.redirects("third"), [])\n \n         # Add second redirect.\n-        st.add(\'second\', \'third\')\n+        st.add("second", "third")\n \n         # There are now two.\n \n-        self.assertEqual(st.get(\'first\'), \'third\')\n-        self.assertEqual(st.get(\'second\'), \'third\')\n-        self.assertIsNone(st.get(\'third\'))\n+        self.assertEqual(st.get("first"), "third")\n+        self.assertEqual(st.get("second"), "third")\n+        self.assertIsNone(st.get("third"))\n \n         # There are two back references as well.\n-        self.assertListEqual(st.redirects(\'first\'), [])\n-        self.assertListEqual(st.redirects(\'second\'), [])\n-        self.assertListEqual(st.redirects(\'third\'), [\'first\', \'second\'])\n+        self.assertListEqual(st.redirects("first"), [])\n+        self.assertListEqual(st.redirects("second"), [])\n+        self.assertListEqual(st.redirects("third"), ["first", "second"])\n \n         # Add third redirect, CIRCULAR.\n-        st.add(\'third\', \'first\')\n+        st.add("third", "first")\n \n         # There are still only two redirects.\n-        self.assertIsNone(st.get(\'first\'))\n-        self.assertEqual(st.get(\'second\'), \'first\')\n-        self.assertEqual(st.get(\'third\'), \'first\')\n-        self.assertNotIn(\'first\', st)\n-        self.assertIn(\'second\', st)\n-        self.assertIn(\'third\', st)\n+        self.assertIsNone(st.get("first"))\n+        self.assertEqual(st.get("second"), "first")\n+        self.assertEqual(st.get("third"), "first")\n+        self.assertNotIn("first", st)\n+        self.assertIn("second", st)\n+        self.assertIn("third", st)\n \n         # And same for the back references.\n-        self.assertListEqual(st.redirects(\'first\'), [\'second\', \'third\'])\n-        self.assertListEqual(st.redirects(\'second\'), [])\n-        self.assertListEqual(st.redirects(\'third\'), [])\n+        self.assertListEqual(st.redirects("first"), ["second", "third"])\n+        self.assertListEqual(st.redirects("second"), [])\n+        self.assertListEqual(st.redirects("third"), [])\n \n     def test_storage_non_string_path_fails(self):\n         st = RedirectionStorage()\n         with self.assertRaises(AttributeError):\n-            st[0] = \'/bar\'\n+            st[0] = "/bar"\n         with self.assertRaises(AttributeError):\n-            st[\'/foo\'] = 0\n+            st["/foo"] = 0\n \n     def test_storage_update_paths(self):\n         st = RedirectionStorage()\n         info = {}\n         time1 = DateTime()\n         for i in range(10):\n-            info[\'/old/{0}\'.format(i)] = \'/new/{0}\'.format(i)\n+            info["/old/{0}".format(i)] = "/new/{0}".format(i)\n         st.update(info)\n         time2 = DateTime()\n         self.assertEqual(len(st), 10)\n-        self.assertEqual(st.get(\'/old/0\'), \'/new/0\')\n-        self.assertEqual(st.get(\'/old/1\'), \'/new/1\')\n-        self.assertTrue(time1 < st.get_full(\'/old/0\')[1] < time2)\n-        self.assertTrue(st.get_full(\'/old/0\')[2])\n+        self.assertEqual(st.get("/old/0"), "/new/0")\n+        self.assertEqual(st.get("/old/1"), "/new/1")\n+        self.assertTrue(time1 < st.get_full("/old/0")[1] < time2)\n+        self.assertTrue(st.get_full("/old/0")[2])\n \n     def test_storage_update_tuple(self):\n         st = RedirectionStorage()\n         info = {}\n         for i in range(10):\n-            info[\'/old/{0}\'.format(i)] = (\n-                \'/new/{0}\'.format(i),\n+            info["/old/{0}".format(i)] = (\n+                "/new/{0}".format(i),\n                 DateTime(),\n                 False,\n             )\n         st.update(info)\n-        self.assertEqual(st.get(\'/old/0\'), \'/new/0\')\n-        self.assertEqual(st.get(\'/old/1\'), \'/new/1\')\n-        self.assertEqual(st.get_full(\'/old/0\'), info[\'/old/0\'])\n+        self.assertEqual(st.get("/old/0"), "/new/0")\n+        self.assertEqual(st.get("/old/1"), "/new/1")\n+        self.assertEqual(st.get_full("/old/0"), info["/old/0"])\n \n     def test_storage_update_keeps_info(self):\n         st = RedirectionStorage()\n         info = {}\n         time1 = DateTime()\n         time2 = DateTime()\n-        info[\'/old/1\'] = (\'/new\', time1, False)\n-        info[\'/old/2\'] = (\'/new\', time2, True)\n+        info["/old/1"] = ("/new", time1, False)\n+        info["/old/2"] = ("/new", time2, True)\n         st.update(info)\n         self.assertEqual(len(st), 2)\n-        self.assertEqual(st.get(\'/old/1\'), \'/new\')\n-        self.assertEqual(st.get(\'/old/2\'), \'/new\')\n-        self.assertListEqual(\n-            sorted(st.redirects(\'/new\')), [\'/old/1\', \'/old/2\']\n-        )\n-        self.assertEqual(st.get_full(\'/old/1\'), info[\'/old/1\'])\n-        self.assertEqual(st.get_full(\'/old/2\'), info[\'/old/2\'])\n+        self.assertEqual(st.get("/old/1"), "/new")\n+        self.assertEqual(st.get("/old/2"), "/new")\n+        self.assertListEqual(sorted(st.redirects("/new")), ["/old/1", "/old/2"])\n+        self.assertEqual(st.get_full("/old/1"), info["/old/1"])\n+        self.assertEqual(st.get_full("/old/2"), info["/old/2"])\n         # New info\n-        del info[\'/old/1\']\n+        del info["/old/1"]\n         time3 = DateTime()\n-        info[\'/old/2\'] = (\'/new/2\', time2, False)\n-        info[\'/old/3\'] = (\'/new\', time3, True)\n+        info["/old/2"] = ("/new/2", time2, False)\n+        info["/old/3"] = ("/new", time3, True)\n         st.update(info)\n         self.assertEqual(len(st), 3)\n-        self.assertEqual(st.get(\'/old/1\'), \'/new\')\n-        self.assertEqual(st.get(\'/old/2\'), \'/new/2\')\n-        self.assertEqual(st.get(\'/old/3\'), \'/new\')\n-        self.assertListEqual(\n-            sorted(st.redirects(\'/new\')), [\'/old/1\', \'/old/3\']\n-        )\n-        self.assertListEqual(sorted(st.redirects(\'/new/2\')), [\'/old/2\'])\n-        self.assertEqual(st.get_full(\'/old/2\'), info[\'/old/2\'])\n-        self.assertEqual(st.get_full(\'/old/3\'), info[\'/old/3\'])\n+        self.assertEqual(st.get("/old/1"), "/new")\n+        self.assertEqual(st.get("/old/2"), "/new/2")\n+        self.assertEqual(st.get("/old/3"), "/new")\n+        self.assertListEqual(sorted(st.redirects("/new")), ["/old/1", "/old/3"])\n+        self.assertListEqual(sorted(st.redirects("/new/2")), ["/old/2"])\n+        self.assertEqual(st.get_full("/old/2"), info["/old/2"])\n+        self.assertEqual(st.get_full("/old/3"), info["/old/3"])\n \n     def test_storage_update_mixed(self):\n         st = RedirectionStorage()\n         info = {}\n         time1 = DateTime()\n         for i in range(10):\n-            info[\'/old/{0}\'.format(i)] = \'/new/{0}\'.format(i)\n+            info["/old/{0}".format(i)] = "/new/{0}".format(i)\n         for i in range(10, 20):\n-            info[\'/old/{0}\'.format(i)] = (\n-                \'/new/{0}\'.format(i),\n+            info["/old/{0}".format(i)] = (\n+                "/new/{0}".format(i),\n                 DateTime(),\n                 False,\n             )\n         for i in range(20, 30):\n-            info[\'/old/{0}\'.format(i)] = (\'/new/{0}\'.format(i), None, True)\n+            info["/old/{0}".format(i)] = ("/new/{0}".format(i), None, True)\n         st.update(info)\n         time2 = DateTime()\n         self.assertEqual(len(st), 30)\n-        self.assertEqual(st.get(\'/old/0\'), \'/new/0\')\n-        self.assertEqual(st.get(\'/old/1\'), \'/new/1\')\n-        self.assertTrue(time1 < st.get_full(\'/old/0\')[1] < time2)\n-        self.assertTrue(st.get_full(\'/old/0\')[2])\n-        self.assertEqual(st.get(\'/old/10\'), \'/new/10\')\n-        self.assertEqual(st.get(\'/old/11\'), \'/new/11\')\n-        self.assertEqual(st.get_full(\'/old/10\'), info[\'/old/10\'])\n-        self.assertEqual(st.get(\'/old/20\'), \'/new/20\')\n-        self.assertEqual(st.get(\'/old/21\'), \'/new/21\')\n-        self.assertTrue(time1 < st.get_full(\'/old/20\')[1] < time2)\n-        self.assertTrue(st.get_full(\'/old/20\')[2])\n+        self.assertEqual(st.get("/old/0"), "/new/0")\n+        self.assertEqual(st.get("/old/1"), "/new/1")\n+        self.assertTrue(time1 < st.get_full("/old/0")[1] < time2)\n+        self.assertTrue(st.get_full("/old/0")[2])\n+        self.assertEqual(st.get("/old/10"), "/new/10")\n+        self.assertEqual(st.get("/old/11"), "/new/11")\n+        self.assertEqual(st.get_full("/old/10"), info["/old/10"])\n+        self.assertEqual(st.get("/old/20"), "/new/20")\n+        self.assertEqual(st.get("/old/21"), "/new/21")\n+        self.assertTrue(time1 < st.get_full("/old/20")[1] < time2)\n+        self.assertTrue(st.get_full("/old/20")[2])\n         # Update again with the same info.\n         # This may set new dates.\n         st.update(info)\n         time3 = DateTime()\n         self.assertEqual(len(st), 30)\n-        self.assertEqual(st.get(\'/old/0\'), \'/new/0\')\n-        self.assertTrue(time2 < st.get_full(\'/old/0\')[1] < time3)\n-        self.assertTrue(st.get_full(\'/old/0\')[2])\n-        self.assertEqual(st.get(\'/old/10\'), \'/new/10\')\n-        self.assertEqual(st.get_full(\'/old/10\'), info[\'/old/10\'])\n-        self.assertEqual(st.get(\'/old/20\'), \'/new/20\')\n-        self.assertTrue(time2 < st.get_full(\'/old/20\')[1] < time3)\n-        self.assertTrue(st.get_full(\'/old/20\')[2])\n+        self.assertEqual(st.get("/old/0"), "/new/0")\n+        self.assertTrue(time2 < st.get_full("/old/0")[1] < time3)\n+        self.assertTrue(st.get_full("/old/0")[2])\n+        self.assertEqual(st.get("/old/10"), "/new/10")\n+        self.assertEqual(st.get_full("/old/10"), info["/old/10"])\n+        self.assertEqual(st.get("/old/20"), "/new/20")\n+        self.assertTrue(time2 < st.get_full("/old/20")[1] < time3)\n+        self.assertTrue(st.get_full("/old/20")[2])\n \n     def test_rebuild(self):\n         # Rebuild the internal information.\n@@ -488,16 +482,16 @@ def test_rebuild(self):\n         # Should run fine on an empty storage.\n         st._rebuild()\n         # Set internals directly.\n-        st._paths[\'/old\'] = \'/new\'\n-        st._paths[\'/older\'] = \'/new\'\n-        st._paths[\'/first\'] = \'/second\'\n-        st._rpaths[\'/unused\'] = \'/unknown\'\n+        st._paths["/old"] = "/new"\n+        st._paths["/older"] = "/new"\n+        st._paths["/first"] = "/second"\n+        st._rpaths["/unused"] = "/unknown"\n         # Add some bad redirects, which should have been updated to point to /new.\n-        st._paths[\'/bad\'] = \'/old\'\n-        st._paths[\'/worse\'] = \'/old\'\n-        st._paths[\'/worst\'] = \'/worse\'\n-        self.assertIsInstance(st._paths[\'/old\'], str)\n-        self.assertEqual(st._paths[\'/old\'], \'/new\')\n+        st._paths["/bad"] = "/old"\n+        st._paths["/worse"] = "/old"\n+        st._paths["/worst"] = "/worse"\n+        self.assertIsInstance(st._paths["/old"], str)\n+        self.assertEqual(st._paths["/old"], "/new")\n         self.assertEqual(len(st._paths), 6)\n         self.assertEqual(len(st._rpaths), 1)\n \n@@ -508,15 +502,15 @@ def test_rebuild(self):\n         # The _paths should be tuples now.\n         self.assertEqual(\n             sorted(list(st._paths)),\n-            [\'/bad\', \'/first\', \'/old\', \'/older\', \'/worse\', \'/worst\'],\n+            ["/bad", "/first", "/old", "/older", "/worse", "/worst"],\n         )\n-        info = st._paths[\'/old\']\n+        info = st._paths["/old"]\n         self.assertIsInstance(info, tuple)\n         # The good ones were pointing to /new or /second, which should stay the same,\n         # but the bad ones have been updated to point to new as well.\n         self.assertSetEqual(\n             set([path[0] for path in st._paths.values()]),\n-            set([\'/new\', \'/second\']),\n+            set(["/new", "/second"]),\n         )\n         # Date should be set to the same for all.\n         self.assertIsInstance(info[1], DateTime)\n@@ -529,11 +523,11 @@ def test_rebuild(self):\n         self.assertEqual(info[2], True)\n         # _rpaths should be filled now with only the new one.\n         self.assertEqual(len(st._rpaths), 2)\n-        self.assertNotIn(\'/unused\', st._rpaths)\n-        self.assertEqual(sorted(list(st._rpaths[\'/second\'])), [\'/first\'])\n+        self.assertNotIn("/unused", st._rpaths)\n+        self.assertEqual(sorted(list(st._rpaths["/second"])), ["/first"])\n         self.assertEqual(\n-            sorted(list(st._rpaths[\'/new\'])),\n-            [\'/bad\', \'/old\', \'/older\', \'/worse\', \'/worst\'],\n+            sorted(list(st._rpaths["/new"])),\n+            ["/bad", "/old", "/older", "/worse", "/worst"],\n         )\n \n         # Rebuild again.  Nothing fundamentally should have changed,\n@@ -543,16 +537,12 @@ def test_rebuild(self):\n         st._rebuild()\n         self.assertIs(old_paths, st._paths)\n         self.assertIsNot(old_rpaths, st._rpaths)\n-        self.assertListEqual(\n-            sorted(list(old_rpaths)), sorted(list(st._rpaths))\n-        )\n+        self.assertListEqual(sorted(list(old_rpaths)), sorted(list(st._rpaths)))\n         self.assertSetEqual(\n             set([path[0] for path in st._paths.values()]),\n-            set([\'/new\', \'/second\']),\n+            set(["/new", "/second"]),\n         )\n         self.assertSetEqual(\n             set([path[1] for path in st._paths.values()]), set([new_time])\n         )\n-        self.assertSetEqual(\n-            set([path[2] for path in st._paths.values()]), set([True])\n-        )\n+        self.assertSetEqual(set([path[2] for path in st._paths.values()]), set([True]))\ndiff --git a/plone/app/redirector/tests/test_view.py b/plone/app/redirector/tests/test_view.py\nindex 295c8be..d153176 100644\n--- a/plone/app/redirector/tests/test_view.py\n+++ b/plone/app/redirector/tests/test_view.py\n@@ -8,199 +8,198 @@\n from Products.CMFPlone.interfaces import ISearchSchema\n from plone.registry.interfaces import IRegistry\n \n-from plone.app.redirector.testing import \\\n-    PLONE_APP_REDIRECTOR_INTEGRATION_TESTING\n+from plone.app.redirector.testing import PLONE_APP_REDIRECTOR_INTEGRATION_TESTING\n \n \n class TestRedirectorView(unittest.TestCase):\n-    """Ensure that the redirector view behaves as expected.\n-    """\n+    """Ensure that the redirector view behaves as expected."""\n \n     layer = PLONE_APP_REDIRECTOR_INTEGRATION_TESTING\n \n     def setUp(self):\n-        self.portal = self.layer[\'portal\']\n-        self.request = self.layer[\'request\']\n-        setRoles(self.portal, TEST_USER_ID, [\'Manager\'])\n+        self.portal = self.layer["portal"]\n+        self.request = self.layer["request"]\n+        setRoles(self.portal, TEST_USER_ID, ["Manager"])\n         self.portal.invokeFactory("Folder", "folder")\n         self.folder = self.portal.folder\n         self.storage = getUtility(IRedirectionStorage)\n \n-    def view(self, context, actual_url, query_string=\'\'):\n-        self.request[\'ACTUAL_URL\'] = actual_url\n-        self.request[\'QUERY_STRING\'] = query_string\n-        return getMultiAdapter((context, self.request),\n-            name=\'plone_redirector_view\')\n+    def view(self, context, actual_url, query_string=""):\n+        self.request["ACTUAL_URL"] = actual_url\n+        self.request["QUERY_STRING"] = query_string\n+        return getMultiAdapter((context, self.request), name="plone_redirector_view")\n \n     def test_attempt_redirect_with_known_url(self):\n-        fp = \'/\'.join(self.folder.getPhysicalPath())\n+        fp = "/".join(self.folder.getPhysicalPath())\n         fu = self.folder.absolute_url()\n-        self.storage.add(fp + \'/foo\', fp + \'/bar\')\n-        view = self.view(self.portal, fu + \'/foo\')\n+        self.storage.add(fp + "/foo", fp + "/bar")\n+        view = self.view(self.portal, fu + "/foo")\n         self.assertEqual(True, view.attempt_redirect())\n         self.assertEqual(302, self.request.response.getStatus())\n-        self.assertEqual(fu + \'/bar\',\n-            self.request.response.getHeader(\'location\'))\n+        self.assertEqual(fu + "/bar", self.request.response.getHeader("location"))\n \n     def test_attempt_redirect_with_known_url_and_template(self):\n-        fp = \'/\'.join(self.folder.getPhysicalPath())\n+        fp = "/".join(self.folder.getPhysicalPath())\n         fu = self.folder.absolute_url()\n-        self.storage.add(fp + \'/foo\', fp + \'/bar\')\n-        view = self.view(self.portal, fu + \'/foo/view\')\n+        self.storage.add(fp + "/foo", fp + "/bar")\n+        view = self.view(self.portal, fu + "/foo/view")\n         self.assertEqual(True, view.attempt_redirect())\n         self.assertEqual(302, self.request.response.getStatus())\n-        self.assertEqual(fu + \'/bar/view\',\n-            self.request.response.getHeader(\'location\'))\n+        self.assertEqual(fu + "/bar/view", self.request.response.getHeader("location"))\n \n     def test_attempt_redirect_with_known_url_and_view_with_part(self):\n-        fp = \'/\'.join(self.folder.getPhysicalPath())\n+        fp = "/".join(self.folder.getPhysicalPath())\n         fu = self.folder.absolute_url()\n-        self.storage.add(fp + \'/foo\', fp + \'/bar\')\n-        view = self.view(self.portal, fu + \'/foo/@@view/part\')\n+        self.storage.add(fp + "/foo", fp + "/bar")\n+        view = self.view(self.portal, fu + "/foo/@@view/part")\n         self.assertEqual(True, view.attempt_redirect())\n         self.assertEqual(302, self.request.response.getStatus())\n-        self.assertEqual(fu + \'/bar/@@view/part\',\n-            self.request.response.getHeader(\'location\'))\n+        self.assertEqual(\n+            fu + "/bar/@@view/part", self.request.response.getHeader("location")\n+        )\n \n     def test_attempt_redirect_with_unknown_url(self):\n         fu = self.folder.absolute_url()\n-        view = self.view(self.portal, fu + \'/foo\')\n+        view = self.view(self.portal, fu + "/foo")\n         self.assertEqual(False, view.attempt_redirect())\n         self.assertNotEqual(302, self.request.response.getStatus())\n \n     def test_attempt_redirect_with_unknown_url_with_illegal_characters(self):\n         fu = self.folder.absolute_url()\n-        view = self.view(self.portal, fu + \'+L\xc3\x83\xc2\xa4nder\')\n+        view = self.view(self.portal, fu + "+L\xc3\x83\xc2\xa4nder")\n         self.assertEqual(False, view.attempt_redirect())\n         self.assertNotEqual(302, self.request.response.getStatus())\n \n     def test_attempt_redirect_with_quoted_url(self):\n-        fp = \'/\'.join(self.folder.getPhysicalPath())\n+        fp = "/".join(self.folder.getPhysicalPath())\n         fu = self.folder.absolute_url()\n-        self.storage.add(fp + \'/foo\', fp + \'/bar\')\n-        view = self.view(self.portal, fu + \'/foo/baz%20quux\')\n+        self.storage.add(fp + "/foo", fp + "/bar")\n+        view = self.view(self.portal, fu + "/foo/baz%20quux")\n         self.assertEqual(True, view.attempt_redirect())\n         self.assertEqual(302, self.request.response.getStatus())\n-        self.assertEqual(fu + \'/bar/baz%20quux\',\n-            self.request.response.getHeader(\'location\'))\n+        self.assertEqual(\n+            fu + "/bar/baz%20quux", self.request.response.getHeader("location")\n+        )\n \n     def test_attempt_redirect_with_query_string(self):\n-        fp = \'/\'.join(self.folder.getPhysicalPath())\n+        fp = "/".join(self.folder.getPhysicalPath())\n         fu = self.folder.absolute_url()\n-        self.storage.add(fp + \'/foo?blah=blah\', fp + \'/bar\')\n-        view = self.view(self.portal, fu + \'/foo\', \'blah=blah\')\n+        self.storage.add(fp + "/foo?blah=blah", fp + "/bar")\n+        view = self.view(self.portal, fu + "/foo", "blah=blah")\n         self.assertEqual(True, view.attempt_redirect())\n         self.assertEqual(302, self.request.response.getStatus())\n-        self.assertEqual(fu + \'/bar\',\n-            self.request.response.getHeader(\'location\'))\n+        self.assertEqual(fu + "/bar", self.request.response.getHeader("location"))\n \n     def test_attempt_redirect_appending_query_string(self):\n-        fp = \'/\'.join(self.folder.getPhysicalPath())\n+        fp = "/".join(self.folder.getPhysicalPath())\n         fu = self.folder.absolute_url()\n-        self.storage.add(fp + \'/foo\', fp + \'/bar\')\n-        view = self.view(self.portal, fu + \'/foo\', \'blah=blah\')\n+        self.storage.add(fp + "/foo", fp + "/bar")\n+        view = self.view(self.portal, fu + "/foo", "blah=blah")\n         self.assertEqual(True, view.attempt_redirect())\n         self.assertEqual(302, self.request.response.getStatus())\n-        self.assertEqual(fu + \'/bar?blah=blah\',\n-            self.request.response.getHeader(\'location\'))\n+        self.assertEqual(\n+            fu + "/bar?blah=blah", self.request.response.getHeader("location")\n+        )\n \n     def test_attempt_redirect_with_external_url(self):\n-        fp = \'/\'.join(self.folder.getPhysicalPath())\n+        fp = "/".join(self.folder.getPhysicalPath())\n         fu = self.folder.absolute_url()\n-        self.storage.add(fp + \'/foo\',\n-                         \'http://otherhost\' + fp + \'/bar%20qux corge\')\n-        view = self.view(self.portal, fu + \'/foo\')\n+        self.storage.add(fp + "/foo", "http://otherhost" + fp + "/bar%20qux corge")\n+        view = self.view(self.portal, fu + "/foo")\n         self.assertEqual(True, view.attempt_redirect())\n         self.assertEqual(302, self.request.response.getStatus())\n-        self.assertEqual(\'http://otherhost\' + fp + \'/bar%20qux%20corge\',\n-            self.request.response.getHeader(\'location\'))\n+        self.assertEqual(\n+            "http://otherhost" + fp + "/bar%20qux%20corge",\n+            self.request.response.getHeader("location"),\n+        )\n \n     def test_find_first_parent_found_leaf(self):\n-        self.folder.invokeFactory(\'Folder\', \'f1\')\n+        self.folder.invokeFactory("Folder", "f1")\n         fu = self.folder.absolute_url()\n-        view = self.view(self.portal, fu + \'/f1/p1\')\n+        view = self.view(self.portal, fu + "/f1/p1")\n         obj = view.find_first_parent()\n-        self.assertEqual(fu + \'/f1\', obj.absolute_url())\n+        self.assertEqual(fu + "/f1", obj.absolute_url())\n \n     def test_find_first_parent_found_node(self):\n-        self.folder.invokeFactory(\'Folder\', \'f1\')\n+        self.folder.invokeFactory("Folder", "f1")\n         fu = self.folder.absolute_url()\n-        view = self.view(self.portal, fu + \'/f1/p1/p2\')\n+        view = self.view(self.portal, fu + "/f1/p1/p2")\n         obj = view.find_first_parent()\n-        self.assertEqual(fu + \'/f1\', obj.absolute_url())\n+        self.assertEqual(fu + "/f1", obj.absolute_url())\n \n     def test_find_first_parent_not_found(self):\n-        view = self.view(self.portal, \'/foo/f1/p1/p2\')\n+        view = self.view(self.portal, "/foo/f1/p1/p2")\n         self.assertEqual(None, view.find_first_parent())\n \n     def test_find_first_parent_not_viewable(self):\n         view = self.view(\n             self.portal,\n-            self.portal.absolute_url() + \'/portal_css/Plone Default/gone.css\')\n+            self.portal.absolute_url() + "/portal_css/Plone Default/gone.css",\n+        )\n         self.assertEqual(None, view.find_first_parent())\n \n     def test_search_leaf(self):\n-        self.folder.invokeFactory(\'Folder\', \'f1\')\n-        self.folder.invokeFactory(\'Folder\', \'f2\')\n-        self.folder.f1.invokeFactory(\'Document\', \'p1\')\n-        self.folder.f1.invokeFactory(\'Document\', \'p2\')\n+        self.folder.invokeFactory("Folder", "f1")\n+        self.folder.invokeFactory("Folder", "f2")\n+        self.folder.f1.invokeFactory("Document", "p1")\n+        self.folder.f1.invokeFactory("Document", "p2")\n         fu = self.folder.absolute_url()\n-        view = self.view(self.portal, fu + \'/f2/p1\')\n+        view = self.view(self.portal, fu + "/f2/p1")\n         urls = sorted([b.getURL() for b in view.search_for_similar()])\n         self.assertEqual(1, len(urls))\n-        self.assertEqual(fu + \'/f1/p1\', urls[0])\n+        self.assertEqual(fu + "/f1/p1", urls[0])\n \n     def test_search_ignore_ids(self):\n-        self.folder.invokeFactory(\'Folder\', \'f1\')\n-        self.folder.invokeFactory(\'Folder\', \'f2\')\n-        self.folder.f1.invokeFactory(\'Document\', \'p1\')\n-        self.folder.f1.invokeFactory(\'Document\', \'p2\')\n-        self.folder.f1.invokeFactory(\'Document\', \'p3\', title=\'view\')\n+        self.folder.invokeFactory("Folder", "f1")\n+        self.folder.invokeFactory("Folder", "f2")\n+        self.folder.f1.invokeFactory("Document", "p1")\n+        self.folder.f1.invokeFactory("Document", "p2")\n+        self.folder.f1.invokeFactory("Document", "p3", title="view")\n         fu = self.folder.absolute_url()\n-        view = self.view(self.portal, fu + \'/f2/p1/view\')\n+        view = self.view(self.portal, fu + "/f2/p1/view")\n         urls = sorted([b.getURL() for b in view.search_for_similar()])\n         self.assertEqual(1, len(urls))\n-        self.assertEqual(fu + \'/f1/p1\', urls[0])\n+        self.assertEqual(fu + "/f1/p1", urls[0])\n \n     def test_search_node(self):\n-        self.folder.invokeFactory(\'Folder\', \'f1\')\n-        self.folder.invokeFactory(\'Folder\', \'f2\')\n-        self.folder.f1.invokeFactory(\'Document\', \'p1\')\n-        self.folder.f1.invokeFactory(\'Document\', \'p2\')\n+        self.folder.invokeFactory("Folder", "f1")\n+        self.folder.invokeFactory("Folder", "f2")\n+        self.folder.f1.invokeFactory("Document", "p1")\n+        self.folder.f1.invokeFactory("Document", "p2")\n         fu = self.folder.absolute_url()\n-        view = self.view(self.portal, fu + \'/f2/p1/f3\')\n+        view = self.view(self.portal, fu + "/f2/p1/f3")\n         urls = sorted([b.getURL() for b in view.search_for_similar()])\n         self.assertEqual(1, len(urls))\n-        self.assertEqual(fu + \'/f1/p1\', urls[0])\n+        self.assertEqual(fu + "/f1/p1", urls[0])\n \n     def test_search_parens(self):\n-        self.folder.invokeFactory(\'Folder\', \'f1\')\n-        self.folder.invokeFactory(\'Folder\', \'f2\')\n-        self.folder.f1.invokeFactory(\'Document\', \'p1\')\n-        self.folder.f1.invokeFactory(\'Document\', \'p2\')\n+        self.folder.invokeFactory("Folder", "f1")\n+        self.folder.invokeFactory("Folder", "f2")\n+        self.folder.f1.invokeFactory("Document", "p1")\n+        self.folder.f1.invokeFactory("Document", "p2")\n         fu = self.folder.absolute_url()\n-        view = self.view(self.portal, fu + \'/f2/p1/f3(\')\n+        view = self.view(self.portal, fu + "/f2/p1/f3(")\n         urls = sorted([b.getURL() for b in view.search_for_similar()])\n         self.assertEqual(1, len(urls))\n-        self.assertEqual(fu + \'/f1/p1\', urls[0])\n+        self.assertEqual(fu + "/f1/p1", urls[0])\n \n     def test_search_query_parser_error(self):\n-        view = self.view(self.portal, self.portal.absolute_url() + \'/&\')\n+        view = self.view(self.portal, self.portal.absolute_url() + "/&")\n         try:\n             urls = view.search_for_similar()\n         except:\n-            self.fail(\'Query parsing error was not handled.\')\n+            self.fail("Query parsing error was not handled.")\n \n     def test_search_blacklisted(self):\n-        self.folder.invokeFactory(\'Folder\', \'f1\')\n-        self.folder.invokeFactory(\'Folder\', \'f2\')\n-        self.folder.f1.invokeFactory(\'Document\', \'p1\')\n-        self.folder.f1.invokeFactory(\'Document\', \'p2\')\n+        self.folder.invokeFactory("Folder", "f1")\n+        self.folder.invokeFactory("Folder", "f2")\n+        self.folder.f1.invokeFactory("Document", "p1")\n+        self.folder.f1.invokeFactory("Document", "p2")\n         fu = self.folder.absolute_url()\n         registry = getUtility(IRegistry)\n         settings = registry.forInterface(ISearchSchema, prefix="plone")\n-        settings.types_not_searched = (\'Document\',)\n-        view = self.view(self.portal, fu + \'/f2/p1\')\n+        settings.types_not_searched = ("Document",)\n+        view = self.view(self.portal, fu + "/f2/p1")\n         urls = sorted([b.getURL() for b in view.search_for_similar()])\n         self.assertEqual(1, len(urls))\n-        self.assertEqual(fu + \'/f2\', urls[0])\n+        self.assertEqual(fu + "/f2", urls[0])\n'

Repository: plone.app.redirector


Branch: refs/heads/master
Date: 2022-04-07T17:48:36+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.app.redirector/commit/bf80fa8f1530898f7199ebdd553ad9de4356814a

isort

Files changed:
M plone/app/redirector/browser.py
M plone/app/redirector/interfaces.py
M plone/app/redirector/policy.py
M plone/app/redirector/storage.py
M plone/app/redirector/subscribers.py
M plone/app/redirector/testing.py
M plone/app/redirector/tests/test_browser.py
M plone/app/redirector/tests/test_events.py
M plone/app/redirector/tests/test_setup.py
M plone/app/redirector/tests/test_view.py

b'diff --git a/plone/app/redirector/browser.py b/plone/app/redirector/browser.py\nindex 29b40f4..e794c56 100644\n--- a/plone/app/redirector/browser.py\n+++ b/plone/app/redirector/browser.py\n@@ -1,22 +1,21 @@\n # -*- coding: utf-8 -*-\n \n-from zope.interface import implementer\n-from zope.component import queryUtility, getMultiAdapter\n-\n-from Acquisition import aq_base, aq_inner\n-from Products.Five.browser import BrowserView\n-from Products.CMFCore.utils import getToolByName\n-from Products.ZCTextIndex.ParseTree import QueryError, ParseError\n-\n+from Acquisition import aq_base\n+from Acquisition import aq_inner\n from plone.app.redirector.interfaces import IFourOhFourView\n-from plone.app.redirector.interfaces import IRedirectionStorage\n from plone.app.redirector.interfaces import IRedirectionPolicy\n-\n+from plone.app.redirector.interfaces import IRedirectionStorage\n from plone.memoize.instance import memoize\n-\n+from Products.CMFCore.utils import getToolByName\n+from Products.Five.browser import BrowserView\n+from Products.ZCTextIndex.ParseTree import ParseError\n+from Products.ZCTextIndex.ParseTree import QueryError\n from six.moves import urllib\n from six.moves.urllib.parse import quote\n from six.moves.urllib.parse import unquote\n+from zope.component import getMultiAdapter\n+from zope.component import queryUtility\n+from zope.interface import implementer\n \n import logging\n \ndiff --git a/plone/app/redirector/interfaces.py b/plone/app/redirector/interfaces.py\nindex 1e1ad8f..d6f6089 100644\n--- a/plone/app/redirector/interfaces.py\n+++ b/plone/app/redirector/interfaces.py\n@@ -1,5 +1,6 @@\n # -*- coding: utf-8 -*-\n-from zope.interface import Interface, Attribute\n+from zope.interface import Attribute\n+from zope.interface import Interface\n \n \n class IRedirectionPolicy(Interface):\ndiff --git a/plone/app/redirector/policy.py b/plone/app/redirector/policy.py\nindex a6aa79c..9ccc7f6 100644\n--- a/plone/app/redirector/policy.py\n+++ b/plone/app/redirector/policy.py\n@@ -1,8 +1,8 @@\n # -*- coding: utf-8 -*-\n-from zope.interface import implementer, Interface\n-from zope.component import adapts\n-\n from plone.app.redirector.interfaces import IRedirectionPolicy\n+from zope.component import adapts\n+from zope.interface import implementer\n+from zope.interface import Interface\n \n \n @implementer(IRedirectionPolicy)\ndiff --git a/plone/app/redirector/storage.py b/plone/app/redirector/storage.py\nindex e3786a6..61df32f 100644\n--- a/plone/app/redirector/storage.py\n+++ b/plone/app/redirector/storage.py\n@@ -1,10 +1,10 @@\n # -*- coding: utf-8 -*-\n-from zope.interface import implementer\n-\n-from persistent import Persistent\n-from BTrees.OOBTree import OOBTree, OOSet\n+from BTrees.OOBTree import OOBTree\n+from BTrees.OOBTree import OOSet\n from DateTime import DateTime\n+from persistent import Persistent\n from plone.app.redirector.interfaces import IRedirectionStorage\n+from zope.interface import implementer\n \n \n _marker = object()\ndiff --git a/plone/app/redirector/subscribers.py b/plone/app/redirector/subscribers.py\nindex 0105c03..04cb5a2 100644\n--- a/plone/app/redirector/subscribers.py\n+++ b/plone/app/redirector/subscribers.py\n@@ -1,9 +1,8 @@\n # -*- coding: utf-8 -*-\n-from zope.component import queryUtility\n-from Products.CMFCore.utils import getToolByName\n-from plone.app.redirector.interfaces import IRedirectionStorage\n-\n from Acquisition import aq_base\n+from plone.app.redirector.interfaces import IRedirectionStorage\n+from Products.CMFCore.utils import getToolByName\n+from zope.component import queryUtility\n \n \n def objectMoved(obj, event):\ndiff --git a/plone/app/redirector/testing.py b/plone/app/redirector/testing.py\nindex 3cc7771..46ed08c 100644\n--- a/plone/app/redirector/testing.py\n+++ b/plone/app/redirector/testing.py\n@@ -1,9 +1,8 @@\n # -*- coding: utf-8 -*-\n from plone.app.contenttypes.testing import PLONE_APP_CONTENTTYPES_FIXTURE\n-from plone.app.testing import PloneSandboxLayer\n-from plone.app.testing import IntegrationTesting\n from plone.app.testing import FunctionalTesting\n-\n+from plone.app.testing import IntegrationTesting\n+from plone.app.testing import PloneSandboxLayer\n from zope.configuration import xmlconfig\n \n \ndiff --git a/plone/app/redirector/tests/test_browser.py b/plone/app/redirector/tests/test_browser.py\nindex 9a6992b..1a7ad3b 100644\n--- a/plone/app/redirector/tests/test_browser.py\n+++ b/plone/app/redirector/tests/test_browser.py\n@@ -1,8 +1,6 @@\n # -*- coding: utf-8 -*-\n from plone.app.redirector.interfaces import IRedirectionStorage\n-from plone.app.redirector.testing import (\n-    PLONE_APP_REDIRECTOR_FUNCTIONAL_TESTING,\n-)\n+from plone.app.redirector.testing import PLONE_APP_REDIRECTOR_FUNCTIONAL_TESTING\n from plone.app.testing import SITE_OWNER_NAME\n from plone.app.testing import SITE_OWNER_PASSWORD\n from plone.testing.z2 import Browser\ndiff --git a/plone/app/redirector/tests/test_events.py b/plone/app/redirector/tests/test_events.py\nindex 4e44b45..ba0b5d8 100644\n--- a/plone/app/redirector/tests/test_events.py\n+++ b/plone/app/redirector/tests/test_events.py\n@@ -1,12 +1,12 @@\n # -*- coding: utf-8 -*-\n-from plone.app.testing import TEST_USER_ID\n-from plone.app.testing import setRoles\n-import unittest\n-import transaction\n-\n-from zope.component import getUtility\n from plone.app.redirector.interfaces import IRedirectionStorage\n from plone.app.redirector.testing import PLONE_APP_REDIRECTOR_INTEGRATION_TESTING\n+from plone.app.testing import setRoles\n+from plone.app.testing import TEST_USER_ID\n+from zope.component import getUtility\n+\n+import transaction\n+import unittest\n \n \n class TestRedirectorEvents(unittest.TestCase):\ndiff --git a/plone/app/redirector/tests/test_setup.py b/plone/app/redirector/tests/test_setup.py\nindex 64ad331..4deb04c 100644\n--- a/plone/app/redirector/tests/test_setup.py\n+++ b/plone/app/redirector/tests/test_setup.py\n@@ -1,10 +1,9 @@\n # -*- coding: utf-8 -*-\n-import unittest\n-\n-from zope.component import queryUtility\n-\n from plone.app.redirector.interfaces import IRedirectionStorage\n from plone.app.redirector.testing import PLONE_APP_REDIRECTOR_INTEGRATION_TESTING\n+from zope.component import queryUtility\n+\n+import unittest\n \n \n class TestRedirectorSetup(unittest.TestCase):\ndiff --git a/plone/app/redirector/tests/test_view.py b/plone/app/redirector/tests/test_view.py\nindex d153176..47d4741 100644\n--- a/plone/app/redirector/tests/test_view.py\n+++ b/plone/app/redirector/tests/test_view.py\n@@ -1,14 +1,14 @@\n # -*- coding: utf-8 -*-\n-import unittest\n-from plone.app.testing import TEST_USER_ID\n-from plone.app.testing import setRoles\n-\n-from zope.component import getUtility, getMultiAdapter\n from plone.app.redirector.interfaces import IRedirectionStorage\n-from Products.CMFPlone.interfaces import ISearchSchema\n+from plone.app.redirector.testing import PLONE_APP_REDIRECTOR_INTEGRATION_TESTING\n+from plone.app.testing import setRoles\n+from plone.app.testing import TEST_USER_ID\n from plone.registry.interfaces import IRegistry\n+from Products.CMFPlone.interfaces import ISearchSchema\n+from zope.component import getMultiAdapter\n+from zope.component import getUtility\n \n-from plone.app.redirector.testing import PLONE_APP_REDIRECTOR_INTEGRATION_TESTING\n+import unittest\n \n \n class TestRedirectorView(unittest.TestCase):\n'

Repository: plone.app.redirector


Branch: refs/heads/master
Date: 2022-04-07T17:49:09+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.app.redirector/commit/42f4fe8d543a0b34524a7147143c1641cbffdbcb

pyupgrade

Files changed:
M plone/__init__.py
M plone/app/__init__.py
M plone/app/redirector/__init__.py
M plone/app/redirector/browser.py
M plone/app/redirector/interfaces.py
M plone/app/redirector/policy.py
M plone/app/redirector/storage.py
M plone/app/redirector/subscribers.py
M plone/app/redirector/testing.py
M plone/app/redirector/tests/__init__.py
M plone/app/redirector/tests/test_browser.py
M plone/app/redirector/tests/test_events.py
M plone/app/redirector/tests/test_performance.py
M plone/app/redirector/tests/test_setup.py
M plone/app/redirector/tests/test_storage.py
M plone/app/redirector/tests/test_view.py

b'diff --git a/plone/__init__.py b/plone/__init__.py\nindex ca12a73..05f0beb 100644\n--- a/plone/__init__.py\n+++ b/plone/__init__.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n # See http://peak.telecommunity.com/DevCenter/setuptools#namespace-packages\n try:\n     __import__("pkg_resources").declare_namespace(__name__)\ndiff --git a/plone/app/__init__.py b/plone/app/__init__.py\nindex ca12a73..05f0beb 100644\n--- a/plone/app/__init__.py\n+++ b/plone/app/__init__.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n # See http://peak.telecommunity.com/DevCenter/setuptools#namespace-packages\n try:\n     __import__("pkg_resources").declare_namespace(__name__)\ndiff --git a/plone/app/redirector/__init__.py b/plone/app/redirector/__init__.py\nindex ec51c5a..792d600 100644\n--- a/plone/app/redirector/__init__.py\n+++ b/plone/app/redirector/__init__.py\n@@ -1,2 +1 @@\n-# -*- coding: utf-8 -*-\n #\ndiff --git a/plone/app/redirector/browser.py b/plone/app/redirector/browser.py\nindex e794c56..ea21756 100644\n--- a/plone/app/redirector/browser.py\n+++ b/plone/app/redirector/browser.py\n@@ -1,5 +1,3 @@\n-# -*- coding: utf-8 -*-\n-\n from Acquisition import aq_base\n from Acquisition import aq_inner\n from plone.app.redirector.interfaces import IFourOhFourView\n@@ -47,7 +45,7 @@ def attempt_redirect(self):\n \n         query_string = self.request.QUERY_STRING\n         if query_string:\n-            new_path = storage.get("%s?%s" % (old_path, query_string))\n+            new_path = storage.get(f"{old_path}?{query_string}")\n             # if we matched on the query_string we don\'t want to include it\n             # in redirect\n             if new_path:\ndiff --git a/plone/app/redirector/interfaces.py b/plone/app/redirector/interfaces.py\nindex d6f6089..daf5baf 100644\n--- a/plone/app/redirector/interfaces.py\n+++ b/plone/app/redirector/interfaces.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from zope.interface import Attribute\n from zope.interface import Interface\n \ndiff --git a/plone/app/redirector/policy.py b/plone/app/redirector/policy.py\nindex 9ccc7f6..cb2e153 100644\n--- a/plone/app/redirector/policy.py\n+++ b/plone/app/redirector/policy.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.app.redirector.interfaces import IRedirectionPolicy\n from zope.component import adapts\n from zope.interface import implementer\n@@ -6,7 +5,7 @@\n \n \n @implementer(IRedirectionPolicy)\n-class RedirectionPolicy(object):\n+class RedirectionPolicy:\n     adapts(Interface)\n \n     def __init__(self, context):\ndiff --git a/plone/app/redirector/storage.py b/plone/app/redirector/storage.py\nindex 61df32f..50d97f0 100644\n--- a/plone/app/redirector/storage.py\n+++ b/plone/app/redirector/storage.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from BTrees.OOBTree import OOBTree\n from BTrees.OOBTree import OOSet\n from DateTime import DateTime\ndiff --git a/plone/app/redirector/subscribers.py b/plone/app/redirector/subscribers.py\nindex 04cb5a2..ccaa381 100644\n--- a/plone/app/redirector/subscribers.py\n+++ b/plone/app/redirector/subscribers.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from Acquisition import aq_base\n from plone.app.redirector.interfaces import IRedirectionStorage\n from Products.CMFCore.utils import getToolByName\n@@ -16,7 +15,7 @@ def objectMoved(obj, event):\n     ):\n         storage = queryUtility(IRedirectionStorage)\n         if storage is not None:\n-            old_path = "%s/%s" % (\n+            old_path = "{}/{}".format(\n                 "/".join(event.oldParent.getPhysicalPath()),\n                 event.oldName,\n             )\ndiff --git a/plone/app/redirector/testing.py b/plone/app/redirector/testing.py\nindex 46ed08c..f4af544 100644\n--- a/plone/app/redirector/testing.py\n+++ b/plone/app/redirector/testing.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.app.contenttypes.testing import PLONE_APP_CONTENTTYPES_FIXTURE\n from plone.app.testing import FunctionalTesting\n from plone.app.testing import IntegrationTesting\ndiff --git a/plone/app/redirector/tests/__init__.py b/plone/app/redirector/tests/__init__.py\nindex ec51c5a..792d600 100644\n--- a/plone/app/redirector/tests/__init__.py\n+++ b/plone/app/redirector/tests/__init__.py\n@@ -1,2 +1 @@\n-# -*- coding: utf-8 -*-\n #\ndiff --git a/plone/app/redirector/tests/test_browser.py b/plone/app/redirector/tests/test_browser.py\nindex 1a7ad3b..f3db724 100644\n--- a/plone/app/redirector/tests/test_browser.py\n+++ b/plone/app/redirector/tests/test_browser.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.app.redirector.interfaces import IRedirectionStorage\n from plone.app.redirector.testing import PLONE_APP_REDIRECTOR_FUNCTIONAL_TESTING\n from plone.app.testing import SITE_OWNER_NAME\n@@ -27,7 +26,7 @@ def setUp(self):\n         self.browser.handleErrors = False\n         self.browser.addHeader(\n             "Authorization",\n-            "Basic {0}:{1}".format(SITE_OWNER_NAME, SITE_OWNER_PASSWORD),\n+            f"Basic {SITE_OWNER_NAME}:{SITE_OWNER_PASSWORD}",\n         )\n         portal = self.layer["portal"]\n         self.portal_url = portal.absolute_url()\ndiff --git a/plone/app/redirector/tests/test_events.py b/plone/app/redirector/tests/test_events.py\nindex ba0b5d8..118aa43 100644\n--- a/plone/app/redirector/tests/test_events.py\n+++ b/plone/app/redirector/tests/test_events.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.app.redirector.interfaces import IRedirectionStorage\n from plone.app.redirector.testing import PLONE_APP_REDIRECTOR_INTEGRATION_TESTING\n from plone.app.testing import setRoles\ndiff --git a/plone/app/redirector/tests/test_performance.py b/plone/app/redirector/tests/test_performance.py\nindex bcd6844..3eee742 100644\n--- a/plone/app/redirector/tests/test_performance.py\n+++ b/plone/app/redirector/tests/test_performance.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from contextlib import contextmanager\n from plone.app.redirector.storage import RedirectionStorage\n from time import time\n@@ -26,9 +25,9 @@ def pretty_number(num):\n         return num\n     num = int(num / 1000)\n     if num < 1000:\n-        return "{0} thousand".format(num)\n+        return f"{num} thousand"\n     num = int(num / 1000)\n-    return "{0} million".format(num)\n+    return f"{num} million"\n \n \n class TestStoragePerformance(unittest.TestCase):\n@@ -47,12 +46,12 @@ def timeit(self, message, limit=0):\n         limit = max(limit, 0.3)\n         if total > limit:\n             self.fail(\n-                "{0} takes too long: {1:.2f} seconds (max {2})".format(\n+                "{} takes too long: {:.2f} seconds (max {})".format(\n                     message, total, limit\n                 )\n             )\n         elif VERBOSE:\n-            print("{0}: {1:.2f} seconds (max {2})".format(message, total, limit))\n+            print(f"{message}: {total:.2f} seconds (max {limit})")\n \n     def test_storage_performance(self):\n         """Test the performance of some of the code.\n@@ -79,11 +78,11 @@ def test_storage_performance(self):\n         # Take one tenth of the items at first.\n         num = max(int(NUMBER / 10), 1)\n         with self.timeit(\n-            "Inserting {0} individual items".format(pretty_number(num)),\n+            f"Inserting {pretty_number(num)} individual items",\n             num / 10000.0,\n         ):\n             for i in range(num):\n-                st["/old/{0}".format(i)] = "/new/{0}".format(i)\n+                st[f"/old/{i}"] = f"/new/{i}"\n \n         # I expected this to be almost instantaneous because we replace\n         # the data with new OOBTrees, but it still takes time:\n@@ -93,20 +92,20 @@ def test_storage_performance(self):\n \n         # Should be fairly quick.\n         with self.timeit(\n-            "Preparing {0} items for bulk import".format(pretty_number(NUMBER)),\n+            f"Preparing {pretty_number(NUMBER)} items for bulk import",\n             NUMBER / 100000.0,\n         ):\n-            info = {"/old/{0}".format(i): "/new/{0}".format(i) for i in range(NUMBER)}\n+            info = {f"/old/{i}": f"/new/{i}" for i in range(NUMBER)}\n \n         # Can take long.  But 10.000 per second should be no problem.\n         with self.timeit(\n-            "Inserting {0} prepared items in bulk".format(pretty_number(NUMBER)),\n+            f"Inserting {pretty_number(NUMBER)} prepared items in bulk",\n             NUMBER / 10000.0,\n         ):\n             # Prepare input:\n             info = {}\n             for i in range(NUMBER):\n-                info["/old/{0}".format(i)] = "/new/{0}".format(i)\n+                info[f"/old/{i}"] = f"/new/{i}"\n             st.update(info)\n \n         # Should be almost instantaneous.\ndiff --git a/plone/app/redirector/tests/test_setup.py b/plone/app/redirector/tests/test_setup.py\nindex 4deb04c..fa43a73 100644\n--- a/plone/app/redirector/tests/test_setup.py\n+++ b/plone/app/redirector/tests/test_setup.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.app.redirector.interfaces import IRedirectionStorage\n from plone.app.redirector.testing import PLONE_APP_REDIRECTOR_INTEGRATION_TESTING\n from zope.component import queryUtility\ndiff --git a/plone/app/redirector/tests/test_storage.py b/plone/app/redirector/tests/test_storage.py\nindex cc092df..74734bd 100644\n--- a/plone/app/redirector/tests/test_storage.py\n+++ b/plone/app/redirector/tests/test_storage.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from DateTime import DateTime\n from plone.app.redirector.storage import RedirectionStorage\n \n@@ -380,7 +379,7 @@ def test_storage_update_paths(self):\n         info = {}\n         time1 = DateTime()\n         for i in range(10):\n-            info["/old/{0}".format(i)] = "/new/{0}".format(i)\n+            info[f"/old/{i}"] = f"/new/{i}"\n         st.update(info)\n         time2 = DateTime()\n         self.assertEqual(len(st), 10)\n@@ -393,8 +392,8 @@ def test_storage_update_tuple(self):\n         st = RedirectionStorage()\n         info = {}\n         for i in range(10):\n-            info["/old/{0}".format(i)] = (\n-                "/new/{0}".format(i),\n+            info[f"/old/{i}"] = (\n+                f"/new/{i}",\n                 DateTime(),\n                 False,\n             )\n@@ -437,15 +436,15 @@ def test_storage_update_mixed(self):\n         info = {}\n         time1 = DateTime()\n         for i in range(10):\n-            info["/old/{0}".format(i)] = "/new/{0}".format(i)\n+            info[f"/old/{i}"] = f"/new/{i}"\n         for i in range(10, 20):\n-            info["/old/{0}".format(i)] = (\n-                "/new/{0}".format(i),\n+            info[f"/old/{i}"] = (\n+                f"/new/{i}",\n                 DateTime(),\n                 False,\n             )\n         for i in range(20, 30):\n-            info["/old/{0}".format(i)] = ("/new/{0}".format(i), None, True)\n+            info[f"/old/{i}"] = (f"/new/{i}", None, True)\n         st.update(info)\n         time2 = DateTime()\n         self.assertEqual(len(st), 30)\n@@ -509,15 +508,15 @@ def test_rebuild(self):\n         # The good ones were pointing to /new or /second, which should stay the same,\n         # but the bad ones have been updated to point to new as well.\n         self.assertSetEqual(\n-            set([path[0] for path in st._paths.values()]),\n-            set(["/new", "/second"]),\n+            {path[0] for path in st._paths.values()},\n+            {"/new", "/second"},\n         )\n         # Date should be set to the same for all.\n         self.assertIsInstance(info[1], DateTime)\n         new_time = info[1]\n         self.assertTrue(time1 < new_time < time2)\n         self.assertSetEqual(\n-            set([path[1] for path in st._paths.values()]), set([new_time])\n+            {path[1] for path in st._paths.values()}, {new_time}\n         )\n         # manual is set to True when migrating to tuples:\n         self.assertEqual(info[2], True)\n@@ -539,10 +538,10 @@ def test_rebuild(self):\n         self.assertIsNot(old_rpaths, st._rpaths)\n         self.assertListEqual(sorted(list(old_rpaths)), sorted(list(st._rpaths)))\n         self.assertSetEqual(\n-            set([path[0] for path in st._paths.values()]),\n-            set(["/new", "/second"]),\n+            {path[0] for path in st._paths.values()},\n+            {"/new", "/second"},\n         )\n         self.assertSetEqual(\n-            set([path[1] for path in st._paths.values()]), set([new_time])\n+            {path[1] for path in st._paths.values()}, {new_time}\n         )\n-        self.assertSetEqual(set([path[2] for path in st._paths.values()]), set([True]))\n+        self.assertSetEqual({path[2] for path in st._paths.values()}, {True})\ndiff --git a/plone/app/redirector/tests/test_view.py b/plone/app/redirector/tests/test_view.py\nindex 47d4741..2d89b65 100644\n--- a/plone/app/redirector/tests/test_view.py\n+++ b/plone/app/redirector/tests/test_view.py\n@@ -1,4 +1,3 @@\n-# -*- coding: utf-8 -*-\n from plone.app.redirector.interfaces import IRedirectionStorage\n from plone.app.redirector.testing import PLONE_APP_REDIRECTOR_INTEGRATION_TESTING\n from plone.app.testing import setRoles\n@@ -145,7 +144,7 @@ def test_search_leaf(self):\n         self.folder.f1.invokeFactory("Document", "p2")\n         fu = self.folder.absolute_url()\n         view = self.view(self.portal, fu + "/f2/p1")\n-        urls = sorted([b.getURL() for b in view.search_for_similar()])\n+        urls = sorted(b.getURL() for b in view.search_for_similar())\n         self.assertEqual(1, len(urls))\n         self.assertEqual(fu + "/f1/p1", urls[0])\n \n@@ -157,7 +156,7 @@ def test_search_ignore_ids(self):\n         self.folder.f1.invokeFactory("Document", "p3", title="view")\n         fu = self.folder.absolute_url()\n         view = self.view(self.portal, fu + "/f2/p1/view")\n-        urls = sorted([b.getURL() for b in view.search_for_similar()])\n+        urls = sorted(b.getURL() for b in view.search_for_similar())\n         self.assertEqual(1, len(urls))\n         self.assertEqual(fu + "/f1/p1", urls[0])\n \n@@ -168,7 +167,7 @@ def test_search_node(self):\n         self.folder.f1.invokeFactory("Document", "p2")\n         fu = self.folder.absolute_url()\n         view = self.view(self.portal, fu + "/f2/p1/f3")\n-        urls = sorted([b.getURL() for b in view.search_for_similar()])\n+        urls = sorted(b.getURL() for b in view.search_for_similar())\n         self.assertEqual(1, len(urls))\n         self.assertEqual(fu + "/f1/p1", urls[0])\n \n@@ -179,7 +178,7 @@ def test_search_parens(self):\n         self.folder.f1.invokeFactory("Document", "p2")\n         fu = self.folder.absolute_url()\n         view = self.view(self.portal, fu + "/f2/p1/f3(")\n-        urls = sorted([b.getURL() for b in view.search_for_similar()])\n+        urls = sorted(b.getURL() for b in view.search_for_similar())\n         self.assertEqual(1, len(urls))\n         self.assertEqual(fu + "/f1/p1", urls[0])\n \n@@ -200,6 +199,6 @@ def test_search_blacklisted(self):\n         settings = registry.forInterface(ISearchSchema, prefix="plone")\n         settings.types_not_searched = ("Document",)\n         view = self.view(self.portal, fu + "/f2/p1")\n-        urls = sorted([b.getURL() for b in view.search_for_similar()])\n+        urls = sorted(b.getURL() for b in view.search_for_similar())\n         self.assertEqual(1, len(urls))\n         self.assertEqual(fu + "/f2", urls[0])\n'

Repository: plone.app.redirector


Branch: refs/heads/master
Date: 2022-04-07T17:51:10+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.app.redirector/commit/9bcbb00c2fdbc7fd066de50b58bb6457d5fbc7c9

cleanup namespace declaration

Files changed:
M plone/__init__.py
M plone/app/__init__.py

b'diff --git a/plone/__init__.py b/plone/__init__.py\nindex 05f0beb..5284146 100644\n--- a/plone/__init__.py\n+++ b/plone/__init__.py\n@@ -1,7 +1 @@\n-# See http://peak.telecommunity.com/DevCenter/setuptools#namespace-packages\n-try:\n-    __import__("pkg_resources").declare_namespace(__name__)\n-except ImportError:\n-    from pkgutil import extend_path\n-\n-    __path__ = extend_path(__path__, __name__)\n+__import__("pkg_resources").declare_namespace(__name__)\ndiff --git a/plone/app/__init__.py b/plone/app/__init__.py\nindex 05f0beb..5284146 100644\n--- a/plone/app/__init__.py\n+++ b/plone/app/__init__.py\n@@ -1,7 +1 @@\n-# See http://peak.telecommunity.com/DevCenter/setuptools#namespace-packages\n-try:\n-    __import__("pkg_resources").declare_namespace(__name__)\n-except ImportError:\n-    from pkgutil import extend_path\n-\n-    __path__ = extend_path(__path__, __name__)\n+__import__("pkg_resources").declare_namespace(__name__)\n'

Repository: plone.app.redirector


Branch: refs/heads/master
Date: 2022-04-07T17:51:24+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.app.redirector/commit/7fc78a6f7ab331536fe2d007ed7421cf5d8a9565

remove Archetypes specific code

Files changed:
M plone/app/redirector/subscribers.py

b'diff --git a/plone/app/redirector/subscribers.py b/plone/app/redirector/subscribers.py\nindex ccaa381..061b072 100644\n--- a/plone/app/redirector/subscribers.py\n+++ b/plone/app/redirector/subscribers.py\n@@ -29,19 +29,6 @@ def objectMoved(obj, event):\n                 new_path_of_moved = "/".join(event.object.getPhysicalPath())\n                 old_path = old_path + new_path[len(new_path_of_moved) :]\n \n-            # XXX: Special case - don\'t remember anything happening inside portal_factory\n-            if "/portal_factory/" in old_path:\n-                return\n-\n-            # Special case: don\'t remember object when it was just created...\n-            putils = getToolByName(obj, "plone_utils")\n-            if putils is not None and putils.isIDAutoGenerated(event.oldName):\n-                request = getattr(obj, "REQUEST", None)\n-                if request is not None and "ACTUAL_URL" in request:\n-                    url = request["ACTUAL_URL"].split("/")\n-                    if "portal_factory" in url and event.oldName in url:\n-                        return\n-\n             storage.add(old_path, new_path)\n \n \n'

Repository: plone.app.redirector


Branch: refs/heads/master
Date: 2022-04-07T17:54:13+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.app.redirector/commit/ba6289780675a56b0bd30a29d8652f2ddb640247

one ZCML is enough

Files changed:
M plone/app/redirector/configure.zcml
D plone/app/redirector/events.zcml

b'diff --git a/plone/app/redirector/configure.zcml b/plone/app/redirector/configure.zcml\nindex fc1f992..d348758 100644\n--- a/plone/app/redirector/configure.zcml\n+++ b/plone/app/redirector/configure.zcml\n@@ -13,6 +13,18 @@\n         allowed_interface=".interfaces.IFourOhFourView"\n         />\n \n-    <include package="." file="events.zcml" />\n+    <!-- Remember the movements of CMF objects -->\n+    <subscriber\n+        for="Products.CMFCore.interfaces.IContentish\n+             zope.lifecycleevent.interfaces.IObjectMovedEvent"\n+        handler=".subscribers.objectMoved"\n+        />\n+\n+    <subscriber\n+        for="Products.CMFCore.interfaces.IContentish\n+             zope.lifecycleevent.interfaces.IObjectRemovedEvent"\n+        handler=".subscribers.objectRemoved"\n+        />\n+\n \n </configure>\ndiff --git a/plone/app/redirector/events.zcml b/plone/app/redirector/events.zcml\ndeleted file mode 100644\nindex 2266a1c..0000000\n--- a/plone/app/redirector/events.zcml\n+++ /dev/null\n@@ -1,17 +0,0 @@\n-<configure\n-   xmlns="http://namespaces.zope.org/zope">\n-\n-    <!-- Remember the movements of CMF objects -->\n-    <subscriber\n-        for="Products.CMFCore.interfaces.IContentish\n-             zope.lifecycleevent.interfaces.IObjectMovedEvent"\n-        handler=".subscribers.objectMoved"\n-        />\n-\n-    <subscriber\n-        for="Products.CMFCore.interfaces.IContentish\n-             zope.lifecycleevent.interfaces.IObjectRemovedEvent"\n-        handler=".subscribers.objectRemoved"\n-        />\n-\n-</configure>\n'

