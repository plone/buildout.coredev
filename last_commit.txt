Repository: plone.app.z3cform


Branch: refs/heads/master
Date: 2023-03-23T10:00:56+01:00
Author: Peter Mathis (petschki) <peter.mathis@kombinat.at>
Commit: https://github.com/plone/plone.app.z3cform/commit/bb8efeb786e4edd65b3b8833e65be5da81232993

takeover plone.app.widgets utils and base classes

Files changed:
A plone/app/z3cform/converters.zcml
A plone/app/z3cform/tests/test_utils_patterns.py
A plone/app/z3cform/tests/test_widgets_patterns.py
A plone/app/z3cform/widgets.zcml
A plone/app/z3cform/widgets/__init__.py
A plone/app/z3cform/widgets/base.py
A plone/app/z3cform/widgets/datetime.py
A plone/app/z3cform/widgets/link.py
A plone/app/z3cform/widgets/patterns.py
A plone/app/z3cform/widgets/querystring.py
A plone/app/z3cform/widgets/relateditems.py
A plone/app/z3cform/widgets/richtext.py
A plone/app/z3cform/widgets/select.py
A plone/app/z3cform/widgets/singlecheckbox.py
M plone/app/z3cform/configure.zcml
M plone/app/z3cform/tests/test_widgets.py
M plone/app/z3cform/utils.py
M plone/app/z3cform/widget.py
D plone/app/z3cform/widget.zcml

b'diff --git a/plone/app/z3cform/configure.zcml b/plone/app/z3cform/configure.zcml\nindex 9bd4ec02..e4401171 100644\n--- a/plone/app/z3cform/configure.zcml\n+++ b/plone/app/z3cform/configure.zcml\n@@ -8,7 +8,6 @@\n     >\n \n   <include package="plone.z3cform" />\n-  <include package="plone.app.widgets" />\n   <include package=".wysiwyg" />\n \n   <!-- Configuration installation profile -->\n@@ -78,32 +77,11 @@\n   <!-- Use a custom actions manager that knows how to do CSRF token authentication. -->\n   <adapter factory=".csrf.AuthenticatedButtonActions" />\n \n-  <adapter factory=".converters.DatetimeWidgetConverter" />\n-  <adapter factory=".converters.DateWidgetConverter" />\n-  <adapter factory=".converters.DateWidgetToDatetimeConverter" />\n-  <adapter factory=".converters.TimeWidgetConverter" />\n-  <adapter factory=".converters.SelectWidgetConverter" />\n-  <adapter factory=".converters.SequenceSelectWidgetConverter" />\n-  <adapter factory=".converters.AjaxSelectWidgetConverter" />\n-  <adapter factory=".converters.QueryStringDataConverter" />\n-  <adapter factory=".converters.RelationChoiceRelatedItemsWidgetConverter" />\n-  <adapter\n-      factory=".converters.RelationChoiceRelatedItemsWidgetConverter"\n-      for="z3c.relationfield.interfaces.IRelationChoice\n-           .interfaces.ITextWidget"\n-      />\n-  <adapter factory=".converters.RelationChoiceSelectWidgetConverter" />\n-  <adapter factory=".converters.RelatedItemsDataConverter" />\n-  <adapter\n-      factory=".converters.RelatedItemsDataConverter"\n-      for="z3c.relationfield.interfaces.IRelationList\n-           .interfaces.ITextWidget"\n-      />\n-  <adapter factory=".converters.RelationListSelectWidgetDataConverter" />\n-  <adapter factory=".converters.LinkWidgetDataConverter" />\n+  <!-- converters -->\n+  <include file="converters.zcml" />\n \n   <!-- widgets -->\n-  <include file="widget.zcml" />\n+  <include file="widgets.zcml" />\n \n   <!-- error snippet -->\n   <adapter\n@@ -119,10 +97,4 @@\n       name="ZPublisher.HTTPRequest.FileUpload"\n       />\n \n-  <utility\n-      provides=".interfaces.IRichTextWidgetInputModeRenderer"\n-      name="tinymce"\n-      component=".widget.tinymce_richtextwidget_render"\n-      />\n-\n </configure>\ndiff --git a/plone/app/z3cform/converters.zcml b/plone/app/z3cform/converters.zcml\nnew file mode 100644\nindex 00000000..4edd89df\n--- /dev/null\n+++ b/plone/app/z3cform/converters.zcml\n@@ -0,0 +1,20 @@\n+<configure xmlns="http://namespaces.zope.org/zope">\n+    <adapter factory=".converters.BoolSingleCheckboxDataConverter" />\n+    <adapter factory=".converters.DatetimeWidgetConverter" />\n+    <adapter factory=".converters.DateWidgetConverter" />\n+    <adapter factory=".converters.DateWidgetToDatetimeConverter" />\n+    <adapter factory=".converters.TimeWidgetConverter" />\n+    <adapter factory=".converters.SelectWidgetConverter" />\n+    <adapter factory=".converters.SequenceSelectWidgetConverter" />\n+    <adapter factory=".converters.AjaxSelectWidgetConverter" />\n+    <adapter factory=".converters.QueryStringDataConverter" />\n+    <adapter factory=".converters.RelationChoiceRelatedItemsWidgetConverter" />\n+    <adapter factory=".converters.RelationChoiceRelatedItemsWidgetConverter"\n+             for="z3c.relationfield.interfaces.IRelationChoice .interfaces.ITextWidget" />\n+    <adapter factory=".converters.RelationChoiceSelectWidgetConverter" />\n+    <adapter factory=".converters.RelatedItemsDataConverter" />\n+    <adapter factory=".converters.RelatedItemsDataConverter"\n+             for="z3c.relationfield.interfaces.IRelationList .interfaces.ITextWidget" />\n+    <adapter factory=".converters.RelationListSelectWidgetDataConverter" />\n+    <adapter factory=".converters.LinkWidgetDataConverter" />\n+</configure>\ndiff --git a/plone/app/z3cform/tests/test_utils_patterns.py b/plone/app/z3cform/tests/test_utils_patterns.py\nnew file mode 100644\nindex 00000000..99bd36f7\n--- /dev/null\n+++ b/plone/app/z3cform/tests/test_utils_patterns.py\n@@ -0,0 +1,327 @@\n+# -*- coding: utf-8 -*-\n+from mock import patch\n+from plone.app.testing import setRoles\n+from plone.app.testing import TEST_USER_ID\n+from plone.app.z3cform.tests.layer import PAZ3CForm_INTEGRATION_TESTING\n+from plone.app.z3cform.widgets.querystring import get_querystring_options\n+from plone.app.z3cform.widgets.relateditems import get_relateditems_options\n+from plone.app.z3cform.widgets.richtext import get_tinymce_options\n+\n+import unittest\n+\n+\n+class TestQueryStringOptions(unittest.TestCase):\n+    layer = PAZ3CForm_INTEGRATION_TESTING\n+\n+    def setUp(self):\n+        setRoles(self.layer[\'portal\'], TEST_USER_ID, [\'Contributor\'])\n+\n+    def test__query_string_options(self):\n+        """Test query string options on root:\n+        All URLs and paths equal root url and path,\n+        no favorites\n+        """\n+\n+        portal = self.layer[\'portal\']\n+        options = get_querystring_options(\n+            portal,\n+            \'@@qsOptions\'\n+        )\n+\n+        # Test base options\n+        self.assertEqual(\n+            options[\'indexOptionsUrl\'],\n+            \'http://nohost/plone/@@qsOptions\'\n+        )\n+\n+        self.assertEqual(\n+            options[\'previewCountURL\'],\n+            \'http://nohost/plone/@@querybuildernumberofresults\'\n+        )\n+\n+        self.assertEqual(\n+            options[\'previewURL\'],\n+            \'http://nohost/plone/@@querybuilder_html_results\'\n+        )\n+\n+        # Test options of the AJAX select widget\n+        self.assertEqual(\n+            options[\'patternAjaxSelectOptions\'][\'separator\'],\n+            \';\'\n+        )\n+\n+        # Test options of the date picker\n+        self.assertEqual(\n+            options[\'patternDateOptions\'],\n+            {\'behavior\': \'native\', \'week-numbers\': \'show\', \'first-day\': 0, \'today\': \'Today\', \'clear\': \'Clear\'}\n+        )\n+\n+        # Test options of the related items widget\n+        self.assertEqual(\n+            options[\'patternRelateditemsOptions\'][\'basePath\'],\n+            \'/plone\'\n+        )\n+        self.assertTrue(\n+            \'recentlyUsed\' not in options[\'patternRelateditemsOptions\']\n+        )\n+\n+\n+class TestRelatedItemsOptions(unittest.TestCase):\n+    layer = PAZ3CForm_INTEGRATION_TESTING\n+\n+    def setUp(self):\n+        setRoles(self.layer[\'portal\'], TEST_USER_ID, [\'Contributor\'])\n+\n+    def test__base_relateditems_options(self):\n+        """Test related items options on root:\n+        All URLs and paths equal root url and path,\n+        no favorites\n+        """\n+\n+        portal = self.layer[\'portal\']\n+        options = get_relateditems_options(\n+            portal,\n+            None,\n+            \'#!@\',\n+            \'test_vocab\',\n+            \'@@vocab\',\n+            \'testfield\'\n+        )\n+\n+        # vocab is correctly set\n+        self.assertTrue(\n+            \'@@vocab?name=test_vocab&field=testfield\'\n+            in options[\'vocabularyUrl\']\n+        )\n+\n+        # rootUrl contains something\n+        self.assertTrue(\n+            bool(options[\'rootUrl\'])\n+        )\n+\n+        root_path = context_path = \'/\'.join(portal.getPhysicalPath())\n+        root_url = context_url = portal.absolute_url()\n+\n+        # context_path contains something, otherwise this test is meaningless\n+        self.assertTrue(bool(context_path))\n+        # context_url contains something, otherwise this test is meaningless\n+        self.assertTrue(bool(context_url))\n+\n+        self.assertEqual(\n+            options[\'rootUrl\'],\n+            root_url\n+        )\n+\n+        self.assertEqual(\n+            options[\'rootPath\'],\n+            root_path\n+        )\n+\n+        self.assertEqual(\n+            options[\'vocabularyUrl\'],\n+            root_url + \'/@@vocab?name=test_vocab&field=testfield\'\n+        )\n+\n+        self.assertEqual(\n+            options[\'basePath\'],\n+            context_path\n+        )\n+\n+        self.assertEqual(\n+            options[\'contextPath\'],\n+            context_path\n+        )\n+\n+        self.assertEqual(\n+            options[\'separator\'],\n+            \'#!@\'\n+        )\n+\n+        self.assertTrue(\n+            \'favorites\' not in options\n+        )\n+\n+        # Recently used is configured, but off per default.\n+        self.assertEqual(\n+            options[\'recentlyUsed\'],\n+            False\n+        )\n+        self.assertEqual(\n+            options[\'recentlyUsedKey\'],\n+            \'relateditems_recentlyused_testfield_\' + TEST_USER_ID\n+        )\n+\n+    def test__subfolder_relateditems_options(self):\n+        """Test related items options on subfolder:\n+        Vocab called on root, start path is folder, have favorites.\n+        """\n+\n+        portal = self.layer[\'portal\']\n+        portal.invokeFactory(\'Folder\', \'sub\')\n+        sub = portal.sub\n+        options = get_relateditems_options(\n+            sub,\n+            None,\n+            \'#!@\',\n+            \'test_vocab\',\n+            \'@@vocab\',\n+            \'testfield\'\n+        )\n+\n+        # vocab is correctly set\n+        self.assertTrue(\n+            \'@@vocab?name=test_vocab&field=testfield\'\n+            in options[\'vocabularyUrl\']\n+        )\n+\n+        # rootUrl contains something\n+        self.assertTrue(\n+            bool(options[\'rootUrl\'])\n+        )\n+\n+        root_path = \'/\'.join(portal.getPhysicalPath())\n+        root_url = portal.absolute_url()\n+        context_path = \'/\'.join(sub.getPhysicalPath())\n+        context_url = sub.absolute_url()\n+\n+        # context_path contains something, otherwise this test is meaningless\n+        self.assertTrue(bool(context_path))\n+        # context_url contains something, otherwise this test is meaningless\n+        self.assertTrue(bool(context_url))\n+\n+        self.assertEqual(\n+            options[\'rootUrl\'],\n+            root_url\n+        )\n+\n+        self.assertEqual(\n+            options[\'rootPath\'],\n+            root_path\n+        )\n+\n+        self.assertEqual(\n+            options[\'vocabularyUrl\'],\n+            root_url + \'/@@vocab?name=test_vocab&field=testfield\'\n+        )\n+\n+        self.assertEqual(\n+            options[\'basePath\'],\n+            context_path\n+        )\n+\n+        self.assertEqual(\n+            options[\'contextPath\'],\n+            context_path\n+        )\n+\n+        self.assertEqual(\n+            options[\'separator\'],\n+            \'#!@\'\n+        )\n+\n+        self.assertEqual(\n+            len(options[\'favorites\']),\n+            2\n+        )\n+\n+        self.assertEqual(\n+            sorted(options[\'favorites\'][0].keys()),\n+            [\'path\', \'title\']\n+        )\n+\n+    def test__subdocument_relateditems_options(self):\n+        """Test related items options on subdoc:\n+        Vocab called on root, start path is root as document is not folderish,\n+        no favorites.\n+        """\n+\n+        portal = self.layer[\'portal\']\n+        portal.invokeFactory(\'Document\', \'sub\')\n+        sub = portal.sub\n+        options = get_relateditems_options(\n+            sub,\n+            None,\n+            \'#!@\',\n+            \'test_vocab\',\n+            \'@@vocab\',\n+            \'testfield\'\n+        )\n+\n+        # vocab is correctly set\n+        self.assertTrue(\n+            \'@@vocab?name=test_vocab&field=testfield\'\n+            in options[\'vocabularyUrl\']\n+        )\n+\n+        # rootUrl contains something\n+        self.assertTrue(\n+            bool(options[\'rootUrl\'])\n+        )\n+\n+        root_path = \'/\'.join(portal.getPhysicalPath())\n+        root_url = portal.absolute_url()\n+        context_path = \'/\'.join(sub.getPhysicalPath())\n+        context_url = sub.absolute_url()\n+\n+        # context_path contains something, otherwise this test is meaningless\n+        self.assertTrue(bool(context_path))\n+        # context_url contains something, otherwise this test is meaningless\n+        self.assertTrue(bool(context_url))\n+\n+        self.assertEqual(\n+            options[\'rootUrl\'],\n+            root_url\n+        )\n+\n+        self.assertEqual(\n+            options[\'rootPath\'],\n+            root_path\n+        )\n+\n+        self.assertEqual(\n+            options[\'vocabularyUrl\'],\n+            root_url + \'/@@vocab?name=test_vocab&field=testfield\'\n+        )\n+\n+        self.assertEqual(\n+            options[\'basePath\'],\n+            root_path\n+        )\n+\n+        self.assertEqual(\n+            options[\'contextPath\'],\n+            context_path\n+        )\n+\n+        self.assertEqual(\n+            options[\'separator\'],\n+            \'#!@\'\n+        )\n+\n+        self.assertTrue(\n+            \'favorites\' not in options\n+        )\n+\n+\n+class TestTinyMCEOptions(unittest.TestCase):\n+    layer = PAZ3CForm_INTEGRATION_TESTING\n+\n+    def setUp(self):\n+        setRoles(self.layer[\'portal\'], TEST_USER_ID, [\'Contributor\'])\n+\n+    def test__tinymce_options_different_contexts(self):\n+        """Test if ``get_tinymce_options`` can be called with different\n+        contexts, including invalid and form contexts.\n+        """\n+        request = self.layer[\'request\']\n+        portal = self.layer[\'portal\']\n+        portal.invokeFactory(\'Folder\', \'sub\')\n+        sub = portal.sub\n+\n+        # TinyMCE on portal context\n+        options = get_tinymce_options(portal, None, request)\n+        self.assertEqual(options[\'relatedItems\'][\'basePath\'], \'/plone\')\n+\n+        # TinyMCE on sub folder context\n+        options = get_tinymce_options(sub, None, request)\n+        self.assertEqual(options[\'relatedItems\'][\'basePath\'], \'/plone/sub\')\ndiff --git a/plone/app/z3cform/tests/test_widgets.py b/plone/app/z3cform/tests/test_widgets.py\nindex dea25970..8dafd337 100644\n--- a/plone/app/z3cform/tests/test_widgets.py\n+++ b/plone/app/z3cform/tests/test_widgets.py\n@@ -6,11 +6,11 @@\n from plone.app.contentlisting.contentlisting import ContentListing\n from plone.app.testing import setRoles\n from plone.app.testing import TEST_USER_ID\n-from plone.app.widgets.utils import NotImplemented as PatternNotImplemented\n from plone.app.z3cform.tests.layer import PAZ3CForm_INTEGRATION_TESTING\n-from plone.app.z3cform.widget import BaseWidget\n-from plone.app.z3cform.widget import DateWidget\n-from plone.app.z3cform.widget import RelatedItemsWidget\n+from plone.app.z3cform.widgets.base import BaseWidget\n+from plone.app.z3cform.widgets.base import PatternNotImplemented\n+from plone.app.z3cform.widgets.datetime import DateWidget\n+from plone.app.z3cform.widgets.relateditems import RelatedItemsWidget\n from plone.autoform.directives import widget\n from plone.autoform.form import AutoExtensibleForm\n from plone.base.interfaces import IMarkupSchema\n@@ -102,8 +102,8 @@ def test_widget_pattern_notimplemented(self):\n         )\n \n     def test_widget_base_notimplemented(self):\n-        from plone.app.widgets.base import InputWidget\n-        from plone.app.z3cform.widget import BaseWidget\n+        from plone.app.z3cform.widgets.base import BaseWidget\n+        from plone.app.z3cform.widgets.patterns import InputWidget\n \n         widget = BaseWidget(self.request)\n         widget.field = self.field\n@@ -122,8 +122,8 @@ def test_widget_base_notimplemented(self):\n         )\n \n     def test_widget_base_custom_css(self):\n-        from plone.app.widgets.base import InputWidget\n-        from plone.app.z3cform.widget import BaseWidget\n+        from plone.app.z3cform.widgets.base import BaseWidget\n+        from plone.app.z3cform.widgets.patterns import InputWidget\n \n         widget = BaseWidget(self.request)\n         widget.field = self.field\n@@ -137,8 +137,8 @@ def test_widget_base_custom_css(self):\n         )\n \n     def test_widget_base_pattern_options_with_functions(self):\n-        from plone.app.widgets.base import InputWidget\n-        from plone.app.z3cform.widget import BaseWidget\n+        from plone.app.z3cform.widgets.base import BaseWidget\n+        from plone.app.z3cform.widgets.patterns import InputWidget\n \n         widget = BaseWidget(self.request)\n         widget.context = "testcontext"\n@@ -183,7 +183,7 @@ def test_widget_base_pattern_options_with_functions(self):\n \n class DateWidgetTests(unittest.TestCase):\n     def setUp(self):\n-        from plone.app.z3cform.widget import DateWidget\n+        from plone.app.z3cform.widgets.datetime import DateWidget\n \n         self.request = TestRequest(environ={"HTTP_ACCEPT_LANGUAGE": "en"})\n         self.field = Date(__name__="datefield")\n@@ -217,7 +217,7 @@ def test_widget_required(self):\n         self.assertEqual(base_args["pattern_options"]["clear"], False)\n \n     def test_data_converter(self):\n-        from plone.app.z3cform.widget import DateWidgetConverter\n+        from plone.app.z3cform.widgets.datetime import DateWidgetConverter\n \n         converter = DateWidgetConverter(self.field, self.widget)\n \n@@ -252,8 +252,8 @@ def test_data_converter(self):\n         )\n \n     def test_fieldwidget(self):\n-        from plone.app.z3cform.widget import DateFieldWidget\n-        from plone.app.z3cform.widget import DateWidget\n+        from plone.app.z3cform.widgets.datetime import DateFieldWidget\n+        from plone.app.z3cform.widgets.datetime import DateWidget\n \n         field = Mock(__name__="field", title="", required=True)\n         request = Mock()\n@@ -286,7 +286,7 @@ def test_dateformatter(self):\n \n class DatetimeWidgetTests(unittest.TestCase):\n     def setUp(self):\n-        from plone.app.z3cform.widget import DatetimeWidget\n+        from plone.app.z3cform.widgets.datetime import DatetimeWidget\n \n         self.request = TestRequest(environ={"HTTP_ACCEPT_LANGUAGE": "en"})\n         self.field = Datetime(__name__="datetimefield")\n@@ -324,7 +324,7 @@ def test_widget_required(self):\n         self.assertEqual(base_args["pattern_options"]["clear"], False)\n \n     def test_data_converter(self):\n-        from plone.app.z3cform.widget import DatetimeWidgetConverter\n+        from plone.app.z3cform.widgets.datetime import DatetimeWidgetConverter\n \n         converter = DatetimeWidgetConverter(self.field, self.widget)\n \n@@ -360,7 +360,7 @@ def test_data_converter(self):\n \n     def test_data_converter__no_timezone(self):\n         """When no timezone is set, don\'t apply one."""\n-        from plone.app.z3cform.widget import DatetimeWidgetConverter\n+        from plone.app.z3cform.widgets.datetime import DatetimeWidgetConverter\n \n         context = Mock()\n \n@@ -381,7 +381,7 @@ def test_data_converter__no_timezone(self):\n \n     def test_data_converter__timezone_id(self):\n         """When a (pytz) timezone id is set, use that."""\n-        from plone.app.z3cform.widget import DatetimeWidgetConverter\n+        from plone.app.z3cform.widgets.datetime import DatetimeWidgetConverter\n \n         context = Mock()\n \n@@ -405,7 +405,7 @@ def test_data_converter__timezone_callback(self):\n         """When a timezone callback is set, returning a (pytz) timezone id,\n         use that.\n         """\n-        from plone.app.z3cform.widget import DatetimeWidgetConverter\n+        from plone.app.z3cform.widgets.datetime import DatetimeWidgetConverter\n \n         context = Mock()\n \n@@ -426,8 +426,8 @@ def test_data_converter__timezone_callback(self):\n         self.widget.default_timezone = None\n \n     def test_fieldwidget(self):\n-        from plone.app.z3cform.widget import DatetimeFieldWidget\n-        from plone.app.z3cform.widget import DatetimeWidget\n+        from plone.app.z3cform.widgets.datetime import DatetimeFieldWidget\n+        from plone.app.z3cform.widgets.datetime import DatetimeWidget\n \n         field = Mock(__name__="field", title="", required=True)\n         request = Mock()\n@@ -462,7 +462,7 @@ def test_datetimeformatter(self):\n \n class TimeWidgetTests(unittest.TestCase):\n     def setUp(self):\n-        from plone.app.z3cform.widget import TimeWidget\n+        from plone.app.z3cform.widgets.datetime import TimeWidget\n \n         self.request = TestRequest(environ={"HTTP_ACCEPT_LANGUAGE": "en"})\n         self.field = Time(__name__="timefield")\n@@ -499,8 +499,8 @@ def test_data_converter(self):\n         )\n \n     def test_fieldwidget(self):\n-        from plone.app.z3cform.widget import TimeFieldWidget\n-        from plone.app.z3cform.widget import TimeWidget\n+        from plone.app.z3cform.widgets.datetime import TimeFieldWidget\n+        from plone.app.z3cform.widgets.datetime import TimeWidget\n \n         field = Mock(__name__="field", title="", required=True)\n         request = Mock()\n@@ -1202,15 +1202,15 @@ def test_converter_empty_value(self):\n         self.assertEqual(converter.toFieldValue("[]"), None)\n \n     @mock.patch(\n-        "plone.app.widgets.utils.get_date_options",\n+        "plone.app.z3cform.widgets.datetime.get_date_options",\n         new=lambda *args, **kwargs: None,\n     )\n     @mock.patch(\n-        "plone.app.widgets.utils.get_relateditems_options",\n+        "plone.app.z3cform.widgets.relateditems.get_relateditems_options",\n         new=lambda *args, **kwargs: None,\n     )\n     def test_widget(self):\n-        from plone.app.z3cform.widget import QueryStringWidget\n+        from plone.app.z3cform.widgets.querystring import QueryStringWidget\n \n         widget = QueryStringWidget(self.request)\n         self.assertEqual(\n@@ -1405,13 +1405,13 @@ def setUp(self):\n         self.request = TestRequest(environ={"HTTP_ACCEPT_LANGUAGE": "en"})\n \n     @mock.patch(\n-        "plone.app.widgets.utils.getToolByName",\n+        "Products.CMFCore.utils.getToolByName",\n         new=Mock(return_value=Mock(return_value="testuser")),\n     )\n     def test_single_selection(self):\n         """The pattern_options value for maximumSelectionSize should\n         be 1 when the field only allows a single selection."""\n-        from plone.app.z3cform.widget import RelatedItemsFieldWidget\n+        from plone.app.z3cform.widgets.relateditems import RelatedItemsFieldWidget\n \n         context = Mock(\n             absolute_url=lambda: "fake_url", getPhysicalPath=lambda: ["", "site"]\n@@ -1428,7 +1428,7 @@ def test_single_selection(self):\n         self.assertEqual(pattern_options.get("maximumSelectionSize", 0), 1)\n \n     @mock.patch(\n-        "plone.app.widgets.utils.getToolByName",\n+        "Products.CMFCore.utils.getToolByName",\n         new=Mock(return_value=Mock(return_value="testuser")),\n     )\n     def test_multiple_selection(self):\n@@ -1461,9 +1461,8 @@ def test_multiple_selection(self):\n         )\n \n     def test_converter_RelationChoice(self):\n-        from plone.app.z3cform.converters import (\n-            RelationChoiceRelatedItemsWidgetConverter,\n-        )\n+        from plone.app.z3cform.converters import \\\n+            RelationChoiceRelatedItemsWidgetConverter\n \n         brain = Mock(getObject=Mock(return_value="obj"))\n         portal_catalog = Mock(return_value=[brain])\n@@ -1579,7 +1578,7 @@ def add_mock_fti(portal):\n     fti = DexterityFTI("dx_mock")\n     portal.portal_types._setObject("dx_mock", fti)\n     fti.klass = "plone.dexterity.content.Item"\n-    fti.schema = "plone.app.widgets.tests.test_dx.IMockSchema"\n+    fti.schema = "plone.dexterity.tests.schemata.ITestSchema"\n     fti.filter_content_types = False\n     fti.behaviors = ("plone.app.dexterity.behaviors.metadata.IBasic",)\n \ndiff --git a/plone/app/z3cform/tests/test_widgets_patterns.py b/plone/app/z3cform/tests/test_widgets_patterns.py\nnew file mode 100644\nindex 00000000..b91fc1bc\n--- /dev/null\n+++ b/plone/app/z3cform/tests/test_widgets_patterns.py\n@@ -0,0 +1,279 @@\n+import unittest\n+\n+\n+class BaseWidgetTests(unittest.TestCase):\n+    """Tests for plone.app.z3cform.widgets.patterns.BaseWidget."""\n+\n+    def test_defaults(self):\n+        from plone.app.z3cform.widgets.patterns import BaseWidget\n+\n+        widget = BaseWidget(\'input\', \'example1\')\n+        self.assertEqual(\n+            widget.render(),\n+            u\'<input class="pat-example1"/>\')\n+\n+        self.assertEqual(widget.klass, \'pat-example1\')\n+\n+    def test_different_element_tag(self):\n+        from plone.app.z3cform.widgets.patterns import BaseWidget\n+\n+        widget = BaseWidget(\'select\', \'example1\')\n+        self.assertEqual(\n+            widget.render(),\n+            u\'<select class="pat-example1"/>\')\n+\n+        self.assertEqual(widget.klass, \'pat-example1\')\n+\n+    def test_setting_patterns_options(self):\n+        from plone.app.z3cform.widgets.patterns import BaseWidget\n+\n+        widget = BaseWidget(\n+            \'input\',\n+            \'example1\',\n+            pattern_options={\n+                \'option1\': \'value1\',\n+                \'option2\': \'value2\',\n+            })\n+\n+        html = widget.render()\n+        # the order of options is non-deterministic\n+        result1 = u\'<input class="pat-example1" data-pat-example1="{&quot;option1&quot;: &quot;value1&quot;, &quot;option2&quot;: &quot;value2&quot;}"/>\'  # noqa: E501\n+        result2 = u\'<input class="pat-example1" data-pat-example1="{&quot;option2&quot;: &quot;value2&quot;, &quot;option1&quot;: &quot;value1&quot;}"/>\'  # noqa: E501\n+        self.assertIn(html, [result1, result2])\n+\n+\n+class InputWidgetTests(unittest.TestCase):\n+    """Tests for plone.app.z3cform.widgets.patterns.InputWidget."""\n+\n+    def test_defaults(self):\n+        from plone.app.z3cform.widgets.patterns import InputWidget\n+\n+        widget = InputWidget(\'example1\', name=\'example2\')\n+\n+        self.assertEqual(\n+            widget.render(),\n+            \'<input class="pat-example1" type="text" name="example2"/>\')\n+\n+        self.assertEqual(widget.type, \'text\')\n+        self.assertEqual(widget.value, None)\n+\n+    def test_set_type_and_value(self):\n+        from plone.app.z3cform.widgets.patterns import InputWidget\n+\n+        widget = InputWidget(\n+            \'example1\',\n+            name=\'example2\',\n+            type=\'email\',\n+            value=\'example3\'\n+        )\n+\n+        self.assertEqual(\n+            widget.render(),\n+            u\'<input class="pat-example1" type="email" \'\n+            \'name="example2" value="example3"/>\')\n+\n+        self.assertEqual(widget.type, \'email\')\n+        self.assertEqual(widget.value, \'example3\')\n+\n+        widget.type = \'text\'\n+        widget.value = \'example4\'\n+        self.assertEqual(\n+            widget.render(),\n+            u\'<input class="pat-example1" type="text" \'\n+            \'name="example2" value="example4"/>\')\n+\n+        self.assertEqual(widget.type, \'text\')\n+        self.assertEqual(widget.value, \'example4\')\n+\n+        del widget.type\n+        del widget.value\n+        self.assertEqual(\n+            widget.render(),\n+            u\'<input class="pat-example1" name="example2"/>\')\n+\n+        self.assertEqual(widget.type, None)\n+        self.assertEqual(widget.value, None)\n+\n+\n+class SelectWidgetTests(unittest.TestCase):\n+    """Tests for plone.app.z3cform.widgets.patterns.SelectWidget."""\n+\n+    def test_defaults(self):\n+        from plone.app.z3cform.widgets.patterns import SelectWidget\n+\n+        widget = SelectWidget(\'example1\', name=\'example2\')\n+\n+        self.assertEqual(\n+            widget.render(),\n+            u\'<select class="pat-example1" name="example2"></select>\')\n+        self.assertEqual(list(widget.items), [])\n+        self.assertEqual(widget.value, [])\n+\n+    def test_set_items_and_value(self):\n+        from plone.app.z3cform.widgets.patterns import SelectWidget\n+\n+        items = [\n+            (\'token1\', \'value1\'),\n+            (\'token2\', \'value2\'),\n+            (\'token3\', \'value3\'),\n+        ]\n+        widget = SelectWidget(\n+            \'example1\',\n+            name=\'example2\',\n+            value=\'token2\',\n+            items=items\n+        )\n+\n+        self.assertEqual(\n+            widget.render(),\n+            u\'<select class="pat-example1" name="example2">\'\n+            \'<option value="token1">value1</option>\'\n+            \'<option value="token2" selected="selected">value2</option>\'\n+            \'<option value="token3">value3</option>\'\n+            \'</select>\')\n+\n+        self.assertEqual(list(widget.items), items)\n+        self.assertEqual(widget.value, [\'token2\'])\n+\n+        widget.value = \'token1\'\n+        self.assertEqual(\n+            widget.render(),\n+            u\'<select class="pat-example1" name="example2">\'\n+            \'<option value="token1" selected="selected">value1</option>\'\n+            \'<option value="token2">value2</option>\'\n+            \'<option value="token3">value3</option>\'\n+            \'</select>\')\n+\n+        self.assertEqual(list(widget.items), items)\n+        self.assertEqual(widget.value, [\'token1\'])\n+\n+        del widget.value\n+        self.assertEqual(\n+            widget.render(),\n+            u\'<select class="pat-example1" name="example2">\'\n+            \'<option value="token1">value1</option>\'\n+            \'<option value="token2">value2</option>\'\n+            \'<option value="token3">value3</option>\'\n+            \'</select>\')\n+\n+        del widget.items\n+        self.assertEqual(\n+            widget.render(),\n+            \'<select class="pat-example1" name="example2"></select>\')\n+\n+    def test_multiple(self):\n+        from plone.app.z3cform.widgets.patterns import SelectWidget\n+\n+        items = [\n+            (\'token1\', \'value1\'),\n+            (\'token2\', \'value2\'),\n+            (\'token3\', \'value3\'),\n+        ]\n+        widget = SelectWidget(\n+            \'example1\',\n+            name=\'example2\',\n+            value=[\'token2\'],\n+            items=items,\n+            multiple=True,\n+        )\n+\n+        self.assertEqual(\n+            widget.render(),\n+            u\'<select class="pat-example1" multiple="multiple" name="example2">\'\n+            \'<option value="token1">value1</option>\'\n+            \'<option value="token2" selected="selected">value2</option>\'\n+            \'<option value="token3">value3</option>\'\n+            \'</select>\')\n+\n+        self.assertEqual(list(widget.items), items)\n+        self.assertEqual(widget.value, [\'token2\'])\n+\n+        widget.value = [\'token1\', \'token2\']\n+        self.assertEqual(\n+            widget.render(),\n+            u\'<select class="pat-example1" multiple="multiple" name="example2">\'\n+            \'<option value="token1" selected="selected">value1</option>\'\n+            \'<option value="token2" selected="selected">value2</option>\'\n+            \'<option value="token3">value3</option>\'\n+            \'</select>\')\n+\n+        self.assertEqual(list(widget.items), items)\n+        self.assertEqual(widget.value, [\'token1\', \'token2\'])\n+\n+        del widget.value\n+        self.assertEqual(\n+            widget.render(),\n+            u\'<select class="pat-example1" multiple="multiple" name="example2">\'\n+            \'<option value="token1">value1</option>\'\n+            \'<option value="token2">value2</option>\'\n+            \'<option value="token3">value3</option>\'\n+            \'</select>\')\n+\n+        del widget.items\n+        self.assertEqual(\n+            widget.render(),\n+            u\'<select class="pat-example1" multiple="multiple" \'\n+            \'name="example2"></select>\')\n+\n+\n+class TextareaWidgetTests(unittest.TestCase):\n+    """Tests for plone.app.z3cform.widgets.patterns.TextareaWidget."""\n+\n+    def test_defaults(self):\n+        from plone.app.z3cform.widgets.patterns import TextareaWidget\n+\n+        widget = TextareaWidget(\'example1\', name="example2")\n+        self.assertEqual(\n+            widget.render(),\n+            u\'<textarea class="pat-example1" name="example2"></textarea>\')\n+\n+        self.assertEqual(widget.name, \'example2\')\n+        self.assertEqual(widget.klass, \'pat-example1\')\n+        self.assertEqual(widget.value, \'\')\n+\n+    def test_setting_patterns_options(self):\n+        from plone.app.z3cform.widgets.patterns import TextareaWidget\n+\n+        widget = TextareaWidget(\n+            \'example1\',\n+            name=\'example2\',\n+            pattern_options={\n+                \'option1\': \'value1\',\n+                \'option2\': \'value2\',\n+            })\n+\n+        html = widget.render()\n+        # the order of options is non-deterministic\n+        result1 = u\'<textarea class="pat-example1" name="example2" data-pat-example1="{&quot;option1&quot;: &quot;value1&quot;, &quot;option2&quot;: &quot;value2&quot;}"></textarea>\'  # noqa: E501\n+        result2 = u\'<textarea class="pat-example1" name="example2" data-pat-example1="{&quot;option2&quot;: &quot;value2&quot;, &quot;option1&quot;: &quot;value1&quot;}"></textarea>\'  # noqa: E501\n+        self.assertIn(html, [result1, result2])\n+\n+    def test_set_value(self):\n+        from plone.app.z3cform.widgets.patterns import TextareaWidget\n+\n+        widget = TextareaWidget(\'example1\', name="example2", value=\'example3\')\n+        self.assertEqual(\n+            widget.render(),\n+            u\'<textarea class="pat-example1" name="example2">\'\n+            \'example3\'\n+            \'</textarea>\')\n+\n+        self.assertEqual(widget.value, \'example3\')\n+\n+        widget.value = \'example4\'\n+        self.assertEqual(\n+            widget.render(),\n+            u\'<textarea class="pat-example1" name="example2">\'\n+            \'example4\'\n+            \'</textarea>\')\n+\n+        del widget.value\n+        self.assertEqual(\n+            widget.render(),\n+            u\'<textarea class="pat-example1" name="example2"></textarea>\')\n+\n+    def test_can_not_change_element_tag(self):\n+        from plone.app.z3cform.widgets.patterns import TextareaWidget\n+        self.assertRaises(\n+            TypeError,\n+            TextareaWidget, \'example1\', el=\'input\', name=\'example2\')\ndiff --git a/plone/app/z3cform/utils.py b/plone/app/z3cform/utils.py\nindex bf2bed63..09c4e50d 100644\n--- a/plone/app/z3cform/utils.py\n+++ b/plone/app/z3cform/utils.py\n@@ -1,6 +1,11 @@\n from Acquisition import aq_base\n+from copy import deepcopy\n+from plone.app.layout.navigation.root import getNavigationRootObject\n from Products.CMFCore.interfaces import IContentish\n from Products.CMFCore.interfaces import IFolderish\n+from Products.CMFCore.interfaces import ISiteRoot\n+from z3c.form.interfaces import IForm\n+from zope.component import providedBy\n from zope.component.hooks import getSite\n from zope.globalrequest import getRequest\n \n@@ -104,3 +109,75 @@ def is_same_domain(url1, url2):\n     purl1 = urllib.parse.urlparse(url1)\n     purl2 = urllib.parse.urlparse(url2)\n     return purl1.scheme == purl2.scheme and purl1.netloc == purl2.netloc\n+\n+\n+def dict_merge(dict_a, dict_b):\n+    """Helper method which merges two dictionaries.\n+\n+    Recursively merges dict\'s. not just simple a[\'key\'] = b[\'key\'], if\n+    both a and b have a key who\'s value is a dict then dict_merge is called\n+    on both values and the result stored in the returned dictionary.\n+\n+    http://www.xormedia.com/recursively-merge-dictionaries-in-python\n+\n+    :param dict_a: [required] First dictiornary.\n+    :type dict_a: dict\n+\n+    :param dict_b: [required] Second dictiornary.\n+    :type dict_b: dict\n+\n+    :returns: Merged dictionary.\n+    :rtype: dict\n+    """\n+\n+    if not isinstance(dict_b, dict):\n+        return dict_b\n+    result = deepcopy(dict_a)\n+    for k, v in dict_b.items():\n+        if k in result and isinstance(result[k], dict):\n+                result[k] = dict_merge(result[k], v)\n+        else:\n+            result[k] = deepcopy(v)\n+    return result\n+\n+\n+def get_widget_form(widget):\n+    form = getattr(widget, \'form\', None)\n+    if getattr(aq_base(form), \'parentForm\', None) is not None:\n+        form = form.parentForm\n+    return form\n+\n+\n+def get_portal():\n+    closest_site = getSite()\n+    if closest_site is not None:\n+        for potential_portal in closest_site.aq_chain:\n+            if ISiteRoot in providedBy(potential_portal):\n+                return potential_portal\n+\n+\n+def get_portal_url(context):\n+    portal = get_portal()\n+    if portal:\n+        root = getNavigationRootObject(context, portal)\n+        if root:\n+            try:\n+                return root.absolute_url()\n+            except AttributeError:\n+                return portal.absolute_url()\n+        else:\n+            return portal.absolute_url()\n+    return \'\'\n+\n+\n+def get_context_url(context):\n+    if IForm.providedBy(context):\n+        # Use the request URL if we are looking at an addform\n+        url = context.request.get(\'URL\')\n+    elif hasattr(context, \'absolute_url\'):\n+        url = context.absolute_url\n+        if callable(url):\n+            url = url()\n+    else:\n+        url = get_portal_url(context)\n+    return url\ndiff --git a/plone/app/z3cform/widget.py b/plone/app/z3cform/widget.py\nindex 28d15706..d956e8dc 100644\n--- a/plone/app/z3cform/widget.py\n+++ b/plone/app/z3cform/widget.py\n@@ -1,993 +1,62 @@\n-from Acquisition import aq_base\n-from Acquisition import ImplicitAcquisitionWrapper\n-from collections import UserDict\n-from lxml import etree\n-from OFS.interfaces import ISimpleItem\n-from plone.app.contentlisting.interfaces import IContentListing\n-from plone.app.textfield.value import RichTextValue\n-from plone.app.textfield.widget import RichTextWidget as patext_RichTextWidget\n-from plone.app.vocabularies.terms import TermWithDescription\n-from plone.app.widgets.base import dict_merge\n-from plone.app.widgets.base import InputWidget\n-from plone.app.widgets.base import SelectWidget as BaseSelectWidget\n-from plone.app.widgets.base import TextareaWidget\n-from plone.app.widgets.utils import get_context_url\n-from plone.app.widgets.utils import get_date_options\n-from plone.app.widgets.utils import get_querystring_options\n-from plone.app.widgets.utils import get_relateditems_options\n-from plone.app.widgets.utils import get_tinymce_options\n-from plone.app.widgets.utils import get_widget_form\n-from plone.app.widgets.utils import NotImplemented as PatternNotImplemented\n-from plone.app.z3cform.converters import DatetimeWidgetConverter\n-from plone.app.z3cform.converters import DateWidgetConverter\n-from plone.app.z3cform.interfaces import IAjaxSelectWidget\n-from plone.app.z3cform.interfaces import IDatetimeWidget\n-from plone.app.z3cform.interfaces import IDateWidget\n-from plone.app.z3cform.interfaces import ILinkWidget\n-from plone.app.z3cform.interfaces import IPloneFormLayer\n-from plone.app.z3cform.interfaces import IQueryStringWidget\n-from plone.app.z3cform.interfaces import IRelatedItemsWidget\n-from plone.app.z3cform.interfaces import IRichTextWidget\n-from plone.app.z3cform.interfaces import IRichTextWidgetInputModeRenderer\n-from plone.app.z3cform.interfaces import ISelectWidget\n-from plone.app.z3cform.interfaces import ISingleCheckBoxBoolWidget\n-from plone.app.z3cform.interfaces import ITimeWidget\n-from plone.app.z3cform.utils import call_callables\n-from plone.app.z3cform.utils import closest_content\n-from plone.base.utils import safe_text\n-from plone.registry.interfaces import IRegistry\n-from Products.CMFCore.utils import getToolByName\n-from z3c.form import interfaces as form_ifaces\n-from z3c.form.browser.checkbox import SingleCheckBoxWidget\n-from z3c.form.browser.select import SelectWidget as z3cform_SelectWidget\n-from z3c.form.browser.text import TextWidget as z3cform_TextWidget\n-from z3c.form.interfaces import IEditForm\n-from z3c.form.interfaces import IFieldWidget\n-from z3c.form.interfaces import IForm\n-from z3c.form.interfaces import NO_VALUE\n-from z3c.form.term import BoolTerms\n-from z3c.form.term import Terms\n-from z3c.form.widget import FieldWidget\n-from z3c.form.widget import Widget\n-from zope.component import adapter\n-from zope.component import getUtility\n-from zope.component import queryUtility\n-from zope.component.hooks import getSite\n-from zope.i18n import translate\n-from zope.interface import implementer\n-from zope.interface import implementer_only\n-from zope.schema import interfaces as schema_ifaces\n-from zope.schema.interfaces import IBool\n-from zope.schema.interfaces import IChoice\n-from zope.schema.interfaces import ICollection\n-from zope.schema.interfaces import ISequence\n-from zope.schema.interfaces import IVocabularyFactory\n-from zope.schema.vocabulary import SimpleTerm\n-from zope.schema.vocabulary import SimpleVocabulary\n-\n-import collections\n-import json\n-\n-\n-class BaseWidget(Widget):\n-    """Base widget for z3c.form."""\n-\n-    pattern = None\n-    pattern_options = {}\n-    _adapterValueAttributes = Widget._adapterValueAttributes + ("pattern_options",)\n-\n-    def _base(self, pattern, pattern_options={}):\n-        """Base widget class."""\n-        raise PatternNotImplemented\n-\n-    def _base_args(self):\n-        """Method which will calculate _base class arguments.\n-\n-        Returns (as python dictionary):\n-            - `pattern`: pattern name\n-            - `pattern_options`: pattern options\n-\n-        :returns: Arguments which will be passed to _base\n-        :rtype: dict\n-        """\n-        if self.pattern is None:\n-            raise PatternNotImplemented("\'pattern\' option is not provided.")\n-        return {\n-            "pattern": self.pattern,\n-            "pattern_options": self.pattern_options.copy(),\n-        }\n-\n-    def render(self):\n-        """Render widget.\n-\n-        :returns: Widget\'s HTML.\n-        :rtype: string\n-        """\n-        if self.mode != "input":\n-            return super().render()\n-\n-        _base_args = self._base_args()\n-        _base_args["pattern_options"] = call_callables(\n-            _base_args["pattern_options"],\n-            self.context,\n-        )\n-\n-        pattern_widget = self._base(**_base_args)\n-        if getattr(self, "klass", False):\n-            pattern_widget.klass = "{} {}".format(\n-                pattern_widget.klass,\n-                self.klass,\n-            )\n-        return pattern_widget.render()\n-\n-    def is_subform_widget(self):\n-        return getattr(aq_base(self.form), "parentForm", None) is not None\n-\n-\n-@implementer_only(IDateWidget)\n-class DateWidget(BaseWidget, z3cform_TextWidget):\n-    """Date widget for z3c.form.\n-\n-    :param default_timezone: A Olson DB/pytz timezone identifier or a callback\n-                             returning such an identifier.\n-    :type default_timezone: String or callback\n-\n-    :param default_time: Time used by converter as fallback if no time was set in UI.\n-    :type default_time: String or callback\n-\n-    The default_timezone and default_time arguments are only used if a datewidget is\n-    used on a datetime field. If used on a date field they are ignored.\n-    """\n-\n-    _base_type = "date"\n-    _converter = DateWidgetConverter\n-    _formater = "date"\n-    _formater_length = "short"\n-\n-    default_timezone = None\n-    default_time = "00:00:00"\n-\n-    pattern = "date-picker"\n-    pattern_options = BaseWidget.pattern_options.copy()\n-\n-    def _base(self, **kw):\n-        return InputWidget(\n-            type=self._base_type,\n-            **kw,\n-        )\n-\n-    def _base_args(self):\n-        """Method which will calculate _base class arguments.\n-\n-        Returns (as python dictionary):\n-            - `pattern`: pattern name\n-            - `pattern_options`: pattern options\n-            - `name`: field name\n-            - `value`: field value\n-\n-        :returns: Arguments which will be passed to _base\n-        :rtype: dict\n-        """\n-        args = super()._base_args()\n-        args["name"] = self.name\n-        args["value"] = (self.request.get(self.name, self.value) or "").strip()\n-\n-        args.setdefault("pattern_options", {})\n-        if self.field.required:\n-            # Required fields should not have a "Clear" button\n-            args["pattern_options"]["clear"] = False\n-        args["pattern_options"] = dict_merge(\n-            get_date_options(self.request), args["pattern_options"]\n-        )\n-\n-        return args\n-\n-    def render(self):\n-        """Render widget.\n-\n-        :returns: Widget\'s HTML.\n-        :rtype: string\n-        """\n-        if self.mode != "display":\n-            self.addClass("form-control")\n-            return super().render()\n-\n-        if not self.value:\n-            return ""\n-\n-        field_value = self._converter(self.field, self).toFieldValue(self.value)\n-        if field_value is self.field.missing_value:\n-            return ""\n-\n-        formatter = self.request.locale.dates.getFormatter(\n-            self._formater,\n-            self._formater_length,\n-        )\n-        return formatter.format(field_value)\n-\n-\n-@implementer_only(IDatetimeWidget)\n-class DatetimeWidget(DateWidget):\n-    """Datetime widget for z3c.form.\n-\n-    :param default_timezone: A Olson DB/pytz timezone identifier or a callback\n-                             returning such an identifier.\n-    :type default_timezone: String or callback\n-\n-    :param default_time: Time used by converter as fallback if no time was set in UI.\n-    :type default_time: String or callback\n-    """\n-\n-    _base_type = "datetime-local"\n-    _converter = DatetimeWidgetConverter\n-    _formater = "dateTime"\n-\n-    default_timezone = None\n-    default_time = "00:00:00"\n-\n-    pattern = "datetime-picker"\n-\n-\n-@implementer_only(ITimeWidget)\n-class TimeWidget(BaseWidget, z3cform_TextWidget):\n-    pattern = ""\n-\n-    def _base(self, **kw):\n-        return InputWidget(\n-            type="time",\n-            name=self.name,\n-            value=(self.request.get(self.name, self.value) or "").strip(),\n-            **kw,\n-        )\n-\n-    def render(self):\n-        if self.mode != "display":\n-            self.addClass("form-control")\n-        return super().render()\n-\n-\n-@implementer_only(ISelectWidget)\n-class SelectWidget(BaseWidget, z3cform_SelectWidget):\n-    """Select widget for z3c.form."""\n-\n-    _base = BaseSelectWidget\n-\n-    pattern = "select2"\n-    pattern_options = BaseWidget.pattern_options.copy()\n-\n-    separator = ";"\n-    noValueToken = ""\n-    noValueMessage = ""\n-    multiple = None\n-    orderable = False\n-    required = True\n-\n-    @property\n-    def items(self):\n-        """\n-        Optionally handle ITreeVocabulary vocabs as dicts.\n-        """\n-        terms = self.terms\n-        if form_ifaces.ITerms.providedBy(terms):\n-            terms = terms.terms\n-\n-        if schema_ifaces.ITreeVocabulary.providedBy(terms):\n-            groups = collections.OrderedDict()\n-            for group_term, option_terms in terms.items():\n-                group_widget = type(self)(self.request)\n-                group_widget.terms = option_terms\n-                group_label = group_term.title or group_term.value or group_term.token\n-                groups[group_label] = super(SelectWidget, group_widget).items\n-            return groups\n-        else:\n-            return super().items\n-\n-    def _base_args(self):\n-        """Method which will calculate _base class arguments.\n-\n-        Returns (as python dictionary):\n-            - `pattern`: pattern name\n-            - `pattern_options`: pattern options\n-            - `name`: field name\n-            - `value`: field value\n-            - `multiple`: field multiple\n-            - `items`: field items from which we can select to\n-\n-        :returns: Arguments which will be passed to _base\n-        :rtype: dict\n-        """\n-        args = super()._base_args()\n-        args["name"] = self.name\n-        args["value"] = self.value\n-        args["multiple"] = self.multiple\n-\n-        self.required = self.field.required\n-\n-        options = args.setdefault("pattern_options", {})\n-        if self.multiple or ICollection.providedBy(self.field):\n-            args["multiple"] = self.multiple = True\n-\n-        # ISequence represents an orderable collection\n-        if ISequence.providedBy(self.field) or self.orderable:\n-            options["orderable"] = True\n-\n-        if self.multiple:\n-            options["separator"] = self.separator\n-\n-        # Allow to clear field value if it is not required\n-        if not self.required:\n-            options["allowClear"] = True\n-\n-        base_items = self.items\n-        if callable(base_items):\n-            # items used to be a property in all widgets, then in the select\n-            # widget it became a method, then in a few others too, but never in\n-            # all, so this was reverted to let it be a property again.  Let\'s\n-            # support both here to avoid breaking on some z3c.form versions.\n-            # See https://github.com/zopefoundation/z3c.form/issues/44\n-            base_items = base_items()\n-\n-        def makeItem(item):\n-            """\n-            Gather the information needed by the widget for the given term.\n-            """\n-            if not isinstance(item["content"], str):\n-                item["content"] = translate(\n-                    item["content"], context=self.request, default=item["value"]\n-                )\n-            return (item["value"], item["content"])\n-\n-        if isinstance(base_items, dict):\n-            items = collections.OrderedDict(\n-                (group_label, [makeItem(base_item) for base_item in group_options])\n-                for group_label, group_options in base_items.items()\n-            )\n-        else:\n-            items = [makeItem(item) for item in base_items]\n-        args["items"] = items\n-\n-        return args\n-\n-    def extract(self, default=NO_VALUE):\n-        """Override extract to handle delimited response values.\n-        Skip the vocabulary validation provided in the parent\n-        method, since it\'s not ever done for single selects."""\n-        if (\n-            self.name not in self.request\n-            and self.name + "-empty-marker" in self.request\n-        ):\n-            return []\n-        return self.request.get(self.name, default)\n-\n-\n-@implementer_only(IAjaxSelectWidget)\n-class AjaxSelectWidget(BaseWidget, z3cform_TextWidget):\n-    """Ajax select widget for z3c.form."""\n-\n-    _base = InputWidget\n-\n-    pattern = "select2"\n-    pattern_options = BaseWidget.pattern_options.copy()\n-\n-    separator = ";"\n-    vocabulary = None\n-    vocabulary_view = "@@getVocabulary"\n-    orderable = False\n-\n-    def _view_context(self):\n-        view_context = get_widget_form(self)\n-        # For EditForms and non-Forms (in tests), the vocabulary is looked\n-        # up on the context, otherwise on the view\n-        if IEditForm.providedBy(view_context):\n-            if self.is_subform_widget():\n-                view_context = self.form.parentForm.context\n-            elif not ISimpleItem.providedBy(self.context):\n-                view_context = self.form.context\n-            else:\n-                view_context = self.context\n-        elif not IForm.providedBy(view_context):\n-            view_context = self.context\n-        return view_context\n-\n-    def get_vocabulary(self):\n-        if self.vocabulary and isinstance(self.vocabulary, str):\n-            factory = queryUtility(\n-                IVocabularyFactory,\n-                self.vocabulary,\n-            )\n-            if factory:\n-                return factory(self._view_context())\n-        return self.vocabulary\n-\n-    def display_items(self):\n-        if self.value:\n-            tokens = self.value.split(self.separator)\n-            vocabulary = self.get_vocabulary()\n-            for token in tokens:\n-                item = {"token": token, "title": token}\n-                if vocabulary is not None:\n-                    try:\n-                        item["title"] = vocabulary.getTermByToken(token).title\n-                    except LookupError:\n-                        pass\n-                yield item\n-\n-    def has_multiple_values(self):\n-        return self.value and self.value.split(self.separator)\n-\n-    def _ajaxselect_options(self):\n-        options = {\n-            "separator": self.separator,\n-        }\n-        if self.vocabulary:\n-            options["vocabularyUrl"] = "{}/{}?name={}".format(\n-                get_context_url(self._view_context()),\n-                self.vocabulary_view,\n-                self.vocabulary,\n-            )\n-            field_name = self.field and self.field.__name__ or None\n-            if field_name:\n-                options["vocabularyUrl"] += f"&field={field_name}"\n-            vocabulary = self.get_vocabulary()\n-            if vocabulary is not None and self.value:\n-                options["initialValues"] = dict()\n-                for token in self.value.split(self.separator):\n-                    try:\n-                        term = vocabulary.getTermByToken(token)\n-                        options["initialValues"][term.token] = term.title\n-                    except LookupError:\n-                        options["initialValues"][token] = token\n-\n-        return options\n-\n-    def update(self):\n-        super().update()\n-        field = getattr(self, "field", None)\n-        field = getattr(field, "value_type", field)\n-        if (\n-            not self.vocabulary\n-            and field is not None\n-            and getattr(field, "vocabularyName", None)\n-        ):\n-            self.vocabulary = field.vocabularyName\n-\n-    def _base_args(self):\n-        """Method which will calculate _base class arguments.\n-\n-        Returns (as python dictionary):\n-            - `pattern`: pattern name\n-            - `pattern_options`: pattern options\n-            - `name`: field name\n-            - `value`: field value\n-\n-        :returns: Arguments which will be passed to _base\n-        :rtype: dict\n-        """\n-        args = super()._base_args()\n-        args["name"] = self.name\n-        args["value"] = self.value\n-        args.setdefault("pattern_options", {})\n-        context = self.context\n-        field = None\n-\n-        if IChoice.providedBy(self.field):\n-            args["pattern_options"]["maximumSelectionSize"] = 1\n-            field = self.field\n-        elif ICollection.providedBy(self.field):\n-            field = self.field.value_type\n-        if IChoice.providedBy(field):\n-            args["pattern_options"]["allowNewItems"] = "false"\n-\n-        args["pattern_options"] = dict_merge(\n-            self._ajaxselect_options(), args["pattern_options"]\n-        )\n-\n-        if field and getattr(field, "vocabulary", None):\n-            form_url = self.request.getURL()\n-            source_url = "{:s}/++widget++{:s}/@@getSource".format(\n-                form_url,\n-                self.name,\n-            )\n-            args["pattern_options"]["vocabularyUrl"] = source_url\n-\n-        # ISequence represents an orderable collection\n-        if ISequence.providedBy(self.field) or self.orderable:\n-            args["pattern_options"]["orderable"] = True\n-\n-        if self.vocabulary == "plone.app.vocabularies.Keywords":\n-            membership = getToolByName(context, "portal_membership")\n-            user = membership.getAuthenticatedMember()\n-\n-            registry = getUtility(IRegistry)\n-            roles_allowed_to_add_keywords = registry.get(\n-                "plone.roles_allowed_to_add_keywords", set()\n-            )\n-            roles = set(user.getRolesInContext(context))\n-            allowNewItems = bool(\n-                roles.intersection(roles_allowed_to_add_keywords),\n-            )\n-            args["pattern_options"]["allowNewItems"] = str(\n-                allowNewItems,\n-            ).lower()\n-\n-        return args\n-\n-\n-@implementer_only(IRelatedItemsWidget)\n-class RelatedItemsWidget(BaseWidget, z3cform_TextWidget):\n-    """RelatedItems widget for z3c.form."""\n-\n-    _base = InputWidget\n-\n-    pattern = "relateditems"\n-    pattern_options = BaseWidget.pattern_options.copy()\n-\n-    separator = ";"\n-    vocabulary = None\n-    vocabulary_override = False\n-    vocabulary_view = "@@getVocabulary"\n-    orderable = False\n-\n-    def update(self):\n-        super().update()\n-        field = getattr(self, "field", None)\n-        if ICollection.providedBy(self.field):\n-            field = self.field.value_type\n-        if (\n-            not self.vocabulary\n-            and field is not None\n-            and getattr(field, "vocabularyName", None)\n-        ):\n-            self.vocabulary = field.vocabularyName\n-            self.vocabulary_override = True\n-        else:\n-            self.vocabulary = "plone.app.vocabularies.Catalog"\n-\n-    def _base_args(self):\n-        """Method which will calculate _base class arguments.\n-\n-        Returns (as python dictionary):\n-            - `pattern`: pattern name\n-            - `pattern_options`: pattern options\n-            - `name`: field name\n-            - `value`: field value\n-\n-        :returns: Arguments which will be passed to _base\n-        :rtype: dict\n-        """\n-        args = super()._base_args()\n-\n-        args["name"] = self.name\n-        args["value"] = self.value\n-        args.setdefault("pattern_options", {})\n-\n-        field = None\n-        if IChoice.providedBy(self.field):\n-            args["pattern_options"]["maximumSelectionSize"] = 1\n-            field = self.field\n-        elif ICollection.providedBy(self.field):\n-            field = self.field.value_type\n-\n-        vocabulary_name = self.vocabulary\n-\n-        field_name = self.field and self.field.__name__ or None\n-\n-        context = self.context\n-        view_context = get_widget_form(self)\n-        # For EditForms and non-Forms (in tests), the vocabulary is looked\n-        # up on the context, otherwise on the view\n-        if IEditForm.providedBy(view_context):\n-            if self.is_subform_widget():\n-                view_context = self.form.parentForm.context\n-            elif not ISimpleItem.providedBy(context):\n-                view_context = self.form.context\n-            else:\n-                view_context = context\n-        elif not IForm.providedBy(view_context):\n-            view_context = context\n-        else:\n-            pass\n-            # view_context is defined above already\n-\n-        root_search_mode = (\n-            args["pattern_options"].get("mode", None)\n-            and "basePath" not in args["pattern_options"]\n-        )\n-\n-        args["pattern_options"] = dict_merge(\n-            get_relateditems_options(\n-                view_context,\n-                args["value"],\n-                self.separator,\n-                vocabulary_name,\n-                self.vocabulary_view,\n-                field_name,\n-            ),\n-            args["pattern_options"],\n-        )\n-        if root_search_mode:\n-            # Delete default basePath option in search mode, when no basePath\n-            # was explicitly set.\n-            del args["pattern_options"]["basePath"]\n-        if (\n-            not self.vocabulary_override\n-            and field\n-            and getattr(field, "vocabulary", None)\n-        ):\n-            # widget vocab takes precedence over field\n-            form_url = self.request.getURL()\n-            source_url = "{:s}/++widget++{:s}/@@getSource".format(\n-                form_url,\n-                self.name,\n-            )\n-            args["pattern_options"]["vocabularyUrl"] = source_url\n-\n-        return args\n-\n-    def items(self):\n-        """Return item for the widget values for the display template\n-\n-        Query the catalog for the widget-value (uuids) to only display items\n-        that the user is allowed to see. Accessing the value with e.g.\n-        getattr(self.context, self.__name__) would yield the items unfiltered.\n-        Uses IContentListing for easy access to MimeTypeIcon and more.\n-        """\n-        results = []\n-        if not self.value:\n-            return results\n-        separator = getattr(self, "separator", ";")\n-        uuids = self.value.split(separator)\n-\n-        try:\n-            catalog = getToolByName(self.context, "portal_catalog")\n-        except AttributeError:\n-            catalog = getToolByName(getSite(), "portal_catalog")\n-\n-        brains = catalog(UID=uuids)\n-        # restore original order\n-        results = sorted(brains, key=lambda brain: uuids.index(brain.UID))\n-        return IContentListing(results)\n-\n-\n-@implementer_only(IQueryStringWidget)\n-class QueryStringWidget(BaseWidget, z3cform_TextWidget):\n-    """QueryString widget for z3c.form."""\n-\n-    _base = InputWidget\n-\n-    pattern = "querystring"\n-    pattern_options = BaseWidget.pattern_options.copy()\n-\n-    querystring_view = "@@qsOptions"\n-\n-    def _base_args(self):\n-        """Method which will calculate _base class arguments.\n-\n-        Returns (as python dictionary):\n-            - `pattern`: pattern name\n-            - `pattern_options`: pattern options\n-            - `name`: field name\n-            - `value`: field value\n-\n-        :returns: Arguments which will be passed to _base\n-        :rtype: dict\n-        """\n-        args = super()._base_args()\n-        args["name"] = self.name\n-        args["value"] = self.value\n-\n-        args.setdefault("pattern_options", {})\n-        args["pattern_options"] = dict_merge(\n-            get_querystring_options(self.context, self.querystring_view),\n-            args["pattern_options"],\n-        )\n-\n-        return args\n-\n-\n-@implementer_only(IRichTextWidget)\n-class RichTextWidget(BaseWidget, patext_RichTextWidget):\n-    """TinyMCE widget for z3c.form."""\n-\n-    _base = TextareaWidget\n-\n-    pattern_options = BaseWidget.pattern_options.copy()\n-\n-    def __init__(self, *args, **kwargs):\n-        super().__init__(*args, **kwargs)\n-        self._pattern = None\n-\n-    def wrapped_context(self):\n-        """ "We need to wrap the context to be able to acquire the root\n-        of the site to get tools, as done in plone.app.textfield"""\n-        context = self.context\n-        content = closest_content(context)\n-        if context.__class__ == dict:\n-            context = UserDict(self.context)\n-        return ImplicitAcquisitionWrapper(context, content)\n-\n-    @property\n-    def pattern(self):\n-        """dynamically grab the actual pattern name so it will\n-        work with custom visual editors"""\n-        if self._pattern is None:\n-            self._pattern = self.getWysiwygEditor()\n-        return self._pattern\n-\n-    def _base_args(self):\n-        args = super()._base_args()\n-        args["name"] = self.name\n-        value = self.value and self.value.raw or ""\n-        value = self.request.get(self.name, value)\n-        args["value"] = value\n-\n-        args.setdefault("pattern_options", {})\n-        merged_options = dict_merge(\n-            get_tinymce_options(\n-                self.wrapped_context(),\n-                self.field,\n-                self.request,\n-            ),\n-            args["pattern_options"],\n-        )\n-        args["pattern_options"] = merged_options\n-\n-        return args\n-\n-    def render(self):\n-        """Render widget.\n-\n-        :returns: Widget\'s HTML.\n-        :rtype: string\n-        """\n-        if self.mode != "display":\n-            renderer = queryUtility(\n-                IRichTextWidgetInputModeRenderer,\n-                name=self.getWysiwygEditor(),\n-                default=tinymce_richtextwidget_render,\n-            )\n-            return renderer(self)\n-\n-        if not self.value:\n-            return ""\n-\n-        if isinstance(self.value, RichTextValue):\n-            return self.value.output_relative_to(self.context)\n-\n-        return super().render()\n-\n-    def render_input_mode(self):\n-        # MODE "INPUT"\n-        rendered = ""\n-        allowed_mime_types = self.allowedMimeTypes()\n-        if not allowed_mime_types or len(allowed_mime_types) <= 1:\n-            # Display textarea with default widget\n-            rendered = super().render()\n-        else:\n-            # Let pat-textarea-mimetype-selector choose the widget\n-\n-            # Initialize the widget without a pattern\n-            base_args = self._base_args()\n-            pattern_options = base_args["pattern_options"]\n-            del base_args["pattern"]\n-            del base_args["pattern_options"]\n-            textarea_widget = self._base(None, None, **base_args)\n-            textarea_widget.klass = "form-control"\n-            mt_pattern_name = "{}{}".format(\n-                self._base._klass_prefix,\n-                "textareamimetypeselector",\n-            )\n-\n-            # Initialize mimetype selector pattern\n-            # TODO: default_mime_type returns \'text/html\', regardless of\n-            # settings. fix in plone.app.textfield\n-            value_mime_type = (\n-                self.value.mimeType if self.value else self.field.default_mime_type\n-            )\n-            mt_select = etree.Element("select")\n-            mt_select.attrib["id"] = f"{self.id}_text_format"\n-            mt_select.attrib["name"] = f"{self.name}.mimeType"\n-            mt_select.attrib["class"] = f"form-select {mt_pattern_name}"\n-            mt_select.attrib[f"data-{mt_pattern_name}"] = json.dumps(\n-                {\n-                    "textareaName": self.name,\n-                    "widgets": {\n-                        "text/html": {  # TODO: currently, we only support\n-                            # richtext widget config for\n-                            # \'text/html\', no other mimetypes.\n-                            "pattern": self.pattern,\n-                            "patternOptions": pattern_options,\n-                        },\n-                    },\n-                },\n-            )\n-\n-            # Create a list of allowed mime types\n-            for mt in allowed_mime_types:\n-                opt = etree.Element("option")\n-                opt.attrib["value"] = mt\n-                if value_mime_type == mt:\n-                    opt.attrib["selected"] = "selected"\n-                opt.text = mt\n-                mt_select.append(opt)\n-\n-            # Render the combined widget\n-            rendered = "{}\\n{}".format(\n-                textarea_widget.render(),\n-                etree.tostring(mt_select, encoding="unicode"),\n-            )\n-        return rendered\n-\n-\n-def tinymce_richtextwidget_render(widget):\n-    return RichTextWidget.render_input_mode(widget)\n-\n-\n-@implementer_only(ILinkWidget)\n-class LinkWidget(z3cform_TextWidget):\n-    """Implementation of enhanced link widget.\n-\n-    .. note::\n-        Unlike the others here, this is not a plone.app.widgets based widget\n-        and it uses it\'s own template.\n-    """\n-\n-    def pattern_data(self):\n-        pattern_data = {\n-            "vocabularyUrl": "{}/@@getVocabulary?name=plone.app.vocabularies.Catalog".format(  # noqa\n-                getSite().absolute_url(0),\n-            ),\n-            "maximumSelectionSize": 1,\n-        }\n-        return json.dumps(pattern_data)\n-\n-    def extract(self, default=NO_VALUE):\n-        form = self.request.form\n-        internal = form.get(self.name + ".internal")\n-        external = form.get(self.name + ".external")\n-        email = form.get(self.name + ".email")\n-        if internal:\n-            url = "${portal_url}/resolveuid/" + internal\n-        elif email:\n-            subject = form.get(self.name + ".subject")\n-            if email[:7] != "mailto:":\n-                email = "mailto:" + email\n-            if not subject:\n-                url = email\n-            else:\n-                url = "{email}?subject={subject}".format(\n-                    email=email,\n-                    subject=subject,\n-                )\n-        else:\n-            url = external  # the default is `http://` so we land here\n-        if url:\n-            self.request.form[self.name] = safe_text(url)\n-        return super().extract(default=default)\n-\n-\n-@implementer(IFieldWidget)\n-def DateFieldWidget(field, request):\n-    return FieldWidget(field, DateWidget(request))\n-\n-\n-@implementer(IFieldWidget)\n-def DatetimeFieldWidget(field, request):\n-    return FieldWidget(field, DatetimeWidget(request))\n-\n-\n-@implementer(IFieldWidget)\n-def TimeFieldWidget(field, request):\n-    return FieldWidget(field, TimeWidget(request))\n-\n-\n-@implementer(IFieldWidget)\n-def SelectFieldWidget(field, request):\n-    return FieldWidget(field, SelectWidget(request))\n-\n-\n-@implementer(IFieldWidget)\n-def AjaxSelectFieldWidget(field, request, extra=None):\n-    if extra is not None:\n-        request = extra\n-    return FieldWidget(field, AjaxSelectWidget(request))\n-\n-\n-@implementer(IFieldWidget)\n-def RelatedItemsFieldWidget(field, request, extra=None):\n-    if extra is not None:\n-        request = extra\n-    return FieldWidget(field, RelatedItemsWidget(request))\n-\n-\n-@implementer(IFieldWidget)\n-def RichTextFieldWidget(field, request):\n-    return FieldWidget(field, RichTextWidget(request))\n-\n-\n-@implementer(IFieldWidget)\n-def QueryStringFieldWidget(field, request, extra=None):\n-    if extra is not None:\n-        request = extra\n-    return FieldWidget(field, QueryStringWidget(request))\n-\n-\n-@implementer(IFieldWidget)\n-def LinkFieldWidget(field, request):\n-    return FieldWidget(field, LinkWidget(request))\n-\n-\n-@implementer_only(ISingleCheckBoxBoolWidget)\n-class SingleCheckBoxBoolWidget(SingleCheckBoxWidget):\n-    """Single Input type checkbox widget implementation."""\n-\n-    klass = "single-checkbox-bool-widget"\n-\n-    @property\n-    def label(self):\n-        if self.mode == "input":\n-            return ""\n-        return getattr(self, "_label", "")\n-\n-    @label.setter\n-    def label(self, value):\n-        self._label = value\n-\n-    @property\n-    def description(self):\n-        if self.mode == "input":\n-            return ""\n-        return getattr(self, "_description", "")\n-\n-    @description.setter\n-    def description(self, value):\n-        self._description = value\n-\n-    def updateTerms(self):\n-        if self.mode == "input":\n-            # in input mode use only one checkbox with true\n-            self.terms = Terms()\n-            self.terms.terms = SimpleVocabulary(\n-                (\n-                    TermWithDescription(\n-                        True,\n-                        "selected",\n-                        getattr(self, "_label", None) or self.field.title,\n-                        getattr(\n-                            self,\n-                            "_description",\n-                            None,\n-                        )\n-                        or self.field.description,\n-                    ),\n-                )\n-            )\n-            return self.terms\n-        if not self.terms:\n-            self.terms = Terms()\n-            self.terms.terms = SimpleVocabulary(\n-                [\n-                    SimpleTerm(*args)\n-                    for args in [\n-                        (True, "selected", BoolTerms.trueLabel),\n-                        (False, "unselected", BoolTerms.falseLabel),\n-                    ]\n-                ],\n-            )\n-        return self.terms\n-\n-    @property\n-    def items(self):\n-        result = super().items\n-        for record in result:\n-            term = self.terms.terms.getTermByToken(record["value"])\n-            record["description"] = getattr(term, "description", "")\n-            record["required"] = self.required\n-        return result\n-\n-\n-@adapter(IBool, IPloneFormLayer)\n-@implementer(IFieldWidget)\n-def SingleCheckBoxBoolFieldWidget(field, request):\n-    """IFieldWidget factory for CheckBoxWidget."""\n-    return FieldWidget(field, SingleCheckBoxBoolWidget(request))\n+from zope.deferredimport import deprecated as deprecated_import\n+\n+\n+deprecated_import(\n+    "Import from plone.app.z3cform.converters instead (will be removed in Plone 7)",\n+    DatetimeWidgetConverter=\'plone.app.z3cform.converters:DatetimeWidgetConverter\',\n+    DateWidgetConverter=\'plone.app.z3cform.converters:DateWidgetConverter\',\n+)\n+\n+deprecated_import(\n+    "Import from plone.app.z3cform.widgets.base instead (will be removed in Plone 7)",\n+    BaseWidget=\'plone.app.z3cform.widgets.base:BaseWidget\',\n+)\n+\n+deprecated_import(\n+    "Import from plone.app.z3cform.widgets.datetime instead (will be removed in Plone 7)",\n+    DateFieldWidget=\'plone.app.z3cform.widgets.datetime:DateFieldWidget\',\n+    DatetimeFieldWidget=\'plone.app.z3cform.widgets.datetime:DatetimeFieldWidget\',\n+    DatetimeWidget=\'plone.app.z3cform.widgets.datetime:DatetimeWidget\',\n+    DateWidget=\'plone.app.z3cform.widgets.datetime:DateWidget\',\n+    TimeFieldWidget=\'plone.app.z3cform.widgets.datetime:TimeFieldWidget\',\n+    TimeWidget=\'plone.app.z3cform.widgets.datetime:TimeWidget\',\n+)\n+\n+deprecated_import(\n+    "Import from plone.app.z3cform.widgets.link instead (will be removed in Plone 7)",\n+    LinkFieldWidget=\'plone.app.z3cform.widgets.link:LinkFieldWidget\',\n+    LinkWidget=\'plone.app.z3cform.widgets.link:LinkWidget\',\n+)\n+\n+deprecated_import(\n+    "Import from plone.app.z3cform.widgets.querystring instead (will be removed in Plone 7)",\n+    QueryStringFieldWidget=\'plone.app.z3cform.widgets.querystring:QueryStringFieldWidget\',\n+    QueryStringWidget=\'plone.app.z3cform.widgets.querystring:QueryStringWidget\',\n+)\n+\n+deprecated_import(\n+    "Import from plone.app.z3cform.widgets.relateditems instead (will be removed in Plone 7)",\n+    RelatedItemsFieldWidget=\'plone.app.z3cform.widgets.relateditems:RelatedItemsFieldWidget\',\n+    RelatedItemsWidget=\'plone.app.z3cform.widgets.relateditems:RelatedItemsWidget\',\n+)\n+\n+deprecated_import(\n+    "Import from plone.app.z3cform.widgets.richtext instead (will be removed in Plone 7)",\n+    RichTextFieldWidget=\'plone.app.z3cform.widgets.richtext:RichTextFieldWidget\',\n+    RichTextWidget=\'plone.app.z3cform.widgets.richtext:RichTextWidget\',\n+)\n+\n+deprecated_import(\n+    "Import from plone.app.z3cform.widgets.select instead (will be removed in Plone 7)",\n+    AjaxSelectFieldWidget=\'plone.app.z3cform.widgets.select:AjaxSelectFieldWidget\',\n+    AjaxSelectWidget=\'plone.app.z3cform.widgets.select:AjaxSelectWidget\',\n+    SelectFieldWidget=\'plone.app.z3cform.widgets.select:SelectFieldWidget\',\n+    SelectWidget=\'plone.app.z3cform.widgets.select:SelectWidget\',\n+)\n+\n+deprecated_import(\n+    "Import from plone.app.z3cform.widgets.singlecheckbox instead (will be removed in Plone 7)",\n+    SingleCheckBoxBoolFieldWidget=\'plone.app.z3cform.widgets.singlecheckbox:SingleCheckBoxBoolFieldWidget\',\n+    SingleCheckBoxBoolWidget=\'plone.app.z3cform.widgets.singlecheckbox:SingleCheckBoxBoolWidget\',\n+    SingleCheckBoxWidget=\'plone.app.z3cform.widgets.singlecheckbox:SingleCheckBoxWidget\',\n+)\ndiff --git a/plone/app/z3cform/widget.zcml b/plone/app/z3cform/widget.zcml\ndeleted file mode 100644\nindex ed453f03..00000000\n--- a/plone/app/z3cform/widget.zcml\n+++ /dev/null\n@@ -1,300 +0,0 @@\n-<configure\n-    xmlns="http://namespaces.zope.org/zope"\n-    xmlns:z3c="http://namespaces.zope.org/z3c"\n-    i18n_domain="plone"\n-    >\n-\n-  <!-- Make the default widget for sequence-of-text-lines a textlines\n-       widget; the default is too confusing -->\n-\n-  <adapter\n-      factory="plone.z3cform.textlines.textlines.TextLinesFieldWidgetFactory"\n-      provides="z3c.form.interfaces.IFieldWidget"\n-      for="zope.schema.interfaces.IList\n-           zope.schema.interfaces.ITextLine\n-           plone.app.z3cform.interfaces.IPloneFormLayer"\n-      />\n-  <adapter\n-      factory="plone.z3cform.textlines.textlines.TextLinesFieldWidgetFactory"\n-      provides="z3c.form.interfaces.IFieldWidget"\n-      for="zope.schema.interfaces.ITuple\n-           zope.schema.interfaces.ITextLine\n-           plone.app.z3cform.interfaces.IPloneFormLayer"\n-      />\n-  <adapter\n-      factory="plone.z3cform.textlines.textlines.TextLinesFieldWidgetFactory"\n-      provides="z3c.form.interfaces.IFieldWidget"\n-      for="zope.schema.interfaces.IAbstractSet\n-           zope.schema.interfaces.ITextLine\n-           plone.app.z3cform.interfaces.IPloneFormLayer"\n-      />\n-\n-  <adapter\n-      factory="plone.z3cform.textlines.textlines.TextLinesFieldWidgetFactory"\n-      provides="z3c.form.interfaces.IFieldWidget"\n-      for="zope.schema.interfaces.IList\n-           zope.schema.interfaces.IASCIILine\n-           plone.app.z3cform.interfaces.IPloneFormLayer"\n-      />\n-  <adapter\n-      factory="plone.z3cform.textlines.textlines.TextLinesFieldWidgetFactory"\n-      provides="z3c.form.interfaces.IFieldWidget"\n-      for="zope.schema.interfaces.ITuple\n-           zope.schema.interfaces.IASCIILine\n-           plone.app.z3cform.interfaces.IPloneFormLayer"\n-      />\n-  <adapter\n-      factory="plone.z3cform.textlines.textlines.TextLinesFieldWidgetFactory"\n-      provides="z3c.form.interfaces.IFieldWidget"\n-      for="zope.schema.interfaces.IAbstractSet\n-           zope.schema.interfaces.IASCIILine\n-           plone.app.z3cform.interfaces.IPloneFormLayer"\n-      />\n-\n-  <adapter\n-      factory=".widget.SingleCheckBoxBoolFieldWidget"\n-      for="zope.schema.interfaces.IBool\n-           .interfaces.IPloneFormLayer"\n-      />\n-  <adapter factory=".converters.BoolSingleCheckboxDataConverter" />\n-\n-  <z3c:widgetTemplate\n-      field="zope.schema.interfaces.IBool"\n-      widget=".interfaces.ISingleCheckBoxBoolWidget"\n-      template="templates/singlecheckboxbool_display.pt"\n-      layer=".interfaces.IPloneFormLayer"\n-      mode="display"\n-      />\n-  <z3c:widgetTemplate\n-      field="zope.schema.interfaces.IBool"\n-      widget=".interfaces.ISingleCheckBoxBoolWidget"\n-      template="templates/singlecheckboxbool_input.pt"\n-      layer=".interfaces.IPloneFormLayer"\n-      mode="input"\n-      />\n-  <z3c:widgetTemplate\n-      field="*"\n-      widget=".interfaces.IAjaxSelectWidget"\n-      template="templates/ajaxselect_display.pt"\n-      layer=".interfaces.IPloneFormLayer"\n-      mode="display"\n-      />\n-  <z3c:widgetTemplate\n-      field="zope.schema.interfaces.IBool"\n-      widget=".interfaces.ISingleCheckBoxBoolWidget"\n-      template="templates/singlecheckboxbool_hidden.pt"\n-      layer=".interfaces.IPloneFormLayer"\n-      mode="hidden"\n-      />\n-\n-  <z3c:widgetTemplate\n-      widget="z3c.form.interfaces.IMultiWidget"\n-      template="templates/multi_input.pt"\n-      layer=".interfaces.IPloneFormLayer"\n-      mode="input"\n-      />\n-\n-  <z3c:widgetTemplate\n-      widget="z3c.form.interfaces.IObjectWidget"\n-      template="templates/object_input.pt"\n-      layer=".interfaces.IPloneFormLayer"\n-      mode="input"\n-      />\n-\n-  <z3c:widgetTemplate\n-      widget=".interfaces.ILinkWidget"\n-      template="templates/link_input.pt"\n-      layer=".interfaces.IPloneFormLayer"\n-      mode="input"\n-      />\n-\n-  <z3c:widgetTemplate\n-      widget=".interfaces.IRelatedItemsWidget"\n-      template="templates/relateditems_display.pt"\n-      layer=".interfaces.IPloneFormLayer"\n-      mode="display"\n-      />\n-\n-  <!-- widget registration stuff -->\n-  <class class=".widget.DateWidget">\n-    <require\n-        permission="zope.Public"\n-        interface=".interfaces.IDateWidget"\n-        />\n-  </class>\n-\n-  <adapter\n-      factory=".widget.DateFieldWidget"\n-      for="zope.schema.interfaces.IDate\n-           plone.app.z3cform.interfaces.IPloneFormLayer"\n-      />\n-\n-  <class class=".widget.DatetimeWidget">\n-    <require\n-        permission="zope.Public"\n-        interface=".interfaces.IDatetimeWidget"\n-        />\n-  </class>\n-\n-  <adapter\n-      factory=".widget.DatetimeFieldWidget"\n-      for="zope.schema.interfaces.IDatetime\n-           plone.app.z3cform.interfaces.IPloneFormLayer"\n-      />\n-\n-  <class class=".widget.TimeWidget">\n-    <require\n-        permission="zope.Public"\n-        interface=".interfaces.ITimeWidget"\n-        />\n-  </class>\n-\n-  <adapter\n-      factory=".widget.TimeFieldWidget"\n-      for="zope.schema.interfaces.ITime\n-           plone.app.z3cform.interfaces.IPloneFormLayer"\n-      />\n-\n-  <adapter\n-      factory=".widget.RelatedItemsFieldWidget"\n-      for="z3c.relationfield.interfaces.IRelationChoice\n-           plone.app.z3cform.interfaces.IPloneFormLayer"\n-      />\n-\n-  <adapter\n-      factory=".widget.RelatedItemsFieldWidget"\n-      for="z3c.relationfield.interfaces.IRelationList\n-           plone.app.z3cform.interfaces.IPloneFormLayer"\n-      />\n-\n-  <adapter\n-      factory=".widget.RelatedItemsFieldWidget"\n-      for="zope.schema.interfaces.IChoice\n-           plone.app.vocabularies.catalog.CatalogSource\n-           plone.app.z3cform.interfaces.IPloneFormLayer"\n-      />\n-\n-  <adapter\n-      factory=".widget.QueryStringFieldWidget"\n-      for="zope.schema.interfaces.IList\n-           zope.schema.interfaces.IDict\n-           plone.app.z3cform.interfaces.IPloneFormLayer"\n-      />\n-\n-  <adapter\n-      factory=".widget.RichTextFieldWidget"\n-      for="plone.app.textfield.interfaces.IRichText\n-           plone.app.z3cform.interfaces.IPloneFormLayer"\n-      />\n-\n-  <adapter\n-      factory=".widget.LinkFieldWidget"\n-      for="z3c.form.interfaces.ITextWidget\n-           plone.app.z3cform.interfaces.IPloneFormLayer"\n-      />\n-\n-  <!-- z3c.form overrides -->\n-\n-  <z3c:widgetTemplate\n-      widget="z3c.form.interfaces.ITextWidget"\n-      template="templates/text_input.pt"\n-      layer=".interfaces.IPloneFormLayer"\n-      mode="input"\n-      />\n-\n-  <z3c:widgetTemplate\n-      field="zope.schema.interfaces.IDatetime"\n-      widget=".interfaces.IDatetimeWidget"\n-      template="templates/text_input.pt"\n-      layer=".interfaces.IPloneFormLayer"\n-      mode="input"\n-      />\n-\n-  <z3c:widgetTemplate\n-      widget="z3c.form.interfaces.ITextAreaWidget"\n-      template="templates/textarea_input.pt"\n-      layer=".interfaces.IPloneFormLayer"\n-      mode="input"\n-      />\n-\n-  <z3c:widgetTemplate\n-      widget="z3c.form.interfaces.ISelectWidget"\n-      template="templates/select_input.pt"\n-      layer=".interfaces.IPloneFormLayer"\n-      mode="input"\n-      />\n-\n-  <z3c:widgetTemplate\n-      widget="z3c.form.interfaces.IOrderedSelectWidget"\n-      template="templates/orderedselect_input.pt"\n-      layer=".interfaces.IPloneFormLayer"\n-      mode="input"\n-      />\n-\n-  <z3c:widgetTemplate\n-      widget="z3c.form.interfaces.IRadioWidget"\n-      template="templates/radio_input.pt"\n-      layer=".interfaces.IPloneFormLayer"\n-      mode="input"\n-      />\n-\n-  <z3c:widgetTemplate\n-      widget="z3c.form.interfaces.IRadioWidget"\n-      template="templates/radio_input_single.pt"\n-      layer=".interfaces.IPloneFormLayer"\n-      mode="input_single"\n-      />\n-\n-  <z3c:widgetTemplate\n-      widget="z3c.form.interfaces.ISubmitWidget"\n-      template="templates/submit_input.pt"\n-      layer=".interfaces.IPloneFormLayer"\n-      mode="input"\n-      />\n-\n-  <z3c:widgetTemplate\n-      widget="z3c.form.interfaces.ICheckBoxWidget"\n-      template="templates/checkbox_input.pt"\n-      layer=".interfaces.IPloneFormLayer"\n-      mode="input"\n-      />\n-\n-  <z3c:widgetTemplate\n-      widget="z3c.form.interfaces.IPasswordWidget"\n-      template="templates/password_input.pt"\n-      layer=".interfaces.IPloneFormLayer"\n-      mode="input"\n-      />\n-\n-  <!-- plone.formwidget.namedfile -->\n-  <z3c:widgetTemplate\n-      widget="plone.formwidget.namedfile.interfaces.INamedFileWidget"\n-      template="templates/file_input.pt"\n-      layer=".interfaces.IPloneFormLayer"\n-      mode="input"\n-      />\n-\n-  <z3c:widgetTemplate\n-      widget="plone.formwidget.namedfile.interfaces.INamedImageWidget"\n-      template="templates/image_input.pt"\n-      layer=".interfaces.IPloneFormLayer"\n-      mode="input"\n-      />\n-\n-  <!-- plone.z3cform.textlines -->\n-  <z3c:widgetTemplate\n-      widget="plone.z3cform.textlines.textlines.ITextLinesWidget"\n-      template="templates/textlines_input.pt"\n-      layer=".interfaces.IPloneFormLayer"\n-      mode="input"\n-      />\n-\n-  <!-- plone.app.textfield -->\n-  <z3c:widgetTemplate\n-      widget="plone.app.textfield.widget.IRichTextWidget"\n-      template="templates/textfield_widget_input.pt"\n-      layer=".interfaces.IPloneFormLayer"\n-      mode="input"\n-      />\n-\n-</configure>\ndiff --git a/plone/app/z3cform/widgets.zcml b/plone/app/z3cform/widgets.zcml\nnew file mode 100644\nindex 00000000..ce185633\n--- /dev/null\n+++ b/plone/app/z3cform/widgets.zcml\n@@ -0,0 +1,297 @@\n+<configure\n+    xmlns="http://namespaces.zope.org/zope"\n+    xmlns:z3c="http://namespaces.zope.org/z3c">\n+\n+    <!-- Make the default widget for sequence-of-text-lines a textlines\n+       widget; the default is too confusing -->\n+\n+    <adapter\n+        factory="plone.z3cform.textlines.textlines.TextLinesFieldWidgetFactory"\n+        provides="z3c.form.interfaces.IFieldWidget"\n+        for="zope.schema.interfaces.IList\n+            zope.schema.interfaces.ITextLine\n+            plone.app.z3cform.interfaces.IPloneFormLayer" />\n+\n+    <adapter\n+        factory="plone.z3cform.textlines.textlines.TextLinesFieldWidgetFactory"\n+        provides="z3c.form.interfaces.IFieldWidget"\n+        for="zope.schema.interfaces.ITuple\n+            zope.schema.interfaces.ITextLine\n+            plone.app.z3cform.interfaces.IPloneFormLayer" />\n+\n+    <adapter\n+        factory="plone.z3cform.textlines.textlines.TextLinesFieldWidgetFactory"\n+        provides="z3c.form.interfaces.IFieldWidget"\n+        for="zope.schema.interfaces.IAbstractSet\n+            zope.schema.interfaces.ITextLine\n+            plone.app.z3cform.interfaces.IPloneFormLayer"\n+        />\n+\n+    <adapter\n+        factory="plone.z3cform.textlines.textlines.TextLinesFieldWidgetFactory"\n+        provides="z3c.form.interfaces.IFieldWidget"\n+        for="zope.schema.interfaces.IList\n+            zope.schema.interfaces.IASCIILine\n+            plone.app.z3cform.interfaces.IPloneFormLayer"\n+        />\n+\n+    <adapter\n+        factory="plone.z3cform.textlines.textlines.TextLinesFieldWidgetFactory"\n+        provides="z3c.form.interfaces.IFieldWidget"\n+        for="zope.schema.interfaces.ITuple\n+            zope.schema.interfaces.IASCIILine\n+            plone.app.z3cform.interfaces.IPloneFormLayer"\n+        />\n+    <adapter\n+        factory="plone.z3cform.textlines.textlines.TextLinesFieldWidgetFactory"\n+        provides="z3c.form.interfaces.IFieldWidget"\n+        for="zope.schema.interfaces.IAbstractSet\n+            zope.schema.interfaces.IASCIILine\n+            plone.app.z3cform.interfaces.IPloneFormLayer"\n+        />\n+\n+    <!-- single checkbox boolean -->\n+    <adapter\n+        factory=".widgets.singlecheckbox.SingleCheckBoxBoolFieldWidget"\n+        for="zope.schema.interfaces.IBool\n+            .interfaces.IPloneFormLayer"\n+        />\n+\n+    <z3c:widgetTemplate\n+        mode="display"\n+        field="zope.schema.interfaces.IBool"\n+        widget=".interfaces.ISingleCheckBoxBoolWidget"\n+        layer=".interfaces.IPloneFormLayer"\n+        template="templates/singlecheckboxbool_display.pt"\n+        />\n+\n+    <z3c:widgetTemplate\n+        mode="input"\n+        field="zope.schema.interfaces.IBool"\n+        widget=".interfaces.ISingleCheckBoxBoolWidget"\n+        layer=".interfaces.IPloneFormLayer"\n+        template="templates/singlecheckboxbool_input.pt"\n+        />\n+\n+    <!-- ajaxselect -->\n+    <z3c:widgetTemplate\n+        mode="display"\n+        field="*"\n+        widget=".interfaces.IAjaxSelectWidget"\n+        layer=".interfaces.IPloneFormLayer"\n+        template="templates/ajaxselect_display.pt"\n+        />\n+\n+    <z3c:widgetTemplate\n+        mode="hidden"\n+        field="zope.schema.interfaces.IBool"\n+        widget=".interfaces.ISingleCheckBoxBoolWidget"\n+        layer=".interfaces.IPloneFormLayer"\n+        template="templates/singlecheckboxbool_hidden.pt"\n+        />\n+\n+    <!-- multi -->\n+    <z3c:widgetTemplate\n+        mode="input"\n+        widget="z3c.form.interfaces.IMultiWidget"\n+        layer=".interfaces.IPloneFormLayer"\n+        template="templates/multi_input.pt"\n+        />\n+\n+    <!-- object -->\n+    <z3c:widgetTemplate\n+        mode="input"\n+        widget="z3c.form.interfaces.IObjectWidget"\n+        layer=".interfaces.IPloneFormLayer"\n+        template="templates/object_input.pt"\n+        />\n+\n+    <!-- date/time -->\n+    <class class=".widgets.datetime.DateWidget">\n+        <require permission="zope.Public"\n+                interface=".interfaces.IDateWidget" />\n+    </class>\n+\n+    <adapter\n+        factory=".widgets.datetime.DateFieldWidget"\n+        for="zope.schema.interfaces.IDate\n+             plone.app.z3cform.interfaces.IPloneFormLayer" />\n+\n+    <class class=".widgets.datetime.DatetimeWidget">\n+        <require permission="zope.Public"\n+                interface=".interfaces.IDatetimeWidget" />\n+    </class>\n+\n+    <adapter\n+        factory=".widgets.datetime.DatetimeFieldWidget"\n+        for="zope.schema.interfaces.IDatetime\n+            plone.app.z3cform.interfaces.IPloneFormLayer"\n+        />\n+\n+    <class class=".widgets.datetime.TimeWidget">\n+        <require permission="zope.Public"\n+                interface=".interfaces.ITimeWidget" />\n+    </class>\n+\n+    <adapter\n+        factory=".widgets.datetime.TimeFieldWidget"\n+        for="zope.schema.interfaces.ITime\n+            plone.app.z3cform.interfaces.IPloneFormLayer"\n+        />\n+\n+    <!-- relateditems -->\n+\n+    <adapter factory=".widgets.relateditems.RelatedItemsFieldWidget"\n+        for="z3c.relationfield.interfaces.IRelationChoice\n+             plone.app.z3cform.interfaces.IPloneFormLayer" />\n+\n+    <adapter factory=".widgets.relateditems.RelatedItemsFieldWidget"\n+        for="z3c.relationfield.interfaces.IRelationList\n+             plone.app.z3cform.interfaces.IPloneFormLayer" />\n+\n+    <adapter factory=".widgets.relateditems.RelatedItemsFieldWidget"\n+        for="zope.schema.interfaces.IChoice\n+             plone.app.vocabularies.catalog.CatalogSource\n+             plone.app.z3cform.interfaces.IPloneFormLayer" />\n+\n+    <z3c:widgetTemplate\n+        mode="display"\n+        widget=".interfaces.IRelatedItemsWidget"\n+        layer=".interfaces.IPloneFormLayer"\n+        template="templates/relateditems_display.pt"\n+        />\n+\n+    <!-- querystring -->\n+    <adapter factory=".widgets.querystring.QueryStringFieldWidget"\n+            for="zope.schema.interfaces.IList\n+                zope.schema.interfaces.IDict\n+                plone.app.z3cform.interfaces.IPloneFormLayer"/>\n+\n+    <!-- richtext -->\n+    <adapter factory=".widgets.richtext.RichTextFieldWidget"\n+        for="plone.app.textfield.interfaces.IRichText\n+                plone.app.z3cform.interfaces.IPloneFormLayer"/>\n+\n+    <!-- link -->\n+    <adapter factory=".widgets.link.LinkFieldWidget"\n+        for="z3c.form.interfaces.ITextWidget\n+                plone.app.z3cform.interfaces.IPloneFormLayer"/>\n+\n+    <z3c:widgetTemplate\n+        mode="input"\n+        widget=".interfaces.ILinkWidget"\n+        layer=".interfaces.IPloneFormLayer"\n+        template="templates/link_input.pt"\n+        />\n+\n+    <!-- z3c.form overrides -->\n+\n+    <z3c:widgetTemplate\n+        mode="input"\n+        widget="z3c.form.interfaces.ITextWidget"\n+        layer=".interfaces.IPloneFormLayer"\n+        template="templates/text_input.pt"\n+        />\n+\n+    <z3c:widgetTemplate\n+        mode="input"\n+        field="zope.schema.interfaces.IDatetime"\n+        widget=".interfaces.IDatetimeWidget"\n+        layer=".interfaces.IPloneFormLayer"\n+        template="templates/text_input.pt"\n+        />\n+\n+    <z3c:widgetTemplate\n+        mode="input"\n+        widget="z3c.form.interfaces.ITextAreaWidget"\n+        layer=".interfaces.IPloneFormLayer"\n+        template="templates/textarea_input.pt"\n+        />\n+\n+    <z3c:widgetTemplate\n+        mode="input"\n+        widget="z3c.form.interfaces.ISelectWidget"\n+        layer=".interfaces.IPloneFormLayer"\n+        template="templates/select_input.pt"\n+        />\n+\n+    <z3c:widgetTemplate\n+        mode="input"\n+        widget="z3c.form.interfaces.IOrderedSelectWidget"\n+        layer=".interfaces.IPloneFormLayer"\n+        template="templates/orderedselect_input.pt"\n+        />\n+\n+    <z3c:widgetTemplate\n+        mode="input"\n+        widget="z3c.form.interfaces.IRadioWidget"\n+        layer=".interfaces.IPloneFormLayer"\n+        template="templates/radio_input.pt"\n+        />\n+\n+    <z3c:widgetTemplate\n+        mode="input_single"\n+        widget="z3c.form.interfaces.IRadioWidget"\n+        layer=".interfaces.IPloneFormLayer"\n+        template="templates/radio_input_single.pt"\n+        />\n+\n+    <z3c:widgetTemplate\n+        mode="input"\n+        widget="z3c.form.interfaces.ISubmitWidget"\n+        layer=".interfaces.IPloneFormLayer"\n+        template="templates/submit_input.pt"\n+        />\n+\n+    <z3c:widgetTemplate\n+        mode="input"\n+        widget="z3c.form.interfaces.ICheckBoxWidget"\n+        layer=".interfaces.IPloneFormLayer"\n+        template="templates/checkbox_input.pt"\n+        />\n+\n+    <z3c:widgetTemplate\n+        mode="input"\n+        widget="z3c.form.interfaces.IPasswordWidget"\n+        layer=".interfaces.IPloneFormLayer"\n+        template="templates/password_input.pt"\n+        />\n+\n+    <!-- plone.formwidget.namedfile -->\n+    <z3c:widgetTemplate\n+        mode="input"\n+        widget="plone.formwidget.namedfile.interfaces.INamedFileWidget"\n+        layer=".interfaces.IPloneFormLayer"\n+        template="templates/file_input.pt"\n+        />\n+\n+    <z3c:widgetTemplate\n+        mode="input"\n+        widget="plone.formwidget.namedfile.interfaces.INamedImageWidget"\n+        layer=".interfaces.IPloneFormLayer"\n+        template="templates/image_input.pt"\n+        />\n+\n+    <!-- plone.z3cform.textlines -->\n+    <z3c:widgetTemplate\n+        mode="input"\n+        widget="plone.z3cform.textlines.textlines.ITextLinesWidget"\n+        layer=".interfaces.IPloneFormLayer"\n+        template="templates/textlines_input.pt"\n+        />\n+\n+    <!-- plone.app.textfield -->\n+    <z3c:widgetTemplate\n+        mode="input"\n+        widget="plone.app.textfield.widget.IRichTextWidget"\n+        layer=".interfaces.IPloneFormLayer"\n+        template="templates/textfield_widget_input.pt"\n+        />\n+\n+    <utility\n+        component=".widgets.richtext.tinymce_richtextwidget_render"\n+        provides="plone.app.z3cform.interfaces.IRichTextWidgetInputModeRenderer"\n+        name="tinymce"\n+        />\n+\n+</configure>\ndiff --git a/plone/app/z3cform/widgets/__init__.py b/plone/app/z3cform/widgets/__init__.py\nnew file mode 100644\nindex 00000000..e69de29b\ndiff --git a/plone/app/z3cform/widgets/base.py b/plone/app/z3cform/widgets/base.py\nnew file mode 100644\nindex 00000000..6cf87aef\n--- /dev/null\n+++ b/plone/app/z3cform/widgets/base.py\n@@ -0,0 +1,62 @@\n+from Acquisition import aq_base\n+from plone.app.z3cform.utils import call_callables\n+from z3c.form.widget import Widget\n+\n+\n+class PatternNotImplemented(Exception):\n+    """Raised when method/property is not implemented"""\n+\n+\n+class BaseWidget(Widget):\n+    """Base widget for z3c.form."""\n+\n+    pattern = None\n+    pattern_options = {}\n+    _adapterValueAttributes = Widget._adapterValueAttributes + ("pattern_options",)\n+\n+    def _base(self, pattern, pattern_options={}):\n+        """Base widget class."""\n+        raise PatternNotImplemented\n+\n+    def _base_args(self):\n+        """Method which will calculate _base class arguments.\n+\n+        Returns (as python dictionary):\n+            - `pattern`: pattern name\n+            - `pattern_options`: pattern options\n+\n+        :returns: Arguments which will be passed to _base\n+        :rtype: dict\n+        """\n+        if self.pattern is None:\n+            raise PatternNotImplemented("\'pattern\' option is not provided.")\n+        return {\n+            "pattern": self.pattern,\n+            "pattern_options": self.pattern_options.copy(),\n+        }\n+\n+    def render(self):\n+        """Render widget.\n+\n+        :returns: Widget\'s HTML.\n+        :rtype: string\n+        """\n+        if self.mode != "input":\n+            return super().render()\n+\n+        _base_args = self._base_args()\n+        _base_args["pattern_options"] = call_callables(\n+            _base_args["pattern_options"],\n+            self.context,\n+        )\n+\n+        pattern_widget = self._base(**_base_args)\n+        if getattr(self, "klass", False):\n+            pattern_widget.klass = "{} {}".format(\n+                pattern_widget.klass,\n+                self.klass,\n+            )\n+        return pattern_widget.render()\n+\n+    def is_subform_widget(self):\n+        return getattr(aq_base(self.form), "parentForm", None) is not None\ndiff --git a/plone/app/z3cform/widgets/datetime.py b/plone/app/z3cform/widgets/datetime.py\nnew file mode 100644\nindex 00000000..fcf99ba0\n--- /dev/null\n+++ b/plone/app/z3cform/widgets/datetime.py\n@@ -0,0 +1,163 @@\n+from plone.app.z3cform.converters import DatetimeWidgetConverter\n+from plone.app.z3cform.converters import DateWidgetConverter\n+from plone.app.z3cform.interfaces import IDatetimeWidget\n+from plone.app.z3cform.interfaces import IDateWidget\n+from plone.app.z3cform.interfaces import ITimeWidget\n+from plone.app.z3cform.utils import dict_merge\n+from plone.app.z3cform.widgets.base import BaseWidget\n+from plone.app.z3cform.widgets.patterns import InputWidget\n+from plone.base import PloneMessageFactory as _\n+from z3c.form.browser.text import TextWidget\n+from z3c.form.interfaces import IFieldWidget\n+from z3c.form.widget import FieldWidget\n+from zope.i18n import translate\n+from zope.interface import implementer\n+from zope.interface import implementer_only\n+\n+\n+def get_date_options(request):\n+    calendar = request.locale.dates.calendars[\'gregorian\']\n+    return {\n+        \'behavior\': \'native\',\n+        \'week-numbers\': \'show\',\n+        \'first-day\': calendar.week.get(\'firstDay\') == 1 and 1 or 0,\n+        \'today\': translate(_(u"Today"), context=request),\n+        \'clear\': translate(_(u"Clear"), context=request),\n+    }\n+\n+\n+@implementer_only(IDateWidget)\n+class DateWidget(BaseWidget, TextWidget):\n+    """Date widget for z3c.form.\n+\n+    :param default_timezone: A Olson DB/pytz timezone identifier or a callback\n+                             returning such an identifier.\n+    :type default_timezone: String or callback\n+\n+    :param default_time: Time used by converter as fallback if no time was set in UI.\n+    :type default_time: String or callback\n+\n+    The default_timezone and default_time arguments are only used if a datewidget is\n+    used on a datetime field. If used on a date field they are ignored.\n+    """\n+    _base_type = "date"\n+    _converter = DateWidgetConverter\n+    _formater = "date"\n+    _formater_length = "short"\n+\n+    default_timezone = None\n+    default_time = "00:00:00"\n+\n+    pattern = "date-picker"\n+    pattern_options = BaseWidget.pattern_options.copy()\n+\n+    def _base(self, **kw):\n+        return InputWidget(\n+            type=self._base_type,\n+            **kw,\n+        )\n+\n+    def _base_args(self):\n+        """Method which will calculate _base class arguments.\n+\n+        Returns (as python dictionary):\n+            - `pattern`: pattern name\n+            - `pattern_options`: pattern options\n+            - `name`: field name\n+            - `value`: field value\n+\n+        :returns: Arguments which will be passed to _base\n+        :rtype: dict\n+        """\n+        args = super()._base_args()\n+        args["name"] = self.name\n+        args["value"] = (self.request.get(self.name, self.value) or "").strip()\n+\n+        args.setdefault("pattern_options", {})\n+        if self.field.required:\n+            # Required fields should not have a "Clear" button\n+            args["pattern_options"]["clear"] = False\n+        args["pattern_options"] = dict_merge(\n+            get_date_options(self.request), args["pattern_options"]\n+        )\n+\n+        return args\n+\n+    def render(self):\n+        """Render widget.\n+\n+        :returns: Widget\'s HTML.\n+        :rtype: string\n+        """\n+        if self.mode != "display":\n+            self.addClass("form-control")\n+            return super().render()\n+\n+        if not self.value:\n+            return ""\n+\n+        field_value = self._converter(self.field, self).toFieldValue(self.value)\n+        if field_value is self.field.missing_value:\n+            return ""\n+\n+        formatter = self.request.locale.dates.getFormatter(\n+            self._formater,\n+            self._formater_length,\n+        )\n+        return formatter.format(field_value)\n+\n+\n+@implementer(IFieldWidget)\n+def DateFieldWidget(field, request):\n+    return FieldWidget(field, DateWidget(request))\n+\n+\n+@implementer_only(IDatetimeWidget)\n+class DatetimeWidget(DateWidget):\n+    """Datetime widget for z3c.form.\n+\n+    :param default_timezone: A Olson DB/pytz timezone identifier or a callback\n+                             returning such an identifier.\n+    :type default_timezone: String or callback\n+\n+    :param default_time: Time used by converter as fallback if no time was set in UI.\n+    :type default_time: String or callback\n+    """\n+\n+    _base_type = "datetime-local"\n+    _converter = DatetimeWidgetConverter\n+    _formater = "dateTime"\n+\n+    default_timezone = None\n+    default_time = "00:00:00"\n+\n+    pattern = "datetime-picker"\n+\n+\n+@implementer(IFieldWidget)\n+def DatetimeFieldWidget(field, request):\n+    return FieldWidget(field, DatetimeWidget(request))\n+\n+\n+@implementer_only(ITimeWidget)\n+class TimeWidget(BaseWidget, TextWidget):\n+\n+    pattern = ""\n+\n+    def _base(self, **kw):\n+        return InputWidget(\n+            type="time",\n+            name=self.name,\n+            value=(self.request.get(self.name, self.value) or "").strip(),\n+            **kw,\n+        )\n+\n+    def render(self):\n+        if self.mode != "display":\n+            self.addClass("form-control")\n+        return super().render()\n+\n+\n+@implementer(IFieldWidget)\n+def TimeFieldWidget(field, request):\n+    return FieldWidget(field, TimeWidget(request))\ndiff --git a/plone/app/z3cform/widgets/link.py b/plone/app/z3cform/widgets/link.py\nnew file mode 100644\nindex 00000000..d9eb02df\n--- /dev/null\n+++ b/plone/app/z3cform/widgets/link.py\n@@ -0,0 +1,59 @@\n+from plone.app.z3cform.interfaces import ILinkWidget\n+from plone.base.utils import safe_text\n+from z3c.form.browser.text import TextWidget as z3cform_TextWidget\n+from z3c.form.interfaces import IFieldWidget\n+from z3c.form.interfaces import NO_VALUE\n+from z3c.form.widget import FieldWidget\n+from zope.component.hooks import getSite\n+from zope.interface import implementer\n+from zope.interface import implementer_only\n+\n+import json\n+\n+\n+@implementer_only(ILinkWidget)\n+class LinkWidget(z3cform_TextWidget):\n+    """Implementation of enhanced link widget.\n+\n+    .. note::\n+        Unlike the others here, this is not a pattern based widget\n+        and it uses it\'s own template.\n+    """\n+\n+    def pattern_data(self):\n+        pattern_data = {\n+            "vocabularyUrl": "{}/@@getVocabulary?name=plone.app.vocabularies.Catalog".format(  # noqa\n+                getSite().absolute_url(0),\n+            ),\n+            "maximumSelectionSize": 1,\n+        }\n+        return json.dumps(pattern_data)\n+\n+    def extract(self, default=NO_VALUE):\n+        form = self.request.form\n+        internal = form.get(self.name + ".internal")\n+        external = form.get(self.name + ".external")\n+        email = form.get(self.name + ".email")\n+        if internal:\n+            url = "${portal_url}/resolveuid/" + internal\n+        elif email:\n+            subject = form.get(self.name + ".subject")\n+            if email[:7] != "mailto:":\n+                email = "mailto:" + email\n+            if not subject:\n+                url = email\n+            else:\n+                url = "{email}?subject={subject}".format(\n+                    email=email,\n+                    subject=subject,\n+                )\n+        else:\n+            url = external  # the default is `http://` so we land here\n+        if url:\n+            self.request.form[self.name] = safe_text(url)\n+        return super().extract(default=default)\n+\n+\n+@implementer(IFieldWidget)\n+def LinkFieldWidget(field, request):\n+    return FieldWidget(field, LinkWidget(request))\ndiff --git a/plone/app/z3cform/widgets/patterns.py b/plone/app/z3cform/widgets/patterns.py\nnew file mode 100644\nindex 00000000..14c3da51\n--- /dev/null\n+++ b/plone/app/z3cform/widgets/patterns.py\n@@ -0,0 +1,322 @@\n+from copy import deepcopy\n+from lxml import etree\n+\n+import collections\n+import json\n+import six\n+\n+\n+def el_attrib(name):\n+    """Helper property methods to get/set/delete element property.\n+\n+    :param name: [required] Name of the element property.\n+    :type name: string\n+\n+    :returns: Property with getter/setter/deletter.\n+    :rtype: property\n+    """\n+\n+    def _get(self):\n+        if name in self.el.attrib:\n+            value = self.el.attrib[name]\n+            if value.strip().startswith(\'[\') or value.strip().startswith(\'{\'):\n+                value = json.loads(value)\n+            return value\n+\n+    def _set(self, value):\n+        if value is None:\n+            return\n+        if isinstance(value, (list, tuple)):\n+            value = \' \'.join(value)\n+        if isinstance(value, (dict, set)):\n+            value = json.dumps(value)\n+        if isinstance(value, six.binary_type):\n+            value = value.decode(\'utf8\')\n+        self.el.attrib[name] = value\n+\n+    def _del(self):\n+        if name in self.el.attrib:\n+            del self.el.attrib[name]\n+\n+    return property(_get, _set, _del)\n+\n+\n+class BaseWidget(object):\n+    """Basic patterns widget."""\n+\n+    _klass_prefix = \'pat-\'\n+    klass = el_attrib(\'class\')\n+\n+    def __init__(self, el, pattern, pattern_options={}):\n+        """\n+        :param el: [required] element type (eg. input, div, textarea, a, ...).\n+        :type el: string\n+\n+        :param pattern: [required] Pattern name.\n+        :type pattern: string\n+\n+        :param pattern_options: Patterns options.\n+        :type pattern_options: dict\n+        """\n+\n+        self.pattern = pattern\n+        self.el = etree.Element(el)\n+        if pattern:\n+            self.klass = self._klass_prefix + pattern\n+        self.pattern_options = pattern_options\n+\n+    def update(self):\n+        """Updating pattern_options in element `data-*` attribute."""\n+        if self.pattern_options:\n+            self.el.attrib[\'data-\' + self._klass_prefix + self.pattern] = \\\n+                json.dumps(self.pattern_options)\n+\n+    def render(self):\n+        """Renders the widget\n+\n+        :returns: Widget\'s HTML.\n+        :rtype: string\n+        """\n+\n+        self.update()\n+        return etree.tostring(self.el, encoding=six.text_type)\n+\n+\n+class InputWidget(BaseWidget):\n+    """Widget with `input` element."""\n+\n+    type = el_attrib(\'type\')\n+    value = el_attrib(\'value\')\n+    name = el_attrib(\'name\')\n+\n+    def __init__(self, pattern, pattern_options={}, type=\'text\', name=None,\n+                 value=None):\n+        """\n+        :param pattern: [required] Pattern name.\n+        :type pattern: string\n+\n+        :param pattern_options: Patterns options.\n+        :type pattern_options: dict\n+\n+        :param type: `type` attribute of element.\n+        :type type: string\n+\n+        :param name: `name` attribute of element.\n+        :type name: string\n+\n+        :param value: `value` attribute of element.\n+        :type value: string\n+        """\n+        super().__init__(\'input\', pattern, pattern_options)\n+        self.type = type\n+        if name is not None:\n+            self.name = name\n+        if value is not None:\n+            self.value = value\n+\n+\n+class SelectWidget(BaseWidget):\n+    """Widget with `select` element."""\n+\n+    name = el_attrib(\'name\')\n+    _multiple = el_attrib(\'multiple\')\n+\n+    def __init__(self, pattern, pattern_options={}, items=[], name=None,\n+                 value=None, multiple=False):\n+        """\n+        :param pattern: [required] Pattern name.\n+        :type pattern: string\n+\n+        :param pattern_options: Patterns options.\n+        :type pattern_options: dict\n+\n+        :param items: List of value and title pairs which represents possible\n+                      options to choose from.\n+        :type items: list\n+\n+        :param name: `name` attribute of element.\n+        :type name: string\n+\n+        :param value: `value` attribute of element.\n+        :type value: string\n+\n+        :param multiple: `multiple` attribute of element.\n+        :type multiple: bool\n+        """\n+        super().__init__(\'select\', pattern, pattern_options)\n+        self.el.text = \'\'\n+        self.items = items\n+        self.multiple = multiple\n+        if name is not None:\n+            self.name = name\n+        if value is not None:\n+            self.value = value\n+\n+    def _get_items(self):\n+        """Get list of possible options.\n+\n+        :returns: List of value and title pairs.\n+        :rtype: list\n+        """\n+        if self.el.find(\'optgroup\') is not None:\n+            return collections.OrderedDict(\n+                (group.attrib[\'label\'], [\n+                    (option.attrib[\'value\'], option.text)\n+                    for option in group.iter("option")])\n+                for group in self.el.iter("optgroup"))\n+        else:\n+            return [\n+                (option.attrib[\'value\'], option.text)\n+                for option in self.el.iter("option")]\n+\n+    def _set_items(self, value):\n+        """Set options for element.\n+\n+        :param value: List of value and title pairs which represents possible\n+                      options to choose from.\n+        :type value: list\n+        """\n+        def addOptions(el, options):\n+            """\n+            Add <option> elements for each vocab item.\n+            """\n+            for token, title in options:\n+                option = etree.SubElement(el, \'option\')\n+                option.attrib[\'value\'] = token\n+                option.text = title\n+\n+        if isinstance(value, dict):\n+            for group_label, options in value.items():\n+                group = etree.SubElement(self.el, \'optgroup\')\n+                group.attrib[\'label\'] = group_label\n+                addOptions(group, options)\n+        else:\n+            for token, title in value:\n+                option = etree.SubElement(self.el, \'option\')\n+                option.attrib[\'value\'] = token\n+                option.text = title\n+\n+    def _del_items(self):\n+        """Removing options from inside of elements."""\n+        for group in self.el.iter("optgroup"):\n+            self.el.remove(group)\n+        for element in self.el.iter("option"):\n+            self.el.remove(element)\n+\n+    items = property(_get_items, _set_items, _del_items)\n+\n+    def _get_value(self):\n+        """Return selected option(s).\n+\n+        :returns: Returns list of selected option(s) values.\n+        :rtype: list\n+        """\n+        value = []\n+        for element in self.el.iter("option"):\n+            if \'selected\' in element.attrib and \\\n+                    element.attrib[\'selected\'] == \'selected\':\n+                value.append(element.attrib[\'value\'])\n+        return value\n+\n+    def _set_value(self, value):\n+        """Select option(s).\n+\n+        :param value: We are expecting option\'s value which should be selected.\n+        :type value: list or string\n+        """\n+        if isinstance(value, six.string_types):\n+            value = [value]\n+\n+        for element in self.el.iter("option"):\n+            if element.attrib[\'value\'] in value:\n+                element.attrib[\'selected\'] = \'selected\'\n+            elif \'selected\' in element.attrib and \\\n+                    element.attrib[\'selected\'] == \'selected\':\n+                del element.attrib[\'selected\']\n+\n+    def _del_value(self):\n+        """Unselect all selected options.\n+        """\n+        for element in self.el.iter("option"):\n+            if \'selected\' in element.attrib and \\\n+               element.attrib[\'selected\'] == \'selected\':\n+                del element.attrib[\'selected\']\n+\n+    value = property(_get_value, _set_value, _del_value)\n+\n+    def _get_multiple(self):\n+        """Does element allows multiple items to be selected.\n+\n+        :returns: `True` if allows multiple elements to be selected, otherwise\n+                  `False`.\n+        :rtype: bool\n+        """\n+        if self._multiple == \'multiple\':\n+            return True\n+        return False\n+\n+    def _set_multiple(self, value):\n+        """Make element accept multiple values.\n+\n+        :param value: `True` if you want to set element as `multiple`,\n+                      otherwise `False`\n+        :type value: bool\n+        """\n+        if value:\n+            self._multiple = \'multiple\'\n+        else:\n+            self._del_multiple()\n+\n+    def _del_multiple(self):\n+        """Remove `multiple` attribute from element."""\n+        del self._multiple\n+\n+    multiple = property(_get_multiple, _set_multiple, _del_multiple)\n+\n+\n+class TextareaWidget(BaseWidget):\n+    """Widget with `textarea` element."""\n+\n+    name = el_attrib(\'name\')\n+\n+    def __init__(self, pattern, pattern_options={}, name=None, value=None):\n+        """\n+        :param pattern: [required] Pattern name.\n+        :type pattern: string\n+\n+        :param pattern_options: Patterns options.\n+        :type pattern_options: dict\n+\n+        :param name: `name` attribute of element.\n+        :type name: string\n+\n+        :param value: `value` of element.\n+        :type value: string\n+        """\n+        super().__init__(\'textarea\', pattern,\n+                                             pattern_options)\n+        self.el.text = \'\'\n+        if name is not None:\n+            self.name = name\n+        if value is not None:\n+            self.value = value\n+\n+    def _get_value(self):\n+        """\n+        :returns: Value of element.\n+        :rtype: string\n+        """\n+        return self.el.text\n+\n+    def _set_value(self, value):\n+        """\n+        :param value: Set value of element.\n+        :type value: string\n+        """\n+        self.el.text = value\n+\n+    def _del_value(self):\n+        """Set empty string as value of element."""\n+        self.el.text = \'\'\n+\n+    value = property(_get_value, _set_value, _del_value)\ndiff --git a/plone/app/z3cform/widgets/querystring.py b/plone/app/z3cform/widgets/querystring.py\nnew file mode 100644\nindex 00000000..ce904db9\n--- /dev/null\n+++ b/plone/app/z3cform/widgets/querystring.py\n@@ -0,0 +1,81 @@\n+from plone.app.z3cform.interfaces import IQueryStringWidget\n+from plone.app.z3cform.utils import dict_merge\n+from plone.app.z3cform.utils import get_portal_url\n+from plone.app.z3cform.widgets.base import BaseWidget\n+from plone.app.z3cform.widgets.datetime import get_date_options\n+from plone.app.z3cform.widgets.patterns import InputWidget\n+from plone.app.z3cform.widgets.relateditems import get_relateditems_options\n+from z3c.form.browser.text import TextWidget as z3cform_TextWidget\n+from z3c.form.interfaces import IFieldWidget\n+from z3c.form.widget import FieldWidget\n+from zope.globalrequest import getRequest\n+from zope.interface import implementer\n+from zope.interface import implementer_only\n+\n+\n+def get_querystring_options(context, querystring_view):\n+    portal_url = get_portal_url(context)\n+    try:\n+        base_url = context.absolute_url()\n+    except AttributeError:\n+        base_url = portal_url\n+    return {\n+        \'indexOptionsUrl\': \'{}/{}\'.format(portal_url, querystring_view),\n+        \'previewURL\': \'%s/@@querybuilder_html_results\' % base_url,\n+        \'previewCountURL\': \'%s/@@querybuildernumberofresults\' % base_url,\n+        \'patternDateOptions\': get_date_options(getRequest()),\n+        \'patternAjaxSelectOptions\': {\'separator\': \';\'},\n+        \'patternRelateditemsOptions\': get_relateditems_options(\n+            context,\n+            None,\n+            \';\',\n+            \'plone.app.vocabularies.Catalog\',\n+            \'@@getVocabulary\',\n+            \'relatedItems\',\n+            include_recently_added=False\n+        )\n+    }\n+\n+\n+@implementer_only(IQueryStringWidget)\n+class QueryStringWidget(BaseWidget, z3cform_TextWidget):\n+    """QueryString widget for z3c.form."""\n+\n+    _base = InputWidget\n+\n+    pattern = "querystring"\n+    pattern_options = BaseWidget.pattern_options.copy()\n+\n+    querystring_view = "@@qsOptions"\n+\n+    def _base_args(self):\n+        """Method which will calculate _base class arguments.\n+\n+        Returns (as python dictionary):\n+            - `pattern`: pattern name\n+            - `pattern_options`: pattern options\n+            - `name`: field name\n+            - `value`: field value\n+\n+        :returns: Arguments which will be passed to _base\n+        :rtype: dict\n+        """\n+        args = super()._base_args()\n+        args["name"] = self.name\n+        args["value"] = self.value\n+\n+        args.setdefault("pattern_options", {})\n+        args["pattern_options"] = dict_merge(\n+            get_querystring_options(self.context, self.querystring_view),\n+            args["pattern_options"],\n+        )\n+\n+        return args\n+\n+\n+@implementer(IFieldWidget)\n+def QueryStringFieldWidget(field, request, extra=None):\n+    if extra is not None:\n+        request = extra\n+    return FieldWidget(field, QueryStringWidget(request))\n+\ndiff --git a/plone/app/z3cform/widgets/relateditems.py b/plone/app/z3cform/widgets/relateditems.py\nnew file mode 100644\nindex 00000000..802aadbf\n--- /dev/null\n+++ b/plone/app/z3cform/widgets/relateditems.py\n@@ -0,0 +1,247 @@\n+from Acquisition import aq_parent\n+from OFS.interfaces import IFolder\n+from OFS.interfaces import ISimpleItem\n+from plone.app.contentlisting.interfaces import IContentListing\n+from plone.app.layout.navigation.root import getNavigationRootObject\n+from plone.app.z3cform.interfaces import IRelatedItemsWidget\n+from plone.app.z3cform.utils import dict_merge\n+from plone.app.z3cform.utils import get_context_url\n+from plone.app.z3cform.utils import get_widget_form\n+from plone.app.z3cform.widgets.base import BaseWidget\n+from plone.app.z3cform.widgets.patterns import InputWidget\n+from plone.base import PloneMessageFactory as _\n+from plone.base.utils import get_top_site_from_url\n+from Products.CMFCore.utils import getToolByName\n+from z3c.form.browser.text import TextWidget as z3cform_TextWidget\n+from z3c.form.interfaces import IEditForm\n+from z3c.form.interfaces import IFieldWidget\n+from z3c.form.interfaces import IForm\n+from z3c.form.widget import FieldWidget\n+from zope.component.hooks import getSite\n+from zope.globalrequest import getRequest\n+from zope.interface import implementer\n+from zope.interface import implementer_only\n+from zope.schema.interfaces import IChoice\n+from zope.schema.interfaces import ICollection\n+\n+\n+def get_relateditems_options(context, value, separator, vocabulary_name,\n+                             vocabulary_view, field_name=None,\n+                             include_recently_added=True):\n+\n+    if IForm.providedBy(context):\n+        context = context.context\n+\n+    request = getRequest()\n+    site = get_top_site_from_url(context, request)\n+    options = {\n+        \'separator\': separator,\n+    }\n+    if not vocabulary_name:\n+        # we need a vocabulary!\n+        raise ValueError(\'RelatedItems needs a vocabulary\')\n+    options[\'vocabularyUrl\'] = \'{0}/{1}?name={2}\'.format(\n+        get_context_url(site), vocabulary_view, vocabulary_name,\n+    )\n+    if field_name:\n+        options[\'vocabularyUrl\'] += \'&field={0}\'.format(field_name)\n+    if value:\n+        options[\'initialValues\'] = {}\n+        catalog = False\n+        if vocabulary_name == \'plone.app.vocabularies.Catalog\':\n+            catalog = getToolByName(getSite(), \'portal_catalog\')\n+        for value in value.split(separator):\n+            title = value\n+            if catalog:\n+                result = catalog(UID=value)\n+                title = result[0].Title if result else value\n+            options[\'initialValues\'][value] = title\n+\n+    nav_root = getNavigationRootObject(context, site)\n+\n+    if not ISimpleItem.providedBy(context):\n+        context = nav_root\n+\n+    # basePath - start to search/browse in here.\n+    base_path_context = context\n+    if not IFolder.providedBy(base_path_context):\n+        base_path_context = aq_parent(base_path_context)\n+    if not base_path_context:\n+        base_path_context = nav_root\n+    options[\'basePath\'] = \'/\'.join(base_path_context.getPhysicalPath())\n+\n+    # rootPath - Only display breadcrumb elements deeper than this path.\n+    options[\'rootPath\'] = \'/\'.join(site.getPhysicalPath()) if site else \'/\'\n+\n+    # rootUrl: Visible URL up to the rootPath. This is prepended to the\n+    # currentPath to generate submission URLs.\n+    options[\'rootUrl\'] = site.absolute_url() if site else \'\'\n+\n+    # contextPath - current edited object. Will not be available to select.\n+    options[\'contextPath\'] = \'/\'.join(context.getPhysicalPath())\n+\n+    if base_path_context != nav_root:\n+        options[\'favorites\'] = [\n+            {\n+                \'title\': _(u\'Current Content\'),\n+                \'path\': \'/\'.join(base_path_context.getPhysicalPath())\n+            }, {\n+                \'title\': _(u\'Start Page\'),\n+                \'path\': \'/\'.join(nav_root.getPhysicalPath())\n+            }\n+        ]\n+\n+    if include_recently_added:\n+        # Options for recently used key\n+        tool = getToolByName(context, \'portal_membership\')\n+        user = tool.getAuthenticatedMember()\n+        options[\'recentlyUsed\'] = False  # Keep that off in Plone 5.1\n+        options[\'recentlyUsedKey\'] = (u\'relateditems_recentlyused_%s_%s\' % (\n+            field_name or \'\',\n+            user.id\n+        ))  # use string substitution with %s here for automatic str casting.\n+\n+    return options\n+\n+\n+@implementer_only(IRelatedItemsWidget)\n+class RelatedItemsWidget(BaseWidget, z3cform_TextWidget):\n+    """RelatedItems widget for z3c.form."""\n+\n+    _base = InputWidget\n+\n+    pattern = "relateditems"\n+    pattern_options = BaseWidget.pattern_options.copy()\n+\n+    separator = ";"\n+    vocabulary = None\n+    vocabulary_override = False\n+    vocabulary_view = "@@getVocabulary"\n+    orderable = False\n+\n+    def update(self):\n+        super().update()\n+        field = getattr(self, "field", None)\n+        if ICollection.providedBy(self.field):\n+            field = self.field.value_type\n+        if (\n+            not self.vocabulary\n+            and field is not None\n+            and getattr(field, "vocabularyName", None)\n+        ):\n+            self.vocabulary = field.vocabularyName\n+            self.vocabulary_override = True\n+        else:\n+            self.vocabulary = "plone.app.vocabularies.Catalog"\n+\n+    def _base_args(self):\n+        """Method which will calculate _base class arguments.\n+\n+        Returns (as python dictionary):\n+            - `pattern`: pattern name\n+            - `pattern_options`: pattern options\n+            - `name`: field name\n+            - `value`: field value\n+\n+        :returns: Arguments which will be passed to _base\n+        :rtype: dict\n+        """\n+        args = super()._base_args()\n+\n+        args["name"] = self.name\n+        args["value"] = self.value\n+        args.setdefault("pattern_options", {})\n+\n+        field = None\n+        if IChoice.providedBy(self.field):\n+            args["pattern_options"]["maximumSelectionSize"] = 1\n+            field = self.field\n+        elif ICollection.providedBy(self.field):\n+            field = self.field.value_type\n+\n+        vocabulary_name = self.vocabulary\n+\n+        field_name = self.field and self.field.__name__ or None\n+\n+        context = self.context\n+        view_context = get_widget_form(self)\n+        # For EditForms and non-Forms (in tests), the vocabulary is looked\n+        # up on the context, otherwise on the view\n+        if IEditForm.providedBy(view_context):\n+            if self.is_subform_widget():\n+                view_context = self.form.parentForm.context\n+            elif not ISimpleItem.providedBy(context):\n+                view_context = self.form.context\n+            else:\n+                view_context = context\n+        elif not IForm.providedBy(view_context):\n+            view_context = context\n+        else:\n+            pass\n+            # view_context is defined above already\n+\n+        root_search_mode = (\n+            args["pattern_options"].get("mode", None)\n+            and "basePath" not in args["pattern_options"]\n+        )\n+\n+        args["pattern_options"] = dict_merge(\n+            get_relateditems_options(\n+                view_context,\n+                args["value"],\n+                self.separator,\n+                vocabulary_name,\n+                self.vocabulary_view,\n+                field_name,\n+            ),\n+            args["pattern_options"],\n+        )\n+        if root_search_mode:\n+            # Delete default basePath option in search mode, when no basePath\n+            # was explicitly set.\n+            del args["pattern_options"]["basePath"]\n+        if (\n+            not self.vocabulary_override\n+            and field\n+            and getattr(field, "vocabulary", None)\n+        ):\n+            # widget vocab takes precedence over field\n+            form_url = self.request.getURL()\n+            source_url = "{:s}/++widget++{:s}/@@getSource".format(\n+                form_url,\n+                self.name,\n+            )\n+            args["pattern_options"]["vocabularyUrl"] = source_url\n+\n+        return args\n+\n+    def items(self):\n+        """Return item for the widget values for the display template\n+\n+        Query the catalog for the widget-value (uuids) to only display items\n+        that the user is allowed to see. Accessing the value with e.g.\n+        getattr(self.context, self.__name__) would yield the items unfiltered.\n+        Uses IContentListing for easy access to MimeTypeIcon and more.\n+        """\n+        results = []\n+        if not self.value:\n+            return results\n+        separator = getattr(self, "separator", ";")\n+        uuids = self.value.split(separator)\n+\n+        try:\n+            catalog = getToolByName(self.context, "portal_catalog")\n+        except AttributeError:\n+            catalog = getToolByName(getSite(), "portal_catalog")\n+\n+        brains = catalog(UID=uuids)\n+        # restore original order\n+        results = sorted(brains, key=lambda brain: uuids.index(brain.UID))\n+        return IContentListing(results)\n+\n+\n+@implementer(IFieldWidget)\n+def RelatedItemsFieldWidget(field, request, extra=None):\n+    if extra is not None:\n+        request = extra\n+    return FieldWidget(field, RelatedItemsWidget(request))\ndiff --git a/plone/app/z3cform/widgets/richtext.py b/plone/app/z3cform/widgets/richtext.py\nnew file mode 100644\nindex 00000000..6e0b2c63\n--- /dev/null\n+++ b/plone/app/z3cform/widgets/richtext.py\n@@ -0,0 +1,184 @@\n+from Acquisition import ImplicitAcquisitionWrapper\n+from collections import UserDict\n+from lxml import etree\n+from plone.app.textfield.value import RichTextValue\n+from plone.app.textfield.widget import RichTextWidget as patext_RichTextWidget\n+from plone.app.z3cform.interfaces import IRichTextWidget\n+from plone.app.z3cform.interfaces import IRichTextWidgetInputModeRenderer\n+from plone.app.z3cform.utils import closest_content\n+from plone.app.z3cform.utils import dict_merge\n+from plone.app.z3cform.widgets.base import BaseWidget\n+from plone.app.z3cform.widgets.patterns import TextareaWidget\n+from z3c.form.interfaces import IFieldWidget\n+from z3c.form.widget import FieldWidget\n+from zope.component import ComponentLookupError\n+from zope.component import getMultiAdapter\n+from zope.component import queryUtility\n+from zope.interface import implementer\n+from zope.interface import implementer_only\n+\n+import json\n+import logging\n+\n+logger = logging.getLogger(__name__)\n+\n+\n+def get_tinymce_options(context, field, request):\n+    """\n+    We\'re just going to be looking up settings from\n+    plone pattern options\n+    """\n+    options = {}\n+    try:\n+        pattern_options = getMultiAdapter(\n+            (context, request, field),\n+            name="plone_settings").tinymce()[\'data-pat-tinymce\']\n+        options = json.loads(pattern_options)\n+    except (ComponentLookupError, AttributeError):\n+        logger.warning("Can not load tinymce pattern options!", exc_info=True)\n+    return options\n+\n+\n+@implementer_only(IRichTextWidget)\n+class RichTextWidget(BaseWidget, patext_RichTextWidget):\n+    """TinyMCE widget for z3c.form."""\n+\n+    _base = TextareaWidget\n+\n+    pattern_options = BaseWidget.pattern_options.copy()\n+\n+    def __init__(self, *args, **kwargs):\n+        super().__init__(*args, **kwargs)\n+        self._pattern = None\n+\n+    def wrapped_context(self):\n+        """ "We need to wrap the context to be able to acquire the root\n+        of the site to get tools, as done in plone.app.textfield"""\n+        context = self.context\n+        content = closest_content(context)\n+        if context.__class__ == dict:\n+            context = UserDict(self.context)\n+        return ImplicitAcquisitionWrapper(context, content)\n+\n+    @property\n+    def pattern(self):\n+        """dynamically grab the actual pattern name so it will\n+        work with custom visual editors"""\n+        if self._pattern is None:\n+            self._pattern = self.getWysiwygEditor()\n+        return self._pattern\n+\n+    def _base_args(self):\n+        args = super()._base_args()\n+        args["name"] = self.name\n+        value = self.value and self.value.raw or ""\n+        value = self.request.get(self.name, value)\n+        args["value"] = value\n+\n+        args.setdefault("pattern_options", {})\n+        merged_options = dict_merge(\n+            get_tinymce_options(\n+                self.wrapped_context(),\n+                self.field,\n+                self.request,\n+            ),\n+            args["pattern_options"],\n+        )\n+        args["pattern_options"] = merged_options\n+\n+        return args\n+\n+    def render(self):\n+        """Render widget.\n+\n+        :returns: Widget\'s HTML.\n+        :rtype: string\n+        """\n+        if self.mode != "display":\n+            renderer = queryUtility(\n+                IRichTextWidgetInputModeRenderer,\n+                name=self.getWysiwygEditor(),\n+                default=tinymce_richtextwidget_render,\n+            )\n+            return renderer(self)\n+\n+        if not self.value:\n+            return ""\n+\n+        if isinstance(self.value, RichTextValue):\n+            return self.value.output_relative_to(self.context)\n+\n+        return super().render()\n+\n+    def render_input_mode(self):\n+        # MODE "INPUT"\n+        rendered = ""\n+        allowed_mime_types = self.allowedMimeTypes()\n+        if not allowed_mime_types or len(allowed_mime_types) <= 1:\n+            # Display textarea with default widget\n+            rendered = super().render()\n+        else:\n+            # Let pat-textarea-mimetype-selector choose the widget\n+\n+            # Initialize the widget without a pattern\n+            base_args = self._base_args()\n+            pattern_options = base_args["pattern_options"]\n+            del base_args["pattern"]\n+            del base_args["pattern_options"]\n+            textarea_widget = self._base(None, None, **base_args)\n+            textarea_widget.klass = "form-control"\n+            mt_pattern_name = "{}{}".format(\n+                self._base._klass_prefix,\n+                "textareamimetypeselector",\n+            )\n+\n+            # Initialize mimetype selector pattern\n+            # TODO: default_mime_type returns \'text/html\', regardless of\n+            # settings. fix in plone.app.textfield\n+            value_mime_type = (\n+                self.value.mimeType if self.value else self.field.default_mime_type\n+            )\n+            mt_select = etree.Element("select")\n+            mt_select.attrib["id"] = f"{self.id}_text_format"\n+            mt_select.attrib["name"] = f"{self.name}.mimeType"\n+            mt_select.attrib["class"] = "form-select {}".format(mt_pattern_name)\n+            mt_select.attrib[f"data-{mt_pattern_name}"] = json.dumps(\n+                {\n+                    "textareaName": self.name,\n+                    "widgets": {\n+                        "text/html": {  # TODO: currently, we only support\n+                            # richtext widget config for\n+                            # \'text/html\', no other mimetypes.\n+                            "pattern": self.pattern,\n+                            "patternOptions": pattern_options,\n+                        },\n+                    },\n+                },\n+            )\n+\n+            # Create a list of allowed mime types\n+            for mt in allowed_mime_types:\n+                opt = etree.Element("option")\n+                opt.attrib["value"] = mt\n+                if value_mime_type == mt:\n+                    opt.attrib["selected"] = "selected"\n+                opt.text = mt\n+                mt_select.append(opt)\n+\n+            # Render the combined widget\n+            rendered = "{}\\n{}".format(\n+                textarea_widget.render(),\n+                etree.tostring(mt_select, encoding="unicode"),\n+            )\n+        return rendered\n+\n+\n+def tinymce_richtextwidget_render(widget):\n+    return RichTextWidget.render_input_mode(widget)\n+\n+\n+@implementer(IFieldWidget)\n+def RichTextFieldWidget(field, request):\n+    return FieldWidget(field, RichTextWidget(request))\n+\n+\ndiff --git a/plone/app/z3cform/widgets/select.py b/plone/app/z3cform/widgets/select.py\nnew file mode 100644\nindex 00000000..9eda7df9\n--- /dev/null\n+++ b/plone/app/z3cform/widgets/select.py\n@@ -0,0 +1,310 @@\n+from OFS.interfaces import ISimpleItem\n+from plone.app.z3cform.interfaces import IAjaxSelectWidget\n+from plone.app.z3cform.interfaces import ISelectWidget\n+from plone.app.z3cform.utils import dict_merge\n+from plone.app.z3cform.utils import get_context_url\n+from plone.app.z3cform.utils import get_widget_form\n+from plone.app.z3cform.widgets.base import BaseWidget\n+from plone.app.z3cform.widgets.patterns import InputWidget\n+from plone.app.z3cform.widgets.patterns import SelectWidget\n+from plone.registry.interfaces import IRegistry\n+from Products.CMFCore.utils import getToolByName\n+from z3c.form import interfaces as form_ifaces\n+from z3c.form.browser.select import SelectWidget as z3cform_SelectWidget\n+from z3c.form.browser.text import TextWidget as z3cform_TextWidget\n+from z3c.form.interfaces import IEditForm\n+from z3c.form.interfaces import IFieldWidget\n+from z3c.form.interfaces import IForm\n+from z3c.form.interfaces import NO_VALUE\n+from z3c.form.widget import FieldWidget\n+from zope.component import getUtility\n+from zope.component import queryUtility\n+from zope.i18n import translate\n+from zope.interface import implementer\n+from zope.interface import implementer_only\n+from zope.schema import interfaces as schema_ifaces\n+from zope.schema.interfaces import IChoice\n+from zope.schema.interfaces import ICollection\n+from zope.schema.interfaces import ISequence\n+from zope.schema.interfaces import IVocabularyFactory\n+\n+import collections\n+\n+\n+@implementer_only(ISelectWidget)\n+class SelectWidget(BaseWidget, z3cform_SelectWidget):\n+    """Select widget for z3c.form."""\n+\n+    _base = SelectWidget\n+\n+    pattern = "select2"\n+    pattern_options = BaseWidget.pattern_options.copy()\n+\n+    separator = ";"\n+    noValueToken = ""\n+    noValueMessage = ""\n+    multiple = None\n+    orderable = False\n+    required = True\n+\n+    @property\n+    def items(self):\n+        """\n+        Optionally handle ITreeVocabulary vocabs as dicts.\n+        """\n+        terms = self.terms\n+        if form_ifaces.ITerms.providedBy(terms):\n+            terms = terms.terms\n+\n+        if schema_ifaces.ITreeVocabulary.providedBy(terms):\n+            groups = collections.OrderedDict()\n+            for group_term, option_terms in terms.items():\n+                group_widget = type(self)(self.request)\n+                group_widget.terms = option_terms\n+                group_label = group_term.title or group_term.value or group_term.token\n+                groups[group_label] = super(SelectWidget, group_widget).items\n+            return groups\n+        else:\n+            return super().items\n+\n+    def _base_args(self):\n+        """Method which will calculate _base class arguments.\n+\n+        Returns (as python dictionary):\n+            - `pattern`: pattern name\n+            - `pattern_options`: pattern options\n+            - `name`: field name\n+            - `value`: field value\n+            - `multiple`: field multiple\n+            - `items`: field items from which we can select to\n+\n+        :returns: Arguments which will be passed to _base\n+        :rtype: dict\n+        """\n+        args = super()._base_args()\n+        args["name"] = self.name\n+        args["value"] = self.value\n+        args["multiple"] = self.multiple\n+\n+        self.required = self.field.required\n+\n+        options = args.setdefault("pattern_options", {})\n+        if self.multiple or ICollection.providedBy(self.field):\n+            args["multiple"] = self.multiple = True\n+\n+        # ISequence represents an orderable collection\n+        if ISequence.providedBy(self.field) or self.orderable:\n+            options["orderable"] = True\n+\n+        if self.multiple:\n+            options["separator"] = self.separator\n+\n+        # Allow to clear field value if it is not required\n+        if not self.required:\n+            options["allowClear"] = True\n+\n+        base_items = self.items\n+        if callable(base_items):\n+            # items used to be a property in all widgets, then in the select\n+            # widget it became a method, then in a few others too, but never in\n+            # all, so this was reverted to let it be a property again.  Let\'s\n+            # support both here to avoid breaking on some z3c.form versions.\n+            # See https://github.com/zopefoundation/z3c.form/issues/44\n+            base_items = base_items()\n+\n+        def makeItem(item):\n+            """\n+            Gather the information needed by the widget for the given term.\n+            """\n+            if not isinstance(item["content"], str):\n+                item["content"] = translate(\n+                    item["content"], context=self.request, default=item["value"]\n+                )\n+            return (item["value"], item["content"])\n+\n+        if isinstance(base_items, dict):\n+            items = collections.OrderedDict(\n+                (group_label, [makeItem(base_item) for base_item in group_options])\n+                for group_label, group_options in base_items.items()\n+            )\n+        else:\n+            items = [makeItem(item) for item in base_items]\n+        args["items"] = items\n+\n+        return args\n+\n+    def extract(self, default=NO_VALUE):\n+        """Override extract to handle delimited response values.\n+        Skip the vocabulary validation provided in the parent\n+        method, since it\'s not ever done for single selects."""\n+        if (\n+            self.name not in self.request\n+            and self.name + "-empty-marker" in self.request\n+        ):\n+            return []\n+        return self.request.get(self.name, default)\n+\n+\n+@implementer_only(IAjaxSelectWidget)\n+class AjaxSelectWidget(BaseWidget, z3cform_TextWidget):\n+    """Ajax select widget for z3c.form."""\n+\n+    _base = InputWidget\n+\n+    pattern = "select2"\n+    pattern_options = BaseWidget.pattern_options.copy()\n+\n+    separator = ";"\n+    vocabulary = None\n+    vocabulary_view = "@@getVocabulary"\n+    orderable = False\n+\n+    def _view_context(self):\n+        view_context = get_widget_form(self)\n+        # For EditForms and non-Forms (in tests), the vocabulary is looked\n+        # up on the context, otherwise on the view\n+        if IEditForm.providedBy(view_context):\n+            if self.is_subform_widget():\n+                view_context = self.form.parentForm.context\n+            elif not ISimpleItem.providedBy(self.context):\n+                view_context = self.form.context\n+            else:\n+                view_context = self.context\n+        elif not IForm.providedBy(view_context):\n+            view_context = self.context\n+        return view_context\n+\n+    def get_vocabulary(self):\n+        if self.vocabulary and isinstance(self.vocabulary, str):\n+            factory = queryUtility(\n+                IVocabularyFactory,\n+                self.vocabulary,\n+            )\n+            if factory:\n+                return factory(self._view_context())\n+        return self.vocabulary\n+\n+    def display_items(self):\n+        if self.value:\n+            tokens = self.value.split(self.separator)\n+            vocabulary = self.get_vocabulary()\n+            for token in tokens:\n+                item = {"token": token, "title": token}\n+                if vocabulary is not None:\n+                    try:\n+                        item["title"] = vocabulary.getTermByToken(token).title\n+                    except LookupError:\n+                        pass\n+                yield item\n+\n+    def has_multiple_values(self):\n+        return self.value and self.value.split(self.separator)\n+\n+    def _ajaxselect_options(self):\n+        options = {\n+            "separator": self.separator,\n+        }\n+        if self.vocabulary:\n+            options["vocabularyUrl"] = "{}/{}?name={}".format(\n+                get_context_url(self._view_context()),\n+                self.vocabulary_view,\n+                self.vocabulary,\n+            )\n+            field_name = self.field and self.field.__name__ or None\n+            if field_name:\n+                options["vocabularyUrl"] += f"&field={field_name}"\n+            vocabulary = self.get_vocabulary()\n+            if vocabulary is not None and self.value:\n+                options["initialValues"] = dict()\n+                for token in self.value.split(self.separator):\n+                    try:\n+                        term = vocabulary.getTermByToken(token)\n+                        options["initialValues"][term.token] = term.title\n+                    except LookupError:\n+                        options["initialValues"][token] = token\n+\n+        return options\n+\n+    def update(self):\n+        super().update()\n+        field = getattr(self, "field", None)\n+        field = getattr(field, "value_type", field)\n+        if (\n+            not self.vocabulary\n+            and field is not None\n+            and getattr(field, "vocabularyName", None)\n+        ):\n+            self.vocabulary = field.vocabularyName\n+\n+    def _base_args(self):\n+        """Method which will calculate _base class arguments.\n+\n+        Returns (as python dictionary):\n+            - `pattern`: pattern name\n+            - `pattern_options`: pattern options\n+            - `name`: field name\n+            - `value`: field value\n+\n+        :returns: Arguments which will be passed to _base\n+        :rtype: dict\n+        """\n+        args = super()._base_args()\n+        args["name"] = self.name\n+        args["value"] = self.value\n+        args.setdefault("pattern_options", {})\n+        context = self.context\n+        field = None\n+\n+        if IChoice.providedBy(self.field):\n+            args["pattern_options"]["maximumSelectionSize"] = 1\n+            field = self.field\n+        elif ICollection.providedBy(self.field):\n+            field = self.field.value_type\n+        if IChoice.providedBy(field):\n+            args["pattern_options"]["allowNewItems"] = "false"\n+\n+        args["pattern_options"] = dict_merge(\n+            self._ajaxselect_options(), args["pattern_options"]\n+        )\n+\n+        if field and getattr(field, "vocabulary", None):\n+            form_url = self.request.getURL()\n+            source_url = "{:s}/++widget++{:s}/@@getSource".format(\n+                form_url,\n+                self.name,\n+            )\n+            args["pattern_options"]["vocabularyUrl"] = source_url\n+\n+        # ISequence represents an orderable collection\n+        if ISequence.providedBy(self.field) or self.orderable:\n+            args["pattern_options"]["orderable"] = True\n+\n+        if self.vocabulary == "plone.app.vocabularies.Keywords":\n+            membership = getToolByName(context, "portal_membership")\n+            user = membership.getAuthenticatedMember()\n+\n+            registry = getUtility(IRegistry)\n+            roles_allowed_to_add_keywords = registry.get(\n+                "plone.roles_allowed_to_add_keywords", set()\n+            )\n+            roles = set(user.getRolesInContext(context))\n+            allowNewItems = bool(\n+                roles.intersection(roles_allowed_to_add_keywords),\n+            )\n+            args["pattern_options"]["allowNewItems"] = str(\n+                allowNewItems,\n+            ).lower()\n+\n+        return args\n+\n+\n+@implementer(IFieldWidget)\n+def SelectFieldWidget(field, request):\n+    return FieldWidget(field, SelectWidget(request))\n+\n+\n+@implementer(IFieldWidget)\n+def AjaxSelectFieldWidget(field, request, extra=None):\n+    if extra is not None:\n+        request = extra\n+    return FieldWidget(field, AjaxSelectWidget(request))\ndiff --git a/plone/app/z3cform/widgets/singlecheckbox.py b/plone/app/z3cform/widgets/singlecheckbox.py\nnew file mode 100644\nindex 00000000..e7e50508\n--- /dev/null\n+++ b/plone/app/z3cform/widgets/singlecheckbox.py\n@@ -0,0 +1,90 @@\n+from plone.app.vocabularies.terms import TermWithDescription\n+from plone.app.z3cform.interfaces import IPloneFormLayer\n+from plone.app.z3cform.interfaces import ISingleCheckBoxBoolWidget\n+from z3c.form.browser.checkbox import SingleCheckBoxWidget\n+from z3c.form.interfaces import IFieldWidget\n+from z3c.form.term import BoolTerms\n+from z3c.form.term import Terms\n+from z3c.form.widget import FieldWidget\n+from zope.component import adapter\n+from zope.interface import implementer\n+from zope.interface import implementer_only\n+from zope.schema.interfaces import IBool\n+from zope.schema.vocabulary import SimpleTerm\n+from zope.schema.vocabulary import SimpleVocabulary\n+\n+\n+@implementer_only(ISingleCheckBoxBoolWidget)\n+class SingleCheckBoxBoolWidget(SingleCheckBoxWidget):\n+    """Single Input type checkbox widget implementation."""\n+\n+    klass = "single-checkbox-bool-widget"\n+\n+    @property\n+    def label(self):\n+        if self.mode == "input":\n+            return ""\n+        return getattr(self, "_label", "")\n+\n+    @label.setter\n+    def label(self, value):\n+        self._label = value\n+\n+    @property\n+    def description(self):\n+        if self.mode == "input":\n+            return ""\n+        return getattr(self, "_description", "")\n+\n+    @description.setter\n+    def description(self, value):\n+        self._description = value\n+\n+    def updateTerms(self):\n+        if self.mode == "input":\n+            # in input mode use only one checkbox with true\n+            self.terms = Terms()\n+            self.terms.terms = SimpleVocabulary(\n+                (\n+                    TermWithDescription(\n+                        True,\n+                        "selected",\n+                        getattr(self, "_label", None) or self.field.title,\n+                        getattr(\n+                            self,\n+                            "_description",\n+                            None,\n+                        )\n+                        or self.field.description,\n+                    ),\n+                )\n+            )\n+            return self.terms\n+        if not self.terms:\n+            self.terms = Terms()\n+            self.terms.terms = SimpleVocabulary(\n+                [\n+                    SimpleTerm(*args)\n+                    for args in [\n+                        (True, "selected", BoolTerms.trueLabel),\n+                        (False, "unselected", BoolTerms.falseLabel),\n+                    ]\n+                ],\n+            )\n+        return self.terms\n+\n+    @property\n+    def items(self):\n+        result = super().items\n+        for record in result:\n+            term = self.terms.terms.getTermByToken(record["value"])\n+            record["description"] = getattr(term, "description", "")\n+            record["required"] = self.required\n+        return result\n+\n+\n+@adapter(IBool, IPloneFormLayer)\n+@implementer(IFieldWidget)\n+def SingleCheckBoxBoolFieldWidget(field, request):\n+    """IFieldWidget factory for CheckBoxWidget."""\n+    return FieldWidget(field, SingleCheckBoxBoolWidget(request))\n'

Repository: plone.app.z3cform


Branch: refs/heads/master
Date: 2023-03-23T10:01:26+01:00
Author: Peter Mathis (petschki) <peter.mathis@kombinat.at>
Commit: https://github.com/plone/plone.app.z3cform/commit/2db4edf090707b89810cf7abc9f879cde55aed22

do not depend on plone.app.widgets anymore

Files changed:
M setup.py

b'diff --git a/setup.py b/setup.py\nindex 6311dd5..fa661d3 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -53,28 +53,14 @@ def read(*rnames):\n     zip_safe=False,\n     python_requires=">=3.8",\n     install_requires=[\n-        "lxml",\n-        "plone.app.contentlisting",\n-        "plone.app.vocabularies",\n         "plone.app.textfield>=1.3.6",\n-        "plone.app.widgets>=2.4.2",\n         "plone.base",\n-        "plone.dexterity",\n-        "plone.i18n",\n-        "plone.namedfile",\n         "plone.protect",\n-        "plone.registry",\n-        "plone.uuid",\n-        "plone.z3cform",\n-        "Products.GenericSetup",\n-        "pytz",\n         "setuptools",\n         "z3c.form >= 4.0",\n-        "z3c.relationfield",\n-        "zope.browserpage",\n-        "zope.contentprovider",\n+        "z3c.formwidget.query",\n+        "zope.deprecation",\n         "zope.globalrequest",\n-        "zope.pagetemplate",\n         "Zope",\n     ],\n     extras_require={\n'

Repository: plone.app.z3cform


Branch: refs/heads/master
Date: 2023-03-23T10:01:26+01:00
Author: Peter Mathis (petschki) <peter.mathis@kombinat.at>
Commit: https://github.com/plone/plone.app.z3cform/commit/e55bdf420c57362f9844913da1041417ea65d613

changenote

Files changed:
A news/19.feature

b'diff --git a/news/19.feature b/news/19.feature\nnew file mode 100644\nindex 0000000..be498c6\n--- /dev/null\n+++ b/news/19.feature\n@@ -0,0 +1,2 @@\n+Merge utils and base classes from  ``plone.app.widgets`` and do not depend\n+on it anymore. [petschki]\n'

Repository: plone.app.z3cform


Branch: refs/heads/master
Date: 2023-03-23T10:01:26+01:00
Author: Peter Mathis (petschki) <peter.mathis@kombinat.at>
Commit: https://github.com/plone/plone.app.z3cform/commit/df1dac2d1d2bfe4f0102b3688aafbd6b1b714365

fix import and mocked querystring_options in patterns tests

Files changed:
A plone/app/z3cform/tests/test_patterns.py
M plone/app/z3cform/tests/test_widgets.py
D plone/app/z3cform/tests/test_utils_patterns.py
D plone/app/z3cform/tests/test_widgets_patterns.py

b'diff --git a/plone/app/z3cform/tests/test_widgets_patterns.py b/plone/app/z3cform/tests/test_patterns.py\nsimilarity index 51%\nrename from plone/app/z3cform/tests/test_widgets_patterns.py\nrename to plone/app/z3cform/tests/test_patterns.py\nindex b91fc1b..1bc3672 100644\n--- a/plone/app/z3cform/tests/test_widgets_patterns.py\n+++ b/plone/app/z3cform/tests/test_patterns.py\n@@ -1,6 +1,332 @@\n+# -*- coding: utf-8 -*-\n+from mock import patch\n+from plone.app.testing import setRoles\n+from plone.app.testing import TEST_USER_ID\n+from plone.app.z3cform.widgets.querystring import get_querystring_options\n+from plone.app.z3cform.widgets.relateditems import get_relateditems_options\n+from plone.app.z3cform.widgets.richtext import get_tinymce_options\n+from plone.app.z3cform.tests.layer import PAZ3CForm_INTEGRATION_TESTING\n+\n import unittest\n \n \n+class TestQueryStringOptions(unittest.TestCase):\n+    layer = PAZ3CForm_INTEGRATION_TESTING\n+\n+    def setUp(self):\n+        setRoles(self.layer[\'portal\'], TEST_USER_ID, [\'Contributor\'])\n+\n+    def test__query_string_options(self):\n+        """Test query string options on root:\n+        All URLs and paths equal root url and path,\n+        no favorites\n+        """\n+\n+        portal = self.layer[\'portal\']\n+        options = get_querystring_options(\n+            portal,\n+            \'@@qsOptions\'\n+        )\n+\n+        # Test base options\n+        self.assertEqual(\n+            options[\'indexOptionsUrl\'],\n+            \'http://nohost/plone/@@qsOptions\'\n+        )\n+\n+        self.assertEqual(\n+            options[\'previewCountURL\'],\n+            \'http://nohost/plone/@@querybuildernumberofresults\'\n+        )\n+\n+        self.assertEqual(\n+            options[\'previewURL\'],\n+            \'http://nohost/plone/@@querybuilder_html_results\'\n+        )\n+\n+        # Test options of the AJAX select widget\n+        self.assertEqual(\n+            options[\'patternAjaxSelectOptions\'][\'separator\'],\n+            \';\'\n+        )\n+\n+        # Test options of the date picker\n+        self.assertEqual(\n+            options[\'patternDateOptions\'],\n+            {\'behavior\': \'native\', \'week-numbers\': \'show\', \'first-day\': 0, \'today\': \'Today\', \'clear\': \'Clear\'}\n+        )\n+\n+        # Test options of the related items widget\n+        self.assertEqual(\n+            options[\'patternRelateditemsOptions\'][\'basePath\'],\n+            \'/plone\'\n+        )\n+        self.assertTrue(\n+            \'recentlyUsed\' not in options[\'patternRelateditemsOptions\']\n+        )\n+\n+\n+class TestRelatedItemsOptions(unittest.TestCase):\n+    layer = PAZ3CForm_INTEGRATION_TESTING\n+\n+    def setUp(self):\n+        setRoles(self.layer[\'portal\'], TEST_USER_ID, [\'Contributor\'])\n+\n+    def test__base_relateditems_options(self):\n+        """Test related items options on root:\n+        All URLs and paths equal root url and path,\n+        no favorites\n+        """\n+\n+        portal = self.layer[\'portal\']\n+        options = get_relateditems_options(\n+            portal,\n+            None,\n+            \'#!@\',\n+            \'test_vocab\',\n+            \'@@vocab\',\n+            \'testfield\'\n+        )\n+\n+        # vocab is correctly set\n+        self.assertTrue(\n+            \'@@vocab?name=test_vocab&field=testfield\'\n+            in options[\'vocabularyUrl\']\n+        )\n+\n+        # rootUrl contains something\n+        self.assertTrue(\n+            bool(options[\'rootUrl\'])\n+        )\n+\n+        root_path = context_path = \'/\'.join(portal.getPhysicalPath())\n+        root_url = context_url = portal.absolute_url()\n+\n+        # context_path contains something, otherwise this test is meaningless\n+        self.assertTrue(bool(context_path))\n+        # context_url contains something, otherwise this test is meaningless\n+        self.assertTrue(bool(context_url))\n+\n+        self.assertEqual(\n+            options[\'rootUrl\'],\n+            root_url\n+        )\n+\n+        self.assertEqual(\n+            options[\'rootPath\'],\n+            root_path\n+        )\n+\n+        self.assertEqual(\n+            options[\'vocabularyUrl\'],\n+            root_url + \'/@@vocab?name=test_vocab&field=testfield\'\n+        )\n+\n+        self.assertEqual(\n+            options[\'basePath\'],\n+            context_path\n+        )\n+\n+        self.assertEqual(\n+            options[\'contextPath\'],\n+            context_path\n+        )\n+\n+        self.assertEqual(\n+            options[\'separator\'],\n+            \'#!@\'\n+        )\n+\n+        self.assertTrue(\n+            \'favorites\' not in options\n+        )\n+\n+        # Recently used is configured, but off per default.\n+        self.assertEqual(\n+            options[\'recentlyUsed\'],\n+            False\n+        )\n+        self.assertEqual(\n+            options[\'recentlyUsedKey\'],\n+            \'relateditems_recentlyused_testfield_\' + TEST_USER_ID\n+        )\n+\n+    def test__subfolder_relateditems_options(self):\n+        """Test related items options on subfolder:\n+        Vocab called on root, start path is folder, have favorites.\n+        """\n+\n+        portal = self.layer[\'portal\']\n+        portal.invokeFactory(\'Folder\', \'sub\')\n+        sub = portal.sub\n+        options = get_relateditems_options(\n+            sub,\n+            None,\n+            \'#!@\',\n+            \'test_vocab\',\n+            \'@@vocab\',\n+            \'testfield\'\n+        )\n+\n+        # vocab is correctly set\n+        self.assertTrue(\n+            \'@@vocab?name=test_vocab&field=testfield\'\n+            in options[\'vocabularyUrl\']\n+        )\n+\n+        # rootUrl contains something\n+        self.assertTrue(\n+            bool(options[\'rootUrl\'])\n+        )\n+\n+        root_path = \'/\'.join(portal.getPhysicalPath())\n+        root_url = portal.absolute_url()\n+        context_path = \'/\'.join(sub.getPhysicalPath())\n+        context_url = sub.absolute_url()\n+\n+        # context_path contains something, otherwise this test is meaningless\n+        self.assertTrue(bool(context_path))\n+        # context_url contains something, otherwise this test is meaningless\n+        self.assertTrue(bool(context_url))\n+\n+        self.assertEqual(\n+            options[\'rootUrl\'],\n+            root_url\n+        )\n+\n+        self.assertEqual(\n+            options[\'rootPath\'],\n+            root_path\n+        )\n+\n+        self.assertEqual(\n+            options[\'vocabularyUrl\'],\n+            root_url + \'/@@vocab?name=test_vocab&field=testfield\'\n+        )\n+\n+        self.assertEqual(\n+            options[\'basePath\'],\n+            context_path\n+        )\n+\n+        self.assertEqual(\n+            options[\'contextPath\'],\n+            context_path\n+        )\n+\n+        self.assertEqual(\n+            options[\'separator\'],\n+            \'#!@\'\n+        )\n+\n+        self.assertEqual(\n+            len(options[\'favorites\']),\n+            2\n+        )\n+\n+        self.assertEqual(\n+            sorted(options[\'favorites\'][0].keys()),\n+            [\'path\', \'title\']\n+        )\n+\n+    def test__subdocument_relateditems_options(self):\n+        """Test related items options on subdoc:\n+        Vocab called on root, start path is root as document is not folderish,\n+        no favorites.\n+        """\n+\n+        portal = self.layer[\'portal\']\n+        portal.invokeFactory(\'Document\', \'sub\')\n+        sub = portal.sub\n+        options = get_relateditems_options(\n+            sub,\n+            None,\n+            \'#!@\',\n+            \'test_vocab\',\n+            \'@@vocab\',\n+            \'testfield\'\n+        )\n+\n+        # vocab is correctly set\n+        self.assertTrue(\n+            \'@@vocab?name=test_vocab&field=testfield\'\n+            in options[\'vocabularyUrl\']\n+        )\n+\n+        # rootUrl contains something\n+        self.assertTrue(\n+            bool(options[\'rootUrl\'])\n+        )\n+\n+        root_path = \'/\'.join(portal.getPhysicalPath())\n+        root_url = portal.absolute_url()\n+        context_path = \'/\'.join(sub.getPhysicalPath())\n+        context_url = sub.absolute_url()\n+\n+        # context_path contains something, otherwise this test is meaningless\n+        self.assertTrue(bool(context_path))\n+        # context_url contains something, otherwise this test is meaningless\n+        self.assertTrue(bool(context_url))\n+\n+        self.assertEqual(\n+            options[\'rootUrl\'],\n+            root_url\n+        )\n+\n+        self.assertEqual(\n+            options[\'rootPath\'],\n+            root_path\n+        )\n+\n+        self.assertEqual(\n+            options[\'vocabularyUrl\'],\n+            root_url + \'/@@vocab?name=test_vocab&field=testfield\'\n+        )\n+\n+        self.assertEqual(\n+            options[\'basePath\'],\n+            root_path\n+        )\n+\n+        self.assertEqual(\n+            options[\'contextPath\'],\n+            context_path\n+        )\n+\n+        self.assertEqual(\n+            options[\'separator\'],\n+            \'#!@\'\n+        )\n+\n+        self.assertTrue(\n+            \'favorites\' not in options\n+        )\n+\n+\n+class TestTinyMCEOptions(unittest.TestCase):\n+    layer = PAZ3CForm_INTEGRATION_TESTING\n+\n+    def setUp(self):\n+        setRoles(self.layer[\'portal\'], TEST_USER_ID, [\'Contributor\'])\n+\n+    def test__tinymce_options_different_contexts(self):\n+        """Test if ``get_tinymce_options`` can be called with different\n+        contexts, including invalid and form contexts.\n+        """\n+        request = self.layer[\'request\']\n+        portal = self.layer[\'portal\']\n+        portal.invokeFactory(\'Folder\', \'sub\')\n+        sub = portal.sub\n+\n+        # TinyMCE on portal context\n+        options = get_tinymce_options(portal, None, request)\n+        self.assertEqual(options[\'relatedItems\'][\'basePath\'], \'/plone\')\n+\n+        # TinyMCE on sub folder context\n+        options = get_tinymce_options(sub, None, request)\n+        self.assertEqual(options[\'relatedItems\'][\'basePath\'], \'/plone/sub\')\n+\n+\n class BaseWidgetTests(unittest.TestCase):\n     """Tests for plone.app.z3cform.widgets.patterns.BaseWidget."""\n \ndiff --git a/plone/app/z3cform/tests/test_utils_patterns.py b/plone/app/z3cform/tests/test_utils_patterns.py\ndeleted file mode 100644\nindex 99bd36f..0000000\n--- a/plone/app/z3cform/tests/test_utils_patterns.py\n+++ /dev/null\n@@ -1,327 +0,0 @@\n-# -*- coding: utf-8 -*-\n-from mock import patch\n-from plone.app.testing import setRoles\n-from plone.app.testing import TEST_USER_ID\n-from plone.app.z3cform.tests.layer import PAZ3CForm_INTEGRATION_TESTING\n-from plone.app.z3cform.widgets.querystring import get_querystring_options\n-from plone.app.z3cform.widgets.relateditems import get_relateditems_options\n-from plone.app.z3cform.widgets.richtext import get_tinymce_options\n-\n-import unittest\n-\n-\n-class TestQueryStringOptions(unittest.TestCase):\n-    layer = PAZ3CForm_INTEGRATION_TESTING\n-\n-    def setUp(self):\n-        setRoles(self.layer[\'portal\'], TEST_USER_ID, [\'Contributor\'])\n-\n-    def test__query_string_options(self):\n-        """Test query string options on root:\n-        All URLs and paths equal root url and path,\n-        no favorites\n-        """\n-\n-        portal = self.layer[\'portal\']\n-        options = get_querystring_options(\n-            portal,\n-            \'@@qsOptions\'\n-        )\n-\n-        # Test base options\n-        self.assertEqual(\n-            options[\'indexOptionsUrl\'],\n-            \'http://nohost/plone/@@qsOptions\'\n-        )\n-\n-        self.assertEqual(\n-            options[\'previewCountURL\'],\n-            \'http://nohost/plone/@@querybuildernumberofresults\'\n-        )\n-\n-        self.assertEqual(\n-            options[\'previewURL\'],\n-            \'http://nohost/plone/@@querybuilder_html_results\'\n-        )\n-\n-        # Test options of the AJAX select widget\n-        self.assertEqual(\n-            options[\'patternAjaxSelectOptions\'][\'separator\'],\n-            \';\'\n-        )\n-\n-        # Test options of the date picker\n-        self.assertEqual(\n-            options[\'patternDateOptions\'],\n-            {\'behavior\': \'native\', \'week-numbers\': \'show\', \'first-day\': 0, \'today\': \'Today\', \'clear\': \'Clear\'}\n-        )\n-\n-        # Test options of the related items widget\n-        self.assertEqual(\n-            options[\'patternRelateditemsOptions\'][\'basePath\'],\n-            \'/plone\'\n-        )\n-        self.assertTrue(\n-            \'recentlyUsed\' not in options[\'patternRelateditemsOptions\']\n-        )\n-\n-\n-class TestRelatedItemsOptions(unittest.TestCase):\n-    layer = PAZ3CForm_INTEGRATION_TESTING\n-\n-    def setUp(self):\n-        setRoles(self.layer[\'portal\'], TEST_USER_ID, [\'Contributor\'])\n-\n-    def test__base_relateditems_options(self):\n-        """Test related items options on root:\n-        All URLs and paths equal root url and path,\n-        no favorites\n-        """\n-\n-        portal = self.layer[\'portal\']\n-        options = get_relateditems_options(\n-            portal,\n-            None,\n-            \'#!@\',\n-            \'test_vocab\',\n-            \'@@vocab\',\n-            \'testfield\'\n-        )\n-\n-        # vocab is correctly set\n-        self.assertTrue(\n-            \'@@vocab?name=test_vocab&field=testfield\'\n-            in options[\'vocabularyUrl\']\n-        )\n-\n-        # rootUrl contains something\n-        self.assertTrue(\n-            bool(options[\'rootUrl\'])\n-        )\n-\n-        root_path = context_path = \'/\'.join(portal.getPhysicalPath())\n-        root_url = context_url = portal.absolute_url()\n-\n-        # context_path contains something, otherwise this test is meaningless\n-        self.assertTrue(bool(context_path))\n-        # context_url contains something, otherwise this test is meaningless\n-        self.assertTrue(bool(context_url))\n-\n-        self.assertEqual(\n-            options[\'rootUrl\'],\n-            root_url\n-        )\n-\n-        self.assertEqual(\n-            options[\'rootPath\'],\n-            root_path\n-        )\n-\n-        self.assertEqual(\n-            options[\'vocabularyUrl\'],\n-            root_url + \'/@@vocab?name=test_vocab&field=testfield\'\n-        )\n-\n-        self.assertEqual(\n-            options[\'basePath\'],\n-            context_path\n-        )\n-\n-        self.assertEqual(\n-            options[\'contextPath\'],\n-            context_path\n-        )\n-\n-        self.assertEqual(\n-            options[\'separator\'],\n-            \'#!@\'\n-        )\n-\n-        self.assertTrue(\n-            \'favorites\' not in options\n-        )\n-\n-        # Recently used is configured, but off per default.\n-        self.assertEqual(\n-            options[\'recentlyUsed\'],\n-            False\n-        )\n-        self.assertEqual(\n-            options[\'recentlyUsedKey\'],\n-            \'relateditems_recentlyused_testfield_\' + TEST_USER_ID\n-        )\n-\n-    def test__subfolder_relateditems_options(self):\n-        """Test related items options on subfolder:\n-        Vocab called on root, start path is folder, have favorites.\n-        """\n-\n-        portal = self.layer[\'portal\']\n-        portal.invokeFactory(\'Folder\', \'sub\')\n-        sub = portal.sub\n-        options = get_relateditems_options(\n-            sub,\n-            None,\n-            \'#!@\',\n-            \'test_vocab\',\n-            \'@@vocab\',\n-            \'testfield\'\n-        )\n-\n-        # vocab is correctly set\n-        self.assertTrue(\n-            \'@@vocab?name=test_vocab&field=testfield\'\n-            in options[\'vocabularyUrl\']\n-        )\n-\n-        # rootUrl contains something\n-        self.assertTrue(\n-            bool(options[\'rootUrl\'])\n-        )\n-\n-        root_path = \'/\'.join(portal.getPhysicalPath())\n-        root_url = portal.absolute_url()\n-        context_path = \'/\'.join(sub.getPhysicalPath())\n-        context_url = sub.absolute_url()\n-\n-        # context_path contains something, otherwise this test is meaningless\n-        self.assertTrue(bool(context_path))\n-        # context_url contains something, otherwise this test is meaningless\n-        self.assertTrue(bool(context_url))\n-\n-        self.assertEqual(\n-            options[\'rootUrl\'],\n-            root_url\n-        )\n-\n-        self.assertEqual(\n-            options[\'rootPath\'],\n-            root_path\n-        )\n-\n-        self.assertEqual(\n-            options[\'vocabularyUrl\'],\n-            root_url + \'/@@vocab?name=test_vocab&field=testfield\'\n-        )\n-\n-        self.assertEqual(\n-            options[\'basePath\'],\n-            context_path\n-        )\n-\n-        self.assertEqual(\n-            options[\'contextPath\'],\n-            context_path\n-        )\n-\n-        self.assertEqual(\n-            options[\'separator\'],\n-            \'#!@\'\n-        )\n-\n-        self.assertEqual(\n-            len(options[\'favorites\']),\n-            2\n-        )\n-\n-        self.assertEqual(\n-            sorted(options[\'favorites\'][0].keys()),\n-            [\'path\', \'title\']\n-        )\n-\n-    def test__subdocument_relateditems_options(self):\n-        """Test related items options on subdoc:\n-        Vocab called on root, start path is root as document is not folderish,\n-        no favorites.\n-        """\n-\n-        portal = self.layer[\'portal\']\n-        portal.invokeFactory(\'Document\', \'sub\')\n-        sub = portal.sub\n-        options = get_relateditems_options(\n-            sub,\n-            None,\n-            \'#!@\',\n-            \'test_vocab\',\n-            \'@@vocab\',\n-            \'testfield\'\n-        )\n-\n-        # vocab is correctly set\n-        self.assertTrue(\n-            \'@@vocab?name=test_vocab&field=testfield\'\n-            in options[\'vocabularyUrl\']\n-        )\n-\n-        # rootUrl contains something\n-        self.assertTrue(\n-            bool(options[\'rootUrl\'])\n-        )\n-\n-        root_path = \'/\'.join(portal.getPhysicalPath())\n-        root_url = portal.absolute_url()\n-        context_path = \'/\'.join(sub.getPhysicalPath())\n-        context_url = sub.absolute_url()\n-\n-        # context_path contains something, otherwise this test is meaningless\n-        self.assertTrue(bool(context_path))\n-        # context_url contains something, otherwise this test is meaningless\n-        self.assertTrue(bool(context_url))\n-\n-        self.assertEqual(\n-            options[\'rootUrl\'],\n-            root_url\n-        )\n-\n-        self.assertEqual(\n-            options[\'rootPath\'],\n-            root_path\n-        )\n-\n-        self.assertEqual(\n-            options[\'vocabularyUrl\'],\n-            root_url + \'/@@vocab?name=test_vocab&field=testfield\'\n-        )\n-\n-        self.assertEqual(\n-            options[\'basePath\'],\n-            root_path\n-        )\n-\n-        self.assertEqual(\n-            options[\'contextPath\'],\n-            context_path\n-        )\n-\n-        self.assertEqual(\n-            options[\'separator\'],\n-            \'#!@\'\n-        )\n-\n-        self.assertTrue(\n-            \'favorites\' not in options\n-        )\n-\n-\n-class TestTinyMCEOptions(unittest.TestCase):\n-    layer = PAZ3CForm_INTEGRATION_TESTING\n-\n-    def setUp(self):\n-        setRoles(self.layer[\'portal\'], TEST_USER_ID, [\'Contributor\'])\n-\n-    def test__tinymce_options_different_contexts(self):\n-        """Test if ``get_tinymce_options`` can be called with different\n-        contexts, including invalid and form contexts.\n-        """\n-        request = self.layer[\'request\']\n-        portal = self.layer[\'portal\']\n-        portal.invokeFactory(\'Folder\', \'sub\')\n-        sub = portal.sub\n-\n-        # TinyMCE on portal context\n-        options = get_tinymce_options(portal, None, request)\n-        self.assertEqual(options[\'relatedItems\'][\'basePath\'], \'/plone\')\n-\n-        # TinyMCE on sub folder context\n-        options = get_tinymce_options(sub, None, request)\n-        self.assertEqual(options[\'relatedItems\'][\'basePath\'], \'/plone/sub\')\ndiff --git a/plone/app/z3cform/tests/test_widgets.py b/plone/app/z3cform/tests/test_widgets.py\nindex 8dafd33..c64bdc7 100644\n--- a/plone/app/z3cform/tests/test_widgets.py\n+++ b/plone/app/z3cform/tests/test_widgets.py\n@@ -532,7 +532,7 @@ def tearDown(self):\n         base.unregisterAdapter(term.CollectionTermsSource)\n \n     def test_widget(self):\n-        from plone.app.z3cform.widget import SelectWidget\n+        from plone.app.z3cform.widgets.select import SelectWidget\n \n         widget = SelectWidget(self.request)\n         widget.id = "test-widget"\n@@ -630,7 +630,7 @@ def test_widget(self):\n         )\n \n     def test_widget_list_orderable(self):\n-        from plone.app.z3cform.widget import SelectWidget\n+        from plone.app.z3cform.widgets.select import SelectWidget\n \n         widget = SelectWidget(self.request)\n         widget.id = "test-widget"\n@@ -657,7 +657,7 @@ def test_widget_list_orderable(self):\n         )\n \n     def test_widget_tuple_orderable(self):\n-        from plone.app.z3cform.widget import SelectWidget\n+        from plone.app.z3cform.widgets.select import SelectWidget\n \n         widget = SelectWidget(self.request)\n         widget.id = "test-widget"\n@@ -683,7 +683,7 @@ def test_widget_tuple_orderable(self):\n         )\n \n     def test_widget_set_not_orderable(self):\n-        from plone.app.z3cform.widget import SelectWidget\n+        from plone.app.z3cform.widgets.select import SelectWidget\n \n         widget = SelectWidget(self.request)\n         widget.id = "test-widget"\n@@ -710,7 +710,7 @@ def test_widget_set_not_orderable(self):\n         )\n \n     def test_widget_extract(self):\n-        from plone.app.z3cform.widget import SelectWidget\n+        from plone.app.z3cform.widgets.select import SelectWidget\n \n         widget = SelectWidget(self.request)\n         widget.field = Choice(\n@@ -726,7 +726,7 @@ def test_widget_extract(self):\n \n     def test_data_converter_list(self):\n         from plone.app.z3cform.converters import SelectWidgetConverter\n-        from plone.app.z3cform.widget import SelectWidget\n+        from plone.app.z3cform.widgets.select import SelectWidget\n \n         field = List(\n             __name__="listfield",\n@@ -773,7 +773,7 @@ def test_data_converter_list(self):\n \n     def test_data_converter_tuple(self):\n         from plone.app.z3cform.converters import SelectWidgetConverter\n-        from plone.app.z3cform.widget import SelectWidget\n+        from plone.app.z3cform.widgets.select import SelectWidget\n \n         field = Tuple(\n             __name__="tuplefield",\n@@ -809,7 +809,7 @@ def test_data_converter_tuple(self):\n \n     def test_data_converter_handles_empty_value(self):\n         from plone.app.z3cform.converters import SelectWidgetConverter\n-        from plone.app.z3cform.widget import SelectWidget\n+        from plone.app.z3cform.widgets.select import SelectWidget\n \n         field = Tuple(\n             __name__="tuplefield",\n@@ -829,7 +829,7 @@ def test_widget_optgroup(self):\n         """\n         If the widget vocabulary is a mapping <optgroup>\'s are rendered.\n         """\n-        from plone.app.z3cform.widget import SelectWidget\n+        from plone.app.z3cform.widgets.select import SelectWidget\n         from z3c.form import term\n \n         widget = SelectWidget(self.request)\n@@ -885,7 +885,7 @@ def setUp(self):\n         provideUtility(example_vocabulary_factory, name="example")\n \n     def test_widget(self):\n-        from plone.app.z3cform.widget import AjaxSelectWidget\n+        from plone.app.z3cform.widgets.select import AjaxSelectWidget\n \n         widget = AjaxSelectWidget(self.request)\n         widget.update()\n@@ -932,7 +932,7 @@ def test_widget(self):\n         )\n \n     def test_widget_list_orderable(self):\n-        from plone.app.z3cform.widget import AjaxSelectWidget\n+        from plone.app.z3cform.widgets.select import AjaxSelectWidget\n \n         widget = AjaxSelectWidget(self.request)\n         widget.field = List(__name__="selectfield")\n@@ -947,7 +947,7 @@ def test_widget_list_orderable(self):\n         )\n \n     def test_widget_tuple_orderable(self):\n-        from plone.app.z3cform.widget import AjaxSelectWidget\n+        from plone.app.z3cform.widgets.select import AjaxSelectWidget\n \n         widget = AjaxSelectWidget(self.request)\n         widget.field = Tuple(__name__="selectfield")\n@@ -962,7 +962,7 @@ def test_widget_tuple_orderable(self):\n         )\n \n     def test_widget_set_not_orderable(self):\n-        from plone.app.z3cform.widget import AjaxSelectWidget\n+        from plone.app.z3cform.widgets.select import AjaxSelectWidget\n \n         widget = AjaxSelectWidget(self.request)\n         # A set is not orderable\n@@ -978,7 +978,7 @@ def test_widget_set_not_orderable(self):\n         )\n \n     def test_widget_choice(self):\n-        from plone.app.z3cform.widget import AjaxSelectWidget\n+        from plone.app.z3cform.widgets.select import AjaxSelectWidget\n         from zope.schema.interfaces import ISource\n \n         widget = AjaxSelectWidget(self.request)\n@@ -1002,7 +1002,7 @@ def test_widget_choice(self):\n         )\n \n     def test_widget_addform_url_on_addform(self):\n-        from plone.app.z3cform.widget import AjaxSelectWidget\n+        from plone.app.z3cform.widgets.select import AjaxSelectWidget\n \n         widget = AjaxSelectWidget(self.request)\n         form = Mock(parentForm=None)\n@@ -1037,7 +1037,7 @@ def test_widget_addform_url_on_addform(self):\n \n     def test_data_converter_list(self):\n         from plone.app.z3cform.converters import AjaxSelectWidgetConverter\n-        from plone.app.z3cform.widget import AjaxSelectWidget\n+        from plone.app.z3cform.widgets.select import AjaxSelectWidget\n \n         field = List(__name__="listfield", value_type=TextLine())\n         widget = AjaxSelectWidget(self.request)\n@@ -1066,7 +1066,7 @@ def test_data_converter_list(self):\n \n     def test_data_converter_collection_with_vocabulary(self):\n         from plone.app.z3cform.converters import AjaxSelectWidgetConverter\n-        from plone.app.z3cform.widget import AjaxSelectWidget\n+        from plone.app.z3cform.widgets.select import AjaxSelectWidget\n \n         field = Tuple(\n             __name__="listfield",\n@@ -1100,7 +1100,7 @@ def test_data_converter_collection_with_vocabulary(self):\n \n     def test_data_converter_tuple(self):\n         from plone.app.z3cform.converters import AjaxSelectWidgetConverter\n-        from plone.app.z3cform.widget import AjaxSelectWidget\n+        from plone.app.z3cform.widgets.select import AjaxSelectWidget\n \n         field = Tuple(__name__="tuplefield", value_type=TextLine())\n         widget = AjaxSelectWidget(self.request)\n@@ -1128,8 +1128,8 @@ def test_data_converter_tuple(self):\n         )\n \n     def test_fieldwidget(self):\n-        from plone.app.z3cform.widget import AjaxSelectFieldWidget\n-        from plone.app.z3cform.widget import AjaxSelectWidget\n+        from plone.app.z3cform.widgets.select import AjaxSelectFieldWidget\n+        from plone.app.z3cform.widgets.select import AjaxSelectWidget\n \n         field = Mock(__name__="field", title="", required=True)\n         request = Mock()\n@@ -1139,8 +1139,8 @@ def test_fieldwidget(self):\n         self.assertIs(widget.request, request)\n \n     def test_fieldwidget_sequence(self):\n-        from plone.app.z3cform.widget import AjaxSelectFieldWidget\n-        from plone.app.z3cform.widget import AjaxSelectWidget\n+        from plone.app.z3cform.widgets.select import AjaxSelectFieldWidget\n+        from plone.app.z3cform.widgets.select import AjaxSelectWidget\n \n         field = Mock(__name__="field", title="", required=True)\n         vocabulary = Mock()\n@@ -1158,7 +1158,7 @@ def setUp(self):\n         self.request = TestRequest(environ={"HTTP_ACCEPT_LANGUAGE": "en"})\n \n     def test_keywords_can_add(self):\n-        from plone.app.z3cform.widget import AjaxSelectWidget\n+        from plone.app.z3cform.widgets.select import AjaxSelectWidget\n \n         portal = self.layer["portal"]\n         setRoles(portal, TEST_USER_ID, ["Manager"])\n@@ -1171,7 +1171,7 @@ def test_keywords_can_add(self):\n         )\n \n     def test_keywords_cannot_add(self):\n-        from plone.app.z3cform.widget import AjaxSelectWidget\n+        from plone.app.z3cform.widgets.select import AjaxSelectWidget\n \n         portal = self.layer["portal"]\n         widget = AjaxSelectWidget(self.request)\n@@ -1183,6 +1183,17 @@ def test_keywords_cannot_add(self):\n         )\n \n \n+def mock_querystring_options(context, querystring_view):\n+    return {\n+        \'indexOptionsUrl\': \'/{}\'.format(querystring_view),\n+        \'previewURL\': \'/@@querybuilder_html_results\',\n+        \'previewCountURL\': \'/@@querybuildernumberofresults\',\n+        \'patternDateOptions\': None,\n+        \'patternAjaxSelectOptions\': {\'separator\': \';\'},\n+        \'patternRelateditemsOptions\': None,\n+    }\n+\n+\n class QueryStringWidgetTests(unittest.TestCase):\n     def setUp(self):\n         self.request = TestRequest(environ={"HTTP_ACCEPT_LANGUAGE": "en"})\n@@ -1202,12 +1213,8 @@ def test_converter_empty_value(self):\n         self.assertEqual(converter.toFieldValue("[]"), None)\n \n     @mock.patch(\n-        "plone.app.z3cform.widgets.datetime.get_date_options",\n-        new=lambda *args, **kwargs: None,\n-    )\n-    @mock.patch(\n-        "plone.app.z3cform.widgets.relateditems.get_relateditems_options",\n-        new=lambda *args, **kwargs: None,\n+        "plone.app.z3cform.widgets.querystring.get_querystring_options",\n+        new=mock_querystring_options,\n     )\n     def test_widget(self):\n         from plone.app.z3cform.widgets.querystring import QueryStringWidget\n@@ -1249,7 +1256,7 @@ def assertDictContainsSubsetReplacement(self, actual, expected):\n         return set(expected.items()).issubset(set(actual.items()))\n \n     def test_related_items_widget(self):\n-        from plone.app.z3cform.widget import RelatedItemsWidget\n+        from plone.app.z3cform.widgets.relateditems import RelatedItemsWidget\n \n         EXPECTED_ROOT_PATH = "/plone"\n         EXPECTED_ROOT_URL = "http://nohost/plone"\n@@ -1281,7 +1288,7 @@ def test_related_items_widget(self):\n \n     def test_related_items_widget_nav_root(self):\n         from plone.app.layout.navigation.interfaces import INavigationRoot\n-        from plone.app.z3cform.widget import RelatedItemsWidget\n+        from plone.app.z3cform.widgets.relateditems import RelatedItemsWidget\n \n         EXPECTED_ROOT_PATH = "/plone"\n         EXPECTED_ROOT_URL = "http://nohost/plone"\n@@ -1434,7 +1441,7 @@ def test_single_selection(self):\n     def test_multiple_selection(self):\n         """The pattern_options key maximumSelectionSize shouldn\'t be\n         set when the field allows multiple selections"""\n-        from plone.app.z3cform.widget import RelatedItemsFieldWidget\n+        from plone.app.z3cform.widgets.relateditems import RelatedItemsFieldWidget\n         from zope.schema.interfaces import ISource\n         from zope.schema.vocabulary import VocabularyRegistry\n \n@@ -1561,8 +1568,8 @@ def test_converter_List_of_Choice(self):\n             )\n \n     def test_fieldwidget(self):\n-        from plone.app.z3cform.widget import RelatedItemsFieldWidget\n-        from plone.app.z3cform.widget import RelatedItemsWidget\n+        from plone.app.z3cform.widgets.relateditems import RelatedItemsFieldWidget\n+        from plone.app.z3cform.widgets.relateditems import RelatedItemsWidget\n \n         field = Mock(__name__="field", title="", required=True)\n         vocabulary = Mock()\n@@ -1584,7 +1591,7 @@ def add_mock_fti(portal):\n \n \n def _custom_field_widget(field, request):\n-    from plone.app.z3cform.widget import AjaxSelectWidget\n+    from plone.app.z3cform.widgets.select import AjaxSelectWidget\n \n     widget = FieldWidget(field, AjaxSelectWidget(request))\n     widget.vocabulary = "plone.app.vocabularies.PortalTypes"\n@@ -1610,7 +1617,7 @@ class IWithText(Interface):\n         self.field = IWithText["text"]\n \n     def test_widget_params(self):\n-        from plone.app.z3cform.widget import RichTextWidget\n+        from plone.app.z3cform.widgets.richtext import RichTextWidget\n \n         widget = FieldWidget(self.field, RichTextWidget(self.request))\n         # set the context so we can get tinymce settings\n@@ -1632,7 +1639,7 @@ def test_widget_params(self):\n         )\n \n     def test_widget_params_different_contexts(self):\n-        from plone.app.z3cform.widget import RichTextWidget\n+        from plone.app.z3cform.widgets.richtext import RichTextWidget\n \n         setRoles(self.portal, TEST_USER_ID, ["Contributor"])\n \n@@ -1683,7 +1690,7 @@ def test_widget_params_different_contexts(self):\n \n     def test_widget_values(self):\n         from plone.app.textfield.value import RichTextValue\n-        from plone.app.z3cform.widget import RichTextWidget\n+        from plone.app.z3cform.widgets.richtext import RichTextWidget\n \n         widget = FieldWidget(self.field, RichTextWidget(self.request))\n         # set the context so we can get tinymce settings\n@@ -1710,7 +1717,7 @@ def test_dx_tinymcewidget_single_mimetype(self):\n         if IMarkupSchema:\n             # if not, don\'t run this test\n             self._set_mimetypes(allowed=("text/html",))\n-            from plone.app.z3cform.widget import RichTextWidget\n+            from plone.app.z3cform.widgets.richtext import RichTextWidget\n \n             widget = FieldWidget(self.field, RichTextWidget(self.request))\n             # set the context so we can get tinymce settings\n@@ -1729,7 +1736,7 @@ def test_dx_tinymcewidget_multiple_mimetypes_create(self):\n         if IMarkupSchema:\n             # if not, don\'t run this test\n             self._set_mimetypes(allowed=("text/html", "text/plain"))\n-            from plone.app.z3cform.widget import RichTextWidget\n+            from plone.app.z3cform.widgets.richtext import RichTextWidget\n \n             widget = FieldWidget(self.field, RichTextWidget(self.request))\n             # set the context so we can get tinymce settings\n@@ -1753,7 +1760,7 @@ def test_dx_tinymcewidget_multiple_mimetypes_edit(self):\n             # if not, don\'t run this test\n             self._set_mimetypes(allowed=("text/html", "text/plain"))\n             from plone.app.textfield.value import RichTextValue\n-            from plone.app.z3cform.widget import RichTextWidget\n+            from plone.app.z3cform.widgets.richtext import RichTextWidget\n \n             widget = FieldWidget(self.field, RichTextWidget(self.request))\n             # set the context so we can get tinymce settings\n@@ -1780,7 +1787,7 @@ def test_use_default_editor_value(self):\n             proxy = registry.forInterface(IEditingSchema, check=False, prefix="plone")\n             proxy.available_editors = ["dummy", "TinyMCE"]\n             proxy.default_editor = "dummy"\n-            from plone.app.z3cform.widget import RichTextWidget\n+            from plone.app.z3cform.widgets.richtext import RichTextWidget\n \n             widget = FieldWidget(self.field, RichTextWidget(self.request))\n             widget.context = self.portal\n@@ -1788,7 +1795,7 @@ def test_use_default_editor_value(self):\n             self.assertTrue("<p>dummy</p>" in rendered)\n \n             proxy.default_editor = "TinyMCE"\n-            from plone.app.z3cform.widget import RichTextWidget\n+            from plone.app.z3cform.widgets.richtext import RichTextWidget\n \n             widget = FieldWidget(self.field, RichTextWidget(self.request))\n             widget.context = self.portal\n@@ -1806,7 +1813,7 @@ def setUp(self):\n         setRoles(self.portal, TEST_USER_ID, ["Manager"])\n \n     def test_link_widget__pattern_options(self):\n-        from plone.app.z3cform.widget import LinkWidget\n+        from plone.app.z3cform.widgets.link import LinkWidget\n \n         widget = LinkWidget(self.request)\n \n@@ -1818,7 +1825,7 @@ def test_link_widget__pattern_options(self):\n         self.assertEqual(pattern_data["maximumSelectionSize"], 1)\n \n     def test_link_widget__extract_internal(self):\n-        from plone.app.z3cform.widget import LinkWidget\n+        from plone.app.z3cform.widgets.link import LinkWidget\n \n         widget = LinkWidget(self.request)\n         widget.context = self.portal\n@@ -1832,7 +1839,7 @@ def test_link_widget__extract_internal(self):\n         )\n \n     def test_link_widget__extract_external(self):\n-        from plone.app.z3cform.widget import LinkWidget\n+        from plone.app.z3cform.widgets.link import LinkWidget\n \n         widget = LinkWidget(self.request)\n         widget.context = self.portal\n@@ -1846,7 +1853,7 @@ def test_link_widget__extract_external(self):\n         )\n \n     def test_link_widget__extract_email(self):\n-        from plone.app.z3cform.widget import LinkWidget\n+        from plone.app.z3cform.widgets.link import LinkWidget\n \n         widget = LinkWidget(self.request)\n         widget.context = self.portal\n@@ -1860,7 +1867,7 @@ def test_link_widget__extract_email(self):\n         )\n \n     def test_link_widget__extract_email_including_mailto(self):\n-        from plone.app.z3cform.widget import LinkWidget\n+        from plone.app.z3cform.widgets.link import LinkWidget\n \n         widget = LinkWidget(self.request)\n         widget.context = self.portal\n@@ -1875,7 +1882,7 @@ def test_link_widget__extract_email_including_mailto(self):\n \n     def test_link_widget__data_converter(self):\n         from plone.app.z3cform.converters import LinkWidgetDataConverter\n-        from plone.app.z3cform.widget import LinkWidget\n+        from plone.app.z3cform.widgets.link import LinkWidget\n \n         field = TextLine(__name__="linkfield")\n         widget = LinkWidget(self.request)\n'

Repository: plone.app.z3cform


Branch: refs/heads/master
Date: 2023-03-23T10:09:04+01:00
Author: Peter Mathis (petschki) <peter.mathis@kombinat.at>
Commit: https://github.com/plone/plone.app.z3cform/commit/0329dbc7bb185e5a81cd58159307be14270d1d8c

run `tox -e format` and fix `tox -e lint`

Files changed:
M plone/app/z3cform/converters.zcml
M plone/app/z3cform/tests/test_patterns.py
M plone/app/z3cform/tests/test_widgets.py
M plone/app/z3cform/utils.py
M plone/app/z3cform/widget.py
M plone/app/z3cform/widgets.zcml
M plone/app/z3cform/widgets/datetime.py
M plone/app/z3cform/widgets/patterns.py
M plone/app/z3cform/widgets/querystring.py
M plone/app/z3cform/widgets/relateditems.py
M plone/app/z3cform/widgets/richtext.py

b'diff --git a/plone/app/z3cform/converters.zcml b/plone/app/z3cform/converters.zcml\nindex 4edd89d..2bb8d76 100644\n--- a/plone/app/z3cform/converters.zcml\n+++ b/plone/app/z3cform/converters.zcml\n@@ -1,20 +1,26 @@\n <configure xmlns="http://namespaces.zope.org/zope">\n-    <adapter factory=".converters.BoolSingleCheckboxDataConverter" />\n-    <adapter factory=".converters.DatetimeWidgetConverter" />\n-    <adapter factory=".converters.DateWidgetConverter" />\n-    <adapter factory=".converters.DateWidgetToDatetimeConverter" />\n-    <adapter factory=".converters.TimeWidgetConverter" />\n-    <adapter factory=".converters.SelectWidgetConverter" />\n-    <adapter factory=".converters.SequenceSelectWidgetConverter" />\n-    <adapter factory=".converters.AjaxSelectWidgetConverter" />\n-    <adapter factory=".converters.QueryStringDataConverter" />\n-    <adapter factory=".converters.RelationChoiceRelatedItemsWidgetConverter" />\n-    <adapter factory=".converters.RelationChoiceRelatedItemsWidgetConverter"\n-             for="z3c.relationfield.interfaces.IRelationChoice .interfaces.ITextWidget" />\n-    <adapter factory=".converters.RelationChoiceSelectWidgetConverter" />\n-    <adapter factory=".converters.RelatedItemsDataConverter" />\n-    <adapter factory=".converters.RelatedItemsDataConverter"\n-             for="z3c.relationfield.interfaces.IRelationList .interfaces.ITextWidget" />\n-    <adapter factory=".converters.RelationListSelectWidgetDataConverter" />\n-    <adapter factory=".converters.LinkWidgetDataConverter" />\n+  <adapter factory=".converters.BoolSingleCheckboxDataConverter" />\n+  <adapter factory=".converters.DatetimeWidgetConverter" />\n+  <adapter factory=".converters.DateWidgetConverter" />\n+  <adapter factory=".converters.DateWidgetToDatetimeConverter" />\n+  <adapter factory=".converters.TimeWidgetConverter" />\n+  <adapter factory=".converters.SelectWidgetConverter" />\n+  <adapter factory=".converters.SequenceSelectWidgetConverter" />\n+  <adapter factory=".converters.AjaxSelectWidgetConverter" />\n+  <adapter factory=".converters.QueryStringDataConverter" />\n+  <adapter factory=".converters.RelationChoiceRelatedItemsWidgetConverter" />\n+  <adapter\n+      factory=".converters.RelationChoiceRelatedItemsWidgetConverter"\n+      for="z3c.relationfield.interfaces.IRelationChoice\n+           .interfaces.ITextWidget"\n+      />\n+  <adapter factory=".converters.RelationChoiceSelectWidgetConverter" />\n+  <adapter factory=".converters.RelatedItemsDataConverter" />\n+  <adapter\n+      factory=".converters.RelatedItemsDataConverter"\n+      for="z3c.relationfield.interfaces.IRelationList\n+           .interfaces.ITextWidget"\n+      />\n+  <adapter factory=".converters.RelationListSelectWidgetDataConverter" />\n+  <adapter factory=".converters.LinkWidgetDataConverter" />\n </configure>\ndiff --git a/plone/app/z3cform/tests/test_patterns.py b/plone/app/z3cform/tests/test_patterns.py\nindex 1bc3672..cb3722d 100644\n--- a/plone/app/z3cform/tests/test_patterns.py\n+++ b/plone/app/z3cform/tests/test_patterns.py\n@@ -1,11 +1,9 @@\n-# -*- coding: utf-8 -*-\n-from mock import patch\n from plone.app.testing import setRoles\n from plone.app.testing import TEST_USER_ID\n+from plone.app.z3cform.tests.layer import PAZ3CForm_INTEGRATION_TESTING\n from plone.app.z3cform.widgets.querystring import get_querystring_options\n from plone.app.z3cform.widgets.relateditems import get_relateditems_options\n from plone.app.z3cform.widgets.richtext import get_tinymce_options\n-from plone.app.z3cform.tests.layer import PAZ3CForm_INTEGRATION_TESTING\n \n import unittest\n \n@@ -14,7 +12,7 @@ class TestQueryStringOptions(unittest.TestCase):\n     layer = PAZ3CForm_INTEGRATION_TESTING\n \n     def setUp(self):\n-        setRoles(self.layer[\'portal\'], TEST_USER_ID, [\'Contributor\'])\n+        setRoles(self.layer["portal"], TEST_USER_ID, ["Contributor"])\n \n     def test__query_string_options(self):\n         """Test query string options on root:\n@@ -22,55 +20,46 @@ def test__query_string_options(self):\n         no favorites\n         """\n \n-        portal = self.layer[\'portal\']\n-        options = get_querystring_options(\n-            portal,\n-            \'@@qsOptions\'\n-        )\n+        portal = self.layer["portal"]\n+        options = get_querystring_options(portal, "@@qsOptions")\n \n         # Test base options\n-        self.assertEqual(\n-            options[\'indexOptionsUrl\'],\n-            \'http://nohost/plone/@@qsOptions\'\n-        )\n+        self.assertEqual(options["indexOptionsUrl"], "http://nohost/plone/@@qsOptions")\n \n         self.assertEqual(\n-            options[\'previewCountURL\'],\n-            \'http://nohost/plone/@@querybuildernumberofresults\'\n+            options["previewCountURL"],\n+            "http://nohost/plone/@@querybuildernumberofresults",\n         )\n \n         self.assertEqual(\n-            options[\'previewURL\'],\n-            \'http://nohost/plone/@@querybuilder_html_results\'\n+            options["previewURL"], "http://nohost/plone/@@querybuilder_html_results"\n         )\n \n         # Test options of the AJAX select widget\n-        self.assertEqual(\n-            options[\'patternAjaxSelectOptions\'][\'separator\'],\n-            \';\'\n-        )\n+        self.assertEqual(options["patternAjaxSelectOptions"]["separator"], ";")\n \n         # Test options of the date picker\n         self.assertEqual(\n-            options[\'patternDateOptions\'],\n-            {\'behavior\': \'native\', \'week-numbers\': \'show\', \'first-day\': 0, \'today\': \'Today\', \'clear\': \'Clear\'}\n+            options["patternDateOptions"],\n+            {\n+                "behavior": "native",\n+                "week-numbers": "show",\n+                "first-day": 0,\n+                "today": "Today",\n+                "clear": "Clear",\n+            },\n         )\n \n         # Test options of the related items widget\n-        self.assertEqual(\n-            options[\'patternRelateditemsOptions\'][\'basePath\'],\n-            \'/plone\'\n-        )\n-        self.assertTrue(\n-            \'recentlyUsed\' not in options[\'patternRelateditemsOptions\']\n-        )\n+        self.assertEqual(options["patternRelateditemsOptions"]["basePath"], "/plone")\n+        self.assertTrue("recentlyUsed" not in options["patternRelateditemsOptions"])\n \n \n class TestRelatedItemsOptions(unittest.TestCase):\n     layer = PAZ3CForm_INTEGRATION_TESTING\n \n     def setUp(self):\n-        setRoles(self.layer[\'portal\'], TEST_USER_ID, [\'Contributor\'])\n+        setRoles(self.layer["portal"], TEST_USER_ID, ["Contributor"])\n \n     def test__base_relateditems_options(self):\n         """Test related items options on root:\n@@ -78,28 +67,20 @@ def test__base_relateditems_options(self):\n         no favorites\n         """\n \n-        portal = self.layer[\'portal\']\n+        portal = self.layer["portal"]\n         options = get_relateditems_options(\n-            portal,\n-            None,\n-            \'#!@\',\n-            \'test_vocab\',\n-            \'@@vocab\',\n-            \'testfield\'\n+            portal, None, "#!@", "test_vocab", "@@vocab", "testfield"\n         )\n \n         # vocab is correctly set\n         self.assertTrue(\n-            \'@@vocab?name=test_vocab&field=testfield\'\n-            in options[\'vocabularyUrl\']\n+            "@@vocab?name=test_vocab&field=testfield" in options["vocabularyUrl"]\n         )\n \n         # rootUrl contains something\n-        self.assertTrue(\n-            bool(options[\'rootUrl\'])\n-        )\n+        self.assertTrue(bool(options["rootUrl"]))\n \n-        root_path = context_path = \'/\'.join(portal.getPhysicalPath())\n+        root_path = context_path = "/".join(portal.getPhysicalPath())\n         root_url = context_url = portal.absolute_url()\n \n         # context_path contains something, otherwise this test is meaningless\n@@ -107,48 +88,28 @@ def test__base_relateditems_options(self):\n         # context_url contains something, otherwise this test is meaningless\n         self.assertTrue(bool(context_url))\n \n-        self.assertEqual(\n-            options[\'rootUrl\'],\n-            root_url\n-        )\n+        self.assertEqual(options["rootUrl"], root_url)\n \n-        self.assertEqual(\n-            options[\'rootPath\'],\n-            root_path\n-        )\n+        self.assertEqual(options["rootPath"], root_path)\n \n         self.assertEqual(\n-            options[\'vocabularyUrl\'],\n-            root_url + \'/@@vocab?name=test_vocab&field=testfield\'\n+            options["vocabularyUrl"],\n+            root_url + "/@@vocab?name=test_vocab&field=testfield",\n         )\n \n-        self.assertEqual(\n-            options[\'basePath\'],\n-            context_path\n-        )\n+        self.assertEqual(options["basePath"], context_path)\n \n-        self.assertEqual(\n-            options[\'contextPath\'],\n-            context_path\n-        )\n+        self.assertEqual(options["contextPath"], context_path)\n \n-        self.assertEqual(\n-            options[\'separator\'],\n-            \'#!@\'\n-        )\n+        self.assertEqual(options["separator"], "#!@")\n \n-        self.assertTrue(\n-            \'favorites\' not in options\n-        )\n+        self.assertTrue("favorites" not in options)\n \n         # Recently used is configured, but off per default.\n+        self.assertEqual(options["recentlyUsed"], False)\n         self.assertEqual(\n-            options[\'recentlyUsed\'],\n-            False\n-        )\n-        self.assertEqual(\n-            options[\'recentlyUsedKey\'],\n-            \'relateditems_recentlyused_testfield_\' + TEST_USER_ID\n+            options["recentlyUsedKey"],\n+            "relateditems_recentlyused_testfield_" + TEST_USER_ID,\n         )\n \n     def test__subfolder_relateditems_options(self):\n@@ -156,32 +117,24 @@ def test__subfolder_relateditems_options(self):\n         Vocab called on root, start path is folder, have favorites.\n         """\n \n-        portal = self.layer[\'portal\']\n-        portal.invokeFactory(\'Folder\', \'sub\')\n+        portal = self.layer["portal"]\n+        portal.invokeFactory("Folder", "sub")\n         sub = portal.sub\n         options = get_relateditems_options(\n-            sub,\n-            None,\n-            \'#!@\',\n-            \'test_vocab\',\n-            \'@@vocab\',\n-            \'testfield\'\n+            sub, None, "#!@", "test_vocab", "@@vocab", "testfield"\n         )\n \n         # vocab is correctly set\n         self.assertTrue(\n-            \'@@vocab?name=test_vocab&field=testfield\'\n-            in options[\'vocabularyUrl\']\n+            "@@vocab?name=test_vocab&field=testfield" in options["vocabularyUrl"]\n         )\n \n         # rootUrl contains something\n-        self.assertTrue(\n-            bool(options[\'rootUrl\'])\n-        )\n+        self.assertTrue(bool(options["rootUrl"]))\n \n-        root_path = \'/\'.join(portal.getPhysicalPath())\n+        root_path = "/".join(portal.getPhysicalPath())\n         root_url = portal.absolute_url()\n-        context_path = \'/\'.join(sub.getPhysicalPath())\n+        context_path = "/".join(sub.getPhysicalPath())\n         context_url = sub.absolute_url()\n \n         # context_path contains something, otherwise this test is meaningless\n@@ -189,45 +142,24 @@ def test__subfolder_relateditems_options(self):\n         # context_url contains something, otherwise this test is meaningless\n         self.assertTrue(bool(context_url))\n \n-        self.assertEqual(\n-            options[\'rootUrl\'],\n-            root_url\n-        )\n+        self.assertEqual(options["rootUrl"], root_url)\n \n-        self.assertEqual(\n-            options[\'rootPath\'],\n-            root_path\n-        )\n+        self.assertEqual(options["rootPath"], root_path)\n \n         self.assertEqual(\n-            options[\'vocabularyUrl\'],\n-            root_url + \'/@@vocab?name=test_vocab&field=testfield\'\n+            options["vocabularyUrl"],\n+            root_url + "/@@vocab?name=test_vocab&field=testfield",\n         )\n \n-        self.assertEqual(\n-            options[\'basePath\'],\n-            context_path\n-        )\n+        self.assertEqual(options["basePath"], context_path)\n \n-        self.assertEqual(\n-            options[\'contextPath\'],\n-            context_path\n-        )\n+        self.assertEqual(options["contextPath"], context_path)\n \n-        self.assertEqual(\n-            options[\'separator\'],\n-            \'#!@\'\n-        )\n+        self.assertEqual(options["separator"], "#!@")\n \n-        self.assertEqual(\n-            len(options[\'favorites\']),\n-            2\n-        )\n+        self.assertEqual(len(options["favorites"]), 2)\n \n-        self.assertEqual(\n-            sorted(options[\'favorites\'][0].keys()),\n-            [\'path\', \'title\']\n-        )\n+        self.assertEqual(sorted(options["favorites"][0].keys()), ["path", "title"])\n \n     def test__subdocument_relateditems_options(self):\n         """Test related items options on subdoc:\n@@ -235,32 +167,24 @@ def test__subdocument_relateditems_options(self):\n         no favorites.\n         """\n \n-        portal = self.layer[\'portal\']\n-        portal.invokeFactory(\'Document\', \'sub\')\n+        portal = self.layer["portal"]\n+        portal.invokeFactory("Document", "sub")\n         sub = portal.sub\n         options = get_relateditems_options(\n-            sub,\n-            None,\n-            \'#!@\',\n-            \'test_vocab\',\n-            \'@@vocab\',\n-            \'testfield\'\n+            sub, None, "#!@", "test_vocab", "@@vocab", "testfield"\n         )\n \n         # vocab is correctly set\n         self.assertTrue(\n-            \'@@vocab?name=test_vocab&field=testfield\'\n-            in options[\'vocabularyUrl\']\n+            "@@vocab?name=test_vocab&field=testfield" in options["vocabularyUrl"]\n         )\n \n         # rootUrl contains something\n-        self.assertTrue(\n-            bool(options[\'rootUrl\'])\n-        )\n+        self.assertTrue(bool(options["rootUrl"]))\n \n-        root_path = \'/\'.join(portal.getPhysicalPath())\n+        root_path = "/".join(portal.getPhysicalPath())\n         root_url = portal.absolute_url()\n-        context_path = \'/\'.join(sub.getPhysicalPath())\n+        context_path = "/".join(sub.getPhysicalPath())\n         context_url = sub.absolute_url()\n \n         # context_path contains something, otherwise this test is meaningless\n@@ -268,63 +192,46 @@ def test__subdocument_relateditems_options(self):\n         # context_url contains something, otherwise this test is meaningless\n         self.assertTrue(bool(context_url))\n \n-        self.assertEqual(\n-            options[\'rootUrl\'],\n-            root_url\n-        )\n+        self.assertEqual(options["rootUrl"], root_url)\n \n-        self.assertEqual(\n-            options[\'rootPath\'],\n-            root_path\n-        )\n+        self.assertEqual(options["rootPath"], root_path)\n \n         self.assertEqual(\n-            options[\'vocabularyUrl\'],\n-            root_url + \'/@@vocab?name=test_vocab&field=testfield\'\n+            options["vocabularyUrl"],\n+            root_url + "/@@vocab?name=test_vocab&field=testfield",\n         )\n \n-        self.assertEqual(\n-            options[\'basePath\'],\n-            root_path\n-        )\n+        self.assertEqual(options["basePath"], root_path)\n \n-        self.assertEqual(\n-            options[\'contextPath\'],\n-            context_path\n-        )\n+        self.assertEqual(options["contextPath"], context_path)\n \n-        self.assertEqual(\n-            options[\'separator\'],\n-            \'#!@\'\n-        )\n+        self.assertEqual(options["separator"], "#!@")\n \n-        self.assertTrue(\n-            \'favorites\' not in options\n-        )\n+        self.assertTrue("favorites" not in options)\n \n \n class TestTinyMCEOptions(unittest.TestCase):\n     layer = PAZ3CForm_INTEGRATION_TESTING\n \n     def setUp(self):\n-        setRoles(self.layer[\'portal\'], TEST_USER_ID, [\'Contributor\'])\n+        setRoles(self.layer["portal"], TEST_USER_ID, ["Contributor"])\n \n     def test__tinymce_options_different_contexts(self):\n         """Test if ``get_tinymce_options`` can be called with different\n         contexts, including invalid and form contexts.\n         """\n-        request = self.layer[\'request\']\n-        portal = self.layer[\'portal\']\n-        portal.invokeFactory(\'Folder\', \'sub\')\n+        request = self.layer["request"]\n+        portal = self.layer["portal"]\n+        portal.invokeFactory("Folder", "sub")\n         sub = portal.sub\n \n         # TinyMCE on portal context\n         options = get_tinymce_options(portal, None, request)\n-        self.assertEqual(options[\'relatedItems\'][\'basePath\'], \'/plone\')\n+        self.assertEqual(options["relatedItems"]["basePath"], "/plone")\n \n         # TinyMCE on sub folder context\n         options = get_tinymce_options(sub, None, request)\n-        self.assertEqual(options[\'relatedItems\'][\'basePath\'], \'/plone/sub\')\n+        self.assertEqual(options["relatedItems"]["basePath"], "/plone/sub")\n \n \n class BaseWidgetTests(unittest.TestCase):\n@@ -333,38 +240,35 @@ class BaseWidgetTests(unittest.TestCase):\n     def test_defaults(self):\n         from plone.app.z3cform.widgets.patterns import BaseWidget\n \n-        widget = BaseWidget(\'input\', \'example1\')\n-        self.assertEqual(\n-            widget.render(),\n-            u\'<input class="pat-example1"/>\')\n+        widget = BaseWidget("input", "example1")\n+        self.assertEqual(widget.render(), \'<input class="pat-example1"/>\')\n \n-        self.assertEqual(widget.klass, \'pat-example1\')\n+        self.assertEqual(widget.klass, "pat-example1")\n \n     def test_different_element_tag(self):\n         from plone.app.z3cform.widgets.patterns import BaseWidget\n \n-        widget = BaseWidget(\'select\', \'example1\')\n-        self.assertEqual(\n-            widget.render(),\n-            u\'<select class="pat-example1"/>\')\n+        widget = BaseWidget("select", "example1")\n+        self.assertEqual(widget.render(), \'<select class="pat-example1"/>\')\n \n-        self.assertEqual(widget.klass, \'pat-example1\')\n+        self.assertEqual(widget.klass, "pat-example1")\n \n     def test_setting_patterns_options(self):\n         from plone.app.z3cform.widgets.patterns import BaseWidget\n \n         widget = BaseWidget(\n-            \'input\',\n-            \'example1\',\n+            "input",\n+            "example1",\n             pattern_options={\n-                \'option1\': \'value1\',\n-                \'option2\': \'value2\',\n-            })\n+                "option1": "value1",\n+                "option2": "value2",\n+            },\n+        )\n \n         html = widget.render()\n         # the order of options is non-deterministic\n-        result1 = u\'<input class="pat-example1" data-pat-example1="{&quot;option1&quot;: &quot;value1&quot;, &quot;option2&quot;: &quot;value2&quot;}"/>\'  # noqa: E501\n-        result2 = u\'<input class="pat-example1" data-pat-example1="{&quot;option2&quot;: &quot;value2&quot;, &quot;option1&quot;: &quot;value1&quot;}"/>\'  # noqa: E501\n+        result1 = \'<input class="pat-example1" data-pat-example1="{&quot;option1&quot;: &quot;value1&quot;, &quot;option2&quot;: &quot;value2&quot;}"/>\'  # noqa: E501\n+        result2 = \'<input class="pat-example1" data-pat-example1="{&quot;option2&quot;: &quot;value2&quot;, &quot;option1&quot;: &quot;value1&quot;}"/>\'  # noqa: E501\n         self.assertIn(html, [result1, result2])\n \n \n@@ -374,48 +278,47 @@ class InputWidgetTests(unittest.TestCase):\n     def test_defaults(self):\n         from plone.app.z3cform.widgets.patterns import InputWidget\n \n-        widget = InputWidget(\'example1\', name=\'example2\')\n+        widget = InputWidget("example1", name="example2")\n \n         self.assertEqual(\n-            widget.render(),\n-            \'<input class="pat-example1" type="text" name="example2"/>\')\n+            widget.render(), \'<input class="pat-example1" type="text" name="example2"/>\'\n+        )\n \n-        self.assertEqual(widget.type, \'text\')\n+        self.assertEqual(widget.type, "text")\n         self.assertEqual(widget.value, None)\n \n     def test_set_type_and_value(self):\n         from plone.app.z3cform.widgets.patterns import InputWidget\n \n         widget = InputWidget(\n-            \'example1\',\n-            name=\'example2\',\n-            type=\'email\',\n-            value=\'example3\'\n+            "example1", name="example2", type="email", value="example3"\n         )\n \n         self.assertEqual(\n             widget.render(),\n-            u\'<input class="pat-example1" type="email" \'\n-            \'name="example2" value="example3"/>\')\n+            \'<input class="pat-example1" type="email" \'\n+            \'name="example2" value="example3"/>\',\n+        )\n \n-        self.assertEqual(widget.type, \'email\')\n-        self.assertEqual(widget.value, \'example3\')\n+        self.assertEqual(widget.type, "email")\n+        self.assertEqual(widget.value, "example3")\n \n-        widget.type = \'text\'\n-        widget.value = \'example4\'\n+        widget.type = "text"\n+        widget.value = "example4"\n         self.assertEqual(\n             widget.render(),\n-            u\'<input class="pat-example1" type="text" \'\n-            \'name="example2" value="example4"/>\')\n+            \'<input class="pat-example1" type="text" \'\n+            \'name="example2" value="example4"/>\',\n+        )\n \n-        self.assertEqual(widget.type, \'text\')\n-        self.assertEqual(widget.value, \'example4\')\n+        self.assertEqual(widget.type, "text")\n+        self.assertEqual(widget.value, "example4")\n \n         del widget.type\n         del widget.value\n         self.assertEqual(\n-            widget.render(),\n-            u\'<input class="pat-example1" name="example2"/>\')\n+            widget.render(), \'<input class="pat-example1" name="example2"/>\'\n+        )\n \n         self.assertEqual(widget.type, None)\n         self.assertEqual(widget.value, None)\n@@ -427,11 +330,11 @@ class SelectWidgetTests(unittest.TestCase):\n     def test_defaults(self):\n         from plone.app.z3cform.widgets.patterns import SelectWidget\n \n-        widget = SelectWidget(\'example1\', name=\'example2\')\n+        widget = SelectWidget("example1", name="example2")\n \n         self.assertEqual(\n-            widget.render(),\n-            u\'<select class="pat-example1" name="example2"></select>\')\n+            widget.render(), \'<select class="pat-example1" name="example2"></select>\'\n+        )\n         self.assertEqual(list(widget.items), [])\n         self.assertEqual(widget.value, [])\n \n@@ -439,107 +342,109 @@ def test_set_items_and_value(self):\n         from plone.app.z3cform.widgets.patterns import SelectWidget\n \n         items = [\n-            (\'token1\', \'value1\'),\n-            (\'token2\', \'value2\'),\n-            (\'token3\', \'value3\'),\n+            ("token1", "value1"),\n+            ("token2", "value2"),\n+            ("token3", "value3"),\n         ]\n-        widget = SelectWidget(\n-            \'example1\',\n-            name=\'example2\',\n-            value=\'token2\',\n-            items=items\n-        )\n+        widget = SelectWidget("example1", name="example2", value="token2", items=items)\n \n         self.assertEqual(\n             widget.render(),\n-            u\'<select class="pat-example1" name="example2">\'\n+            \'<select class="pat-example1" name="example2">\'\n             \'<option value="token1">value1</option>\'\n             \'<option value="token2" selected="selected">value2</option>\'\n             \'<option value="token3">value3</option>\'\n-            \'</select>\')\n+            "</select>",\n+        )\n \n         self.assertEqual(list(widget.items), items)\n-        self.assertEqual(widget.value, [\'token2\'])\n+        self.assertEqual(widget.value, ["token2"])\n \n-        widget.value = \'token1\'\n+        widget.value = "token1"\n         self.assertEqual(\n             widget.render(),\n-            u\'<select class="pat-example1" name="example2">\'\n+            \'<select class="pat-example1" name="example2">\'\n             \'<option value="token1" selected="selected">value1</option>\'\n             \'<option value="token2">value2</option>\'\n             \'<option value="token3">value3</option>\'\n-            \'</select>\')\n+            "</select>",\n+        )\n \n         self.assertEqual(list(widget.items), items)\n-        self.assertEqual(widget.value, [\'token1\'])\n+        self.assertEqual(widget.value, ["token1"])\n \n         del widget.value\n         self.assertEqual(\n             widget.render(),\n-            u\'<select class="pat-example1" name="example2">\'\n+            \'<select class="pat-example1" name="example2">\'\n             \'<option value="token1">value1</option>\'\n             \'<option value="token2">value2</option>\'\n             \'<option value="token3">value3</option>\'\n-            \'</select>\')\n+            "</select>",\n+        )\n \n         del widget.items\n         self.assertEqual(\n-            widget.render(),\n-            \'<select class="pat-example1" name="example2"></select>\')\n+            widget.render(), \'<select class="pat-example1" name="example2"></select>\'\n+        )\n \n     def test_multiple(self):\n         from plone.app.z3cform.widgets.patterns import SelectWidget\n \n         items = [\n-            (\'token1\', \'value1\'),\n-            (\'token2\', \'value2\'),\n-            (\'token3\', \'value3\'),\n+            ("token1", "value1"),\n+            ("token2", "value2"),\n+            ("token3", "value3"),\n         ]\n         widget = SelectWidget(\n-            \'example1\',\n-            name=\'example2\',\n-            value=[\'token2\'],\n+            "example1",\n+            name="example2",\n+            value=["token2"],\n             items=items,\n             multiple=True,\n         )\n \n         self.assertEqual(\n             widget.render(),\n-            u\'<select class="pat-example1" multiple="multiple" name="example2">\'\n+            \'<select class="pat-example1" multiple="multiple" name="example2">\'\n             \'<option value="token1">value1</option>\'\n             \'<option value="token2" selected="selected">value2</option>\'\n             \'<option value="token3">value3</option>\'\n-            \'</select>\')\n+            "</select>",\n+        )\n \n         self.assertEqual(list(widget.items), items)\n-        self.assertEqual(widget.value, [\'token2\'])\n+        self.assertEqual(widget.value, ["token2"])\n \n-        widget.value = [\'token1\', \'token2\']\n+        widget.value = ["token1", "token2"]\n         self.assertEqual(\n             widget.render(),\n-            u\'<select class="pat-example1" multiple="multiple" name="example2">\'\n+            \'<select class="pat-example1" multiple="multiple" name="example2">\'\n             \'<option value="token1" selected="selected">value1</option>\'\n             \'<option value="token2" selected="selected">value2</option>\'\n             \'<option value="token3">value3</option>\'\n-            \'</select>\')\n+            "</select>",\n+        )\n \n         self.assertEqual(list(widget.items), items)\n-        self.assertEqual(widget.value, [\'token1\', \'token2\'])\n+        self.assertEqual(widget.value, ["token1", "token2"])\n \n         del widget.value\n         self.assertEqual(\n             widget.render(),\n-            u\'<select class="pat-example1" multiple="multiple" name="example2">\'\n+            \'<select class="pat-example1" multiple="multiple" name="example2">\'\n             \'<option value="token1">value1</option>\'\n             \'<option value="token2">value2</option>\'\n             \'<option value="token3">value3</option>\'\n-            \'</select>\')\n+            "</select>",\n+        )\n \n         del widget.items\n         self.assertEqual(\n             widget.render(),\n-            u\'<select class="pat-example1" multiple="multiple" \'\n-            \'name="example2"></select>\')\n+            \'<select class="pat-example1" multiple="multiple" \'\n+            \'name="example2"></select>\',\n+        )\n \n \n class TextareaWidgetTests(unittest.TestCase):\n@@ -548,58 +453,60 @@ class TextareaWidgetTests(unittest.TestCase):\n     def test_defaults(self):\n         from plone.app.z3cform.widgets.patterns import TextareaWidget\n \n-        widget = TextareaWidget(\'example1\', name="example2")\n+        widget = TextareaWidget("example1", name="example2")\n         self.assertEqual(\n             widget.render(),\n-            u\'<textarea class="pat-example1" name="example2"></textarea>\')\n+            \'<textarea class="pat-example1" name="example2"></textarea>\',\n+        )\n \n-        self.assertEqual(widget.name, \'example2\')\n-        self.assertEqual(widget.klass, \'pat-example1\')\n-        self.assertEqual(widget.value, \'\')\n+        self.assertEqual(widget.name, "example2")\n+        self.assertEqual(widget.klass, "pat-example1")\n+        self.assertEqual(widget.value, "")\n \n     def test_setting_patterns_options(self):\n         from plone.app.z3cform.widgets.patterns import TextareaWidget\n \n         widget = TextareaWidget(\n-            \'example1\',\n-            name=\'example2\',\n+            "example1",\n+            name="example2",\n             pattern_options={\n-                \'option1\': \'value1\',\n-                \'option2\': \'value2\',\n-            })\n+                "option1": "value1",\n+                "option2": "value2",\n+            },\n+        )\n \n         html = widget.render()\n         # the order of options is non-deterministic\n-        result1 = u\'<textarea class="pat-example1" name="example2" data-pat-example1="{&quot;option1&quot;: &quot;value1&quot;, &quot;option2&quot;: &quot;value2&quot;}"></textarea>\'  # noqa: E501\n-        result2 = u\'<textarea class="pat-example1" name="example2" data-pat-example1="{&quot;option2&quot;: &quot;value2&quot;, &quot;option1&quot;: &quot;value1&quot;}"></textarea>\'  # noqa: E501\n+        result1 = \'<textarea class="pat-example1" name="example2" data-pat-example1="{&quot;option1&quot;: &quot;value1&quot;, &quot;option2&quot;: &quot;value2&quot;}"></textarea>\'  # noqa: E501\n+        result2 = \'<textarea class="pat-example1" name="example2" data-pat-example1="{&quot;option2&quot;: &quot;value2&quot;, &quot;option1&quot;: &quot;value1&quot;}"></textarea>\'  # noqa: E501\n         self.assertIn(html, [result1, result2])\n \n     def test_set_value(self):\n         from plone.app.z3cform.widgets.patterns import TextareaWidget\n \n-        widget = TextareaWidget(\'example1\', name="example2", value=\'example3\')\n+        widget = TextareaWidget("example1", name="example2", value="example3")\n         self.assertEqual(\n             widget.render(),\n-            u\'<textarea class="pat-example1" name="example2">\'\n-            \'example3\'\n-            \'</textarea>\')\n+            \'<textarea class="pat-example1" name="example2">\' "example3" "</textarea>",\n+        )\n \n-        self.assertEqual(widget.value, \'example3\')\n+        self.assertEqual(widget.value, "example3")\n \n-        widget.value = \'example4\'\n+        widget.value = "example4"\n         self.assertEqual(\n             widget.render(),\n-            u\'<textarea class="pat-example1" name="example2">\'\n-            \'example4\'\n-            \'</textarea>\')\n+            \'<textarea class="pat-example1" name="example2">\' "example4" "</textarea>",\n+        )\n \n         del widget.value\n         self.assertEqual(\n             widget.render(),\n-            u\'<textarea class="pat-example1" name="example2"></textarea>\')\n+            \'<textarea class="pat-example1" name="example2"></textarea>\',\n+        )\n \n     def test_can_not_change_element_tag(self):\n         from plone.app.z3cform.widgets.patterns import TextareaWidget\n+\n         self.assertRaises(\n-            TypeError,\n-            TextareaWidget, \'example1\', el=\'input\', name=\'example2\')\n+            TypeError, TextareaWidget, "example1", el="input", name="example2"\n+        )\ndiff --git a/plone/app/z3cform/tests/test_widgets.py b/plone/app/z3cform/tests/test_widgets.py\nindex c64bdc7..9980de7 100644\n--- a/plone/app/z3cform/tests/test_widgets.py\n+++ b/plone/app/z3cform/tests/test_widgets.py\n@@ -1185,12 +1185,12 @@ def test_keywords_cannot_add(self):\n \n def mock_querystring_options(context, querystring_view):\n     return {\n-        \'indexOptionsUrl\': \'/{}\'.format(querystring_view),\n-        \'previewURL\': \'/@@querybuilder_html_results\',\n-        \'previewCountURL\': \'/@@querybuildernumberofresults\',\n-        \'patternDateOptions\': None,\n-        \'patternAjaxSelectOptions\': {\'separator\': \';\'},\n-        \'patternRelateditemsOptions\': None,\n+        "indexOptionsUrl": f"/{querystring_view}",\n+        "previewURL": "/@@querybuilder_html_results",\n+        "previewCountURL": "/@@querybuildernumberofresults",\n+        "patternDateOptions": None,\n+        "patternAjaxSelectOptions": {"separator": ";"},\n+        "patternRelateditemsOptions": None,\n     }\n \n \n@@ -1468,8 +1468,9 @@ def test_multiple_selection(self):\n         )\n \n     def test_converter_RelationChoice(self):\n-        from plone.app.z3cform.converters import \\\n-            RelationChoiceRelatedItemsWidgetConverter\n+        from plone.app.z3cform.converters import (\n+            RelationChoiceRelatedItemsWidgetConverter,\n+        )\n \n         brain = Mock(getObject=Mock(return_value="obj"))\n         portal_catalog = Mock(return_value=[brain])\ndiff --git a/plone/app/z3cform/utils.py b/plone/app/z3cform/utils.py\nindex 09c4e50..ecc7a4f 100644\n--- a/plone/app/z3cform/utils.py\n+++ b/plone/app/z3cform/utils.py\n@@ -135,15 +135,15 @@ def dict_merge(dict_a, dict_b):\n     result = deepcopy(dict_a)\n     for k, v in dict_b.items():\n         if k in result and isinstance(result[k], dict):\n-                result[k] = dict_merge(result[k], v)\n+            result[k] = dict_merge(result[k], v)\n         else:\n             result[k] = deepcopy(v)\n     return result\n \n \n def get_widget_form(widget):\n-    form = getattr(widget, \'form\', None)\n-    if getattr(aq_base(form), \'parentForm\', None) is not None:\n+    form = getattr(widget, "form", None)\n+    if getattr(aq_base(form), "parentForm", None) is not None:\n         form = form.parentForm\n     return form\n \n@@ -167,14 +167,14 @@ def get_portal_url(context):\n                 return portal.absolute_url()\n         else:\n             return portal.absolute_url()\n-    return \'\'\n+    return ""\n \n \n def get_context_url(context):\n     if IForm.providedBy(context):\n         # Use the request URL if we are looking at an addform\n-        url = context.request.get(\'URL\')\n-    elif hasattr(context, \'absolute_url\'):\n+        url = context.request.get("URL")\n+    elif hasattr(context, "absolute_url"):\n         url = context.absolute_url\n         if callable(url):\n             url = url()\ndiff --git a/plone/app/z3cform/widget.py b/plone/app/z3cform/widget.py\nindex d956e8d..0022bac 100644\n--- a/plone/app/z3cform/widget.py\n+++ b/plone/app/z3cform/widget.py\n@@ -3,60 +3,60 @@\n \n deprecated_import(\n     "Import from plone.app.z3cform.converters instead (will be removed in Plone 7)",\n-    DatetimeWidgetConverter=\'plone.app.z3cform.converters:DatetimeWidgetConverter\',\n-    DateWidgetConverter=\'plone.app.z3cform.converters:DateWidgetConverter\',\n+    DatetimeWidgetConverter="plone.app.z3cform.converters:DatetimeWidgetConverter",\n+    DateWidgetConverter="plone.app.z3cform.converters:DateWidgetConverter",\n )\n \n deprecated_import(\n     "Import from plone.app.z3cform.widgets.base instead (will be removed in Plone 7)",\n-    BaseWidget=\'plone.app.z3cform.widgets.base:BaseWidget\',\n+    BaseWidget="plone.app.z3cform.widgets.base:BaseWidget",\n )\n \n deprecated_import(\n     "Import from plone.app.z3cform.widgets.datetime instead (will be removed in Plone 7)",\n-    DateFieldWidget=\'plone.app.z3cform.widgets.datetime:DateFieldWidget\',\n-    DatetimeFieldWidget=\'plone.app.z3cform.widgets.datetime:DatetimeFieldWidget\',\n-    DatetimeWidget=\'plone.app.z3cform.widgets.datetime:DatetimeWidget\',\n-    DateWidget=\'plone.app.z3cform.widgets.datetime:DateWidget\',\n-    TimeFieldWidget=\'plone.app.z3cform.widgets.datetime:TimeFieldWidget\',\n-    TimeWidget=\'plone.app.z3cform.widgets.datetime:TimeWidget\',\n+    DateFieldWidget="plone.app.z3cform.widgets.datetime:DateFieldWidget",\n+    DatetimeFieldWidget="plone.app.z3cform.widgets.datetime:DatetimeFieldWidget",\n+    DatetimeWidget="plone.app.z3cform.widgets.datetime:DatetimeWidget",\n+    DateWidget="plone.app.z3cform.widgets.datetime:DateWidget",\n+    TimeFieldWidget="plone.app.z3cform.widgets.datetime:TimeFieldWidget",\n+    TimeWidget="plone.app.z3cform.widgets.datetime:TimeWidget",\n )\n \n deprecated_import(\n     "Import from plone.app.z3cform.widgets.link instead (will be removed in Plone 7)",\n-    LinkFieldWidget=\'plone.app.z3cform.widgets.link:LinkFieldWidget\',\n-    LinkWidget=\'plone.app.z3cform.widgets.link:LinkWidget\',\n+    LinkFieldWidget="plone.app.z3cform.widgets.link:LinkFieldWidget",\n+    LinkWidget="plone.app.z3cform.widgets.link:LinkWidget",\n )\n \n deprecated_import(\n     "Import from plone.app.z3cform.widgets.querystring instead (will be removed in Plone 7)",\n-    QueryStringFieldWidget=\'plone.app.z3cform.widgets.querystring:QueryStringFieldWidget\',\n-    QueryStringWidget=\'plone.app.z3cform.widgets.querystring:QueryStringWidget\',\n+    QueryStringFieldWidget="plone.app.z3cform.widgets.querystring:QueryStringFieldWidget",\n+    QueryStringWidget="plone.app.z3cform.widgets.querystring:QueryStringWidget",\n )\n \n deprecated_import(\n     "Import from plone.app.z3cform.widgets.relateditems instead (will be removed in Plone 7)",\n-    RelatedItemsFieldWidget=\'plone.app.z3cform.widgets.relateditems:RelatedItemsFieldWidget\',\n-    RelatedItemsWidget=\'plone.app.z3cform.widgets.relateditems:RelatedItemsWidget\',\n+    RelatedItemsFieldWidget="plone.app.z3cform.widgets.relateditems:RelatedItemsFieldWidget",\n+    RelatedItemsWidget="plone.app.z3cform.widgets.relateditems:RelatedItemsWidget",\n )\n \n deprecated_import(\n     "Import from plone.app.z3cform.widgets.richtext instead (will be removed in Plone 7)",\n-    RichTextFieldWidget=\'plone.app.z3cform.widgets.richtext:RichTextFieldWidget\',\n-    RichTextWidget=\'plone.app.z3cform.widgets.richtext:RichTextWidget\',\n+    RichTextFieldWidget="plone.app.z3cform.widgets.richtext:RichTextFieldWidget",\n+    RichTextWidget="plone.app.z3cform.widgets.richtext:RichTextWidget",\n )\n \n deprecated_import(\n     "Import from plone.app.z3cform.widgets.select instead (will be removed in Plone 7)",\n-    AjaxSelectFieldWidget=\'plone.app.z3cform.widgets.select:AjaxSelectFieldWidget\',\n-    AjaxSelectWidget=\'plone.app.z3cform.widgets.select:AjaxSelectWidget\',\n-    SelectFieldWidget=\'plone.app.z3cform.widgets.select:SelectFieldWidget\',\n-    SelectWidget=\'plone.app.z3cform.widgets.select:SelectWidget\',\n+    AjaxSelectFieldWidget="plone.app.z3cform.widgets.select:AjaxSelectFieldWidget",\n+    AjaxSelectWidget="plone.app.z3cform.widgets.select:AjaxSelectWidget",\n+    SelectFieldWidget="plone.app.z3cform.widgets.select:SelectFieldWidget",\n+    SelectWidget="plone.app.z3cform.widgets.select:SelectWidget",\n )\n \n deprecated_import(\n     "Import from plone.app.z3cform.widgets.singlecheckbox instead (will be removed in Plone 7)",\n-    SingleCheckBoxBoolFieldWidget=\'plone.app.z3cform.widgets.singlecheckbox:SingleCheckBoxBoolFieldWidget\',\n-    SingleCheckBoxBoolWidget=\'plone.app.z3cform.widgets.singlecheckbox:SingleCheckBoxBoolWidget\',\n-    SingleCheckBoxWidget=\'plone.app.z3cform.widgets.singlecheckbox:SingleCheckBoxWidget\',\n+    SingleCheckBoxBoolFieldWidget="plone.app.z3cform.widgets.singlecheckbox:SingleCheckBoxBoolFieldWidget",\n+    SingleCheckBoxBoolWidget="plone.app.z3cform.widgets.singlecheckbox:SingleCheckBoxBoolWidget",\n+    SingleCheckBoxWidget="plone.app.z3cform.widgets.singlecheckbox:SingleCheckBoxWidget",\n )\ndiff --git a/plone/app/z3cform/widgets.zcml b/plone/app/z3cform/widgets.zcml\nindex ce18563..2e81315 100644\n--- a/plone/app/z3cform/widgets.zcml\n+++ b/plone/app/z3cform/widgets.zcml\n@@ -1,297 +1,319 @@\n <configure\n     xmlns="http://namespaces.zope.org/zope"\n-    xmlns:z3c="http://namespaces.zope.org/z3c">\n+    xmlns:z3c="http://namespaces.zope.org/z3c"\n+    >\n \n-    <!-- Make the default widget for sequence-of-text-lines a textlines\n+  <!-- Make the default widget for sequence-of-text-lines a textlines\n        widget; the default is too confusing -->\n \n-    <adapter\n-        factory="plone.z3cform.textlines.textlines.TextLinesFieldWidgetFactory"\n-        provides="z3c.form.interfaces.IFieldWidget"\n-        for="zope.schema.interfaces.IList\n-            zope.schema.interfaces.ITextLine\n-            plone.app.z3cform.interfaces.IPloneFormLayer" />\n-\n-    <adapter\n-        factory="plone.z3cform.textlines.textlines.TextLinesFieldWidgetFactory"\n-        provides="z3c.form.interfaces.IFieldWidget"\n-        for="zope.schema.interfaces.ITuple\n-            zope.schema.interfaces.ITextLine\n-            plone.app.z3cform.interfaces.IPloneFormLayer" />\n-\n-    <adapter\n-        factory="plone.z3cform.textlines.textlines.TextLinesFieldWidgetFactory"\n-        provides="z3c.form.interfaces.IFieldWidget"\n-        for="zope.schema.interfaces.IAbstractSet\n-            zope.schema.interfaces.ITextLine\n-            plone.app.z3cform.interfaces.IPloneFormLayer"\n+  <adapter\n+      factory="plone.z3cform.textlines.textlines.TextLinesFieldWidgetFactory"\n+      provides="z3c.form.interfaces.IFieldWidget"\n+      for="zope.schema.interfaces.IList\n+           zope.schema.interfaces.ITextLine\n+           plone.app.z3cform.interfaces.IPloneFormLayer"\n+      />\n+\n+  <adapter\n+      factory="plone.z3cform.textlines.textlines.TextLinesFieldWidgetFactory"\n+      provides="z3c.form.interfaces.IFieldWidget"\n+      for="zope.schema.interfaces.ITuple\n+           zope.schema.interfaces.ITextLine\n+           plone.app.z3cform.interfaces.IPloneFormLayer"\n+      />\n+\n+  <adapter\n+      factory="plone.z3cform.textlines.textlines.TextLinesFieldWidgetFactory"\n+      provides="z3c.form.interfaces.IFieldWidget"\n+      for="zope.schema.interfaces.IAbstractSet\n+           zope.schema.interfaces.ITextLine\n+           plone.app.z3cform.interfaces.IPloneFormLayer"\n+      />\n+\n+  <adapter\n+      factory="plone.z3cform.textlines.textlines.TextLinesFieldWidgetFactory"\n+      provides="z3c.form.interfaces.IFieldWidget"\n+      for="zope.schema.interfaces.IList\n+           zope.schema.interfaces.IASCIILine\n+           plone.app.z3cform.interfaces.IPloneFormLayer"\n+      />\n+\n+  <adapter\n+      factory="plone.z3cform.textlines.textlines.TextLinesFieldWidgetFactory"\n+      provides="z3c.form.interfaces.IFieldWidget"\n+      for="zope.schema.interfaces.ITuple\n+           zope.schema.interfaces.IASCIILine\n+           plone.app.z3cform.interfaces.IPloneFormLayer"\n+      />\n+  <adapter\n+      factory="plone.z3cform.textlines.textlines.TextLinesFieldWidgetFactory"\n+      provides="z3c.form.interfaces.IFieldWidget"\n+      for="zope.schema.interfaces.IAbstractSet\n+           zope.schema.interfaces.IASCIILine\n+           plone.app.z3cform.interfaces.IPloneFormLayer"\n+      />\n+\n+  <!-- single checkbox boolean -->\n+  <adapter\n+      factory=".widgets.singlecheckbox.SingleCheckBoxBoolFieldWidget"\n+      for="zope.schema.interfaces.IBool\n+           .interfaces.IPloneFormLayer"\n+      />\n+\n+  <z3c:widgetTemplate\n+      field="zope.schema.interfaces.IBool"\n+      widget=".interfaces.ISingleCheckBoxBoolWidget"\n+      template="templates/singlecheckboxbool_display.pt"\n+      layer=".interfaces.IPloneFormLayer"\n+      mode="display"\n+      />\n+\n+  <z3c:widgetTemplate\n+      field="zope.schema.interfaces.IBool"\n+      widget=".interfaces.ISingleCheckBoxBoolWidget"\n+      template="templates/singlecheckboxbool_input.pt"\n+      layer=".interfaces.IPloneFormLayer"\n+      mode="input"\n+      />\n+\n+  <!-- ajaxselect -->\n+  <z3c:widgetTemplate\n+      field="*"\n+      widget=".interfaces.IAjaxSelectWidget"\n+      template="templates/ajaxselect_display.pt"\n+      layer=".interfaces.IPloneFormLayer"\n+      mode="display"\n+      />\n+\n+  <z3c:widgetTemplate\n+      field="zope.schema.interfaces.IBool"\n+      widget=".interfaces.ISingleCheckBoxBoolWidget"\n+      template="templates/singlecheckboxbool_hidden.pt"\n+      layer=".interfaces.IPloneFormLayer"\n+      mode="hidden"\n+      />\n+\n+  <!-- multi -->\n+  <z3c:widgetTemplate\n+      widget="z3c.form.interfaces.IMultiWidget"\n+      template="templates/multi_input.pt"\n+      layer=".interfaces.IPloneFormLayer"\n+      mode="input"\n+      />\n+\n+  <!-- object -->\n+  <z3c:widgetTemplate\n+      widget="z3c.form.interfaces.IObjectWidget"\n+      template="templates/object_input.pt"\n+      layer=".interfaces.IPloneFormLayer"\n+      mode="input"\n+      />\n+\n+  <!-- date/time -->\n+  <class class=".widgets.datetime.DateWidget">\n+    <require\n+        permission="zope.Public"\n+        interface=".interfaces.IDateWidget"\n         />\n-\n-    <adapter\n-        factory="plone.z3cform.textlines.textlines.TextLinesFieldWidgetFactory"\n-        provides="z3c.form.interfaces.IFieldWidget"\n-        for="zope.schema.interfaces.IList\n-            zope.schema.interfaces.IASCIILine\n-            plone.app.z3cform.interfaces.IPloneFormLayer"\n-        />\n-\n-    <adapter\n-        factory="plone.z3cform.textlines.textlines.TextLinesFieldWidgetFactory"\n-        provides="z3c.form.interfaces.IFieldWidget"\n-        for="zope.schema.interfaces.ITuple\n-            zope.schema.interfaces.IASCIILine\n-            plone.app.z3cform.interfaces.IPloneFormLayer"\n-        />\n-    <adapter\n-        factory="plone.z3cform.textlines.textlines.TextLinesFieldWidgetFactory"\n-        provides="z3c.form.interfaces.IFieldWidget"\n-        for="zope.schema.interfaces.IAbstractSet\n-            zope.schema.interfaces.IASCIILine\n-            plone.app.z3cform.interfaces.IPloneFormLayer"\n-        />\n-\n-    <!-- single checkbox boolean -->\n-    <adapter\n-        factory=".widgets.singlecheckbox.SingleCheckBoxBoolFieldWidget"\n-        for="zope.schema.interfaces.IBool\n-            .interfaces.IPloneFormLayer"\n-        />\n-\n-    <z3c:widgetTemplate\n-        mode="display"\n-        field="zope.schema.interfaces.IBool"\n-        widget=".interfaces.ISingleCheckBoxBoolWidget"\n-        layer=".interfaces.IPloneFormLayer"\n-        template="templates/singlecheckboxbool_display.pt"\n-        />\n-\n-    <z3c:widgetTemplate\n-        mode="input"\n-        field="zope.schema.interfaces.IBool"\n-        widget=".interfaces.ISingleCheckBoxBoolWidget"\n-        layer=".interfaces.IPloneFormLayer"\n-        template="templates/singlecheckboxbool_input.pt"\n-        />\n-\n-    <!-- ajaxselect -->\n-    <z3c:widgetTemplate\n-        mode="display"\n-        field="*"\n-        widget=".interfaces.IAjaxSelectWidget"\n-        layer=".interfaces.IPloneFormLayer"\n-        template="templates/ajaxselect_display.pt"\n-        />\n-\n-    <z3c:widgetTemplate\n-        mode="hidden"\n-        field="zope.schema.interfaces.IBool"\n-        widget=".interfaces.ISingleCheckBoxBoolWidget"\n-        layer=".interfaces.IPloneFormLayer"\n-        template="templates/singlecheckboxbool_hidden.pt"\n-        />\n-\n-    <!-- multi -->\n-    <z3c:widgetTemplate\n-        mode="input"\n-        widget="z3c.form.interfaces.IMultiWidget"\n-        layer=".interfaces.IPloneFormLayer"\n-        template="templates/multi_input.pt"\n-        />\n-\n-    <!-- object -->\n-    <z3c:widgetTemplate\n-        mode="input"\n-        widget="z3c.form.interfaces.IObjectWidget"\n-        layer=".interfaces.IPloneFormLayer"\n-        template="templates/object_input.pt"\n-        />\n-\n-    <!-- date/time -->\n-    <class class=".widgets.datetime.DateWidget">\n-        <require permission="zope.Public"\n-                interface=".interfaces.IDateWidget" />\n-    </class>\n-\n-    <adapter\n-        factory=".widgets.datetime.DateFieldWidget"\n-        for="zope.schema.interfaces.IDate\n-             plone.app.z3cform.interfaces.IPloneFormLayer" />\n-\n-    <class class=".widgets.datetime.DatetimeWidget">\n-        <require permission="zope.Public"\n-                interface=".interfaces.IDatetimeWidget" />\n-    </class>\n-\n-    <adapter\n-        factory=".widgets.datetime.DatetimeFieldWidget"\n-        for="zope.schema.interfaces.IDatetime\n-            plone.app.z3cform.interfaces.IPloneFormLayer"\n-        />\n-\n-    <class class=".widgets.datetime.TimeWidget">\n-        <require permission="zope.Public"\n-                interface=".interfaces.ITimeWidget" />\n-    </class>\n-\n-    <adapter\n-        factory=".widgets.datetime.TimeFieldWidget"\n-        for="zope.schema.interfaces.ITime\n-            plone.app.z3cform.interfaces.IPloneFormLayer"\n-        />\n-\n-    <!-- relateditems -->\n-\n-    <adapter factory=".widgets.relateditems.RelatedItemsFieldWidget"\n-        for="z3c.relationfield.interfaces.IRelationChoice\n-             plone.app.z3cform.interfaces.IPloneFormLayer" />\n-\n-    <adapter factory=".widgets.relateditems.RelatedItemsFieldWidget"\n-        for="z3c.relationfield.interfaces.IRelationList\n-             plone.app.z3cform.interfaces.IPloneFormLayer" />\n-\n-    <adapter factory=".widgets.relateditems.RelatedItemsFieldWidget"\n-        for="zope.schema.interfaces.IChoice\n-             plone.app.vocabularies.catalog.CatalogSource\n-             plone.app.z3cform.interfaces.IPloneFormLayer" />\n-\n-    <z3c:widgetTemplate\n-        mode="display"\n-        widget=".interfaces.IRelatedItemsWidget"\n-        layer=".interfaces.IPloneFormLayer"\n-        template="templates/relateditems_display.pt"\n-        />\n-\n-    <!-- querystring -->\n-    <adapter factory=".widgets.querystring.QueryStringFieldWidget"\n-            for="zope.schema.interfaces.IList\n-                zope.schema.interfaces.IDict\n-                plone.app.z3cform.interfaces.IPloneFormLayer"/>\n-\n-    <!-- richtext -->\n-    <adapter factory=".widgets.richtext.RichTextFieldWidget"\n-        for="plone.app.textfield.interfaces.IRichText\n-                plone.app.z3cform.interfaces.IPloneFormLayer"/>\n-\n-    <!-- link -->\n-    <adapter factory=".widgets.link.LinkFieldWidget"\n-        for="z3c.form.interfaces.ITextWidget\n-                plone.app.z3cform.interfaces.IPloneFormLayer"/>\n-\n-    <z3c:widgetTemplate\n-        mode="input"\n-        widget=".interfaces.ILinkWidget"\n-        layer=".interfaces.IPloneFormLayer"\n-        template="templates/link_input.pt"\n+  </class>\n+\n+  <adapter\n+      factory=".widgets.datetime.DateFieldWidget"\n+      for="zope.schema.interfaces.IDate\n+           plone.app.z3cform.interfaces.IPloneFormLayer"\n+      />\n+\n+  <class class=".widgets.datetime.DatetimeWidget">\n+    <require\n+        permission="zope.Public"\n+        interface=".interfaces.IDatetimeWidget"\n         />\n-\n-    <!-- z3c.form overrides -->\n-\n-    <z3c:widgetTemplate\n-        mode="input"\n-        widget="z3c.form.interfaces.ITextWidget"\n-        layer=".interfaces.IPloneFormLayer"\n-        template="templates/text_input.pt"\n-        />\n-\n-    <z3c:widgetTemplate\n-        mode="input"\n-        field="zope.schema.interfaces.IDatetime"\n-        widget=".interfaces.IDatetimeWidget"\n-        layer=".interfaces.IPloneFormLayer"\n-        template="templates/text_input.pt"\n-        />\n-\n-    <z3c:widgetTemplate\n-        mode="input"\n-        widget="z3c.form.interfaces.ITextAreaWidget"\n-        layer=".interfaces.IPloneFormLayer"\n-        template="templates/textarea_input.pt"\n-        />\n-\n-    <z3c:widgetTemplate\n-        mode="input"\n-        widget="z3c.form.interfaces.ISelectWidget"\n-        layer=".interfaces.IPloneFormLayer"\n-        template="templates/select_input.pt"\n-        />\n-\n-    <z3c:widgetTemplate\n-        mode="input"\n-        widget="z3c.form.interfaces.IOrderedSelectWidget"\n-        layer=".interfaces.IPloneFormLayer"\n-        template="templates/orderedselect_input.pt"\n-        />\n-\n-    <z3c:widgetTemplate\n-        mode="input"\n-        widget="z3c.form.interfaces.IRadioWidget"\n-        layer=".interfaces.IPloneFormLayer"\n-        template="templates/radio_input.pt"\n-        />\n-\n-    <z3c:widgetTemplate\n-        mode="input_single"\n-        widget="z3c.form.interfaces.IRadioWidget"\n-        layer=".interfaces.IPloneFormLayer"\n-        template="templates/radio_input_single.pt"\n-        />\n-\n-    <z3c:widgetTemplate\n-        mode="input"\n-        widget="z3c.form.interfaces.ISubmitWidget"\n-        layer=".interfaces.IPloneFormLayer"\n-        template="templates/submit_input.pt"\n-        />\n-\n-    <z3c:widgetTemplate\n-        mode="input"\n-        widget="z3c.form.interfaces.ICheckBoxWidget"\n-        layer=".interfaces.IPloneFormLayer"\n-        template="templates/checkbox_input.pt"\n-        />\n-\n-    <z3c:widgetTemplate\n-        mode="input"\n-        widget="z3c.form.interfaces.IPasswordWidget"\n-        layer=".interfaces.IPloneFormLayer"\n-        template="templates/password_input.pt"\n-        />\n-\n-    <!-- plone.formwidget.namedfile -->\n-    <z3c:widgetTemplate\n-        mode="input"\n-        widget="plone.formwidget.namedfile.interfaces.INamedFileWidget"\n-        layer=".interfaces.IPloneFormLayer"\n-        template="templates/file_input.pt"\n-        />\n-\n-    <z3c:widgetTemplate\n-        mode="input"\n-        widget="plone.formwidget.namedfile.interfaces.INamedImageWidget"\n-        layer=".interfaces.IPloneFormLayer"\n-        template="templates/image_input.pt"\n-        />\n-\n-    <!-- plone.z3cform.textlines -->\n-    <z3c:widgetTemplate\n-        mode="input"\n-        widget="plone.z3cform.textlines.textlines.ITextLinesWidget"\n-        layer=".interfaces.IPloneFormLayer"\n-        template="templates/textlines_input.pt"\n-        />\n-\n-    <!-- plone.app.textfield -->\n-    <z3c:widgetTemplate\n-        mode="input"\n-        widget="plone.app.textfield.widget.IRichTextWidget"\n-        layer=".interfaces.IPloneFormLayer"\n-        template="templates/textfield_widget_input.pt"\n-        />\n-\n-    <utility\n-        component=".widgets.richtext.tinymce_richtextwidget_render"\n-        provides="plone.app.z3cform.interfaces.IRichTextWidgetInputModeRenderer"\n-        name="tinymce"\n+  </class>\n+\n+  <adapter\n+      factory=".widgets.datetime.DatetimeFieldWidget"\n+      for="zope.schema.interfaces.IDatetime\n+           plone.app.z3cform.interfaces.IPloneFormLayer"\n+      />\n+\n+  <class class=".widgets.datetime.TimeWidget">\n+    <require\n+        permission="zope.Public"\n+        interface=".interfaces.ITimeWidget"\n         />\n+  </class>\n+\n+  <adapter\n+      factory=".widgets.datetime.TimeFieldWidget"\n+      for="zope.schema.interfaces.ITime\n+           plone.app.z3cform.interfaces.IPloneFormLayer"\n+      />\n+\n+  <!-- relateditems -->\n+\n+  <adapter\n+      factory=".widgets.relateditems.RelatedItemsFieldWidget"\n+      for="z3c.relationfield.interfaces.IRelationChoice\n+           plone.app.z3cform.interfaces.IPloneFormLayer"\n+      />\n+\n+  <adapter\n+      factory=".widgets.relateditems.RelatedItemsFieldWidget"\n+      for="z3c.relationfield.interfaces.IRelationList\n+           plone.app.z3cform.interfaces.IPloneFormLayer"\n+      />\n+\n+  <adapter\n+      factory=".widgets.relateditems.RelatedItemsFieldWidget"\n+      for="zope.schema.interfaces.IChoice\n+           plone.app.vocabularies.catalog.CatalogSource\n+           plone.app.z3cform.interfaces.IPloneFormLayer"\n+      />\n+\n+  <z3c:widgetTemplate\n+      widget=".interfaces.IRelatedItemsWidget"\n+      template="templates/relateditems_display.pt"\n+      layer=".interfaces.IPloneFormLayer"\n+      mode="display"\n+      />\n+\n+  <!-- querystring -->\n+  <adapter\n+      factory=".widgets.querystring.QueryStringFieldWidget"\n+      for="zope.schema.interfaces.IList\n+           zope.schema.interfaces.IDict\n+           plone.app.z3cform.interfaces.IPloneFormLayer"\n+      />\n+\n+  <!-- richtext -->\n+  <adapter\n+      factory=".widgets.richtext.RichTextFieldWidget"\n+      for="plone.app.textfield.interfaces.IRichText\n+           plone.app.z3cform.interfaces.IPloneFormLayer"\n+      />\n+\n+  <!-- link -->\n+  <adapter\n+      factory=".widgets.link.LinkFieldWidget"\n+      for="z3c.form.interfaces.ITextWidget\n+           plone.app.z3cform.interfaces.IPloneFormLayer"\n+      />\n+\n+  <z3c:widgetTemplate\n+      widget=".interfaces.ILinkWidget"\n+      template="templates/link_input.pt"\n+      layer=".interfaces.IPloneFormLayer"\n+      mode="input"\n+      />\n+\n+  <!-- z3c.form overrides -->\n+\n+  <z3c:widgetTemplate\n+      widget="z3c.form.interfaces.ITextWidget"\n+      template="templates/text_input.pt"\n+      layer=".interfaces.IPloneFormLayer"\n+      mode="input"\n+      />\n+\n+  <z3c:widgetTemplate\n+      field="zope.schema.interfaces.IDatetime"\n+      widget=".interfaces.IDatetimeWidget"\n+      template="templates/text_input.pt"\n+      layer=".interfaces.IPloneFormLayer"\n+      mode="input"\n+      />\n+\n+  <z3c:widgetTemplate\n+      widget="z3c.form.interfaces.ITextAreaWidget"\n+      template="templates/textarea_input.pt"\n+      layer=".interfaces.IPloneFormLayer"\n+      mode="input"\n+      />\n+\n+  <z3c:widgetTemplate\n+      widget="z3c.form.interfaces.ISelectWidget"\n+      template="templates/select_input.pt"\n+      layer=".interfaces.IPloneFormLayer"\n+      mode="input"\n+      />\n+\n+  <z3c:widgetTemplate\n+      widget="z3c.form.interfaces.IOrderedSelectWidget"\n+      template="templates/orderedselect_input.pt"\n+      layer=".interfaces.IPloneFormLayer"\n+      mode="input"\n+      />\n+\n+  <z3c:widgetTemplate\n+      widget="z3c.form.interfaces.IRadioWidget"\n+      template="templates/radio_input.pt"\n+      layer=".interfaces.IPloneFormLayer"\n+      mode="input"\n+      />\n+\n+  <z3c:widgetTemplate\n+      widget="z3c.form.interfaces.IRadioWidget"\n+      template="templates/radio_input_single.pt"\n+      layer=".interfaces.IPloneFormLayer"\n+      mode="input_single"\n+      />\n+\n+  <z3c:widgetTemplate\n+      widget="z3c.form.interfaces.ISubmitWidget"\n+      template="templates/submit_input.pt"\n+      layer=".interfaces.IPloneFormLayer"\n+      mode="input"\n+      />\n+\n+  <z3c:widgetTemplate\n+      widget="z3c.form.interfaces.ICheckBoxWidget"\n+      template="templates/checkbox_input.pt"\n+      layer=".interfaces.IPloneFormLayer"\n+      mode="input"\n+      />\n+\n+  <z3c:widgetTemplate\n+      widget="z3c.form.interfaces.IPasswordWidget"\n+      template="templates/password_input.pt"\n+      layer=".interfaces.IPloneFormLayer"\n+      mode="input"\n+      />\n+\n+  <!-- plone.formwidget.namedfile -->\n+  <z3c:widgetTemplate\n+      widget="plone.formwidget.namedfile.interfaces.INamedFileWidget"\n+      template="templates/file_input.pt"\n+      layer=".interfaces.IPloneFormLayer"\n+      mode="input"\n+      />\n+\n+  <z3c:widgetTemplate\n+      widget="plone.formwidget.namedfile.interfaces.INamedImageWidget"\n+      template="templates/image_input.pt"\n+      layer=".interfaces.IPloneFormLayer"\n+      mode="input"\n+      />\n+\n+  <!-- plone.z3cform.textlines -->\n+  <z3c:widgetTemplate\n+      widget="plone.z3cform.textlines.textlines.ITextLinesWidget"\n+      template="templates/textlines_input.pt"\n+      layer=".interfaces.IPloneFormLayer"\n+      mode="input"\n+      />\n+\n+  <!-- plone.app.textfield -->\n+  <z3c:widgetTemplate\n+      widget="plone.app.textfield.widget.IRichTextWidget"\n+      template="templates/textfield_widget_input.pt"\n+      layer=".interfaces.IPloneFormLayer"\n+      mode="input"\n+      />\n+\n+  <utility\n+      provides="plone.app.z3cform.interfaces.IRichTextWidgetInputModeRenderer"\n+      name="tinymce"\n+      component=".widgets.richtext.tinymce_richtextwidget_render"\n+      />\n \n </configure>\ndiff --git a/plone/app/z3cform/widgets/datetime.py b/plone/app/z3cform/widgets/datetime.py\nindex fcf99ba..699a04c 100644\n--- a/plone/app/z3cform/widgets/datetime.py\n+++ b/plone/app/z3cform/widgets/datetime.py\n@@ -16,13 +16,13 @@\n \n \n def get_date_options(request):\n-    calendar = request.locale.dates.calendars[\'gregorian\']\n+    calendar = request.locale.dates.calendars["gregorian"]\n     return {\n-        \'behavior\': \'native\',\n-        \'week-numbers\': \'show\',\n-        \'first-day\': calendar.week.get(\'firstDay\') == 1 and 1 or 0,\n-        \'today\': translate(_(u"Today"), context=request),\n-        \'clear\': translate(_(u"Clear"), context=request),\n+        "behavior": "native",\n+        "week-numbers": "show",\n+        "first-day": calendar.week.get("firstDay") == 1 and 1 or 0,\n+        "today": translate(_("Today"), context=request),\n+        "clear": translate(_("Clear"), context=request),\n     }\n \n \n@@ -40,6 +40,7 @@ class DateWidget(BaseWidget, TextWidget):\n     The default_timezone and default_time arguments are only used if a datewidget is\n     used on a datetime field. If used on a date field they are ignored.\n     """\n+\n     _base_type = "date"\n     _converter = DateWidgetConverter\n     _formater = "date"\n@@ -141,7 +142,6 @@ def DatetimeFieldWidget(field, request):\n \n @implementer_only(ITimeWidget)\n class TimeWidget(BaseWidget, TextWidget):\n-\n     pattern = ""\n \n     def _base(self, **kw):\ndiff --git a/plone/app/z3cform/widgets/patterns.py b/plone/app/z3cform/widgets/patterns.py\nindex 14c3da5..7bcf8dd 100644\n--- a/plone/app/z3cform/widgets/patterns.py\n+++ b/plone/app/z3cform/widgets/patterns.py\n@@ -1,9 +1,7 @@\n-from copy import deepcopy\n from lxml import etree\n \n import collections\n import json\n-import six\n \n \n def el_attrib(name):\n@@ -19,7 +17,7 @@ def el_attrib(name):\n     def _get(self):\n         if name in self.el.attrib:\n             value = self.el.attrib[name]\n-            if value.strip().startswith(\'[\') or value.strip().startswith(\'{\'):\n+            if value.strip().startswith("[") or value.strip().startswith("{"):\n                 value = json.loads(value)\n             return value\n \n@@ -27,11 +25,11 @@ def _set(self, value):\n         if value is None:\n             return\n         if isinstance(value, (list, tuple)):\n-            value = \' \'.join(value)\n+            value = " ".join(value)\n         if isinstance(value, (dict, set)):\n             value = json.dumps(value)\n-        if isinstance(value, six.binary_type):\n-            value = value.decode(\'utf8\')\n+        if isinstance(value, bytes):\n+            value = value.decode("utf8")\n         self.el.attrib[name] = value\n \n     def _del(self):\n@@ -41,11 +39,11 @@ def _del(self):\n     return property(_get, _set, _del)\n \n \n-class BaseWidget(object):\n+class BaseWidget:\n     """Basic patterns widget."""\n \n-    _klass_prefix = \'pat-\'\n-    klass = el_attrib(\'class\')\n+    _klass_prefix = "pat-"\n+    klass = el_attrib("class")\n \n     def __init__(self, el, pattern, pattern_options={}):\n         """\n@@ -68,8 +66,9 @@ def __init__(self, el, pattern, pattern_options={}):\n     def update(self):\n         """Updating pattern_options in element `data-*` attribute."""\n         if self.pattern_options:\n-            self.el.attrib[\'data-\' + self._klass_prefix + self.pattern] = \\\n-                json.dumps(self.pattern_options)\n+            self.el.attrib["data-" + self._klass_prefix + self.pattern] = json.dumps(\n+                self.pattern_options\n+            )\n \n     def render(self):\n         """Renders the widget\n@@ -79,18 +78,17 @@ def render(self):\n         """\n \n         self.update()\n-        return etree.tostring(self.el, encoding=six.text_type)\n+        return etree.tostring(self.el, encoding=str)\n \n \n class InputWidget(BaseWidget):\n     """Widget with `input` element."""\n \n-    type = el_attrib(\'type\')\n-    value = el_attrib(\'value\')\n-    name = el_attrib(\'name\')\n+    type = el_attrib("type")\n+    value = el_attrib("value")\n+    name = el_attrib("name")\n \n-    def __init__(self, pattern, pattern_options={}, type=\'text\', name=None,\n-                 value=None):\n+    def __init__(self, pattern, pattern_options={}, type="text", name=None, value=None):\n         """\n         :param pattern: [required] Pattern name.\n         :type pattern: string\n@@ -107,7 +105,7 @@ def __init__(self, pattern, pattern_options={}, type=\'text\', name=None,\n         :param value: `value` attribute of element.\n         :type value: string\n         """\n-        super().__init__(\'input\', pattern, pattern_options)\n+        super().__init__("input", pattern, pattern_options)\n         self.type = type\n         if name is not None:\n             self.name = name\n@@ -118,11 +116,18 @@ def __init__(self, pattern, pattern_options={}, type=\'text\', name=None,\n class SelectWidget(BaseWidget):\n     """Widget with `select` element."""\n \n-    name = el_attrib(\'name\')\n-    _multiple = el_attrib(\'multiple\')\n-\n-    def __init__(self, pattern, pattern_options={}, items=[], name=None,\n-                 value=None, multiple=False):\n+    name = el_attrib("name")\n+    _multiple = el_attrib("multiple")\n+\n+    def __init__(\n+        self,\n+        pattern,\n+        pattern_options={},\n+        items=[],\n+        name=None,\n+        value=None,\n+        multiple=False,\n+    ):\n         """\n         :param pattern: [required] Pattern name.\n         :type pattern: string\n@@ -143,8 +148,8 @@ def __init__(self, pattern, pattern_options={}, items=[], name=None,\n         :param multiple: `multiple` attribute of element.\n         :type multiple: bool\n         """\n-        super().__init__(\'select\', pattern, pattern_options)\n-        self.el.text = \'\'\n+        super().__init__("select", pattern, pattern_options)\n+        self.el.text = ""\n         self.items = items\n         self.multiple = multiple\n         if name is not None:\n@@ -158,16 +163,22 @@ def _get_items(self):\n         :returns: List of value and title pairs.\n         :rtype: list\n         """\n-        if self.el.find(\'optgroup\') is not None:\n+        if self.el.find("optgroup") is not None:\n             return collections.OrderedDict(\n-                (group.attrib[\'label\'], [\n-                    (option.attrib[\'value\'], option.text)\n-                    for option in group.iter("option")])\n-                for group in self.el.iter("optgroup"))\n+                (\n+                    group.attrib["label"],\n+                    [\n+                        (option.attrib["value"], option.text)\n+                        for option in group.iter("option")\n+                    ],\n+                )\n+                for group in self.el.iter("optgroup")\n+            )\n         else:\n             return [\n-                (option.attrib[\'value\'], option.text)\n-                for option in self.el.iter("option")]\n+                (option.attrib["value"], option.text)\n+                for option in self.el.iter("option")\n+            ]\n \n     def _set_items(self, value):\n         """Set options for element.\n@@ -176,24 +187,25 @@ def _set_items(self, value):\n                       options to choose from.\n         :type value: list\n         """\n+\n         def addOptions(el, options):\n             """\n             Add <option> elements for each vocab item.\n             """\n             for token, title in options:\n-                option = etree.SubElement(el, \'option\')\n-                option.attrib[\'value\'] = token\n+                option = etree.SubElement(el, "option")\n+                option.attrib["value"] = token\n                 option.text = title\n \n         if isinstance(value, dict):\n             for group_label, options in value.items():\n-                group = etree.SubElement(self.el, \'optgroup\')\n-                group.attrib[\'label\'] = group_label\n+                group = etree.SubElement(self.el, "optgroup")\n+                group.attrib["label"] = group_label\n                 addOptions(group, options)\n         else:\n             for token, title in value:\n-                option = etree.SubElement(self.el, \'option\')\n-                option.attrib[\'value\'] = token\n+                option = etree.SubElement(self.el, "option")\n+                option.attrib["value"] = token\n                 option.text = title\n \n     def _del_items(self):\n@@ -213,9 +225,11 @@ def _get_value(self):\n         """\n         value = []\n         for element in self.el.iter("option"):\n-            if \'selected\' in element.attrib and \\\n-                    element.attrib[\'selected\'] == \'selected\':\n-                value.append(element.attrib[\'value\'])\n+            if (\n+                "selected" in element.attrib\n+                and element.attrib["selected"] == "selected"\n+            ):\n+                value.append(element.attrib["value"])\n         return value\n \n     def _set_value(self, value):\n@@ -224,23 +238,26 @@ def _set_value(self, value):\n         :param value: We are expecting option\'s value which should be selected.\n         :type value: list or string\n         """\n-        if isinstance(value, six.string_types):\n+        if isinstance(value, str):\n             value = [value]\n \n         for element in self.el.iter("option"):\n-            if element.attrib[\'value\'] in value:\n-                element.attrib[\'selected\'] = \'selected\'\n-            elif \'selected\' in element.attrib and \\\n-                    element.attrib[\'selected\'] == \'selected\':\n-                del element.attrib[\'selected\']\n+            if element.attrib["value"] in value:\n+                element.attrib["selected"] = "selected"\n+            elif (\n+                "selected" in element.attrib\n+                and element.attrib["selected"] == "selected"\n+            ):\n+                del element.attrib["selected"]\n \n     def _del_value(self):\n-        """Unselect all selected options.\n-        """\n+        """Unselect all selected options."""\n         for element in self.el.iter("option"):\n-            if \'selected\' in element.attrib and \\\n-               element.attrib[\'selected\'] == \'selected\':\n-                del element.attrib[\'selected\']\n+            if (\n+                "selected" in element.attrib\n+                and element.attrib["selected"] == "selected"\n+            ):\n+                del element.attrib["selected"]\n \n     value = property(_get_value, _set_value, _del_value)\n \n@@ -251,7 +268,7 @@ def _get_multiple(self):\n                   `False`.\n         :rtype: bool\n         """\n-        if self._multiple == \'multiple\':\n+        if self._multiple == "multiple":\n             return True\n         return False\n \n@@ -263,7 +280,7 @@ def _set_multiple(self, value):\n         :type value: bool\n         """\n         if value:\n-            self._multiple = \'multiple\'\n+            self._multiple = "multiple"\n         else:\n             self._del_multiple()\n \n@@ -277,7 +294,7 @@ def _del_multiple(self):\n class TextareaWidget(BaseWidget):\n     """Widget with `textarea` element."""\n \n-    name = el_attrib(\'name\')\n+    name = el_attrib("name")\n \n     def __init__(self, pattern, pattern_options={}, name=None, value=None):\n         """\n@@ -293,9 +310,8 @@ def __init__(self, pattern, pattern_options={}, name=None, value=None):\n         :param value: `value` of element.\n         :type value: string\n         """\n-        super().__init__(\'textarea\', pattern,\n-                                             pattern_options)\n-        self.el.text = \'\'\n+        super().__init__("textarea", pattern, pattern_options)\n+        self.el.text = ""\n         if name is not None:\n             self.name = name\n         if value is not None:\n@@ -317,6 +333,6 @@ def _set_value(self, value):\n \n     def _del_value(self):\n         """Set empty string as value of element."""\n-        self.el.text = \'\'\n+        self.el.text = ""\n \n     value = property(_get_value, _set_value, _del_value)\ndiff --git a/plone/app/z3cform/widgets/querystring.py b/plone/app/z3cform/widgets/querystring.py\nindex ce904db..e186745 100644\n--- a/plone/app/z3cform/widgets/querystring.py\n+++ b/plone/app/z3cform/widgets/querystring.py\n@@ -20,20 +20,20 @@ def get_querystring_options(context, querystring_view):\n     except AttributeError:\n         base_url = portal_url\n     return {\n-        \'indexOptionsUrl\': \'{}/{}\'.format(portal_url, querystring_view),\n-        \'previewURL\': \'%s/@@querybuilder_html_results\' % base_url,\n-        \'previewCountURL\': \'%s/@@querybuildernumberofresults\' % base_url,\n-        \'patternDateOptions\': get_date_options(getRequest()),\n-        \'patternAjaxSelectOptions\': {\'separator\': \';\'},\n-        \'patternRelateditemsOptions\': get_relateditems_options(\n+        "indexOptionsUrl": f"{portal_url}/{querystring_view}",\n+        "previewURL": "%s/@@querybuilder_html_results" % base_url,\n+        "previewCountURL": "%s/@@querybuildernumberofresults" % base_url,\n+        "patternDateOptions": get_date_options(getRequest()),\n+        "patternAjaxSelectOptions": {"separator": ";"},\n+        "patternRelateditemsOptions": get_relateditems_options(\n             context,\n             None,\n-            \';\',\n-            \'plone.app.vocabularies.Catalog\',\n-            \'@@getVocabulary\',\n-            \'relatedItems\',\n-            include_recently_added=False\n-        )\n+            ";",\n+            "plone.app.vocabularies.Catalog",\n+            "@@getVocabulary",\n+            "relatedItems",\n+            include_recently_added=False,\n+        ),\n     }\n \n \n@@ -78,4 +78,3 @@ def QueryStringFieldWidget(field, request, extra=None):\n     if extra is not None:\n         request = extra\n     return FieldWidget(field, QueryStringWidget(request))\n-\ndiff --git a/plone/app/z3cform/widgets/relateditems.py b/plone/app/z3cform/widgets/relateditems.py\nindex 802aadb..2416f0b 100644\n--- a/plone/app/z3cform/widgets/relateditems.py\n+++ b/plone/app/z3cform/widgets/relateditems.py\n@@ -25,37 +25,44 @@\n from zope.schema.interfaces import ICollection\n \n \n-def get_relateditems_options(context, value, separator, vocabulary_name,\n-                             vocabulary_view, field_name=None,\n-                             include_recently_added=True):\n-\n+def get_relateditems_options(\n+    context,\n+    value,\n+    separator,\n+    vocabulary_name,\n+    vocabulary_view,\n+    field_name=None,\n+    include_recently_added=True,\n+):\n     if IForm.providedBy(context):\n         context = context.context\n \n     request = getRequest()\n     site = get_top_site_from_url(context, request)\n     options = {\n-        \'separator\': separator,\n+        "separator": separator,\n     }\n     if not vocabulary_name:\n         # we need a vocabulary!\n-        raise ValueError(\'RelatedItems needs a vocabulary\')\n-    options[\'vocabularyUrl\'] = \'{0}/{1}?name={2}\'.format(\n-        get_context_url(site), vocabulary_view, vocabulary_name,\n+        raise ValueError("RelatedItems needs a vocabulary")\n+    options["vocabularyUrl"] = "{}/{}?name={}".format(\n+        get_context_url(site),\n+        vocabulary_view,\n+        vocabulary_name,\n     )\n     if field_name:\n-        options[\'vocabularyUrl\'] += \'&field={0}\'.format(field_name)\n+        options["vocabularyUrl"] += f"&field={field_name}"\n     if value:\n-        options[\'initialValues\'] = {}\n+        options["initialValues"] = {}\n         catalog = False\n-        if vocabulary_name == \'plone.app.vocabularies.Catalog\':\n-            catalog = getToolByName(getSite(), \'portal_catalog\')\n+        if vocabulary_name == "plone.app.vocabularies.Catalog":\n+            catalog = getToolByName(getSite(), "portal_catalog")\n         for value in value.split(separator):\n             title = value\n             if catalog:\n                 result = catalog(UID=value)\n                 title = result[0].Title if result else value\n-            options[\'initialValues\'][value] = title\n+            options["initialValues"][value] = title\n \n     nav_root = getNavigationRootObject(context, site)\n \n@@ -68,38 +75,35 @@ def get_relateditems_options(context, value, separator, vocabulary_name,\n         base_path_context = aq_parent(base_path_context)\n     if not base_path_context:\n         base_path_context = nav_root\n-    options[\'basePath\'] = \'/\'.join(base_path_context.getPhysicalPath())\n+    options["basePath"] = "/".join(base_path_context.getPhysicalPath())\n \n     # rootPath - Only display breadcrumb elements deeper than this path.\n-    options[\'rootPath\'] = \'/\'.join(site.getPhysicalPath()) if site else \'/\'\n+    options["rootPath"] = "/".join(site.getPhysicalPath()) if site else "/"\n \n     # rootUrl: Visible URL up to the rootPath. This is prepended to the\n     # currentPath to generate submission URLs.\n-    options[\'rootUrl\'] = site.absolute_url() if site else \'\'\n+    options["rootUrl"] = site.absolute_url() if site else ""\n \n     # contextPath - current edited object. Will not be available to select.\n-    options[\'contextPath\'] = \'/\'.join(context.getPhysicalPath())\n+    options["contextPath"] = "/".join(context.getPhysicalPath())\n \n     if base_path_context != nav_root:\n-        options[\'favorites\'] = [\n+        options["favorites"] = [\n             {\n-                \'title\': _(u\'Current Content\'),\n-                \'path\': \'/\'.join(base_path_context.getPhysicalPath())\n-            }, {\n-                \'title\': _(u\'Start Page\'),\n-                \'path\': \'/\'.join(nav_root.getPhysicalPath())\n-            }\n+                "title": _("Current Content"),\n+                "path": "/".join(base_path_context.getPhysicalPath()),\n+            },\n+            {"title": _("Start Page"), "path": "/".join(nav_root.getPhysicalPath())},\n         ]\n \n     if include_recently_added:\n         # Options for recently used key\n-        tool = getToolByName(context, \'portal_membership\')\n+        tool = getToolByName(context, "portal_membership")\n         user = tool.getAuthenticatedMember()\n-        options[\'recentlyUsed\'] = False  # Keep that off in Plone 5.1\n-        options[\'recentlyUsedKey\'] = (u\'relateditems_recentlyused_%s_%s\' % (\n-            field_name or \'\',\n-            user.id\n-        ))  # use string substitution with %s here for automatic str casting.\n+        options["recentlyUsed"] = False  # Keep that off in Plone 5.1\n+        options["recentlyUsedKey"] = "relateditems_recentlyused_{}_{}".format(\n+            field_name or "", user.id\n+        )  # use string substitution with %s here for automatic str casting.\n \n     return options\n \ndiff --git a/plone/app/z3cform/widgets/richtext.py b/plone/app/z3cform/widgets/richtext.py\nindex 6e0b2c6..0c14dd8 100644\n--- a/plone/app/z3cform/widgets/richtext.py\n+++ b/plone/app/z3cform/widgets/richtext.py\n@@ -20,6 +20,7 @@\n import json\n import logging\n \n+\n logger = logging.getLogger(__name__)\n \n \n@@ -31,8 +32,8 @@ def get_tinymce_options(context, field, request):\n     options = {}\n     try:\n         pattern_options = getMultiAdapter(\n-            (context, request, field),\n-            name="plone_settings").tinymce()[\'data-pat-tinymce\']\n+            (context, request, field), name="plone_settings"\n+        ).tinymce()["data-pat-tinymce"]\n         options = json.loads(pattern_options)\n     except (ComponentLookupError, AttributeError):\n         logger.warning("Can not load tinymce pattern options!", exc_info=True)\n@@ -141,7 +142,7 @@ def render_input_mode(self):\n             mt_select = etree.Element("select")\n             mt_select.attrib["id"] = f"{self.id}_text_format"\n             mt_select.attrib["name"] = f"{self.name}.mimeType"\n-            mt_select.attrib["class"] = "form-select {}".format(mt_pattern_name)\n+            mt_select.attrib["class"] = f"form-select {mt_pattern_name}"\n             mt_select.attrib[f"data-{mt_pattern_name}"] = json.dumps(\n                 {\n                     "textareaName": self.name,\n@@ -180,5 +181,3 @@ def tinymce_richtextwidget_render(widget):\n @implementer(IFieldWidget)\n def RichTextFieldWidget(field, request):\n     return FieldWidget(field, RichTextWidget(request))\n-\n-\n'

Repository: plone.app.z3cform


Branch: refs/heads/master
Date: 2023-04-21T20:45:59+02:00
Author: Fred van Dijk (fredvd) <fredvd@gmail.com>
Commit: https://github.com/plone/plone.app.z3cform/commit/d822d7c99da3ba27592dd9ba433f8ea579314e4b

Merge branch 'master' into deprecate-plone-app-widgets

Files changed:
M .meta.toml
M .pre-commit-config.yaml
M CHANGES.rst
M plone/app/z3cform/interfaces.py
M setup.py
M tox.ini
D news/160.bugfix
D news/243ca9ec.internal

b'diff --git a/.meta.toml b/.meta.toml\nindex 4ed1a1d..eb3c765 100644\n--- a/.meta.toml\n+++ b/.meta.toml\n@@ -2,4 +2,4 @@\n # https://github.com/plone/meta/tree/master/config/default\n [meta]\n template = "default"\n-commit-id = "789b0936"\n+commit-id = "3b8337e6"\ndiff --git a/.pre-commit-config.yaml b/.pre-commit-config.yaml\nindex 582f8ac..fdafec1 100644\n--- a/.pre-commit-config.yaml\n+++ b/.pre-commit-config.yaml\n@@ -15,11 +15,11 @@ repos:\n     hooks:\n     -   id: isort\n -   repo: https://github.com/psf/black\n-    rev: 23.1.0\n+    rev: 23.3.0\n     hooks:\n     -   id: black\n -   repo: https://github.com/collective/zpretty\n-    rev: 3.0.2\n+    rev: 3.0.3\n     hooks:\n     -   id: zpretty\n -   repo: https://github.com/PyCQA/flake8\n@@ -27,7 +27,7 @@ repos:\n     hooks:\n     -   id: flake8\n -   repo: https://github.com/codespell-project/codespell\n-    rev: v2.2.2\n+    rev: v2.2.4\n     hooks:\n     -   id: codespell\n         additional_dependencies:\ndiff --git a/CHANGES.rst b/CHANGES.rst\nindex 5a0a14f..6d98c3b 100644\n--- a/CHANGES.rst\n+++ b/CHANGES.rst\n@@ -8,6 +8,44 @@ Changelog\n \n .. towncrier release notes start\n \n+4.0.3 (2023-04-14)\n+------------------\n+\n+Bug fixes:\n+\n+\n+- Fixes transitive circular dependency to plone.schema.\n+  Inherit own Browserlayer from new intermediate browserlayer in plone.schema.\n+  [jensens] (#163)\n+- Add ``test`` extra with the same contents as the ``tests`` extra.\n+  The ``tests`` extra will be removed in Plone 7.\n+  [maurits] (#164)\n+\n+\n+Internal:\n+\n+\n+- Update configuration files.\n+  [plone devs] (3b8337e6)\n+\n+\n+4.0.2 (2023-03-23)\n+------------------\n+\n+Bug fixes:\n+\n+\n+- Fix relative URLs validation in link widget\n+  [laulaz] (#160)\n+\n+\n+Internal:\n+\n+\n+- Update configuration files.\n+  [plone devs] (243ca9ec)\n+\n+\n 4.0.1 (2023-01-26)\n ------------------\n \ndiff --git a/news/160.bugfix b/news/160.bugfix\ndeleted file mode 100644\nindex b1093c6..0000000\n--- a/news/160.bugfix\n+++ /dev/null\n@@ -1,2 +0,0 @@\n-Fix relative URLs validation in link widget\n-[laulaz]\n\\ No newline at end of file\ndiff --git a/news/243ca9ec.internal b/news/243ca9ec.internal\ndeleted file mode 100644\nindex c08f539..0000000\n--- a/news/243ca9ec.internal\n+++ /dev/null\n@@ -1,2 +0,0 @@\n-Update configuration files.\n-[plone devs]\ndiff --git a/plone/app/z3cform/interfaces.py b/plone/app/z3cform/interfaces.py\nindex 1db3ad3..c48fe2e 100644\n--- a/plone/app/z3cform/interfaces.py\n+++ b/plone/app/z3cform/interfaces.py\n@@ -1,5 +1,5 @@\n from plone.app.textfield.widget import IRichTextWidget as patextfield_IRichTextWidget\n-from z3c.form.interfaces import IFormLayer\n+from plone.schema.interfaces import IFormLayer\n from z3c.form.interfaces import IRadioWidget\n from z3c.form.interfaces import ISelectWidget as IBaseSelectWidget\n from z3c.form.interfaces import ISingleCheckBoxWidget\ndiff --git a/setup.py b/setup.py\nindex fa661d3..e472453 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -8,7 +8,7 @@ def read(*rnames):\n     return open(os.path.join(os.path.dirname(__file__), *rnames)).read()\n \n \n-version = "4.0.2.dev0"\n+version = "4.0.4.dev0"\n \n long_description = (\n     read("README.rst")\n@@ -20,6 +20,18 @@ def read(*rnames):\n     + read("CHANGES.rst")\n     + "\\n"\n )\n+test_requirements = [\n+    "plone.app.contenttypes[test]",\n+    "plone.app.layout",\n+    "plone.app.testing",\n+    "plone.autoform",\n+    "plone.browserlayer",\n+    "plone.supermodel",\n+    "plone.testing",\n+    "zope.annotation",\n+    "zope.intid",\n+    "zope.publisher",\n+]\n \n setup(\n     name="plone.app.z3cform",\n@@ -56,6 +68,12 @@ def read(*rnames):\n         "plone.app.textfield>=1.3.6",\n         "plone.base",\n         "plone.protect",\n+        "plone.registry",\n+        "plone.schema",\n+        "plone.uuid",\n+        "plone.z3cform",\n+        "Products.GenericSetup",\n+        "pytz",\n         "setuptools",\n         "z3c.form >= 4.0",\n         "z3c.formwidget.query",\n@@ -64,17 +82,11 @@ def read(*rnames):\n         "Zope",\n     ],\n     extras_require={\n-        "tests": [\n-            "plone.app.contenttypes[test]",\n-            "plone.app.layout",\n-            "plone.app.testing",\n-            "plone.autoform",\n-            "plone.browserlayer",\n-            "plone.supermodel",\n-            "plone.testing",\n-            "zope.annotation",\n-            "zope.intid",\n-            "zope.publisher",\n-        ]\n+        # Until plone.app.z3cform 4.0.2 we only had the \'tests\' extra.\n+        # In 4.0.3 we introduced the \'test\' extra.\n+        # Keep \'tests\' for backwards compatibility.\n+        # Remove it in Plone 7.\n+        "test": test_requirements,\n+        "tests": test_requirements,\n     },\n )\ndiff --git a/tox.ini b/tox.ini\nindex 43e9ac4..b4cbd55 100644\n--- a/tox.ini\n+++ b/tox.ini\n@@ -44,10 +44,25 @@ commands =\n [testenv:test]\n usedevelop = true\n constrain_package_deps = true\n+set_env = ROBOT_BROWSER=headlesschrome\n deps =\n     zope.testrunner\n     -c https://dist.plone.org/release/6.0-dev/constraints.txt\n commands =\n-    zope-testrunner --test-path={toxinidir} -s plone.app.z3cform\n+    zope-testrunner --all --test-path={toxinidir} -s plone.app.z3cform {posargs}\n extras =\n-    tests\n+    test\n+\n+[testenv:coverage]\n+usedevelop = true\n+constrain_package_deps = true\n+set_env = ROBOT_BROWSER=headlesschrome\n+deps =\n+    coverage\n+    zope.testrunner\n+    -c https://dist.plone.org/release/6.0-dev/constraints.txt\n+commands =\n+    coverage run {envbindir}/zope-testrunner --all --test-path={toxinidir} -s plone.app.z3cform {posargs}\n+    coverage report -m --format markdown\n+extras =\n+    test\n'

Repository: plone.app.z3cform


Branch: refs/heads/master
Date: 2023-04-23T09:22:27+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.app.z3cform/commit/b45d0419e2a8cfb815fbcfafddd3e3c9fad151c7

Merge pull request #155 from plone/deprecate-plone-app-widgets

Deprecate `plone.app.widgets`

Files changed:
A news/19.feature
A plone/app/z3cform/converters.zcml
A plone/app/z3cform/tests/test_patterns.py
A plone/app/z3cform/widgets.zcml
A plone/app/z3cform/widgets/__init__.py
A plone/app/z3cform/widgets/base.py
A plone/app/z3cform/widgets/datetime.py
A plone/app/z3cform/widgets/link.py
A plone/app/z3cform/widgets/patterns.py
A plone/app/z3cform/widgets/querystring.py
A plone/app/z3cform/widgets/relateditems.py
A plone/app/z3cform/widgets/richtext.py
A plone/app/z3cform/widgets/select.py
A plone/app/z3cform/widgets/singlecheckbox.py
M plone/app/z3cform/configure.zcml
M plone/app/z3cform/tests/test_widgets.py
M plone/app/z3cform/utils.py
M plone/app/z3cform/widget.py
M setup.py
D plone/app/z3cform/widget.zcml

b'diff --git a/news/19.feature b/news/19.feature\nnew file mode 100644\nindex 00000000..be498c6c\n--- /dev/null\n+++ b/news/19.feature\n@@ -0,0 +1,2 @@\n+Merge utils and base classes from  ``plone.app.widgets`` and do not depend\n+on it anymore. [petschki]\ndiff --git a/plone/app/z3cform/configure.zcml b/plone/app/z3cform/configure.zcml\nindex 9bd4ec02..e4401171 100644\n--- a/plone/app/z3cform/configure.zcml\n+++ b/plone/app/z3cform/configure.zcml\n@@ -8,7 +8,6 @@\n     >\n \n   <include package="plone.z3cform" />\n-  <include package="plone.app.widgets" />\n   <include package=".wysiwyg" />\n \n   <!-- Configuration installation profile -->\n@@ -78,32 +77,11 @@\n   <!-- Use a custom actions manager that knows how to do CSRF token authentication. -->\n   <adapter factory=".csrf.AuthenticatedButtonActions" />\n \n-  <adapter factory=".converters.DatetimeWidgetConverter" />\n-  <adapter factory=".converters.DateWidgetConverter" />\n-  <adapter factory=".converters.DateWidgetToDatetimeConverter" />\n-  <adapter factory=".converters.TimeWidgetConverter" />\n-  <adapter factory=".converters.SelectWidgetConverter" />\n-  <adapter factory=".converters.SequenceSelectWidgetConverter" />\n-  <adapter factory=".converters.AjaxSelectWidgetConverter" />\n-  <adapter factory=".converters.QueryStringDataConverter" />\n-  <adapter factory=".converters.RelationChoiceRelatedItemsWidgetConverter" />\n-  <adapter\n-      factory=".converters.RelationChoiceRelatedItemsWidgetConverter"\n-      for="z3c.relationfield.interfaces.IRelationChoice\n-           .interfaces.ITextWidget"\n-      />\n-  <adapter factory=".converters.RelationChoiceSelectWidgetConverter" />\n-  <adapter factory=".converters.RelatedItemsDataConverter" />\n-  <adapter\n-      factory=".converters.RelatedItemsDataConverter"\n-      for="z3c.relationfield.interfaces.IRelationList\n-           .interfaces.ITextWidget"\n-      />\n-  <adapter factory=".converters.RelationListSelectWidgetDataConverter" />\n-  <adapter factory=".converters.LinkWidgetDataConverter" />\n+  <!-- converters -->\n+  <include file="converters.zcml" />\n \n   <!-- widgets -->\n-  <include file="widget.zcml" />\n+  <include file="widgets.zcml" />\n \n   <!-- error snippet -->\n   <adapter\n@@ -119,10 +97,4 @@\n       name="ZPublisher.HTTPRequest.FileUpload"\n       />\n \n-  <utility\n-      provides=".interfaces.IRichTextWidgetInputModeRenderer"\n-      name="tinymce"\n-      component=".widget.tinymce_richtextwidget_render"\n-      />\n-\n </configure>\ndiff --git a/plone/app/z3cform/converters.zcml b/plone/app/z3cform/converters.zcml\nnew file mode 100644\nindex 00000000..2bb8d76d\n--- /dev/null\n+++ b/plone/app/z3cform/converters.zcml\n@@ -0,0 +1,26 @@\n+<configure xmlns="http://namespaces.zope.org/zope">\n+  <adapter factory=".converters.BoolSingleCheckboxDataConverter" />\n+  <adapter factory=".converters.DatetimeWidgetConverter" />\n+  <adapter factory=".converters.DateWidgetConverter" />\n+  <adapter factory=".converters.DateWidgetToDatetimeConverter" />\n+  <adapter factory=".converters.TimeWidgetConverter" />\n+  <adapter factory=".converters.SelectWidgetConverter" />\n+  <adapter factory=".converters.SequenceSelectWidgetConverter" />\n+  <adapter factory=".converters.AjaxSelectWidgetConverter" />\n+  <adapter factory=".converters.QueryStringDataConverter" />\n+  <adapter factory=".converters.RelationChoiceRelatedItemsWidgetConverter" />\n+  <adapter\n+      factory=".converters.RelationChoiceRelatedItemsWidgetConverter"\n+      for="z3c.relationfield.interfaces.IRelationChoice\n+           .interfaces.ITextWidget"\n+      />\n+  <adapter factory=".converters.RelationChoiceSelectWidgetConverter" />\n+  <adapter factory=".converters.RelatedItemsDataConverter" />\n+  <adapter\n+      factory=".converters.RelatedItemsDataConverter"\n+      for="z3c.relationfield.interfaces.IRelationList\n+           .interfaces.ITextWidget"\n+      />\n+  <adapter factory=".converters.RelationListSelectWidgetDataConverter" />\n+  <adapter factory=".converters.LinkWidgetDataConverter" />\n+</configure>\ndiff --git a/plone/app/z3cform/tests/test_patterns.py b/plone/app/z3cform/tests/test_patterns.py\nnew file mode 100644\nindex 00000000..cb3722da\n--- /dev/null\n+++ b/plone/app/z3cform/tests/test_patterns.py\n@@ -0,0 +1,512 @@\n+from plone.app.testing import setRoles\n+from plone.app.testing import TEST_USER_ID\n+from plone.app.z3cform.tests.layer import PAZ3CForm_INTEGRATION_TESTING\n+from plone.app.z3cform.widgets.querystring import get_querystring_options\n+from plone.app.z3cform.widgets.relateditems import get_relateditems_options\n+from plone.app.z3cform.widgets.richtext import get_tinymce_options\n+\n+import unittest\n+\n+\n+class TestQueryStringOptions(unittest.TestCase):\n+    layer = PAZ3CForm_INTEGRATION_TESTING\n+\n+    def setUp(self):\n+        setRoles(self.layer["portal"], TEST_USER_ID, ["Contributor"])\n+\n+    def test__query_string_options(self):\n+        """Test query string options on root:\n+        All URLs and paths equal root url and path,\n+        no favorites\n+        """\n+\n+        portal = self.layer["portal"]\n+        options = get_querystring_options(portal, "@@qsOptions")\n+\n+        # Test base options\n+        self.assertEqual(options["indexOptionsUrl"], "http://nohost/plone/@@qsOptions")\n+\n+        self.assertEqual(\n+            options["previewCountURL"],\n+            "http://nohost/plone/@@querybuildernumberofresults",\n+        )\n+\n+        self.assertEqual(\n+            options["previewURL"], "http://nohost/plone/@@querybuilder_html_results"\n+        )\n+\n+        # Test options of the AJAX select widget\n+        self.assertEqual(options["patternAjaxSelectOptions"]["separator"], ";")\n+\n+        # Test options of the date picker\n+        self.assertEqual(\n+            options["patternDateOptions"],\n+            {\n+                "behavior": "native",\n+                "week-numbers": "show",\n+                "first-day": 0,\n+                "today": "Today",\n+                "clear": "Clear",\n+            },\n+        )\n+\n+        # Test options of the related items widget\n+        self.assertEqual(options["patternRelateditemsOptions"]["basePath"], "/plone")\n+        self.assertTrue("recentlyUsed" not in options["patternRelateditemsOptions"])\n+\n+\n+class TestRelatedItemsOptions(unittest.TestCase):\n+    layer = PAZ3CForm_INTEGRATION_TESTING\n+\n+    def setUp(self):\n+        setRoles(self.layer["portal"], TEST_USER_ID, ["Contributor"])\n+\n+    def test__base_relateditems_options(self):\n+        """Test related items options on root:\n+        All URLs and paths equal root url and path,\n+        no favorites\n+        """\n+\n+        portal = self.layer["portal"]\n+        options = get_relateditems_options(\n+            portal, None, "#!@", "test_vocab", "@@vocab", "testfield"\n+        )\n+\n+        # vocab is correctly set\n+        self.assertTrue(\n+            "@@vocab?name=test_vocab&field=testfield" in options["vocabularyUrl"]\n+        )\n+\n+        # rootUrl contains something\n+        self.assertTrue(bool(options["rootUrl"]))\n+\n+        root_path = context_path = "/".join(portal.getPhysicalPath())\n+        root_url = context_url = portal.absolute_url()\n+\n+        # context_path contains something, otherwise this test is meaningless\n+        self.assertTrue(bool(context_path))\n+        # context_url contains something, otherwise this test is meaningless\n+        self.assertTrue(bool(context_url))\n+\n+        self.assertEqual(options["rootUrl"], root_url)\n+\n+        self.assertEqual(options["rootPath"], root_path)\n+\n+        self.assertEqual(\n+            options["vocabularyUrl"],\n+            root_url + "/@@vocab?name=test_vocab&field=testfield",\n+        )\n+\n+        self.assertEqual(options["basePath"], context_path)\n+\n+        self.assertEqual(options["contextPath"], context_path)\n+\n+        self.assertEqual(options["separator"], "#!@")\n+\n+        self.assertTrue("favorites" not in options)\n+\n+        # Recently used is configured, but off per default.\n+        self.assertEqual(options["recentlyUsed"], False)\n+        self.assertEqual(\n+            options["recentlyUsedKey"],\n+            "relateditems_recentlyused_testfield_" + TEST_USER_ID,\n+        )\n+\n+    def test__subfolder_relateditems_options(self):\n+        """Test related items options on subfolder:\n+        Vocab called on root, start path is folder, have favorites.\n+        """\n+\n+        portal = self.layer["portal"]\n+        portal.invokeFactory("Folder", "sub")\n+        sub = portal.sub\n+        options = get_relateditems_options(\n+            sub, None, "#!@", "test_vocab", "@@vocab", "testfield"\n+        )\n+\n+        # vocab is correctly set\n+        self.assertTrue(\n+            "@@vocab?name=test_vocab&field=testfield" in options["vocabularyUrl"]\n+        )\n+\n+        # rootUrl contains something\n+        self.assertTrue(bool(options["rootUrl"]))\n+\n+        root_path = "/".join(portal.getPhysicalPath())\n+        root_url = portal.absolute_url()\n+        context_path = "/".join(sub.getPhysicalPath())\n+        context_url = sub.absolute_url()\n+\n+        # context_path contains something, otherwise this test is meaningless\n+        self.assertTrue(bool(context_path))\n+        # context_url contains something, otherwise this test is meaningless\n+        self.assertTrue(bool(context_url))\n+\n+        self.assertEqual(options["rootUrl"], root_url)\n+\n+        self.assertEqual(options["rootPath"], root_path)\n+\n+        self.assertEqual(\n+            options["vocabularyUrl"],\n+            root_url + "/@@vocab?name=test_vocab&field=testfield",\n+        )\n+\n+        self.assertEqual(options["basePath"], context_path)\n+\n+        self.assertEqual(options["contextPath"], context_path)\n+\n+        self.assertEqual(options["separator"], "#!@")\n+\n+        self.assertEqual(len(options["favorites"]), 2)\n+\n+        self.assertEqual(sorted(options["favorites"][0].keys()), ["path", "title"])\n+\n+    def test__subdocument_relateditems_options(self):\n+        """Test related items options on subdoc:\n+        Vocab called on root, start path is root as document is not folderish,\n+        no favorites.\n+        """\n+\n+        portal = self.layer["portal"]\n+        portal.invokeFactory("Document", "sub")\n+        sub = portal.sub\n+        options = get_relateditems_options(\n+            sub, None, "#!@", "test_vocab", "@@vocab", "testfield"\n+        )\n+\n+        # vocab is correctly set\n+        self.assertTrue(\n+            "@@vocab?name=test_vocab&field=testfield" in options["vocabularyUrl"]\n+        )\n+\n+        # rootUrl contains something\n+        self.assertTrue(bool(options["rootUrl"]))\n+\n+        root_path = "/".join(portal.getPhysicalPath())\n+        root_url = portal.absolute_url()\n+        context_path = "/".join(sub.getPhysicalPath())\n+        context_url = sub.absolute_url()\n+\n+        # context_path contains something, otherwise this test is meaningless\n+        self.assertTrue(bool(context_path))\n+        # context_url contains something, otherwise this test is meaningless\n+        self.assertTrue(bool(context_url))\n+\n+        self.assertEqual(options["rootUrl"], root_url)\n+\n+        self.assertEqual(options["rootPath"], root_path)\n+\n+        self.assertEqual(\n+            options["vocabularyUrl"],\n+            root_url + "/@@vocab?name=test_vocab&field=testfield",\n+        )\n+\n+        self.assertEqual(options["basePath"], root_path)\n+\n+        self.assertEqual(options["contextPath"], context_path)\n+\n+        self.assertEqual(options["separator"], "#!@")\n+\n+        self.assertTrue("favorites" not in options)\n+\n+\n+class TestTinyMCEOptions(unittest.TestCase):\n+    layer = PAZ3CForm_INTEGRATION_TESTING\n+\n+    def setUp(self):\n+        setRoles(self.layer["portal"], TEST_USER_ID, ["Contributor"])\n+\n+    def test__tinymce_options_different_contexts(self):\n+        """Test if ``get_tinymce_options`` can be called with different\n+        contexts, including invalid and form contexts.\n+        """\n+        request = self.layer["request"]\n+        portal = self.layer["portal"]\n+        portal.invokeFactory("Folder", "sub")\n+        sub = portal.sub\n+\n+        # TinyMCE on portal context\n+        options = get_tinymce_options(portal, None, request)\n+        self.assertEqual(options["relatedItems"]["basePath"], "/plone")\n+\n+        # TinyMCE on sub folder context\n+        options = get_tinymce_options(sub, None, request)\n+        self.assertEqual(options["relatedItems"]["basePath"], "/plone/sub")\n+\n+\n+class BaseWidgetTests(unittest.TestCase):\n+    """Tests for plone.app.z3cform.widgets.patterns.BaseWidget."""\n+\n+    def test_defaults(self):\n+        from plone.app.z3cform.widgets.patterns import BaseWidget\n+\n+        widget = BaseWidget("input", "example1")\n+        self.assertEqual(widget.render(), \'<input class="pat-example1"/>\')\n+\n+        self.assertEqual(widget.klass, "pat-example1")\n+\n+    def test_different_element_tag(self):\n+        from plone.app.z3cform.widgets.patterns import BaseWidget\n+\n+        widget = BaseWidget("select", "example1")\n+        self.assertEqual(widget.render(), \'<select class="pat-example1"/>\')\n+\n+        self.assertEqual(widget.klass, "pat-example1")\n+\n+    def test_setting_patterns_options(self):\n+        from plone.app.z3cform.widgets.patterns import BaseWidget\n+\n+        widget = BaseWidget(\n+            "input",\n+            "example1",\n+            pattern_options={\n+                "option1": "value1",\n+                "option2": "value2",\n+            },\n+        )\n+\n+        html = widget.render()\n+        # the order of options is non-deterministic\n+        result1 = \'<input class="pat-example1" data-pat-example1="{&quot;option1&quot;: &quot;value1&quot;, &quot;option2&quot;: &quot;value2&quot;}"/>\'  # noqa: E501\n+        result2 = \'<input class="pat-example1" data-pat-example1="{&quot;option2&quot;: &quot;value2&quot;, &quot;option1&quot;: &quot;value1&quot;}"/>\'  # noqa: E501\n+        self.assertIn(html, [result1, result2])\n+\n+\n+class InputWidgetTests(unittest.TestCase):\n+    """Tests for plone.app.z3cform.widgets.patterns.InputWidget."""\n+\n+    def test_defaults(self):\n+        from plone.app.z3cform.widgets.patterns import InputWidget\n+\n+        widget = InputWidget("example1", name="example2")\n+\n+        self.assertEqual(\n+            widget.render(), \'<input class="pat-example1" type="text" name="example2"/>\'\n+        )\n+\n+        self.assertEqual(widget.type, "text")\n+        self.assertEqual(widget.value, None)\n+\n+    def test_set_type_and_value(self):\n+        from plone.app.z3cform.widgets.patterns import InputWidget\n+\n+        widget = InputWidget(\n+            "example1", name="example2", type="email", value="example3"\n+        )\n+\n+        self.assertEqual(\n+            widget.render(),\n+            \'<input class="pat-example1" type="email" \'\n+            \'name="example2" value="example3"/>\',\n+        )\n+\n+        self.assertEqual(widget.type, "email")\n+        self.assertEqual(widget.value, "example3")\n+\n+        widget.type = "text"\n+        widget.value = "example4"\n+        self.assertEqual(\n+            widget.render(),\n+            \'<input class="pat-example1" type="text" \'\n+            \'name="example2" value="example4"/>\',\n+        )\n+\n+        self.assertEqual(widget.type, "text")\n+        self.assertEqual(widget.value, "example4")\n+\n+        del widget.type\n+        del widget.value\n+        self.assertEqual(\n+            widget.render(), \'<input class="pat-example1" name="example2"/>\'\n+        )\n+\n+        self.assertEqual(widget.type, None)\n+        self.assertEqual(widget.value, None)\n+\n+\n+class SelectWidgetTests(unittest.TestCase):\n+    """Tests for plone.app.z3cform.widgets.patterns.SelectWidget."""\n+\n+    def test_defaults(self):\n+        from plone.app.z3cform.widgets.patterns import SelectWidget\n+\n+        widget = SelectWidget("example1", name="example2")\n+\n+        self.assertEqual(\n+            widget.render(), \'<select class="pat-example1" name="example2"></select>\'\n+        )\n+        self.assertEqual(list(widget.items), [])\n+        self.assertEqual(widget.value, [])\n+\n+    def test_set_items_and_value(self):\n+        from plone.app.z3cform.widgets.patterns import SelectWidget\n+\n+        items = [\n+            ("token1", "value1"),\n+            ("token2", "value2"),\n+            ("token3", "value3"),\n+        ]\n+        widget = SelectWidget("example1", name="example2", value="token2", items=items)\n+\n+        self.assertEqual(\n+            widget.render(),\n+            \'<select class="pat-example1" name="example2">\'\n+            \'<option value="token1">value1</option>\'\n+            \'<option value="token2" selected="selected">value2</option>\'\n+            \'<option value="token3">value3</option>\'\n+            "</select>",\n+        )\n+\n+        self.assertEqual(list(widget.items), items)\n+        self.assertEqual(widget.value, ["token2"])\n+\n+        widget.value = "token1"\n+        self.assertEqual(\n+            widget.render(),\n+            \'<select class="pat-example1" name="example2">\'\n+            \'<option value="token1" selected="selected">value1</option>\'\n+            \'<option value="token2">value2</option>\'\n+            \'<option value="token3">value3</option>\'\n+            "</select>",\n+        )\n+\n+        self.assertEqual(list(widget.items), items)\n+        self.assertEqual(widget.value, ["token1"])\n+\n+        del widget.value\n+        self.assertEqual(\n+            widget.render(),\n+            \'<select class="pat-example1" name="example2">\'\n+            \'<option value="token1">value1</option>\'\n+            \'<option value="token2">value2</option>\'\n+            \'<option value="token3">value3</option>\'\n+            "</select>",\n+        )\n+\n+        del widget.items\n+        self.assertEqual(\n+            widget.render(), \'<select class="pat-example1" name="example2"></select>\'\n+        )\n+\n+    def test_multiple(self):\n+        from plone.app.z3cform.widgets.patterns import SelectWidget\n+\n+        items = [\n+            ("token1", "value1"),\n+            ("token2", "value2"),\n+            ("token3", "value3"),\n+        ]\n+        widget = SelectWidget(\n+            "example1",\n+            name="example2",\n+            value=["token2"],\n+            items=items,\n+            multiple=True,\n+        )\n+\n+        self.assertEqual(\n+            widget.render(),\n+            \'<select class="pat-example1" multiple="multiple" name="example2">\'\n+            \'<option value="token1">value1</option>\'\n+            \'<option value="token2" selected="selected">value2</option>\'\n+            \'<option value="token3">value3</option>\'\n+            "</select>",\n+        )\n+\n+        self.assertEqual(list(widget.items), items)\n+        self.assertEqual(widget.value, ["token2"])\n+\n+        widget.value = ["token1", "token2"]\n+        self.assertEqual(\n+            widget.render(),\n+            \'<select class="pat-example1" multiple="multiple" name="example2">\'\n+            \'<option value="token1" selected="selected">value1</option>\'\n+            \'<option value="token2" selected="selected">value2</option>\'\n+            \'<option value="token3">value3</option>\'\n+            "</select>",\n+        )\n+\n+        self.assertEqual(list(widget.items), items)\n+        self.assertEqual(widget.value, ["token1", "token2"])\n+\n+        del widget.value\n+        self.assertEqual(\n+            widget.render(),\n+            \'<select class="pat-example1" multiple="multiple" name="example2">\'\n+            \'<option value="token1">value1</option>\'\n+            \'<option value="token2">value2</option>\'\n+            \'<option value="token3">value3</option>\'\n+            "</select>",\n+        )\n+\n+        del widget.items\n+        self.assertEqual(\n+            widget.render(),\n+            \'<select class="pat-example1" multiple="multiple" \'\n+            \'name="example2"></select>\',\n+        )\n+\n+\n+class TextareaWidgetTests(unittest.TestCase):\n+    """Tests for plone.app.z3cform.widgets.patterns.TextareaWidget."""\n+\n+    def test_defaults(self):\n+        from plone.app.z3cform.widgets.patterns import TextareaWidget\n+\n+        widget = TextareaWidget("example1", name="example2")\n+        self.assertEqual(\n+            widget.render(),\n+            \'<textarea class="pat-example1" name="example2"></textarea>\',\n+        )\n+\n+        self.assertEqual(widget.name, "example2")\n+        self.assertEqual(widget.klass, "pat-example1")\n+        self.assertEqual(widget.value, "")\n+\n+    def test_setting_patterns_options(self):\n+        from plone.app.z3cform.widgets.patterns import TextareaWidget\n+\n+        widget = TextareaWidget(\n+            "example1",\n+            name="example2",\n+            pattern_options={\n+                "option1": "value1",\n+                "option2": "value2",\n+            },\n+        )\n+\n+        html = widget.render()\n+        # the order of options is non-deterministic\n+        result1 = \'<textarea class="pat-example1" name="example2" data-pat-example1="{&quot;option1&quot;: &quot;value1&quot;, &quot;option2&quot;: &quot;value2&quot;}"></textarea>\'  # noqa: E501\n+        result2 = \'<textarea class="pat-example1" name="example2" data-pat-example1="{&quot;option2&quot;: &quot;value2&quot;, &quot;option1&quot;: &quot;value1&quot;}"></textarea>\'  # noqa: E501\n+        self.assertIn(html, [result1, result2])\n+\n+    def test_set_value(self):\n+        from plone.app.z3cform.widgets.patterns import TextareaWidget\n+\n+        widget = TextareaWidget("example1", name="example2", value="example3")\n+        self.assertEqual(\n+            widget.render(),\n+            \'<textarea class="pat-example1" name="example2">\' "example3" "</textarea>",\n+        )\n+\n+        self.assertEqual(widget.value, "example3")\n+\n+        widget.value = "example4"\n+        self.assertEqual(\n+            widget.render(),\n+            \'<textarea class="pat-example1" name="example2">\' "example4" "</textarea>",\n+        )\n+\n+        del widget.value\n+        self.assertEqual(\n+            widget.render(),\n+            \'<textarea class="pat-example1" name="example2"></textarea>\',\n+        )\n+\n+    def test_can_not_change_element_tag(self):\n+        from plone.app.z3cform.widgets.patterns import TextareaWidget\n+\n+        self.assertRaises(\n+            TypeError, TextareaWidget, "example1", el="input", name="example2"\n+        )\ndiff --git a/plone/app/z3cform/tests/test_widgets.py b/plone/app/z3cform/tests/test_widgets.py\nindex dea25970..9980de7c 100644\n--- a/plone/app/z3cform/tests/test_widgets.py\n+++ b/plone/app/z3cform/tests/test_widgets.py\n@@ -6,11 +6,11 @@\n from plone.app.contentlisting.contentlisting import ContentListing\n from plone.app.testing import setRoles\n from plone.app.testing import TEST_USER_ID\n-from plone.app.widgets.utils import NotImplemented as PatternNotImplemented\n from plone.app.z3cform.tests.layer import PAZ3CForm_INTEGRATION_TESTING\n-from plone.app.z3cform.widget import BaseWidget\n-from plone.app.z3cform.widget import DateWidget\n-from plone.app.z3cform.widget import RelatedItemsWidget\n+from plone.app.z3cform.widgets.base import BaseWidget\n+from plone.app.z3cform.widgets.base import PatternNotImplemented\n+from plone.app.z3cform.widgets.datetime import DateWidget\n+from plone.app.z3cform.widgets.relateditems import RelatedItemsWidget\n from plone.autoform.directives import widget\n from plone.autoform.form import AutoExtensibleForm\n from plone.base.interfaces import IMarkupSchema\n@@ -102,8 +102,8 @@ def test_widget_pattern_notimplemented(self):\n         )\n \n     def test_widget_base_notimplemented(self):\n-        from plone.app.widgets.base import InputWidget\n-        from plone.app.z3cform.widget import BaseWidget\n+        from plone.app.z3cform.widgets.base import BaseWidget\n+        from plone.app.z3cform.widgets.patterns import InputWidget\n \n         widget = BaseWidget(self.request)\n         widget.field = self.field\n@@ -122,8 +122,8 @@ def test_widget_base_notimplemented(self):\n         )\n \n     def test_widget_base_custom_css(self):\n-        from plone.app.widgets.base import InputWidget\n-        from plone.app.z3cform.widget import BaseWidget\n+        from plone.app.z3cform.widgets.base import BaseWidget\n+        from plone.app.z3cform.widgets.patterns import InputWidget\n \n         widget = BaseWidget(self.request)\n         widget.field = self.field\n@@ -137,8 +137,8 @@ def test_widget_base_custom_css(self):\n         )\n \n     def test_widget_base_pattern_options_with_functions(self):\n-        from plone.app.widgets.base import InputWidget\n-        from plone.app.z3cform.widget import BaseWidget\n+        from plone.app.z3cform.widgets.base import BaseWidget\n+        from plone.app.z3cform.widgets.patterns import InputWidget\n \n         widget = BaseWidget(self.request)\n         widget.context = "testcontext"\n@@ -183,7 +183,7 @@ def test_widget_base_pattern_options_with_functions(self):\n \n class DateWidgetTests(unittest.TestCase):\n     def setUp(self):\n-        from plone.app.z3cform.widget import DateWidget\n+        from plone.app.z3cform.widgets.datetime import DateWidget\n \n         self.request = TestRequest(environ={"HTTP_ACCEPT_LANGUAGE": "en"})\n         self.field = Date(__name__="datefield")\n@@ -217,7 +217,7 @@ def test_widget_required(self):\n         self.assertEqual(base_args["pattern_options"]["clear"], False)\n \n     def test_data_converter(self):\n-        from plone.app.z3cform.widget import DateWidgetConverter\n+        from plone.app.z3cform.widgets.datetime import DateWidgetConverter\n \n         converter = DateWidgetConverter(self.field, self.widget)\n \n@@ -252,8 +252,8 @@ def test_data_converter(self):\n         )\n \n     def test_fieldwidget(self):\n-        from plone.app.z3cform.widget import DateFieldWidget\n-        from plone.app.z3cform.widget import DateWidget\n+        from plone.app.z3cform.widgets.datetime import DateFieldWidget\n+        from plone.app.z3cform.widgets.datetime import DateWidget\n \n         field = Mock(__name__="field", title="", required=True)\n         request = Mock()\n@@ -286,7 +286,7 @@ def test_dateformatter(self):\n \n class DatetimeWidgetTests(unittest.TestCase):\n     def setUp(self):\n-        from plone.app.z3cform.widget import DatetimeWidget\n+        from plone.app.z3cform.widgets.datetime import DatetimeWidget\n \n         self.request = TestRequest(environ={"HTTP_ACCEPT_LANGUAGE": "en"})\n         self.field = Datetime(__name__="datetimefield")\n@@ -324,7 +324,7 @@ def test_widget_required(self):\n         self.assertEqual(base_args["pattern_options"]["clear"], False)\n \n     def test_data_converter(self):\n-        from plone.app.z3cform.widget import DatetimeWidgetConverter\n+        from plone.app.z3cform.widgets.datetime import DatetimeWidgetConverter\n \n         converter = DatetimeWidgetConverter(self.field, self.widget)\n \n@@ -360,7 +360,7 @@ def test_data_converter(self):\n \n     def test_data_converter__no_timezone(self):\n         """When no timezone is set, don\'t apply one."""\n-        from plone.app.z3cform.widget import DatetimeWidgetConverter\n+        from plone.app.z3cform.widgets.datetime import DatetimeWidgetConverter\n \n         context = Mock()\n \n@@ -381,7 +381,7 @@ def test_data_converter__no_timezone(self):\n \n     def test_data_converter__timezone_id(self):\n         """When a (pytz) timezone id is set, use that."""\n-        from plone.app.z3cform.widget import DatetimeWidgetConverter\n+        from plone.app.z3cform.widgets.datetime import DatetimeWidgetConverter\n \n         context = Mock()\n \n@@ -405,7 +405,7 @@ def test_data_converter__timezone_callback(self):\n         """When a timezone callback is set, returning a (pytz) timezone id,\n         use that.\n         """\n-        from plone.app.z3cform.widget import DatetimeWidgetConverter\n+        from plone.app.z3cform.widgets.datetime import DatetimeWidgetConverter\n \n         context = Mock()\n \n@@ -426,8 +426,8 @@ def test_data_converter__timezone_callback(self):\n         self.widget.default_timezone = None\n \n     def test_fieldwidget(self):\n-        from plone.app.z3cform.widget import DatetimeFieldWidget\n-        from plone.app.z3cform.widget import DatetimeWidget\n+        from plone.app.z3cform.widgets.datetime import DatetimeFieldWidget\n+        from plone.app.z3cform.widgets.datetime import DatetimeWidget\n \n         field = Mock(__name__="field", title="", required=True)\n         request = Mock()\n@@ -462,7 +462,7 @@ def test_datetimeformatter(self):\n \n class TimeWidgetTests(unittest.TestCase):\n     def setUp(self):\n-        from plone.app.z3cform.widget import TimeWidget\n+        from plone.app.z3cform.widgets.datetime import TimeWidget\n \n         self.request = TestRequest(environ={"HTTP_ACCEPT_LANGUAGE": "en"})\n         self.field = Time(__name__="timefield")\n@@ -499,8 +499,8 @@ def test_data_converter(self):\n         )\n \n     def test_fieldwidget(self):\n-        from plone.app.z3cform.widget import TimeFieldWidget\n-        from plone.app.z3cform.widget import TimeWidget\n+        from plone.app.z3cform.widgets.datetime import TimeFieldWidget\n+        from plone.app.z3cform.widgets.datetime import TimeWidget\n \n         field = Mock(__name__="field", title="", required=True)\n         request = Mock()\n@@ -532,7 +532,7 @@ def tearDown(self):\n         base.unregisterAdapter(term.CollectionTermsSource)\n \n     def test_widget(self):\n-        from plone.app.z3cform.widget import SelectWidget\n+        from plone.app.z3cform.widgets.select import SelectWidget\n \n         widget = SelectWidget(self.request)\n         widget.id = "test-widget"\n@@ -630,7 +630,7 @@ def test_widget(self):\n         )\n \n     def test_widget_list_orderable(self):\n-        from plone.app.z3cform.widget import SelectWidget\n+        from plone.app.z3cform.widgets.select import SelectWidget\n \n         widget = SelectWidget(self.request)\n         widget.id = "test-widget"\n@@ -657,7 +657,7 @@ def test_widget_list_orderable(self):\n         )\n \n     def test_widget_tuple_orderable(self):\n-        from plone.app.z3cform.widget import SelectWidget\n+        from plone.app.z3cform.widgets.select import SelectWidget\n \n         widget = SelectWidget(self.request)\n         widget.id = "test-widget"\n@@ -683,7 +683,7 @@ def test_widget_tuple_orderable(self):\n         )\n \n     def test_widget_set_not_orderable(self):\n-        from plone.app.z3cform.widget import SelectWidget\n+        from plone.app.z3cform.widgets.select import SelectWidget\n \n         widget = SelectWidget(self.request)\n         widget.id = "test-widget"\n@@ -710,7 +710,7 @@ def test_widget_set_not_orderable(self):\n         )\n \n     def test_widget_extract(self):\n-        from plone.app.z3cform.widget import SelectWidget\n+        from plone.app.z3cform.widgets.select import SelectWidget\n \n         widget = SelectWidget(self.request)\n         widget.field = Choice(\n@@ -726,7 +726,7 @@ def test_widget_extract(self):\n \n     def test_data_converter_list(self):\n         from plone.app.z3cform.converters import SelectWidgetConverter\n-        from plone.app.z3cform.widget import SelectWidget\n+        from plone.app.z3cform.widgets.select import SelectWidget\n \n         field = List(\n             __name__="listfield",\n@@ -773,7 +773,7 @@ def test_data_converter_list(self):\n \n     def test_data_converter_tuple(self):\n         from plone.app.z3cform.converters import SelectWidgetConverter\n-        from plone.app.z3cform.widget import SelectWidget\n+        from plone.app.z3cform.widgets.select import SelectWidget\n \n         field = Tuple(\n             __name__="tuplefield",\n@@ -809,7 +809,7 @@ def test_data_converter_tuple(self):\n \n     def test_data_converter_handles_empty_value(self):\n         from plone.app.z3cform.converters import SelectWidgetConverter\n-        from plone.app.z3cform.widget import SelectWidget\n+        from plone.app.z3cform.widgets.select import SelectWidget\n \n         field = Tuple(\n             __name__="tuplefield",\n@@ -829,7 +829,7 @@ def test_widget_optgroup(self):\n         """\n         If the widget vocabulary is a mapping <optgroup>\'s are rendered.\n         """\n-        from plone.app.z3cform.widget import SelectWidget\n+        from plone.app.z3cform.widgets.select import SelectWidget\n         from z3c.form import term\n \n         widget = SelectWidget(self.request)\n@@ -885,7 +885,7 @@ def setUp(self):\n         provideUtility(example_vocabulary_factory, name="example")\n \n     def test_widget(self):\n-        from plone.app.z3cform.widget import AjaxSelectWidget\n+        from plone.app.z3cform.widgets.select import AjaxSelectWidget\n \n         widget = AjaxSelectWidget(self.request)\n         widget.update()\n@@ -932,7 +932,7 @@ def test_widget(self):\n         )\n \n     def test_widget_list_orderable(self):\n-        from plone.app.z3cform.widget import AjaxSelectWidget\n+        from plone.app.z3cform.widgets.select import AjaxSelectWidget\n \n         widget = AjaxSelectWidget(self.request)\n         widget.field = List(__name__="selectfield")\n@@ -947,7 +947,7 @@ def test_widget_list_orderable(self):\n         )\n \n     def test_widget_tuple_orderable(self):\n-        from plone.app.z3cform.widget import AjaxSelectWidget\n+        from plone.app.z3cform.widgets.select import AjaxSelectWidget\n \n         widget = AjaxSelectWidget(self.request)\n         widget.field = Tuple(__name__="selectfield")\n@@ -962,7 +962,7 @@ def test_widget_tuple_orderable(self):\n         )\n \n     def test_widget_set_not_orderable(self):\n-        from plone.app.z3cform.widget import AjaxSelectWidget\n+        from plone.app.z3cform.widgets.select import AjaxSelectWidget\n \n         widget = AjaxSelectWidget(self.request)\n         # A set is not orderable\n@@ -978,7 +978,7 @@ def test_widget_set_not_orderable(self):\n         )\n \n     def test_widget_choice(self):\n-        from plone.app.z3cform.widget import AjaxSelectWidget\n+        from plone.app.z3cform.widgets.select import AjaxSelectWidget\n         from zope.schema.interfaces import ISource\n \n         widget = AjaxSelectWidget(self.request)\n@@ -1002,7 +1002,7 @@ def test_widget_choice(self):\n         )\n \n     def test_widget_addform_url_on_addform(self):\n-        from plone.app.z3cform.widget import AjaxSelectWidget\n+        from plone.app.z3cform.widgets.select import AjaxSelectWidget\n \n         widget = AjaxSelectWidget(self.request)\n         form = Mock(parentForm=None)\n@@ -1037,7 +1037,7 @@ def test_widget_addform_url_on_addform(self):\n \n     def test_data_converter_list(self):\n         from plone.app.z3cform.converters import AjaxSelectWidgetConverter\n-        from plone.app.z3cform.widget import AjaxSelectWidget\n+        from plone.app.z3cform.widgets.select import AjaxSelectWidget\n \n         field = List(__name__="listfield", value_type=TextLine())\n         widget = AjaxSelectWidget(self.request)\n@@ -1066,7 +1066,7 @@ def test_data_converter_list(self):\n \n     def test_data_converter_collection_with_vocabulary(self):\n         from plone.app.z3cform.converters import AjaxSelectWidgetConverter\n-        from plone.app.z3cform.widget import AjaxSelectWidget\n+        from plone.app.z3cform.widgets.select import AjaxSelectWidget\n \n         field = Tuple(\n             __name__="listfield",\n@@ -1100,7 +1100,7 @@ def test_data_converter_collection_with_vocabulary(self):\n \n     def test_data_converter_tuple(self):\n         from plone.app.z3cform.converters import AjaxSelectWidgetConverter\n-        from plone.app.z3cform.widget import AjaxSelectWidget\n+        from plone.app.z3cform.widgets.select import AjaxSelectWidget\n \n         field = Tuple(__name__="tuplefield", value_type=TextLine())\n         widget = AjaxSelectWidget(self.request)\n@@ -1128,8 +1128,8 @@ def test_data_converter_tuple(self):\n         )\n \n     def test_fieldwidget(self):\n-        from plone.app.z3cform.widget import AjaxSelectFieldWidget\n-        from plone.app.z3cform.widget import AjaxSelectWidget\n+        from plone.app.z3cform.widgets.select import AjaxSelectFieldWidget\n+        from plone.app.z3cform.widgets.select import AjaxSelectWidget\n \n         field = Mock(__name__="field", title="", required=True)\n         request = Mock()\n@@ -1139,8 +1139,8 @@ def test_fieldwidget(self):\n         self.assertIs(widget.request, request)\n \n     def test_fieldwidget_sequence(self):\n-        from plone.app.z3cform.widget import AjaxSelectFieldWidget\n-        from plone.app.z3cform.widget import AjaxSelectWidget\n+        from plone.app.z3cform.widgets.select import AjaxSelectFieldWidget\n+        from plone.app.z3cform.widgets.select import AjaxSelectWidget\n \n         field = Mock(__name__="field", title="", required=True)\n         vocabulary = Mock()\n@@ -1158,7 +1158,7 @@ def setUp(self):\n         self.request = TestRequest(environ={"HTTP_ACCEPT_LANGUAGE": "en"})\n \n     def test_keywords_can_add(self):\n-        from plone.app.z3cform.widget import AjaxSelectWidget\n+        from plone.app.z3cform.widgets.select import AjaxSelectWidget\n \n         portal = self.layer["portal"]\n         setRoles(portal, TEST_USER_ID, ["Manager"])\n@@ -1171,7 +1171,7 @@ def test_keywords_can_add(self):\n         )\n \n     def test_keywords_cannot_add(self):\n-        from plone.app.z3cform.widget import AjaxSelectWidget\n+        from plone.app.z3cform.widgets.select import AjaxSelectWidget\n \n         portal = self.layer["portal"]\n         widget = AjaxSelectWidget(self.request)\n@@ -1183,6 +1183,17 @@ def test_keywords_cannot_add(self):\n         )\n \n \n+def mock_querystring_options(context, querystring_view):\n+    return {\n+        "indexOptionsUrl": f"/{querystring_view}",\n+        "previewURL": "/@@querybuilder_html_results",\n+        "previewCountURL": "/@@querybuildernumberofresults",\n+        "patternDateOptions": None,\n+        "patternAjaxSelectOptions": {"separator": ";"},\n+        "patternRelateditemsOptions": None,\n+    }\n+\n+\n class QueryStringWidgetTests(unittest.TestCase):\n     def setUp(self):\n         self.request = TestRequest(environ={"HTTP_ACCEPT_LANGUAGE": "en"})\n@@ -1202,15 +1213,11 @@ def test_converter_empty_value(self):\n         self.assertEqual(converter.toFieldValue("[]"), None)\n \n     @mock.patch(\n-        "plone.app.widgets.utils.get_date_options",\n-        new=lambda *args, **kwargs: None,\n-    )\n-    @mock.patch(\n-        "plone.app.widgets.utils.get_relateditems_options",\n-        new=lambda *args, **kwargs: None,\n+        "plone.app.z3cform.widgets.querystring.get_querystring_options",\n+        new=mock_querystring_options,\n     )\n     def test_widget(self):\n-        from plone.app.z3cform.widget import QueryStringWidget\n+        from plone.app.z3cform.widgets.querystring import QueryStringWidget\n \n         widget = QueryStringWidget(self.request)\n         self.assertEqual(\n@@ -1249,7 +1256,7 @@ def assertDictContainsSubsetReplacement(self, actual, expected):\n         return set(expected.items()).issubset(set(actual.items()))\n \n     def test_related_items_widget(self):\n-        from plone.app.z3cform.widget import RelatedItemsWidget\n+        from plone.app.z3cform.widgets.relateditems import RelatedItemsWidget\n \n         EXPECTED_ROOT_PATH = "/plone"\n         EXPECTED_ROOT_URL = "http://nohost/plone"\n@@ -1281,7 +1288,7 @@ def test_related_items_widget(self):\n \n     def test_related_items_widget_nav_root(self):\n         from plone.app.layout.navigation.interfaces import INavigationRoot\n-        from plone.app.z3cform.widget import RelatedItemsWidget\n+        from plone.app.z3cform.widgets.relateditems import RelatedItemsWidget\n \n         EXPECTED_ROOT_PATH = "/plone"\n         EXPECTED_ROOT_URL = "http://nohost/plone"\n@@ -1405,13 +1412,13 @@ def setUp(self):\n         self.request = TestRequest(environ={"HTTP_ACCEPT_LANGUAGE": "en"})\n \n     @mock.patch(\n-        "plone.app.widgets.utils.getToolByName",\n+        "Products.CMFCore.utils.getToolByName",\n         new=Mock(return_value=Mock(return_value="testuser")),\n     )\n     def test_single_selection(self):\n         """The pattern_options value for maximumSelectionSize should\n         be 1 when the field only allows a single selection."""\n-        from plone.app.z3cform.widget import RelatedItemsFieldWidget\n+        from plone.app.z3cform.widgets.relateditems import RelatedItemsFieldWidget\n \n         context = Mock(\n             absolute_url=lambda: "fake_url", getPhysicalPath=lambda: ["", "site"]\n@@ -1428,13 +1435,13 @@ def test_single_selection(self):\n         self.assertEqual(pattern_options.get("maximumSelectionSize", 0), 1)\n \n     @mock.patch(\n-        "plone.app.widgets.utils.getToolByName",\n+        "Products.CMFCore.utils.getToolByName",\n         new=Mock(return_value=Mock(return_value="testuser")),\n     )\n     def test_multiple_selection(self):\n         """The pattern_options key maximumSelectionSize shouldn\'t be\n         set when the field allows multiple selections"""\n-        from plone.app.z3cform.widget import RelatedItemsFieldWidget\n+        from plone.app.z3cform.widgets.relateditems import RelatedItemsFieldWidget\n         from zope.schema.interfaces import ISource\n         from zope.schema.vocabulary import VocabularyRegistry\n \n@@ -1562,8 +1569,8 @@ def test_converter_List_of_Choice(self):\n             )\n \n     def test_fieldwidget(self):\n-        from plone.app.z3cform.widget import RelatedItemsFieldWidget\n-        from plone.app.z3cform.widget import RelatedItemsWidget\n+        from plone.app.z3cform.widgets.relateditems import RelatedItemsFieldWidget\n+        from plone.app.z3cform.widgets.relateditems import RelatedItemsWidget\n \n         field = Mock(__name__="field", title="", required=True)\n         vocabulary = Mock()\n@@ -1579,13 +1586,13 @@ def add_mock_fti(portal):\n     fti = DexterityFTI("dx_mock")\n     portal.portal_types._setObject("dx_mock", fti)\n     fti.klass = "plone.dexterity.content.Item"\n-    fti.schema = "plone.app.widgets.tests.test_dx.IMockSchema"\n+    fti.schema = "plone.dexterity.tests.schemata.ITestSchema"\n     fti.filter_content_types = False\n     fti.behaviors = ("plone.app.dexterity.behaviors.metadata.IBasic",)\n \n \n def _custom_field_widget(field, request):\n-    from plone.app.z3cform.widget import AjaxSelectWidget\n+    from plone.app.z3cform.widgets.select import AjaxSelectWidget\n \n     widget = FieldWidget(field, AjaxSelectWidget(request))\n     widget.vocabulary = "plone.app.vocabularies.PortalTypes"\n@@ -1611,7 +1618,7 @@ class IWithText(Interface):\n         self.field = IWithText["text"]\n \n     def test_widget_params(self):\n-        from plone.app.z3cform.widget import RichTextWidget\n+        from plone.app.z3cform.widgets.richtext import RichTextWidget\n \n         widget = FieldWidget(self.field, RichTextWidget(self.request))\n         # set the context so we can get tinymce settings\n@@ -1633,7 +1640,7 @@ def test_widget_params(self):\n         )\n \n     def test_widget_params_different_contexts(self):\n-        from plone.app.z3cform.widget import RichTextWidget\n+        from plone.app.z3cform.widgets.richtext import RichTextWidget\n \n         setRoles(self.portal, TEST_USER_ID, ["Contributor"])\n \n@@ -1684,7 +1691,7 @@ def test_widget_params_different_contexts(self):\n \n     def test_widget_values(self):\n         from plone.app.textfield.value import RichTextValue\n-        from plone.app.z3cform.widget import RichTextWidget\n+        from plone.app.z3cform.widgets.richtext import RichTextWidget\n \n         widget = FieldWidget(self.field, RichTextWidget(self.request))\n         # set the context so we can get tinymce settings\n@@ -1711,7 +1718,7 @@ def test_dx_tinymcewidget_single_mimetype(self):\n         if IMarkupSchema:\n             # if not, don\'t run this test\n             self._set_mimetypes(allowed=("text/html",))\n-            from plone.app.z3cform.widget import RichTextWidget\n+            from plone.app.z3cform.widgets.richtext import RichTextWidget\n \n             widget = FieldWidget(self.field, RichTextWidget(self.request))\n             # set the context so we can get tinymce settings\n@@ -1730,7 +1737,7 @@ def test_dx_tinymcewidget_multiple_mimetypes_create(self):\n         if IMarkupSchema:\n             # if not, don\'t run this test\n             self._set_mimetypes(allowed=("text/html", "text/plain"))\n-            from plone.app.z3cform.widget import RichTextWidget\n+            from plone.app.z3cform.widgets.richtext import RichTextWidget\n \n             widget = FieldWidget(self.field, RichTextWidget(self.request))\n             # set the context so we can get tinymce settings\n@@ -1754,7 +1761,7 @@ def test_dx_tinymcewidget_multiple_mimetypes_edit(self):\n             # if not, don\'t run this test\n             self._set_mimetypes(allowed=("text/html", "text/plain"))\n             from plone.app.textfield.value import RichTextValue\n-            from plone.app.z3cform.widget import RichTextWidget\n+            from plone.app.z3cform.widgets.richtext import RichTextWidget\n \n             widget = FieldWidget(self.field, RichTextWidget(self.request))\n             # set the context so we can get tinymce settings\n@@ -1781,7 +1788,7 @@ def test_use_default_editor_value(self):\n             proxy = registry.forInterface(IEditingSchema, check=False, prefix="plone")\n             proxy.available_editors = ["dummy", "TinyMCE"]\n             proxy.default_editor = "dummy"\n-            from plone.app.z3cform.widget import RichTextWidget\n+            from plone.app.z3cform.widgets.richtext import RichTextWidget\n \n             widget = FieldWidget(self.field, RichTextWidget(self.request))\n             widget.context = self.portal\n@@ -1789,7 +1796,7 @@ def test_use_default_editor_value(self):\n             self.assertTrue("<p>dummy</p>" in rendered)\n \n             proxy.default_editor = "TinyMCE"\n-            from plone.app.z3cform.widget import RichTextWidget\n+            from plone.app.z3cform.widgets.richtext import RichTextWidget\n \n             widget = FieldWidget(self.field, RichTextWidget(self.request))\n             widget.context = self.portal\n@@ -1807,7 +1814,7 @@ def setUp(self):\n         setRoles(self.portal, TEST_USER_ID, ["Manager"])\n \n     def test_link_widget__pattern_options(self):\n-        from plone.app.z3cform.widget import LinkWidget\n+        from plone.app.z3cform.widgets.link import LinkWidget\n \n         widget = LinkWidget(self.request)\n \n@@ -1819,7 +1826,7 @@ def test_link_widget__pattern_options(self):\n         self.assertEqual(pattern_data["maximumSelectionSize"], 1)\n \n     def test_link_widget__extract_internal(self):\n-        from plone.app.z3cform.widget import LinkWidget\n+        from plone.app.z3cform.widgets.link import LinkWidget\n \n         widget = LinkWidget(self.request)\n         widget.context = self.portal\n@@ -1833,7 +1840,7 @@ def test_link_widget__extract_internal(self):\n         )\n \n     def test_link_widget__extract_external(self):\n-        from plone.app.z3cform.widget import LinkWidget\n+        from plone.app.z3cform.widgets.link import LinkWidget\n \n         widget = LinkWidget(self.request)\n         widget.context = self.portal\n@@ -1847,7 +1854,7 @@ def test_link_widget__extract_external(self):\n         )\n \n     def test_link_widget__extract_email(self):\n-        from plone.app.z3cform.widget import LinkWidget\n+        from plone.app.z3cform.widgets.link import LinkWidget\n \n         widget = LinkWidget(self.request)\n         widget.context = self.portal\n@@ -1861,7 +1868,7 @@ def test_link_widget__extract_email(self):\n         )\n \n     def test_link_widget__extract_email_including_mailto(self):\n-        from plone.app.z3cform.widget import LinkWidget\n+        from plone.app.z3cform.widgets.link import LinkWidget\n \n         widget = LinkWidget(self.request)\n         widget.context = self.portal\n@@ -1876,7 +1883,7 @@ def test_link_widget__extract_email_including_mailto(self):\n \n     def test_link_widget__data_converter(self):\n         from plone.app.z3cform.converters import LinkWidgetDataConverter\n-        from plone.app.z3cform.widget import LinkWidget\n+        from plone.app.z3cform.widgets.link import LinkWidget\n \n         field = TextLine(__name__="linkfield")\n         widget = LinkWidget(self.request)\ndiff --git a/plone/app/z3cform/utils.py b/plone/app/z3cform/utils.py\nindex bf2bed63..ecc7a4f2 100644\n--- a/plone/app/z3cform/utils.py\n+++ b/plone/app/z3cform/utils.py\n@@ -1,6 +1,11 @@\n from Acquisition import aq_base\n+from copy import deepcopy\n+from plone.app.layout.navigation.root import getNavigationRootObject\n from Products.CMFCore.interfaces import IContentish\n from Products.CMFCore.interfaces import IFolderish\n+from Products.CMFCore.interfaces import ISiteRoot\n+from z3c.form.interfaces import IForm\n+from zope.component import providedBy\n from zope.component.hooks import getSite\n from zope.globalrequest import getRequest\n \n@@ -104,3 +109,75 @@ def is_same_domain(url1, url2):\n     purl1 = urllib.parse.urlparse(url1)\n     purl2 = urllib.parse.urlparse(url2)\n     return purl1.scheme == purl2.scheme and purl1.netloc == purl2.netloc\n+\n+\n+def dict_merge(dict_a, dict_b):\n+    """Helper method which merges two dictionaries.\n+\n+    Recursively merges dict\'s. not just simple a[\'key\'] = b[\'key\'], if\n+    both a and b have a key who\'s value is a dict then dict_merge is called\n+    on both values and the result stored in the returned dictionary.\n+\n+    http://www.xormedia.com/recursively-merge-dictionaries-in-python\n+\n+    :param dict_a: [required] First dictiornary.\n+    :type dict_a: dict\n+\n+    :param dict_b: [required] Second dictiornary.\n+    :type dict_b: dict\n+\n+    :returns: Merged dictionary.\n+    :rtype: dict\n+    """\n+\n+    if not isinstance(dict_b, dict):\n+        return dict_b\n+    result = deepcopy(dict_a)\n+    for k, v in dict_b.items():\n+        if k in result and isinstance(result[k], dict):\n+            result[k] = dict_merge(result[k], v)\n+        else:\n+            result[k] = deepcopy(v)\n+    return result\n+\n+\n+def get_widget_form(widget):\n+    form = getattr(widget, "form", None)\n+    if getattr(aq_base(form), "parentForm", None) is not None:\n+        form = form.parentForm\n+    return form\n+\n+\n+def get_portal():\n+    closest_site = getSite()\n+    if closest_site is not None:\n+        for potential_portal in closest_site.aq_chain:\n+            if ISiteRoot in providedBy(potential_portal):\n+                return potential_portal\n+\n+\n+def get_portal_url(context):\n+    portal = get_portal()\n+    if portal:\n+        root = getNavigationRootObject(context, portal)\n+        if root:\n+            try:\n+                return root.absolute_url()\n+            except AttributeError:\n+                return portal.absolute_url()\n+        else:\n+            return portal.absolute_url()\n+    return ""\n+\n+\n+def get_context_url(context):\n+    if IForm.providedBy(context):\n+        # Use the request URL if we are looking at an addform\n+        url = context.request.get("URL")\n+    elif hasattr(context, "absolute_url"):\n+        url = context.absolute_url\n+        if callable(url):\n+            url = url()\n+    else:\n+        url = get_portal_url(context)\n+    return url\ndiff --git a/plone/app/z3cform/widget.py b/plone/app/z3cform/widget.py\nindex 28d15706..0022bac8 100644\n--- a/plone/app/z3cform/widget.py\n+++ b/plone/app/z3cform/widget.py\n@@ -1,993 +1,62 @@\n-from Acquisition import aq_base\n-from Acquisition import ImplicitAcquisitionWrapper\n-from collections import UserDict\n-from lxml import etree\n-from OFS.interfaces import ISimpleItem\n-from plone.app.contentlisting.interfaces import IContentListing\n-from plone.app.textfield.value import RichTextValue\n-from plone.app.textfield.widget import RichTextWidget as patext_RichTextWidget\n-from plone.app.vocabularies.terms import TermWithDescription\n-from plone.app.widgets.base import dict_merge\n-from plone.app.widgets.base import InputWidget\n-from plone.app.widgets.base import SelectWidget as BaseSelectWidget\n-from plone.app.widgets.base import TextareaWidget\n-from plone.app.widgets.utils import get_context_url\n-from plone.app.widgets.utils import get_date_options\n-from plone.app.widgets.utils import get_querystring_options\n-from plone.app.widgets.utils import get_relateditems_options\n-from plone.app.widgets.utils import get_tinymce_options\n-from plone.app.widgets.utils import get_widget_form\n-from plone.app.widgets.utils import NotImplemented as PatternNotImplemented\n-from plone.app.z3cform.converters import DatetimeWidgetConverter\n-from plone.app.z3cform.converters import DateWidgetConverter\n-from plone.app.z3cform.interfaces import IAjaxSelectWidget\n-from plone.app.z3cform.interfaces import IDatetimeWidget\n-from plone.app.z3cform.interfaces import IDateWidget\n-from plone.app.z3cform.interfaces import ILinkWidget\n-from plone.app.z3cform.interfaces import IPloneFormLayer\n-from plone.app.z3cform.interfaces import IQueryStringWidget\n-from plone.app.z3cform.interfaces import IRelatedItemsWidget\n-from plone.app.z3cform.interfaces import IRichTextWidget\n-from plone.app.z3cform.interfaces import IRichTextWidgetInputModeRenderer\n-from plone.app.z3cform.interfaces import ISelectWidget\n-from plone.app.z3cform.interfaces import ISingleCheckBoxBoolWidget\n-from plone.app.z3cform.interfaces import ITimeWidget\n-from plone.app.z3cform.utils import call_callables\n-from plone.app.z3cform.utils import closest_content\n-from plone.base.utils import safe_text\n-from plone.registry.interfaces import IRegistry\n-from Products.CMFCore.utils import getToolByName\n-from z3c.form import interfaces as form_ifaces\n-from z3c.form.browser.checkbox import SingleCheckBoxWidget\n-from z3c.form.browser.select import SelectWidget as z3cform_SelectWidget\n-from z3c.form.browser.text import TextWidget as z3cform_TextWidget\n-from z3c.form.interfaces import IEditForm\n-from z3c.form.interfaces import IFieldWidget\n-from z3c.form.interfaces import IForm\n-from z3c.form.interfaces import NO_VALUE\n-from z3c.form.term import BoolTerms\n-from z3c.form.term import Terms\n-from z3c.form.widget import FieldWidget\n-from z3c.form.widget import Widget\n-from zope.component import adapter\n-from zope.component import getUtility\n-from zope.component import queryUtility\n-from zope.component.hooks import getSite\n-from zope.i18n import translate\n-from zope.interface import implementer\n-from zope.interface import implementer_only\n-from zope.schema import interfaces as schema_ifaces\n-from zope.schema.interfaces import IBool\n-from zope.schema.interfaces import IChoice\n-from zope.schema.interfaces import ICollection\n-from zope.schema.interfaces import ISequence\n-from zope.schema.interfaces import IVocabularyFactory\n-from zope.schema.vocabulary import SimpleTerm\n-from zope.schema.vocabulary import SimpleVocabulary\n-\n-import collections\n-import json\n-\n-\n-class BaseWidget(Widget):\n-    """Base widget for z3c.form."""\n-\n-    pattern = None\n-    pattern_options = {}\n-    _adapterValueAttributes = Widget._adapterValueAttributes + ("pattern_options",)\n-\n-    def _base(self, pattern, pattern_options={}):\n-        """Base widget class."""\n-        raise PatternNotImplemented\n-\n-    def _base_args(self):\n-        """Method which will calculate _base class arguments.\n-\n-        Returns (as python dictionary):\n-            - `pattern`: pattern name\n-            - `pattern_options`: pattern options\n-\n-        :returns: Arguments which will be passed to _base\n-        :rtype: dict\n-        """\n-        if self.pattern is None:\n-            raise PatternNotImplemented("\'pattern\' option is not provided.")\n-        return {\n-            "pattern": self.pattern,\n-            "pattern_options": self.pattern_options.copy(),\n-        }\n-\n-    def render(self):\n-        """Render widget.\n-\n-        :returns: Widget\'s HTML.\n-        :rtype: string\n-        """\n-        if self.mode != "input":\n-            return super().render()\n-\n-        _base_args = self._base_args()\n-        _base_args["pattern_options"] = call_callables(\n-            _base_args["pattern_options"],\n-            self.context,\n-        )\n-\n-        pattern_widget = self._base(**_base_args)\n-        if getattr(self, "klass", False):\n-            pattern_widget.klass = "{} {}".format(\n-                pattern_widget.klass,\n-                self.klass,\n-            )\n-        return pattern_widget.render()\n-\n-    def is_subform_widget(self):\n-        return getattr(aq_base(self.form), "parentForm", None) is not None\n-\n-\n-@implementer_only(IDateWidget)\n-class DateWidget(BaseWidget, z3cform_TextWidget):\n-    """Date widget for z3c.form.\n-\n-    :param default_timezone: A Olson DB/pytz timezone identifier or a callback\n-                             returning such an identifier.\n-    :type default_timezone: String or callback\n-\n-    :param default_time: Time used by converter as fallback if no time was set in UI.\n-    :type default_time: String or callback\n-\n-    The default_timezone and default_time arguments are only used if a datewidget is\n-    used on a datetime field. If used on a date field they are ignored.\n-    """\n-\n-    _base_type = "date"\n-    _converter = DateWidgetConverter\n-    _formater = "date"\n-    _formater_length = "short"\n-\n-    default_timezone = None\n-    default_time = "00:00:00"\n-\n-    pattern = "date-picker"\n-    pattern_options = BaseWidget.pattern_options.copy()\n-\n-    def _base(self, **kw):\n-        return InputWidget(\n-            type=self._base_type,\n-            **kw,\n-        )\n-\n-    def _base_args(self):\n-        """Method which will calculate _base class arguments.\n-\n-        Returns (as python dictionary):\n-            - `pattern`: pattern name\n-            - `pattern_options`: pattern options\n-            - `name`: field name\n-            - `value`: field value\n-\n-        :returns: Arguments which will be passed to _base\n-        :rtype: dict\n-        """\n-        args = super()._base_args()\n-        args["name"] = self.name\n-        args["value"] = (self.request.get(self.name, self.value) or "").strip()\n-\n-        args.setdefault("pattern_options", {})\n-        if self.field.required:\n-            # Required fields should not have a "Clear" button\n-            args["pattern_options"]["clear"] = False\n-        args["pattern_options"] = dict_merge(\n-            get_date_options(self.request), args["pattern_options"]\n-        )\n-\n-        return args\n-\n-    def render(self):\n-        """Render widget.\n-\n-        :returns: Widget\'s HTML.\n-        :rtype: string\n-        """\n-        if self.mode != "display":\n-            self.addClass("form-control")\n-            return super().render()\n-\n-        if not self.value:\n-            return ""\n-\n-        field_value = self._converter(self.field, self).toFieldValue(self.value)\n-        if field_value is self.field.missing_value:\n-            return ""\n-\n-        formatter = self.request.locale.dates.getFormatter(\n-            self._formater,\n-            self._formater_length,\n-        )\n-        return formatter.format(field_value)\n-\n-\n-@implementer_only(IDatetimeWidget)\n-class DatetimeWidget(DateWidget):\n-    """Datetime widget for z3c.form.\n-\n-    :param default_timezone: A Olson DB/pytz timezone identifier or a callback\n-                             returning such an identifier.\n-    :type default_timezone: String or callback\n-\n-    :param default_time: Time used by converter as fallback if no time was set in UI.\n-    :type default_time: String or callback\n-    """\n-\n-    _base_type = "datetime-local"\n-    _converter = DatetimeWidgetConverter\n-    _formater = "dateTime"\n-\n-    default_timezone = None\n-    default_time = "00:00:00"\n-\n-    pattern = "datetime-picker"\n-\n-\n-@implementer_only(ITimeWidget)\n-class TimeWidget(BaseWidget, z3cform_TextWidget):\n-    pattern = ""\n-\n-    def _base(self, **kw):\n-        return InputWidget(\n-            type="time",\n-            name=self.name,\n-            value=(self.request.get(self.name, self.value) or "").strip(),\n-            **kw,\n-        )\n-\n-    def render(self):\n-        if self.mode != "display":\n-            self.addClass("form-control")\n-        return super().render()\n-\n-\n-@implementer_only(ISelectWidget)\n-class SelectWidget(BaseWidget, z3cform_SelectWidget):\n-    """Select widget for z3c.form."""\n-\n-    _base = BaseSelectWidget\n-\n-    pattern = "select2"\n-    pattern_options = BaseWidget.pattern_options.copy()\n-\n-    separator = ";"\n-    noValueToken = ""\n-    noValueMessage = ""\n-    multiple = None\n-    orderable = False\n-    required = True\n-\n-    @property\n-    def items(self):\n-        """\n-        Optionally handle ITreeVocabulary vocabs as dicts.\n-        """\n-        terms = self.terms\n-        if form_ifaces.ITerms.providedBy(terms):\n-            terms = terms.terms\n-\n-        if schema_ifaces.ITreeVocabulary.providedBy(terms):\n-            groups = collections.OrderedDict()\n-            for group_term, option_terms in terms.items():\n-                group_widget = type(self)(self.request)\n-                group_widget.terms = option_terms\n-                group_label = group_term.title or group_term.value or group_term.token\n-                groups[group_label] = super(SelectWidget, group_widget).items\n-            return groups\n-        else:\n-            return super().items\n-\n-    def _base_args(self):\n-        """Method which will calculate _base class arguments.\n-\n-        Returns (as python dictionary):\n-            - `pattern`: pattern name\n-            - `pattern_options`: pattern options\n-            - `name`: field name\n-            - `value`: field value\n-            - `multiple`: field multiple\n-            - `items`: field items from which we can select to\n-\n-        :returns: Arguments which will be passed to _base\n-        :rtype: dict\n-        """\n-        args = super()._base_args()\n-        args["name"] = self.name\n-        args["value"] = self.value\n-        args["multiple"] = self.multiple\n-\n-        self.required = self.field.required\n-\n-        options = args.setdefault("pattern_options", {})\n-        if self.multiple or ICollection.providedBy(self.field):\n-            args["multiple"] = self.multiple = True\n-\n-        # ISequence represents an orderable collection\n-        if ISequence.providedBy(self.field) or self.orderable:\n-            options["orderable"] = True\n-\n-        if self.multiple:\n-            options["separator"] = self.separator\n-\n-        # Allow to clear field value if it is not required\n-        if not self.required:\n-            options["allowClear"] = True\n-\n-        base_items = self.items\n-        if callable(base_items):\n-            # items used to be a property in all widgets, then in the select\n-            # widget it became a method, then in a few others too, but never in\n-            # all, so this was reverted to let it be a property again.  Let\'s\n-            # support both here to avoid breaking on some z3c.form versions.\n-            # See https://github.com/zopefoundation/z3c.form/issues/44\n-            base_items = base_items()\n-\n-        def makeItem(item):\n-            """\n-            Gather the information needed by the widget for the given term.\n-            """\n-            if not isinstance(item["content"], str):\n-                item["content"] = translate(\n-                    item["content"], context=self.request, default=item["value"]\n-                )\n-            return (item["value"], item["content"])\n-\n-        if isinstance(base_items, dict):\n-            items = collections.OrderedDict(\n-                (group_label, [makeItem(base_item) for base_item in group_options])\n-                for group_label, group_options in base_items.items()\n-            )\n-        else:\n-            items = [makeItem(item) for item in base_items]\n-        args["items"] = items\n-\n-        return args\n-\n-    def extract(self, default=NO_VALUE):\n-        """Override extract to handle delimited response values.\n-        Skip the vocabulary validation provided in the parent\n-        method, since it\'s not ever done for single selects."""\n-        if (\n-            self.name not in self.request\n-            and self.name + "-empty-marker" in self.request\n-        ):\n-            return []\n-        return self.request.get(self.name, default)\n-\n-\n-@implementer_only(IAjaxSelectWidget)\n-class AjaxSelectWidget(BaseWidget, z3cform_TextWidget):\n-    """Ajax select widget for z3c.form."""\n-\n-    _base = InputWidget\n-\n-    pattern = "select2"\n-    pattern_options = BaseWidget.pattern_options.copy()\n-\n-    separator = ";"\n-    vocabulary = None\n-    vocabulary_view = "@@getVocabulary"\n-    orderable = False\n-\n-    def _view_context(self):\n-        view_context = get_widget_form(self)\n-        # For EditForms and non-Forms (in tests), the vocabulary is looked\n-        # up on the context, otherwise on the view\n-        if IEditForm.providedBy(view_context):\n-            if self.is_subform_widget():\n-                view_context = self.form.parentForm.context\n-            elif not ISimpleItem.providedBy(self.context):\n-                view_context = self.form.context\n-            else:\n-                view_context = self.context\n-        elif not IForm.providedBy(view_context):\n-            view_context = self.context\n-        return view_context\n-\n-    def get_vocabulary(self):\n-        if self.vocabulary and isinstance(self.vocabulary, str):\n-            factory = queryUtility(\n-                IVocabularyFactory,\n-                self.vocabulary,\n-            )\n-            if factory:\n-                return factory(self._view_context())\n-        return self.vocabulary\n-\n-    def display_items(self):\n-        if self.value:\n-            tokens = self.value.split(self.separator)\n-            vocabulary = self.get_vocabulary()\n-            for token in tokens:\n-                item = {"token": token, "title": token}\n-                if vocabulary is not None:\n-                    try:\n-                        item["title"] = vocabulary.getTermByToken(token).title\n-                    except LookupError:\n-                        pass\n-                yield item\n-\n-    def has_multiple_values(self):\n-        return self.value and self.value.split(self.separator)\n-\n-    def _ajaxselect_options(self):\n-        options = {\n-            "separator": self.separator,\n-        }\n-        if self.vocabulary:\n-            options["vocabularyUrl"] = "{}/{}?name={}".format(\n-                get_context_url(self._view_context()),\n-                self.vocabulary_view,\n-                self.vocabulary,\n-            )\n-            field_name = self.field and self.field.__name__ or None\n-            if field_name:\n-                options["vocabularyUrl"] += f"&field={field_name}"\n-            vocabulary = self.get_vocabulary()\n-            if vocabulary is not None and self.value:\n-                options["initialValues"] = dict()\n-                for token in self.value.split(self.separator):\n-                    try:\n-                        term = vocabulary.getTermByToken(token)\n-                        options["initialValues"][term.token] = term.title\n-                    except LookupError:\n-                        options["initialValues"][token] = token\n-\n-        return options\n-\n-    def update(self):\n-        super().update()\n-        field = getattr(self, "field", None)\n-        field = getattr(field, "value_type", field)\n-        if (\n-            not self.vocabulary\n-            and field is not None\n-            and getattr(field, "vocabularyName", None)\n-        ):\n-            self.vocabulary = field.vocabularyName\n-\n-    def _base_args(self):\n-        """Method which will calculate _base class arguments.\n-\n-        Returns (as python dictionary):\n-            - `pattern`: pattern name\n-            - `pattern_options`: pattern options\n-            - `name`: field name\n-            - `value`: field value\n-\n-        :returns: Arguments which will be passed to _base\n-        :rtype: dict\n-        """\n-        args = super()._base_args()\n-        args["name"] = self.name\n-        args["value"] = self.value\n-        args.setdefault("pattern_options", {})\n-        context = self.context\n-        field = None\n-\n-        if IChoice.providedBy(self.field):\n-            args["pattern_options"]["maximumSelectionSize"] = 1\n-            field = self.field\n-        elif ICollection.providedBy(self.field):\n-            field = self.field.value_type\n-        if IChoice.providedBy(field):\n-            args["pattern_options"]["allowNewItems"] = "false"\n-\n-        args["pattern_options"] = dict_merge(\n-            self._ajaxselect_options(), args["pattern_options"]\n-        )\n-\n-        if field and getattr(field, "vocabulary", None):\n-            form_url = self.request.getURL()\n-            source_url = "{:s}/++widget++{:s}/@@getSource".format(\n-                form_url,\n-                self.name,\n-            )\n-            args["pattern_options"]["vocabularyUrl"] = source_url\n-\n-        # ISequence represents an orderable collection\n-        if ISequence.providedBy(self.field) or self.orderable:\n-            args["pattern_options"]["orderable"] = True\n-\n-        if self.vocabulary == "plone.app.vocabularies.Keywords":\n-            membership = getToolByName(context, "portal_membership")\n-            user = membership.getAuthenticatedMember()\n-\n-            registry = getUtility(IRegistry)\n-            roles_allowed_to_add_keywords = registry.get(\n-                "plone.roles_allowed_to_add_keywords", set()\n-            )\n-            roles = set(user.getRolesInContext(context))\n-            allowNewItems = bool(\n-                roles.intersection(roles_allowed_to_add_keywords),\n-            )\n-            args["pattern_options"]["allowNewItems"] = str(\n-                allowNewItems,\n-            ).lower()\n-\n-        return args\n-\n-\n-@implementer_only(IRelatedItemsWidget)\n-class RelatedItemsWidget(BaseWidget, z3cform_TextWidget):\n-    """RelatedItems widget for z3c.form."""\n-\n-    _base = InputWidget\n-\n-    pattern = "relateditems"\n-    pattern_options = BaseWidget.pattern_options.copy()\n-\n-    separator = ";"\n-    vocabulary = None\n-    vocabulary_override = False\n-    vocabulary_view = "@@getVocabulary"\n-    orderable = False\n-\n-    def update(self):\n-        super().update()\n-        field = getattr(self, "field", None)\n-        if ICollection.providedBy(self.field):\n-            field = self.field.value_type\n-        if (\n-            not self.vocabulary\n-            and field is not None\n-            and getattr(field, "vocabularyName", None)\n-        ):\n-            self.vocabulary = field.vocabularyName\n-            self.vocabulary_override = True\n-        else:\n-            self.vocabulary = "plone.app.vocabularies.Catalog"\n-\n-    def _base_args(self):\n-        """Method which will calculate _base class arguments.\n-\n-        Returns (as python dictionary):\n-            - `pattern`: pattern name\n-            - `pattern_options`: pattern options\n-            - `name`: field name\n-            - `value`: field value\n-\n-        :returns: Arguments which will be passed to _base\n-        :rtype: dict\n-        """\n-        args = super()._base_args()\n-\n-        args["name"] = self.name\n-        args["value"] = self.value\n-        args.setdefault("pattern_options", {})\n-\n-        field = None\n-        if IChoice.providedBy(self.field):\n-            args["pattern_options"]["maximumSelectionSize"] = 1\n-            field = self.field\n-        elif ICollection.providedBy(self.field):\n-            field = self.field.value_type\n-\n-        vocabulary_name = self.vocabulary\n-\n-        field_name = self.field and self.field.__name__ or None\n-\n-        context = self.context\n-        view_context = get_widget_form(self)\n-        # For EditForms and non-Forms (in tests), the vocabulary is looked\n-        # up on the context, otherwise on the view\n-        if IEditForm.providedBy(view_context):\n-            if self.is_subform_widget():\n-                view_context = self.form.parentForm.context\n-            elif not ISimpleItem.providedBy(context):\n-                view_context = self.form.context\n-            else:\n-                view_context = context\n-        elif not IForm.providedBy(view_context):\n-            view_context = context\n-        else:\n-            pass\n-            # view_context is defined above already\n-\n-        root_search_mode = (\n-            args["pattern_options"].get("mode", None)\n-            and "basePath" not in args["pattern_options"]\n-        )\n-\n-        args["pattern_options"] = dict_merge(\n-            get_relateditems_options(\n-                view_context,\n-                args["value"],\n-                self.separator,\n-                vocabulary_name,\n-                self.vocabulary_view,\n-                field_name,\n-            ),\n-            args["pattern_options"],\n-        )\n-        if root_search_mode:\n-            # Delete default basePath option in search mode, when no basePath\n-            # was explicitly set.\n-            del args["pattern_options"]["basePath"]\n-        if (\n-            not self.vocabulary_override\n-            and field\n-            and getattr(field, "vocabulary", None)\n-        ):\n-            # widget vocab takes precedence over field\n-            form_url = self.request.getURL()\n-            source_url = "{:s}/++widget++{:s}/@@getSource".format(\n-                form_url,\n-                self.name,\n-            )\n-            args["pattern_options"]["vocabularyUrl"] = source_url\n-\n-        return args\n-\n-    def items(self):\n-        """Return item for the widget values for the display template\n-\n-        Query the catalog for the widget-value (uuids) to only display items\n-        that the user is allowed to see. Accessing the value with e.g.\n-        getattr(self.context, self.__name__) would yield the items unfiltered.\n-        Uses IContentListing for easy access to MimeTypeIcon and more.\n-        """\n-        results = []\n-        if not self.value:\n-            return results\n-        separator = getattr(self, "separator", ";")\n-        uuids = self.value.split(separator)\n-\n-        try:\n-            catalog = getToolByName(self.context, "portal_catalog")\n-        except AttributeError:\n-            catalog = getToolByName(getSite(), "portal_catalog")\n-\n-        brains = catalog(UID=uuids)\n-        # restore original order\n-        results = sorted(brains, key=lambda brain: uuids.index(brain.UID))\n-        return IContentListing(results)\n-\n-\n-@implementer_only(IQueryStringWidget)\n-class QueryStringWidget(BaseWidget, z3cform_TextWidget):\n-    """QueryString widget for z3c.form."""\n-\n-    _base = InputWidget\n-\n-    pattern = "querystring"\n-    pattern_options = BaseWidget.pattern_options.copy()\n-\n-    querystring_view = "@@qsOptions"\n-\n-    def _base_args(self):\n-        """Method which will calculate _base class arguments.\n-\n-        Returns (as python dictionary):\n-            - `pattern`: pattern name\n-            - `pattern_options`: pattern options\n-            - `name`: field name\n-            - `value`: field value\n-\n-        :returns: Arguments which will be passed to _base\n-        :rtype: dict\n-        """\n-        args = super()._base_args()\n-        args["name"] = self.name\n-        args["value"] = self.value\n-\n-        args.setdefault("pattern_options", {})\n-        args["pattern_options"] = dict_merge(\n-            get_querystring_options(self.context, self.querystring_view),\n-            args["pattern_options"],\n-        )\n-\n-        return args\n-\n-\n-@implementer_only(IRichTextWidget)\n-class RichTextWidget(BaseWidget, patext_RichTextWidget):\n-    """TinyMCE widget for z3c.form."""\n-\n-    _base = TextareaWidget\n-\n-    pattern_options = BaseWidget.pattern_options.copy()\n-\n-    def __init__(self, *args, **kwargs):\n-        super().__init__(*args, **kwargs)\n-        self._pattern = None\n-\n-    def wrapped_context(self):\n-        """ "We need to wrap the context to be able to acquire the root\n-        of the site to get tools, as done in plone.app.textfield"""\n-        context = self.context\n-        content = closest_content(context)\n-        if context.__class__ == dict:\n-            context = UserDict(self.context)\n-        return ImplicitAcquisitionWrapper(context, content)\n-\n-    @property\n-    def pattern(self):\n-        """dynamically grab the actual pattern name so it will\n-        work with custom visual editors"""\n-        if self._pattern is None:\n-            self._pattern = self.getWysiwygEditor()\n-        return self._pattern\n-\n-    def _base_args(self):\n-        args = super()._base_args()\n-        args["name"] = self.name\n-        value = self.value and self.value.raw or ""\n-        value = self.request.get(self.name, value)\n-        args["value"] = value\n-\n-        args.setdefault("pattern_options", {})\n-        merged_options = dict_merge(\n-            get_tinymce_options(\n-                self.wrapped_context(),\n-                self.field,\n-                self.request,\n-            ),\n-            args["pattern_options"],\n-        )\n-        args["pattern_options"] = merged_options\n-\n-        return args\n-\n-    def render(self):\n-        """Render widget.\n-\n-        :returns: Widget\'s HTML.\n-        :rtype: string\n-        """\n-        if self.mode != "display":\n-            renderer = queryUtility(\n-                IRichTextWidgetInputModeRenderer,\n-                name=self.getWysiwygEditor(),\n-                default=tinymce_richtextwidget_render,\n-            )\n-            return renderer(self)\n-\n-        if not self.value:\n-            return ""\n-\n-        if isinstance(self.value, RichTextValue):\n-            return self.value.output_relative_to(self.context)\n-\n-        return super().render()\n-\n-    def render_input_mode(self):\n-        # MODE "INPUT"\n-        rendered = ""\n-        allowed_mime_types = self.allowedMimeTypes()\n-        if not allowed_mime_types or len(allowed_mime_types) <= 1:\n-            # Display textarea with default widget\n-            rendered = super().render()\n-        else:\n-            # Let pat-textarea-mimetype-selector choose the widget\n-\n-            # Initialize the widget without a pattern\n-            base_args = self._base_args()\n-            pattern_options = base_args["pattern_options"]\n-            del base_args["pattern"]\n-            del base_args["pattern_options"]\n-            textarea_widget = self._base(None, None, **base_args)\n-            textarea_widget.klass = "form-control"\n-            mt_pattern_name = "{}{}".format(\n-                self._base._klass_prefix,\n-                "textareamimetypeselector",\n-            )\n-\n-            # Initialize mimetype selector pattern\n-            # TODO: default_mime_type returns \'text/html\', regardless of\n-            # settings. fix in plone.app.textfield\n-            value_mime_type = (\n-                self.value.mimeType if self.value else self.field.default_mime_type\n-            )\n-            mt_select = etree.Element("select")\n-            mt_select.attrib["id"] = f"{self.id}_text_format"\n-            mt_select.attrib["name"] = f"{self.name}.mimeType"\n-            mt_select.attrib["class"] = f"form-select {mt_pattern_name}"\n-            mt_select.attrib[f"data-{mt_pattern_name}"] = json.dumps(\n-                {\n-                    "textareaName": self.name,\n-                    "widgets": {\n-                        "text/html": {  # TODO: currently, we only support\n-                            # richtext widget config for\n-                            # \'text/html\', no other mimetypes.\n-                            "pattern": self.pattern,\n-                            "patternOptions": pattern_options,\n-                        },\n-                    },\n-                },\n-            )\n-\n-            # Create a list of allowed mime types\n-            for mt in allowed_mime_types:\n-                opt = etree.Element("option")\n-                opt.attrib["value"] = mt\n-                if value_mime_type == mt:\n-                    opt.attrib["selected"] = "selected"\n-                opt.text = mt\n-                mt_select.append(opt)\n-\n-            # Render the combined widget\n-            rendered = "{}\\n{}".format(\n-                textarea_widget.render(),\n-                etree.tostring(mt_select, encoding="unicode"),\n-            )\n-        return rendered\n-\n-\n-def tinymce_richtextwidget_render(widget):\n-    return RichTextWidget.render_input_mode(widget)\n-\n-\n-@implementer_only(ILinkWidget)\n-class LinkWidget(z3cform_TextWidget):\n-    """Implementation of enhanced link widget.\n-\n-    .. note::\n-        Unlike the others here, this is not a plone.app.widgets based widget\n-        and it uses it\'s own template.\n-    """\n-\n-    def pattern_data(self):\n-        pattern_data = {\n-            "vocabularyUrl": "{}/@@getVocabulary?name=plone.app.vocabularies.Catalog".format(  # noqa\n-                getSite().absolute_url(0),\n-            ),\n-            "maximumSelectionSize": 1,\n-        }\n-        return json.dumps(pattern_data)\n-\n-    def extract(self, default=NO_VALUE):\n-        form = self.request.form\n-        internal = form.get(self.name + ".internal")\n-        external = form.get(self.name + ".external")\n-        email = form.get(self.name + ".email")\n-        if internal:\n-            url = "${portal_url}/resolveuid/" + internal\n-        elif email:\n-            subject = form.get(self.name + ".subject")\n-            if email[:7] != "mailto:":\n-                email = "mailto:" + email\n-            if not subject:\n-                url = email\n-            else:\n-                url = "{email}?subject={subject}".format(\n-                    email=email,\n-                    subject=subject,\n-                )\n-        else:\n-            url = external  # the default is `http://` so we land here\n-        if url:\n-            self.request.form[self.name] = safe_text(url)\n-        return super().extract(default=default)\n-\n-\n-@implementer(IFieldWidget)\n-def DateFieldWidget(field, request):\n-    return FieldWidget(field, DateWidget(request))\n-\n-\n-@implementer(IFieldWidget)\n-def DatetimeFieldWidget(field, request):\n-    return FieldWidget(field, DatetimeWidget(request))\n-\n-\n-@implementer(IFieldWidget)\n-def TimeFieldWidget(field, request):\n-    return FieldWidget(field, TimeWidget(request))\n-\n-\n-@implementer(IFieldWidget)\n-def SelectFieldWidget(field, request):\n-    return FieldWidget(field, SelectWidget(request))\n-\n-\n-@implementer(IFieldWidget)\n-def AjaxSelectFieldWidget(field, request, extra=None):\n-    if extra is not None:\n-        request = extra\n-    return FieldWidget(field, AjaxSelectWidget(request))\n-\n-\n-@implementer(IFieldWidget)\n-def RelatedItemsFieldWidget(field, request, extra=None):\n-    if extra is not None:\n-        request = extra\n-    return FieldWidget(field, RelatedItemsWidget(request))\n-\n-\n-@implementer(IFieldWidget)\n-def RichTextFieldWidget(field, request):\n-    return FieldWidget(field, RichTextWidget(request))\n-\n-\n-@implementer(IFieldWidget)\n-def QueryStringFieldWidget(field, request, extra=None):\n-    if extra is not None:\n-        request = extra\n-    return FieldWidget(field, QueryStringWidget(request))\n-\n-\n-@implementer(IFieldWidget)\n-def LinkFieldWidget(field, request):\n-    return FieldWidget(field, LinkWidget(request))\n-\n-\n-@implementer_only(ISingleCheckBoxBoolWidget)\n-class SingleCheckBoxBoolWidget(SingleCheckBoxWidget):\n-    """Single Input type checkbox widget implementation."""\n-\n-    klass = "single-checkbox-bool-widget"\n-\n-    @property\n-    def label(self):\n-        if self.mode == "input":\n-            return ""\n-        return getattr(self, "_label", "")\n-\n-    @label.setter\n-    def label(self, value):\n-        self._label = value\n-\n-    @property\n-    def description(self):\n-        if self.mode == "input":\n-            return ""\n-        return getattr(self, "_description", "")\n-\n-    @description.setter\n-    def description(self, value):\n-        self._description = value\n-\n-    def updateTerms(self):\n-        if self.mode == "input":\n-            # in input mode use only one checkbox with true\n-            self.terms = Terms()\n-            self.terms.terms = SimpleVocabulary(\n-                (\n-                    TermWithDescription(\n-                        True,\n-                        "selected",\n-                        getattr(self, "_label", None) or self.field.title,\n-                        getattr(\n-                            self,\n-                            "_description",\n-                            None,\n-                        )\n-                        or self.field.description,\n-                    ),\n-                )\n-            )\n-            return self.terms\n-        if not self.terms:\n-            self.terms = Terms()\n-            self.terms.terms = SimpleVocabulary(\n-                [\n-                    SimpleTerm(*args)\n-                    for args in [\n-                        (True, "selected", BoolTerms.trueLabel),\n-                        (False, "unselected", BoolTerms.falseLabel),\n-                    ]\n-                ],\n-            )\n-        return self.terms\n-\n-    @property\n-    def items(self):\n-        result = super().items\n-        for record in result:\n-            term = self.terms.terms.getTermByToken(record["value"])\n-            record["description"] = getattr(term, "description", "")\n-            record["required"] = self.required\n-        return result\n-\n-\n-@adapter(IBool, IPloneFormLayer)\n-@implementer(IFieldWidget)\n-def SingleCheckBoxBoolFieldWidget(field, request):\n-    """IFieldWidget factory for CheckBoxWidget."""\n-    return FieldWidget(field, SingleCheckBoxBoolWidget(request))\n+from zope.deferredimport import deprecated as deprecated_import\n+\n+\n+deprecated_import(\n+    "Import from plone.app.z3cform.converters instead (will be removed in Plone 7)",\n+    DatetimeWidgetConverter="plone.app.z3cform.converters:DatetimeWidgetConverter",\n+    DateWidgetConverter="plone.app.z3cform.converters:DateWidgetConverter",\n+)\n+\n+deprecated_import(\n+    "Import from plone.app.z3cform.widgets.base instead (will be removed in Plone 7)",\n+    BaseWidget="plone.app.z3cform.widgets.base:BaseWidget",\n+)\n+\n+deprecated_import(\n+    "Import from plone.app.z3cform.widgets.datetime instead (will be removed in Plone 7)",\n+    DateFieldWidget="plone.app.z3cform.widgets.datetime:DateFieldWidget",\n+    DatetimeFieldWidget="plone.app.z3cform.widgets.datetime:DatetimeFieldWidget",\n+    DatetimeWidget="plone.app.z3cform.widgets.datetime:DatetimeWidget",\n+    DateWidget="plone.app.z3cform.widgets.datetime:DateWidget",\n+    TimeFieldWidget="plone.app.z3cform.widgets.datetime:TimeFieldWidget",\n+    TimeWidget="plone.app.z3cform.widgets.datetime:TimeWidget",\n+)\n+\n+deprecated_import(\n+    "Import from plone.app.z3cform.widgets.link instead (will be removed in Plone 7)",\n+    LinkFieldWidget="plone.app.z3cform.widgets.link:LinkFieldWidget",\n+    LinkWidget="plone.app.z3cform.widgets.link:LinkWidget",\n+)\n+\n+deprecated_import(\n+    "Import from plone.app.z3cform.widgets.querystring instead (will be removed in Plone 7)",\n+    QueryStringFieldWidget="plone.app.z3cform.widgets.querystring:QueryStringFieldWidget",\n+    QueryStringWidget="plone.app.z3cform.widgets.querystring:QueryStringWidget",\n+)\n+\n+deprecated_import(\n+    "Import from plone.app.z3cform.widgets.relateditems instead (will be removed in Plone 7)",\n+    RelatedItemsFieldWidget="plone.app.z3cform.widgets.relateditems:RelatedItemsFieldWidget",\n+    RelatedItemsWidget="plone.app.z3cform.widgets.relateditems:RelatedItemsWidget",\n+)\n+\n+deprecated_import(\n+    "Import from plone.app.z3cform.widgets.richtext instead (will be removed in Plone 7)",\n+    RichTextFieldWidget="plone.app.z3cform.widgets.richtext:RichTextFieldWidget",\n+    RichTextWidget="plone.app.z3cform.widgets.richtext:RichTextWidget",\n+)\n+\n+deprecated_import(\n+    "Import from plone.app.z3cform.widgets.select instead (will be removed in Plone 7)",\n+    AjaxSelectFieldWidget="plone.app.z3cform.widgets.select:AjaxSelectFieldWidget",\n+    AjaxSelectWidget="plone.app.z3cform.widgets.select:AjaxSelectWidget",\n+    SelectFieldWidget="plone.app.z3cform.widgets.select:SelectFieldWidget",\n+    SelectWidget="plone.app.z3cform.widgets.select:SelectWidget",\n+)\n+\n+deprecated_import(\n+    "Import from plone.app.z3cform.widgets.singlecheckbox instead (will be removed in Plone 7)",\n+    SingleCheckBoxBoolFieldWidget="plone.app.z3cform.widgets.singlecheckbox:SingleCheckBoxBoolFieldWidget",\n+    SingleCheckBoxBoolWidget="plone.app.z3cform.widgets.singlecheckbox:SingleCheckBoxBoolWidget",\n+    SingleCheckBoxWidget="plone.app.z3cform.widgets.singlecheckbox:SingleCheckBoxWidget",\n+)\ndiff --git a/plone/app/z3cform/widget.zcml b/plone/app/z3cform/widgets.zcml\nsimilarity index 88%\nrename from plone/app/z3cform/widget.zcml\nrename to plone/app/z3cform/widgets.zcml\nindex ed453f03..2e813157 100644\n--- a/plone/app/z3cform/widget.zcml\n+++ b/plone/app/z3cform/widgets.zcml\n@@ -1,7 +1,6 @@\n <configure\n     xmlns="http://namespaces.zope.org/zope"\n     xmlns:z3c="http://namespaces.zope.org/z3c"\n-    i18n_domain="plone"\n     >\n \n   <!-- Make the default widget for sequence-of-text-lines a textlines\n@@ -14,6 +13,7 @@\n            zope.schema.interfaces.ITextLine\n            plone.app.z3cform.interfaces.IPloneFormLayer"\n       />\n+\n   <adapter\n       factory="plone.z3cform.textlines.textlines.TextLinesFieldWidgetFactory"\n       provides="z3c.form.interfaces.IFieldWidget"\n@@ -21,6 +21,7 @@\n            zope.schema.interfaces.ITextLine\n            plone.app.z3cform.interfaces.IPloneFormLayer"\n       />\n+\n   <adapter\n       factory="plone.z3cform.textlines.textlines.TextLinesFieldWidgetFactory"\n       provides="z3c.form.interfaces.IFieldWidget"\n@@ -36,6 +37,7 @@\n            zope.schema.interfaces.IASCIILine\n            plone.app.z3cform.interfaces.IPloneFormLayer"\n       />\n+\n   <adapter\n       factory="plone.z3cform.textlines.textlines.TextLinesFieldWidgetFactory"\n       provides="z3c.form.interfaces.IFieldWidget"\n@@ -51,12 +53,12 @@\n            plone.app.z3cform.interfaces.IPloneFormLayer"\n       />\n \n+  <!-- single checkbox boolean -->\n   <adapter\n-      factory=".widget.SingleCheckBoxBoolFieldWidget"\n+      factory=".widgets.singlecheckbox.SingleCheckBoxBoolFieldWidget"\n       for="zope.schema.interfaces.IBool\n            .interfaces.IPloneFormLayer"\n       />\n-  <adapter factory=".converters.BoolSingleCheckboxDataConverter" />\n \n   <z3c:widgetTemplate\n       field="zope.schema.interfaces.IBool"\n@@ -65,6 +67,7 @@\n       layer=".interfaces.IPloneFormLayer"\n       mode="display"\n       />\n+\n   <z3c:widgetTemplate\n       field="zope.schema.interfaces.IBool"\n       widget=".interfaces.ISingleCheckBoxBoolWidget"\n@@ -72,6 +75,8 @@\n       layer=".interfaces.IPloneFormLayer"\n       mode="input"\n       />\n+\n+  <!-- ajaxselect -->\n   <z3c:widgetTemplate\n       field="*"\n       widget=".interfaces.IAjaxSelectWidget"\n@@ -79,6 +84,7 @@\n       layer=".interfaces.IPloneFormLayer"\n       mode="display"\n       />\n+\n   <z3c:widgetTemplate\n       field="zope.schema.interfaces.IBool"\n       widget=".interfaces.ISingleCheckBoxBoolWidget"\n@@ -87,6 +93,7 @@\n       mode="hidden"\n       />\n \n+  <!-- multi -->\n   <z3c:widgetTemplate\n       widget="z3c.form.interfaces.IMultiWidget"\n       template="templates/multi_input.pt"\n@@ -94,6 +101,7 @@\n       mode="input"\n       />\n \n+  <!-- object -->\n   <z3c:widgetTemplate\n       widget="z3c.form.interfaces.IObjectWidget"\n       template="templates/object_input.pt"\n@@ -101,22 +109,8 @@\n       mode="input"\n       />\n \n-  <z3c:widgetTemplate\n-      widget=".interfaces.ILinkWidget"\n-      template="templates/link_input.pt"\n-      layer=".interfaces.IPloneFormLayer"\n-      mode="input"\n-      />\n-\n-  <z3c:widgetTemplate\n-      widget=".interfaces.IRelatedItemsWidget"\n-      template="templates/relateditems_display.pt"\n-      layer=".interfaces.IPloneFormLayer"\n-      mode="display"\n-      />\n-\n-  <!-- widget registration stuff -->\n-  <class class=".widget.DateWidget">\n+  <!-- date/time -->\n+  <class class=".widgets.datetime.DateWidget">\n     <require\n         permission="zope.Public"\n         interface=".interfaces.IDateWidget"\n@@ -124,12 +118,12 @@\n   </class>\n \n   <adapter\n-      factory=".widget.DateFieldWidget"\n+      factory=".widgets.datetime.DateFieldWidget"\n       for="zope.schema.interfaces.IDate\n            plone.app.z3cform.interfaces.IPloneFormLayer"\n       />\n \n-  <class class=".widget.DatetimeWidget">\n+  <class class=".widgets.datetime.DatetimeWidget">\n     <require\n         permission="zope.Public"\n         interface=".interfaces.IDatetimeWidget"\n@@ -137,12 +131,12 @@\n   </class>\n \n   <adapter\n-      factory=".widget.DatetimeFieldWidget"\n+      factory=".widgets.datetime.DatetimeFieldWidget"\n       for="zope.schema.interfaces.IDatetime\n            plone.app.z3cform.interfaces.IPloneFormLayer"\n       />\n \n-  <class class=".widget.TimeWidget">\n+  <class class=".widgets.datetime.TimeWidget">\n     <require\n         permission="zope.Public"\n         interface=".interfaces.ITimeWidget"\n@@ -150,49 +144,68 @@\n   </class>\n \n   <adapter\n-      factory=".widget.TimeFieldWidget"\n+      factory=".widgets.datetime.TimeFieldWidget"\n       for="zope.schema.interfaces.ITime\n            plone.app.z3cform.interfaces.IPloneFormLayer"\n       />\n \n+  <!-- relateditems -->\n+\n   <adapter\n-      factory=".widget.RelatedItemsFieldWidget"\n+      factory=".widgets.relateditems.RelatedItemsFieldWidget"\n       for="z3c.relationfield.interfaces.IRelationChoice\n            plone.app.z3cform.interfaces.IPloneFormLayer"\n       />\n \n   <adapter\n-      factory=".widget.RelatedItemsFieldWidget"\n+      factory=".widgets.relateditems.RelatedItemsFieldWidget"\n       for="z3c.relationfield.interfaces.IRelationList\n            plone.app.z3cform.interfaces.IPloneFormLayer"\n       />\n \n   <adapter\n-      factory=".widget.RelatedItemsFieldWidget"\n+      factory=".widgets.relateditems.RelatedItemsFieldWidget"\n       for="zope.schema.interfaces.IChoice\n            plone.app.vocabularies.catalog.CatalogSource\n            plone.app.z3cform.interfaces.IPloneFormLayer"\n       />\n \n+  <z3c:widgetTemplate\n+      widget=".interfaces.IRelatedItemsWidget"\n+      template="templates/relateditems_display.pt"\n+      layer=".interfaces.IPloneFormLayer"\n+      mode="display"\n+      />\n+\n+  <!-- querystring -->\n   <adapter\n-      factory=".widget.QueryStringFieldWidget"\n+      factory=".widgets.querystring.QueryStringFieldWidget"\n       for="zope.schema.interfaces.IList\n            zope.schema.interfaces.IDict\n            plone.app.z3cform.interfaces.IPloneFormLayer"\n       />\n \n+  <!-- richtext -->\n   <adapter\n-      factory=".widget.RichTextFieldWidget"\n+      factory=".widgets.richtext.RichTextFieldWidget"\n       for="plone.app.textfield.interfaces.IRichText\n            plone.app.z3cform.interfaces.IPloneFormLayer"\n       />\n \n+  <!-- link -->\n   <adapter\n-      factory=".widget.LinkFieldWidget"\n+      factory=".widgets.link.LinkFieldWidget"\n       for="z3c.form.interfaces.ITextWidget\n            plone.app.z3cform.interfaces.IPloneFormLayer"\n       />\n \n+  <z3c:widgetTemplate\n+      widget=".interfaces.ILinkWidget"\n+      template="templates/link_input.pt"\n+      layer=".interfaces.IPloneFormLayer"\n+      mode="input"\n+      />\n+\n   <!-- z3c.form overrides -->\n \n   <z3c:widgetTemplate\n@@ -297,4 +310,10 @@\n       mode="input"\n       />\n \n+  <utility\n+      provides="plone.app.z3cform.interfaces.IRichTextWidgetInputModeRenderer"\n+      name="tinymce"\n+      component=".widgets.richtext.tinymce_richtextwidget_render"\n+      />\n+\n </configure>\ndiff --git a/plone/app/z3cform/widgets/__init__.py b/plone/app/z3cform/widgets/__init__.py\nnew file mode 100644\nindex 00000000..e69de29b\ndiff --git a/plone/app/z3cform/widgets/base.py b/plone/app/z3cform/widgets/base.py\nnew file mode 100644\nindex 00000000..6cf87aef\n--- /dev/null\n+++ b/plone/app/z3cform/widgets/base.py\n@@ -0,0 +1,62 @@\n+from Acquisition import aq_base\n+from plone.app.z3cform.utils import call_callables\n+from z3c.form.widget import Widget\n+\n+\n+class PatternNotImplemented(Exception):\n+    """Raised when method/property is not implemented"""\n+\n+\n+class BaseWidget(Widget):\n+    """Base widget for z3c.form."""\n+\n+    pattern = None\n+    pattern_options = {}\n+    _adapterValueAttributes = Widget._adapterValueAttributes + ("pattern_options",)\n+\n+    def _base(self, pattern, pattern_options={}):\n+        """Base widget class."""\n+        raise PatternNotImplemented\n+\n+    def _base_args(self):\n+        """Method which will calculate _base class arguments.\n+\n+        Returns (as python dictionary):\n+            - `pattern`: pattern name\n+            - `pattern_options`: pattern options\n+\n+        :returns: Arguments which will be passed to _base\n+        :rtype: dict\n+        """\n+        if self.pattern is None:\n+            raise PatternNotImplemented("\'pattern\' option is not provided.")\n+        return {\n+            "pattern": self.pattern,\n+            "pattern_options": self.pattern_options.copy(),\n+        }\n+\n+    def render(self):\n+        """Render widget.\n+\n+        :returns: Widget\'s HTML.\n+        :rtype: string\n+        """\n+        if self.mode != "input":\n+            return super().render()\n+\n+        _base_args = self._base_args()\n+        _base_args["pattern_options"] = call_callables(\n+            _base_args["pattern_options"],\n+            self.context,\n+        )\n+\n+        pattern_widget = self._base(**_base_args)\n+        if getattr(self, "klass", False):\n+            pattern_widget.klass = "{} {}".format(\n+                pattern_widget.klass,\n+                self.klass,\n+            )\n+        return pattern_widget.render()\n+\n+    def is_subform_widget(self):\n+        return getattr(aq_base(self.form), "parentForm", None) is not None\ndiff --git a/plone/app/z3cform/widgets/datetime.py b/plone/app/z3cform/widgets/datetime.py\nnew file mode 100644\nindex 00000000..699a04ca\n--- /dev/null\n+++ b/plone/app/z3cform/widgets/datetime.py\n@@ -0,0 +1,163 @@\n+from plone.app.z3cform.converters import DatetimeWidgetConverter\n+from plone.app.z3cform.converters import DateWidgetConverter\n+from plone.app.z3cform.interfaces import IDatetimeWidget\n+from plone.app.z3cform.interfaces import IDateWidget\n+from plone.app.z3cform.interfaces import ITimeWidget\n+from plone.app.z3cform.utils import dict_merge\n+from plone.app.z3cform.widgets.base import BaseWidget\n+from plone.app.z3cform.widgets.patterns import InputWidget\n+from plone.base import PloneMessageFactory as _\n+from z3c.form.browser.text import TextWidget\n+from z3c.form.interfaces import IFieldWidget\n+from z3c.form.widget import FieldWidget\n+from zope.i18n import translate\n+from zope.interface import implementer\n+from zope.interface import implementer_only\n+\n+\n+def get_date_options(request):\n+    calendar = request.locale.dates.calendars["gregorian"]\n+    return {\n+        "behavior": "native",\n+        "week-numbers": "show",\n+        "first-day": calendar.week.get("firstDay") == 1 and 1 or 0,\n+        "today": translate(_("Today"), context=request),\n+        "clear": translate(_("Clear"), context=request),\n+    }\n+\n+\n+@implementer_only(IDateWidget)\n+class DateWidget(BaseWidget, TextWidget):\n+    """Date widget for z3c.form.\n+\n+    :param default_timezone: A Olson DB/pytz timezone identifier or a callback\n+                             returning such an identifier.\n+    :type default_timezone: String or callback\n+\n+    :param default_time: Time used by converter as fallback if no time was set in UI.\n+    :type default_time: String or callback\n+\n+    The default_timezone and default_time arguments are only used if a datewidget is\n+    used on a datetime field. If used on a date field they are ignored.\n+    """\n+\n+    _base_type = "date"\n+    _converter = DateWidgetConverter\n+    _formater = "date"\n+    _formater_length = "short"\n+\n+    default_timezone = None\n+    default_time = "00:00:00"\n+\n+    pattern = "date-picker"\n+    pattern_options = BaseWidget.pattern_options.copy()\n+\n+    def _base(self, **kw):\n+        return InputWidget(\n+            type=self._base_type,\n+            **kw,\n+        )\n+\n+    def _base_args(self):\n+        """Method which will calculate _base class arguments.\n+\n+        Returns (as python dictionary):\n+            - `pattern`: pattern name\n+            - `pattern_options`: pattern options\n+            - `name`: field name\n+            - `value`: field value\n+\n+        :returns: Arguments which will be passed to _base\n+        :rtype: dict\n+        """\n+        args = super()._base_args()\n+        args["name"] = self.name\n+        args["value"] = (self.request.get(self.name, self.value) or "").strip()\n+\n+        args.setdefault("pattern_options", {})\n+        if self.field.required:\n+            # Required fields should not have a "Clear" button\n+            args["pattern_options"]["clear"] = False\n+        args["pattern_options"] = dict_merge(\n+            get_date_options(self.request), args["pattern_options"]\n+        )\n+\n+        return args\n+\n+    def render(self):\n+        """Render widget.\n+\n+        :returns: Widget\'s HTML.\n+        :rtype: string\n+        """\n+        if self.mode != "display":\n+            self.addClass("form-control")\n+            return super().render()\n+\n+        if not self.value:\n+            return ""\n+\n+        field_value = self._converter(self.field, self).toFieldValue(self.value)\n+        if field_value is self.field.missing_value:\n+            return ""\n+\n+        formatter = self.request.locale.dates.getFormatter(\n+            self._formater,\n+            self._formater_length,\n+        )\n+        return formatter.format(field_value)\n+\n+\n+@implementer(IFieldWidget)\n+def DateFieldWidget(field, request):\n+    return FieldWidget(field, DateWidget(request))\n+\n+\n+@implementer_only(IDatetimeWidget)\n+class DatetimeWidget(DateWidget):\n+    """Datetime widget for z3c.form.\n+\n+    :param default_timezone: A Olson DB/pytz timezone identifier or a callback\n+                             returning such an identifier.\n+    :type default_timezone: String or callback\n+\n+    :param default_time: Time used by converter as fallback if no time was set in UI.\n+    :type default_time: String or callback\n+    """\n+\n+    _base_type = "datetime-local"\n+    _converter = DatetimeWidgetConverter\n+    _formater = "dateTime"\n+\n+    default_timezone = None\n+    default_time = "00:00:00"\n+\n+    pattern = "datetime-picker"\n+\n+\n+@implementer(IFieldWidget)\n+def DatetimeFieldWidget(field, request):\n+    return FieldWidget(field, DatetimeWidget(request))\n+\n+\n+@implementer_only(ITimeWidget)\n+class TimeWidget(BaseWidget, TextWidget):\n+    pattern = ""\n+\n+    def _base(self, **kw):\n+        return InputWidget(\n+            type="time",\n+            name=self.name,\n+            value=(self.request.get(self.name, self.value) or "").strip(),\n+            **kw,\n+        )\n+\n+    def render(self):\n+        if self.mode != "display":\n+            self.addClass("form-control")\n+        return super().render()\n+\n+\n+@implementer(IFieldWidget)\n+def TimeFieldWidget(field, request):\n+    return FieldWidget(field, TimeWidget(request))\ndiff --git a/plone/app/z3cform/widgets/link.py b/plone/app/z3cform/widgets/link.py\nnew file mode 100644\nindex 00000000..d9eb02df\n--- /dev/null\n+++ b/plone/app/z3cform/widgets/link.py\n@@ -0,0 +1,59 @@\n+from plone.app.z3cform.interfaces import ILinkWidget\n+from plone.base.utils import safe_text\n+from z3c.form.browser.text import TextWidget as z3cform_TextWidget\n+from z3c.form.interfaces import IFieldWidget\n+from z3c.form.interfaces import NO_VALUE\n+from z3c.form.widget import FieldWidget\n+from zope.component.hooks import getSite\n+from zope.interface import implementer\n+from zope.interface import implementer_only\n+\n+import json\n+\n+\n+@implementer_only(ILinkWidget)\n+class LinkWidget(z3cform_TextWidget):\n+    """Implementation of enhanced link widget.\n+\n+    .. note::\n+        Unlike the others here, this is not a pattern based widget\n+        and it uses it\'s own template.\n+    """\n+\n+    def pattern_data(self):\n+        pattern_data = {\n+            "vocabularyUrl": "{}/@@getVocabulary?name=plone.app.vocabularies.Catalog".format(  # noqa\n+                getSite().absolute_url(0),\n+            ),\n+            "maximumSelectionSize": 1,\n+        }\n+        return json.dumps(pattern_data)\n+\n+    def extract(self, default=NO_VALUE):\n+        form = self.request.form\n+        internal = form.get(self.name + ".internal")\n+        external = form.get(self.name + ".external")\n+        email = form.get(self.name + ".email")\n+        if internal:\n+            url = "${portal_url}/resolveuid/" + internal\n+        elif email:\n+            subject = form.get(self.name + ".subject")\n+            if email[:7] != "mailto:":\n+                email = "mailto:" + email\n+            if not subject:\n+                url = email\n+            else:\n+                url = "{email}?subject={subject}".format(\n+                    email=email,\n+                    subject=subject,\n+                )\n+        else:\n+            url = external  # the default is `http://` so we land here\n+        if url:\n+            self.request.form[self.name] = safe_text(url)\n+        return super().extract(default=default)\n+\n+\n+@implementer(IFieldWidget)\n+def LinkFieldWidget(field, request):\n+    return FieldWidget(field, LinkWidget(request))\ndiff --git a/plone/app/z3cform/widgets/patterns.py b/plone/app/z3cform/widgets/patterns.py\nnew file mode 100644\nindex 00000000..7bcf8dda\n--- /dev/null\n+++ b/plone/app/z3cform/widgets/patterns.py\n@@ -0,0 +1,338 @@\n+from lxml import etree\n+\n+import collections\n+import json\n+\n+\n+def el_attrib(name):\n+    """Helper property methods to get/set/delete element property.\n+\n+    :param name: [required] Name of the element property.\n+    :type name: string\n+\n+    :returns: Property with getter/setter/deletter.\n+    :rtype: property\n+    """\n+\n+    def _get(self):\n+        if name in self.el.attrib:\n+            value = self.el.attrib[name]\n+            if value.strip().startswith("[") or value.strip().startswith("{"):\n+                value = json.loads(value)\n+            return value\n+\n+    def _set(self, value):\n+        if value is None:\n+            return\n+        if isinstance(value, (list, tuple)):\n+            value = " ".join(value)\n+        if isinstance(value, (dict, set)):\n+            value = json.dumps(value)\n+        if isinstance(value, bytes):\n+            value = value.decode("utf8")\n+        self.el.attrib[name] = value\n+\n+    def _del(self):\n+        if name in self.el.attrib:\n+            del self.el.attrib[name]\n+\n+    return property(_get, _set, _del)\n+\n+\n+class BaseWidget:\n+    """Basic patterns widget."""\n+\n+    _klass_prefix = "pat-"\n+    klass = el_attrib("class")\n+\n+    def __init__(self, el, pattern, pattern_options={}):\n+        """\n+        :param el: [required] element type (eg. input, div, textarea, a, ...).\n+        :type el: string\n+\n+        :param pattern: [required] Pattern name.\n+        :type pattern: string\n+\n+        :param pattern_options: Patterns options.\n+        :type pattern_options: dict\n+        """\n+\n+        self.pattern = pattern\n+        self.el = etree.Element(el)\n+        if pattern:\n+            self.klass = self._klass_prefix + pattern\n+        self.pattern_options = pattern_options\n+\n+    def update(self):\n+        """Updating pattern_options in element `data-*` attribute."""\n+        if self.pattern_options:\n+            self.el.attrib["data-" + self._klass_prefix + self.pattern] = json.dumps(\n+                self.pattern_options\n+            )\n+\n+    def render(self):\n+        """Renders the widget\n+\n+        :returns: Widget\'s HTML.\n+        :rtype: string\n+        """\n+\n+        self.update()\n+        return etree.tostring(self.el, encoding=str)\n+\n+\n+class InputWidget(BaseWidget):\n+    """Widget with `input` element."""\n+\n+    type = el_attrib("type")\n+    value = el_attrib("value")\n+    name = el_attrib("name")\n+\n+    def __init__(self, pattern, pattern_options={}, type="text", name=None, value=None):\n+        """\n+        :param pattern: [required] Pattern name.\n+        :type pattern: string\n+\n+        :param pattern_options: Patterns options.\n+        :type pattern_options: dict\n+\n+        :param type: `type` attribute of element.\n+        :type type: string\n+\n+        :param name: `name` attribute of element.\n+        :type name: string\n+\n+        :param value: `value` attribute of element.\n+        :type value: string\n+        """\n+        super().__init__("input", pattern, pattern_options)\n+        self.type = type\n+        if name is not None:\n+            self.name = name\n+        if value is not None:\n+            self.value = value\n+\n+\n+class SelectWidget(BaseWidget):\n+    """Widget with `select` element."""\n+\n+    name = el_attrib("name")\n+    _multiple = el_attrib("multiple")\n+\n+    def __init__(\n+        self,\n+        pattern,\n+        pattern_options={},\n+        items=[],\n+        name=None,\n+        value=None,\n+        multiple=False,\n+    ):\n+        """\n+        :param pattern: [required] Pattern name.\n+        :type pattern: string\n+\n+        :param pattern_options: Patterns options.\n+        :type pattern_options: dict\n+\n+        :param items: List of value and title pairs which represents possible\n+                      options to choose from.\n+        :type items: list\n+\n+        :param name: `name` attribute of element.\n+        :type name: string\n+\n+        :param value: `value` attribute of element.\n+        :type value: string\n+\n+        :param multiple: `multiple` attribute of element.\n+        :type multiple: bool\n+        """\n+        super().__init__("select", pattern, pattern_options)\n+        self.el.text = ""\n+        self.items = items\n+        self.multiple = multiple\n+        if name is not None:\n+            self.name = name\n+        if value is not None:\n+            self.value = value\n+\n+    def _get_items(self):\n+        """Get list of possible options.\n+\n+        :returns: List of value and title pairs.\n+        :rtype: list\n+        """\n+        if self.el.find("optgroup") is not None:\n+            return collections.OrderedDict(\n+                (\n+                    group.attrib["label"],\n+                    [\n+                        (option.attrib["value"], option.text)\n+                        for option in group.iter("option")\n+                    ],\n+                )\n+                for group in self.el.iter("optgroup")\n+            )\n+        else:\n+            return [\n+                (option.attrib["value"], option.text)\n+                for option in self.el.iter("option")\n+            ]\n+\n+    def _set_items(self, value):\n+        """Set options for element.\n+\n+        :param value: List of value and title pairs which represents possible\n+                      options to choose from.\n+        :type value: list\n+        """\n+\n+        def addOptions(el, options):\n+            """\n+            Add <option> elements for each vocab item.\n+            """\n+            for token, title in options:\n+                option = etree.SubElement(el, "option")\n+                option.attrib["value"] = token\n+                option.text = title\n+\n+        if isinstance(value, dict):\n+            for group_label, options in value.items():\n+                group = etree.SubElement(self.el, "optgroup")\n+                group.attrib["label"] = group_label\n+                addOptions(group, options)\n+        else:\n+            for token, title in value:\n+                option = etree.SubElement(self.el, "option")\n+                option.attrib["value"] = token\n+                option.text = title\n+\n+    def _del_items(self):\n+        """Removing options from inside of elements."""\n+        for group in self.el.iter("optgroup"):\n+            self.el.remove(group)\n+        for element in self.el.iter("option"):\n+            self.el.remove(element)\n+\n+    items = property(_get_items, _set_items, _del_items)\n+\n+    def _get_value(self):\n+        """Return selected option(s).\n+\n+        :returns: Returns list of selected option(s) values.\n+        :rtype: list\n+        """\n+        value = []\n+        for element in self.el.iter("option"):\n+            if (\n+                "selected" in element.attrib\n+                and element.attrib["selected"] == "selected"\n+            ):\n+                value.append(element.attrib["value"])\n+        return value\n+\n+    def _set_value(self, value):\n+        """Select option(s).\n+\n+        :param value: We are expecting option\'s value which should be selected.\n+        :type value: list or string\n+        """\n+        if isinstance(value, str):\n+            value = [value]\n+\n+        for element in self.el.iter("option"):\n+            if element.attrib["value"] in value:\n+                element.attrib["selected"] = "selected"\n+            elif (\n+                "selected" in element.attrib\n+                and element.attrib["selected"] == "selected"\n+            ):\n+                del element.attrib["selected"]\n+\n+    def _del_value(self):\n+        """Unselect all selected options."""\n+        for element in self.el.iter("option"):\n+            if (\n+                "selected" in element.attrib\n+                and element.attrib["selected"] == "selected"\n+            ):\n+                del element.attrib["selected"]\n+\n+    value = property(_get_value, _set_value, _del_value)\n+\n+    def _get_multiple(self):\n+        """Does element allows multiple items to be selected.\n+\n+        :returns: `True` if allows multiple elements to be selected, otherwise\n+                  `False`.\n+        :rtype: bool\n+        """\n+        if self._multiple == "multiple":\n+            return True\n+        return False\n+\n+    def _set_multiple(self, value):\n+        """Make element accept multiple values.\n+\n+        :param value: `True` if you want to set element as `multiple`,\n+                      otherwise `False`\n+        :type value: bool\n+        """\n+        if value:\n+            self._multiple = "multiple"\n+        else:\n+            self._del_multiple()\n+\n+    def _del_multiple(self):\n+        """Remove `multiple` attribute from element."""\n+        del self._multiple\n+\n+    multiple = property(_get_multiple, _set_multiple, _del_multiple)\n+\n+\n+class TextareaWidget(BaseWidget):\n+    """Widget with `textarea` element."""\n+\n+    name = el_attrib("name")\n+\n+    def __init__(self, pattern, pattern_options={}, name=None, value=None):\n+        """\n+        :param pattern: [required] Pattern name.\n+        :type pattern: string\n+\n+        :param pattern_options: Patterns options.\n+        :type pattern_options: dict\n+\n+        :param name: `name` attribute of element.\n+        :type name: string\n+\n+        :param value: `value` of element.\n+        :type value: string\n+        """\n+        super().__init__("textarea", pattern, pattern_options)\n+        self.el.text = ""\n+        if name is not None:\n+            self.name = name\n+        if value is not None:\n+            self.value = value\n+\n+    def _get_value(self):\n+        """\n+        :returns: Value of element.\n+        :rtype: string\n+        """\n+        return self.el.text\n+\n+    def _set_value(self, value):\n+        """\n+        :param value: Set value of element.\n+        :type value: string\n+        """\n+        self.el.text = value\n+\n+    def _del_value(self):\n+        """Set empty string as value of element."""\n+        self.el.text = ""\n+\n+    value = property(_get_value, _set_value, _del_value)\ndiff --git a/plone/app/z3cform/widgets/querystring.py b/plone/app/z3cform/widgets/querystring.py\nnew file mode 100644\nindex 00000000..e186745c\n--- /dev/null\n+++ b/plone/app/z3cform/widgets/querystring.py\n@@ -0,0 +1,80 @@\n+from plone.app.z3cform.interfaces import IQueryStringWidget\n+from plone.app.z3cform.utils import dict_merge\n+from plone.app.z3cform.utils import get_portal_url\n+from plone.app.z3cform.widgets.base import BaseWidget\n+from plone.app.z3cform.widgets.datetime import get_date_options\n+from plone.app.z3cform.widgets.patterns import InputWidget\n+from plone.app.z3cform.widgets.relateditems import get_relateditems_options\n+from z3c.form.browser.text import TextWidget as z3cform_TextWidget\n+from z3c.form.interfaces import IFieldWidget\n+from z3c.form.widget import FieldWidget\n+from zope.globalrequest import getRequest\n+from zope.interface import implementer\n+from zope.interface import implementer_only\n+\n+\n+def get_querystring_options(context, querystring_view):\n+    portal_url = get_portal_url(context)\n+    try:\n+        base_url = context.absolute_url()\n+    except AttributeError:\n+        base_url = portal_url\n+    return {\n+        "indexOptionsUrl": f"{portal_url}/{querystring_view}",\n+        "previewURL": "%s/@@querybuilder_html_results" % base_url,\n+        "previewCountURL": "%s/@@querybuildernumberofresults" % base_url,\n+        "patternDateOptions": get_date_options(getRequest()),\n+        "patternAjaxSelectOptions": {"separator": ";"},\n+        "patternRelateditemsOptions": get_relateditems_options(\n+            context,\n+            None,\n+            ";",\n+            "plone.app.vocabularies.Catalog",\n+            "@@getVocabulary",\n+            "relatedItems",\n+            include_recently_added=False,\n+        ),\n+    }\n+\n+\n+@implementer_only(IQueryStringWidget)\n+class QueryStringWidget(BaseWidget, z3cform_TextWidget):\n+    """QueryString widget for z3c.form."""\n+\n+    _base = InputWidget\n+\n+    pattern = "querystring"\n+    pattern_options = BaseWidget.pattern_options.copy()\n+\n+    querystring_view = "@@qsOptions"\n+\n+    def _base_args(self):\n+        """Method which will calculate _base class arguments.\n+\n+        Returns (as python dictionary):\n+            - `pattern`: pattern name\n+            - `pattern_options`: pattern options\n+            - `name`: field name\n+            - `value`: field value\n+\n+        :returns: Arguments which will be passed to _base\n+        :rtype: dict\n+        """\n+        args = super()._base_args()\n+        args["name"] = self.name\n+        args["value"] = self.value\n+\n+        args.setdefault("pattern_options", {})\n+        args["pattern_options"] = dict_merge(\n+            get_querystring_options(self.context, self.querystring_view),\n+            args["pattern_options"],\n+        )\n+\n+        return args\n+\n+\n+@implementer(IFieldWidget)\n+def QueryStringFieldWidget(field, request, extra=None):\n+    if extra is not None:\n+        request = extra\n+    return FieldWidget(field, QueryStringWidget(request))\ndiff --git a/plone/app/z3cform/widgets/relateditems.py b/plone/app/z3cform/widgets/relateditems.py\nnew file mode 100644\nindex 00000000..2416f0bd\n--- /dev/null\n+++ b/plone/app/z3cform/widgets/relateditems.py\n@@ -0,0 +1,251 @@\n+from Acquisition import aq_parent\n+from OFS.interfaces import IFolder\n+from OFS.interfaces import ISimpleItem\n+from plone.app.contentlisting.interfaces import IContentListing\n+from plone.app.layout.navigation.root import getNavigationRootObject\n+from plone.app.z3cform.interfaces import IRelatedItemsWidget\n+from plone.app.z3cform.utils import dict_merge\n+from plone.app.z3cform.utils import get_context_url\n+from plone.app.z3cform.utils import get_widget_form\n+from plone.app.z3cform.widgets.base import BaseWidget\n+from plone.app.z3cform.widgets.patterns import InputWidget\n+from plone.base import PloneMessageFactory as _\n+from plone.base.utils import get_top_site_from_url\n+from Products.CMFCore.utils import getToolByName\n+from z3c.form.browser.text import TextWidget as z3cform_TextWidget\n+from z3c.form.interfaces import IEditForm\n+from z3c.form.interfaces import IFieldWidget\n+from z3c.form.interfaces import IForm\n+from z3c.form.widget import FieldWidget\n+from zope.component.hooks import getSite\n+from zope.globalrequest import getRequest\n+from zope.interface import implementer\n+from zope.interface import implementer_only\n+from zope.schema.interfaces import IChoice\n+from zope.schema.interfaces import ICollection\n+\n+\n+def get_relateditems_options(\n+    context,\n+    value,\n+    separator,\n+    vocabulary_name,\n+    vocabulary_view,\n+    field_name=None,\n+    include_recently_added=True,\n+):\n+    if IForm.providedBy(context):\n+        context = context.context\n+\n+    request = getRequest()\n+    site = get_top_site_from_url(context, request)\n+    options = {\n+        "separator": separator,\n+    }\n+    if not vocabulary_name:\n+        # we need a vocabulary!\n+        raise ValueError("RelatedItems needs a vocabulary")\n+    options["vocabularyUrl"] = "{}/{}?name={}".format(\n+        get_context_url(site),\n+        vocabulary_view,\n+        vocabulary_name,\n+    )\n+    if field_name:\n+        options["vocabularyUrl"] += f"&field={field_name}"\n+    if value:\n+        options["initialValues"] = {}\n+        catalog = False\n+        if vocabulary_name == "plone.app.vocabularies.Catalog":\n+            catalog = getToolByName(getSite(), "portal_catalog")\n+        for value in value.split(separator):\n+            title = value\n+            if catalog:\n+                result = catalog(UID=value)\n+                title = result[0].Title if result else value\n+            options["initialValues"][value] = title\n+\n+    nav_root = getNavigationRootObject(context, site)\n+\n+    if not ISimpleItem.providedBy(context):\n+        context = nav_root\n+\n+    # basePath - start to search/browse in here.\n+    base_path_context = context\n+    if not IFolder.providedBy(base_path_context):\n+        base_path_context = aq_parent(base_path_context)\n+    if not base_path_context:\n+        base_path_context = nav_root\n+    options["basePath"] = "/".join(base_path_context.getPhysicalPath())\n+\n+    # rootPath - Only display breadcrumb elements deeper than this path.\n+    options["rootPath"] = "/".join(site.getPhysicalPath()) if site else "/"\n+\n+    # rootUrl: Visible URL up to the rootPath. This is prepended to the\n+    # currentPath to generate submission URLs.\n+    options["rootUrl"] = site.absolute_url() if site else ""\n+\n+    # contextPath - current edited object. Will not be available to select.\n+    options["contextPath"] = "/".join(context.getPhysicalPath())\n+\n+    if base_path_context != nav_root:\n+        options["favorites"] = [\n+            {\n+                "title": _("Current Content"),\n+                "path": "/".join(base_path_context.getPhysicalPath()),\n+            },\n+            {"title": _("Start Page"), "path": "/".join(nav_root.getPhysicalPath())},\n+        ]\n+\n+    if include_recently_added:\n+        # Options for recently used key\n+        tool = getToolByName(context, "portal_membership")\n+        user = tool.getAuthenticatedMember()\n+        options["recentlyUsed"] = False  # Keep that off in Plone 5.1\n+        options["recentlyUsedKey"] = "relateditems_recentlyused_{}_{}".format(\n+            field_name or "", user.id\n+        )  # use string substitution with %s here for automatic str casting.\n+\n+    return options\n+\n+\n+@implementer_only(IRelatedItemsWidget)\n+class RelatedItemsWidget(BaseWidget, z3cform_TextWidget):\n+    """RelatedItems widget for z3c.form."""\n+\n+    _base = InputWidget\n+\n+    pattern = "relateditems"\n+    pattern_options = BaseWidget.pattern_options.copy()\n+\n+    separator = ";"\n+    vocabulary = None\n+    vocabulary_override = False\n+    vocabulary_view = "@@getVocabulary"\n+    orderable = False\n+\n+    def update(self):\n+        super().update()\n+        field = getattr(self, "field", None)\n+        if ICollection.providedBy(self.field):\n+            field = self.field.value_type\n+        if (\n+            not self.vocabulary\n+            and field is not None\n+            and getattr(field, "vocabularyName", None)\n+        ):\n+            self.vocabulary = field.vocabularyName\n+            self.vocabulary_override = True\n+        else:\n+            self.vocabulary = "plone.app.vocabularies.Catalog"\n+\n+    def _base_args(self):\n+        """Method which will calculate _base class arguments.\n+\n+        Returns (as python dictionary):\n+            - `pattern`: pattern name\n+            - `pattern_options`: pattern options\n+            - `name`: field name\n+            - `value`: field value\n+\n+        :returns: Arguments which will be passed to _base\n+        :rtype: dict\n+        """\n+        args = super()._base_args()\n+\n+        args["name"] = self.name\n+        args["value"] = self.value\n+        args.setdefault("pattern_options", {})\n+\n+        field = None\n+        if IChoice.providedBy(self.field):\n+            args["pattern_options"]["maximumSelectionSize"] = 1\n+            field = self.field\n+        elif ICollection.providedBy(self.field):\n+            field = self.field.value_type\n+\n+        vocabulary_name = self.vocabulary\n+\n+        field_name = self.field and self.field.__name__ or None\n+\n+        context = self.context\n+        view_context = get_widget_form(self)\n+        # For EditForms and non-Forms (in tests), the vocabulary is looked\n+        # up on the context, otherwise on the view\n+        if IEditForm.providedBy(view_context):\n+            if self.is_subform_widget():\n+                view_context = self.form.parentForm.context\n+            elif not ISimpleItem.providedBy(context):\n+                view_context = self.form.context\n+            else:\n+                view_context = context\n+        elif not IForm.providedBy(view_context):\n+            view_context = context\n+        else:\n+            pass\n+            # view_context is defined above already\n+\n+        root_search_mode = (\n+            args["pattern_options"].get("mode", None)\n+            and "basePath" not in args["pattern_options"]\n+        )\n+\n+        args["pattern_options"] = dict_merge(\n+            get_relateditems_options(\n+                view_context,\n+                args["value"],\n+                self.separator,\n+                vocabulary_name,\n+                self.vocabulary_view,\n+                field_name,\n+            ),\n+            args["pattern_options"],\n+        )\n+        if root_search_mode:\n+            # Delete default basePath option in search mode, when no basePath\n+            # was explicitly set.\n+            del args["pattern_options"]["basePath"]\n+        if (\n+            not self.vocabulary_override\n+            and field\n+            and getattr(field, "vocabulary", None)\n+        ):\n+            # widget vocab takes precedence over field\n+            form_url = self.request.getURL()\n+            source_url = "{:s}/++widget++{:s}/@@getSource".format(\n+                form_url,\n+                self.name,\n+            )\n+            args["pattern_options"]["vocabularyUrl"] = source_url\n+\n+        return args\n+\n+    def items(self):\n+        """Return item for the widget values for the display template\n+\n+        Query the catalog for the widget-value (uuids) to only display items\n+        that the user is allowed to see. Accessing the value with e.g.\n+        getattr(self.context, self.__name__) would yield the items unfiltered.\n+        Uses IContentListing for easy access to MimeTypeIcon and more.\n+        """\n+        results = []\n+        if not self.value:\n+            return results\n+        separator = getattr(self, "separator", ";")\n+        uuids = self.value.split(separator)\n+\n+        try:\n+            catalog = getToolByName(self.context, "portal_catalog")\n+        except AttributeError:\n+            catalog = getToolByName(getSite(), "portal_catalog")\n+\n+        brains = catalog(UID=uuids)\n+        # restore original order\n+        results = sorted(brains, key=lambda brain: uuids.index(brain.UID))\n+        return IContentListing(results)\n+\n+\n+@implementer(IFieldWidget)\n+def RelatedItemsFieldWidget(field, request, extra=None):\n+    if extra is not None:\n+        request = extra\n+    return FieldWidget(field, RelatedItemsWidget(request))\ndiff --git a/plone/app/z3cform/widgets/richtext.py b/plone/app/z3cform/widgets/richtext.py\nnew file mode 100644\nindex 00000000..0c14dd84\n--- /dev/null\n+++ b/plone/app/z3cform/widgets/richtext.py\n@@ -0,0 +1,183 @@\n+from Acquisition import ImplicitAcquisitionWrapper\n+from collections import UserDict\n+from lxml import etree\n+from plone.app.textfield.value import RichTextValue\n+from plone.app.textfield.widget import RichTextWidget as patext_RichTextWidget\n+from plone.app.z3cform.interfaces import IRichTextWidget\n+from plone.app.z3cform.interfaces import IRichTextWidgetInputModeRenderer\n+from plone.app.z3cform.utils import closest_content\n+from plone.app.z3cform.utils import dict_merge\n+from plone.app.z3cform.widgets.base import BaseWidget\n+from plone.app.z3cform.widgets.patterns import TextareaWidget\n+from z3c.form.interfaces import IFieldWidget\n+from z3c.form.widget import FieldWidget\n+from zope.component import ComponentLookupError\n+from zope.component import getMultiAdapter\n+from zope.component import queryUtility\n+from zope.interface import implementer\n+from zope.interface import implementer_only\n+\n+import json\n+import logging\n+\n+\n+logger = logging.getLogger(__name__)\n+\n+\n+def get_tinymce_options(context, field, request):\n+    """\n+    We\'re just going to be looking up settings from\n+    plone pattern options\n+    """\n+    options = {}\n+    try:\n+        pattern_options = getMultiAdapter(\n+            (context, request, field), name="plone_settings"\n+        ).tinymce()["data-pat-tinymce"]\n+        options = json.loads(pattern_options)\n+    except (ComponentLookupError, AttributeError):\n+        logger.warning("Can not load tinymce pattern options!", exc_info=True)\n+    return options\n+\n+\n+@implementer_only(IRichTextWidget)\n+class RichTextWidget(BaseWidget, patext_RichTextWidget):\n+    """TinyMCE widget for z3c.form."""\n+\n+    _base = TextareaWidget\n+\n+    pattern_options = BaseWidget.pattern_options.copy()\n+\n+    def __init__(self, *args, **kwargs):\n+        super().__init__(*args, **kwargs)\n+        self._pattern = None\n+\n+    def wrapped_context(self):\n+        """ "We need to wrap the context to be able to acquire the root\n+        of the site to get tools, as done in plone.app.textfield"""\n+        context = self.context\n+        content = closest_content(context)\n+        if context.__class__ == dict:\n+            context = UserDict(self.context)\n+        return ImplicitAcquisitionWrapper(context, content)\n+\n+    @property\n+    def pattern(self):\n+        """dynamically grab the actual pattern name so it will\n+        work with custom visual editors"""\n+        if self._pattern is None:\n+            self._pattern = self.getWysiwygEditor()\n+        return self._pattern\n+\n+    def _base_args(self):\n+        args = super()._base_args()\n+        args["name"] = self.name\n+        value = self.value and self.value.raw or ""\n+        value = self.request.get(self.name, value)\n+        args["value"] = value\n+\n+        args.setdefault("pattern_options", {})\n+        merged_options = dict_merge(\n+            get_tinymce_options(\n+                self.wrapped_context(),\n+                self.field,\n+                self.request,\n+            ),\n+            args["pattern_options"],\n+        )\n+        args["pattern_options"] = merged_options\n+\n+        return args\n+\n+    def render(self):\n+        """Render widget.\n+\n+        :returns: Widget\'s HTML.\n+        :rtype: string\n+        """\n+        if self.mode != "display":\n+            renderer = queryUtility(\n+                IRichTextWidgetInputModeRenderer,\n+                name=self.getWysiwygEditor(),\n+                default=tinymce_richtextwidget_render,\n+            )\n+            return renderer(self)\n+\n+        if not self.value:\n+            return ""\n+\n+        if isinstance(self.value, RichTextValue):\n+            return self.value.output_relative_to(self.context)\n+\n+        return super().render()\n+\n+    def render_input_mode(self):\n+        # MODE "INPUT"\n+        rendered = ""\n+        allowed_mime_types = self.allowedMimeTypes()\n+        if not allowed_mime_types or len(allowed_mime_types) <= 1:\n+            # Display textarea with default widget\n+            rendered = super().render()\n+        else:\n+            # Let pat-textarea-mimetype-selector choose the widget\n+\n+            # Initialize the widget without a pattern\n+            base_args = self._base_args()\n+            pattern_options = base_args["pattern_options"]\n+            del base_args["pattern"]\n+            del base_args["pattern_options"]\n+            textarea_widget = self._base(None, None, **base_args)\n+            textarea_widget.klass = "form-control"\n+            mt_pattern_name = "{}{}".format(\n+                self._base._klass_prefix,\n+                "textareamimetypeselector",\n+            )\n+\n+            # Initialize mimetype selector pattern\n+            # TODO: default_mime_type returns \'text/html\', regardless of\n+            # settings. fix in plone.app.textfield\n+            value_mime_type = (\n+                self.value.mimeType if self.value else self.field.default_mime_type\n+            )\n+            mt_select = etree.Element("select")\n+            mt_select.attrib["id"] = f"{self.id}_text_format"\n+            mt_select.attrib["name"] = f"{self.name}.mimeType"\n+            mt_select.attrib["class"] = f"form-select {mt_pattern_name}"\n+            mt_select.attrib[f"data-{mt_pattern_name}"] = json.dumps(\n+                {\n+                    "textareaName": self.name,\n+                    "widgets": {\n+                        "text/html": {  # TODO: currently, we only support\n+                            # richtext widget config for\n+                            # \'text/html\', no other mimetypes.\n+                            "pattern": self.pattern,\n+                            "patternOptions": pattern_options,\n+                        },\n+                    },\n+                },\n+            )\n+\n+            # Create a list of allowed mime types\n+            for mt in allowed_mime_types:\n+                opt = etree.Element("option")\n+                opt.attrib["value"] = mt\n+                if value_mime_type == mt:\n+                    opt.attrib["selected"] = "selected"\n+                opt.text = mt\n+                mt_select.append(opt)\n+\n+            # Render the combined widget\n+            rendered = "{}\\n{}".format(\n+                textarea_widget.render(),\n+                etree.tostring(mt_select, encoding="unicode"),\n+            )\n+        return rendered\n+\n+\n+def tinymce_richtextwidget_render(widget):\n+    return RichTextWidget.render_input_mode(widget)\n+\n+\n+@implementer(IFieldWidget)\n+def RichTextFieldWidget(field, request):\n+    return FieldWidget(field, RichTextWidget(request))\ndiff --git a/plone/app/z3cform/widgets/select.py b/plone/app/z3cform/widgets/select.py\nnew file mode 100644\nindex 00000000..9eda7df9\n--- /dev/null\n+++ b/plone/app/z3cform/widgets/select.py\n@@ -0,0 +1,310 @@\n+from OFS.interfaces import ISimpleItem\n+from plone.app.z3cform.interfaces import IAjaxSelectWidget\n+from plone.app.z3cform.interfaces import ISelectWidget\n+from plone.app.z3cform.utils import dict_merge\n+from plone.app.z3cform.utils import get_context_url\n+from plone.app.z3cform.utils import get_widget_form\n+from plone.app.z3cform.widgets.base import BaseWidget\n+from plone.app.z3cform.widgets.patterns import InputWidget\n+from plone.app.z3cform.widgets.patterns import SelectWidget\n+from plone.registry.interfaces import IRegistry\n+from Products.CMFCore.utils import getToolByName\n+from z3c.form import interfaces as form_ifaces\n+from z3c.form.browser.select import SelectWidget as z3cform_SelectWidget\n+from z3c.form.browser.text import TextWidget as z3cform_TextWidget\n+from z3c.form.interfaces import IEditForm\n+from z3c.form.interfaces import IFieldWidget\n+from z3c.form.interfaces import IForm\n+from z3c.form.interfaces import NO_VALUE\n+from z3c.form.widget import FieldWidget\n+from zope.component import getUtility\n+from zope.component import queryUtility\n+from zope.i18n import translate\n+from zope.interface import implementer\n+from zope.interface import implementer_only\n+from zope.schema import interfaces as schema_ifaces\n+from zope.schema.interfaces import IChoice\n+from zope.schema.interfaces import ICollection\n+from zope.schema.interfaces import ISequence\n+from zope.schema.interfaces import IVocabularyFactory\n+\n+import collections\n+\n+\n+@implementer_only(ISelectWidget)\n+class SelectWidget(BaseWidget, z3cform_SelectWidget):\n+    """Select widget for z3c.form."""\n+\n+    _base = SelectWidget\n+\n+    pattern = "select2"\n+    pattern_options = BaseWidget.pattern_options.copy()\n+\n+    separator = ";"\n+    noValueToken = ""\n+    noValueMessage = ""\n+    multiple = None\n+    orderable = False\n+    required = True\n+\n+    @property\n+    def items(self):\n+        """\n+        Optionally handle ITreeVocabulary vocabs as dicts.\n+        """\n+        terms = self.terms\n+        if form_ifaces.ITerms.providedBy(terms):\n+            terms = terms.terms\n+\n+        if schema_ifaces.ITreeVocabulary.providedBy(terms):\n+            groups = collections.OrderedDict()\n+            for group_term, option_terms in terms.items():\n+                group_widget = type(self)(self.request)\n+                group_widget.terms = option_terms\n+                group_label = group_term.title or group_term.value or group_term.token\n+                groups[group_label] = super(SelectWidget, group_widget).items\n+            return groups\n+        else:\n+            return super().items\n+\n+    def _base_args(self):\n+        """Method which will calculate _base class arguments.\n+\n+        Returns (as python dictionary):\n+            - `pattern`: pattern name\n+            - `pattern_options`: pattern options\n+            - `name`: field name\n+            - `value`: field value\n+            - `multiple`: field multiple\n+            - `items`: field items from which we can select to\n+\n+        :returns: Arguments which will be passed to _base\n+        :rtype: dict\n+        """\n+        args = super()._base_args()\n+        args["name"] = self.name\n+        args["value"] = self.value\n+        args["multiple"] = self.multiple\n+\n+        self.required = self.field.required\n+\n+        options = args.setdefault("pattern_options", {})\n+        if self.multiple or ICollection.providedBy(self.field):\n+            args["multiple"] = self.multiple = True\n+\n+        # ISequence represents an orderable collection\n+        if ISequence.providedBy(self.field) or self.orderable:\n+            options["orderable"] = True\n+\n+        if self.multiple:\n+            options["separator"] = self.separator\n+\n+        # Allow to clear field value if it is not required\n+        if not self.required:\n+            options["allowClear"] = True\n+\n+        base_items = self.items\n+        if callable(base_items):\n+            # items used to be a property in all widgets, then in the select\n+            # widget it became a method, then in a few others too, but never in\n+            # all, so this was reverted to let it be a property again.  Let\'s\n+            # support both here to avoid breaking on some z3c.form versions.\n+            # See https://github.com/zopefoundation/z3c.form/issues/44\n+            base_items = base_items()\n+\n+        def makeItem(item):\n+            """\n+            Gather the information needed by the widget for the given term.\n+            """\n+            if not isinstance(item["content"], str):\n+                item["content"] = translate(\n+                    item["content"], context=self.request, default=item["value"]\n+                )\n+            return (item["value"], item["content"])\n+\n+        if isinstance(base_items, dict):\n+            items = collections.OrderedDict(\n+                (group_label, [makeItem(base_item) for base_item in group_options])\n+                for group_label, group_options in base_items.items()\n+            )\n+        else:\n+            items = [makeItem(item) for item in base_items]\n+        args["items"] = items\n+\n+        return args\n+\n+    def extract(self, default=NO_VALUE):\n+        """Override extract to handle delimited response values.\n+        Skip the vocabulary validation provided in the parent\n+        method, since it\'s not ever done for single selects."""\n+        if (\n+            self.name not in self.request\n+            and self.name + "-empty-marker" in self.request\n+        ):\n+            return []\n+        return self.request.get(self.name, default)\n+\n+\n+@implementer_only(IAjaxSelectWidget)\n+class AjaxSelectWidget(BaseWidget, z3cform_TextWidget):\n+    """Ajax select widget for z3c.form."""\n+\n+    _base = InputWidget\n+\n+    pattern = "select2"\n+    pattern_options = BaseWidget.pattern_options.copy()\n+\n+    separator = ";"\n+    vocabulary = None\n+    vocabulary_view = "@@getVocabulary"\n+    orderable = False\n+\n+    def _view_context(self):\n+        view_context = get_widget_form(self)\n+        # For EditForms and non-Forms (in tests), the vocabulary is looked\n+        # up on the context, otherwise on the view\n+        if IEditForm.providedBy(view_context):\n+            if self.is_subform_widget():\n+                view_context = self.form.parentForm.context\n+            elif not ISimpleItem.providedBy(self.context):\n+                view_context = self.form.context\n+            else:\n+                view_context = self.context\n+        elif not IForm.providedBy(view_context):\n+            view_context = self.context\n+        return view_context\n+\n+    def get_vocabulary(self):\n+        if self.vocabulary and isinstance(self.vocabulary, str):\n+            factory = queryUtility(\n+                IVocabularyFactory,\n+                self.vocabulary,\n+            )\n+            if factory:\n+                return factory(self._view_context())\n+        return self.vocabulary\n+\n+    def display_items(self):\n+        if self.value:\n+            tokens = self.value.split(self.separator)\n+            vocabulary = self.get_vocabulary()\n+            for token in tokens:\n+                item = {"token": token, "title": token}\n+                if vocabulary is not None:\n+                    try:\n+                        item["title"] = vocabulary.getTermByToken(token).title\n+                    except LookupError:\n+                        pass\n+                yield item\n+\n+    def has_multiple_values(self):\n+        return self.value and self.value.split(self.separator)\n+\n+    def _ajaxselect_options(self):\n+        options = {\n+            "separator": self.separator,\n+        }\n+        if self.vocabulary:\n+            options["vocabularyUrl"] = "{}/{}?name={}".format(\n+                get_context_url(self._view_context()),\n+                self.vocabulary_view,\n+                self.vocabulary,\n+            )\n+            field_name = self.field and self.field.__name__ or None\n+            if field_name:\n+                options["vocabularyUrl"] += f"&field={field_name}"\n+            vocabulary = self.get_vocabulary()\n+            if vocabulary is not None and self.value:\n+                options["initialValues"] = dict()\n+                for token in self.value.split(self.separator):\n+                    try:\n+                        term = vocabulary.getTermByToken(token)\n+                        options["initialValues"][term.token] = term.title\n+                    except LookupError:\n+                        options["initialValues"][token] = token\n+\n+        return options\n+\n+    def update(self):\n+        super().update()\n+        field = getattr(self, "field", None)\n+        field = getattr(field, "value_type", field)\n+        if (\n+            not self.vocabulary\n+            and field is not None\n+            and getattr(field, "vocabularyName", None)\n+        ):\n+            self.vocabulary = field.vocabularyName\n+\n+    def _base_args(self):\n+        """Method which will calculate _base class arguments.\n+\n+        Returns (as python dictionary):\n+            - `pattern`: pattern name\n+            - `pattern_options`: pattern options\n+            - `name`: field name\n+            - `value`: field value\n+\n+        :returns: Arguments which will be passed to _base\n+        :rtype: dict\n+        """\n+        args = super()._base_args()\n+        args["name"] = self.name\n+        args["value"] = self.value\n+        args.setdefault("pattern_options", {})\n+        context = self.context\n+        field = None\n+\n+        if IChoice.providedBy(self.field):\n+            args["pattern_options"]["maximumSelectionSize"] = 1\n+            field = self.field\n+        elif ICollection.providedBy(self.field):\n+            field = self.field.value_type\n+        if IChoice.providedBy(field):\n+            args["pattern_options"]["allowNewItems"] = "false"\n+\n+        args["pattern_options"] = dict_merge(\n+            self._ajaxselect_options(), args["pattern_options"]\n+        )\n+\n+        if field and getattr(field, "vocabulary", None):\n+            form_url = self.request.getURL()\n+            source_url = "{:s}/++widget++{:s}/@@getSource".format(\n+                form_url,\n+                self.name,\n+            )\n+            args["pattern_options"]["vocabularyUrl"] = source_url\n+\n+        # ISequence represents an orderable collection\n+        if ISequence.providedBy(self.field) or self.orderable:\n+            args["pattern_options"]["orderable"] = True\n+\n+        if self.vocabulary == "plone.app.vocabularies.Keywords":\n+            membership = getToolByName(context, "portal_membership")\n+            user = membership.getAuthenticatedMember()\n+\n+            registry = getUtility(IRegistry)\n+            roles_allowed_to_add_keywords = registry.get(\n+                "plone.roles_allowed_to_add_keywords", set()\n+            )\n+            roles = set(user.getRolesInContext(context))\n+            allowNewItems = bool(\n+                roles.intersection(roles_allowed_to_add_keywords),\n+            )\n+            args["pattern_options"]["allowNewItems"] = str(\n+                allowNewItems,\n+            ).lower()\n+\n+        return args\n+\n+\n+@implementer(IFieldWidget)\n+def SelectFieldWidget(field, request):\n+    return FieldWidget(field, SelectWidget(request))\n+\n+\n+@implementer(IFieldWidget)\n+def AjaxSelectFieldWidget(field, request, extra=None):\n+    if extra is not None:\n+        request = extra\n+    return FieldWidget(field, AjaxSelectWidget(request))\ndiff --git a/plone/app/z3cform/widgets/singlecheckbox.py b/plone/app/z3cform/widgets/singlecheckbox.py\nnew file mode 100644\nindex 00000000..e7e50508\n--- /dev/null\n+++ b/plone/app/z3cform/widgets/singlecheckbox.py\n@@ -0,0 +1,90 @@\n+from plone.app.vocabularies.terms import TermWithDescription\n+from plone.app.z3cform.interfaces import IPloneFormLayer\n+from plone.app.z3cform.interfaces import ISingleCheckBoxBoolWidget\n+from z3c.form.browser.checkbox import SingleCheckBoxWidget\n+from z3c.form.interfaces import IFieldWidget\n+from z3c.form.term import BoolTerms\n+from z3c.form.term import Terms\n+from z3c.form.widget import FieldWidget\n+from zope.component import adapter\n+from zope.interface import implementer\n+from zope.interface import implementer_only\n+from zope.schema.interfaces import IBool\n+from zope.schema.vocabulary import SimpleTerm\n+from zope.schema.vocabulary import SimpleVocabulary\n+\n+\n+@implementer_only(ISingleCheckBoxBoolWidget)\n+class SingleCheckBoxBoolWidget(SingleCheckBoxWidget):\n+    """Single Input type checkbox widget implementation."""\n+\n+    klass = "single-checkbox-bool-widget"\n+\n+    @property\n+    def label(self):\n+        if self.mode == "input":\n+            return ""\n+        return getattr(self, "_label", "")\n+\n+    @label.setter\n+    def label(self, value):\n+        self._label = value\n+\n+    @property\n+    def description(self):\n+        if self.mode == "input":\n+            return ""\n+        return getattr(self, "_description", "")\n+\n+    @description.setter\n+    def description(self, value):\n+        self._description = value\n+\n+    def updateTerms(self):\n+        if self.mode == "input":\n+            # in input mode use only one checkbox with true\n+            self.terms = Terms()\n+            self.terms.terms = SimpleVocabulary(\n+                (\n+                    TermWithDescription(\n+                        True,\n+                        "selected",\n+                        getattr(self, "_label", None) or self.field.title,\n+                        getattr(\n+                            self,\n+                            "_description",\n+                            None,\n+                        )\n+                        or self.field.description,\n+                    ),\n+                )\n+            )\n+            return self.terms\n+        if not self.terms:\n+            self.terms = Terms()\n+            self.terms.terms = SimpleVocabulary(\n+                [\n+                    SimpleTerm(*args)\n+                    for args in [\n+                        (True, "selected", BoolTerms.trueLabel),\n+                        (False, "unselected", BoolTerms.falseLabel),\n+                    ]\n+                ],\n+            )\n+        return self.terms\n+\n+    @property\n+    def items(self):\n+        result = super().items\n+        for record in result:\n+            term = self.terms.terms.getTermByToken(record["value"])\n+            record["description"] = getattr(term, "description", "")\n+            record["required"] = self.required\n+        return result\n+\n+\n+@adapter(IBool, IPloneFormLayer)\n+@implementer(IFieldWidget)\n+def SingleCheckBoxBoolFieldWidget(field, request):\n+    """IFieldWidget factory for CheckBoxWidget."""\n+    return FieldWidget(field, SingleCheckBoxBoolWidget(request))\ndiff --git a/setup.py b/setup.py\nindex 6df5a7c1..e4724533 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -65,15 +65,8 @@ def read(*rnames):\n     zip_safe=False,\n     python_requires=">=3.8",\n     install_requires=[\n-        "lxml",\n-        "plone.app.contentlisting",\n-        "plone.app.vocabularies",\n         "plone.app.textfield>=1.3.6",\n-        "plone.app.widgets>=2.4.2",\n         "plone.base",\n-        "plone.dexterity",\n-        "plone.i18n",\n-        "plone.namedfile",\n         "plone.protect",\n         "plone.registry",\n         "plone.schema",\n@@ -83,11 +76,9 @@ def read(*rnames):\n         "pytz",\n         "setuptools",\n         "z3c.form >= 4.0",\n-        "z3c.relationfield",\n-        "zope.browserpage",\n-        "zope.contentprovider",\n+        "z3c.formwidget.query",\n+        "zope.deprecation",\n         "zope.globalrequest",\n-        "zope.pagetemplate",\n         "Zope",\n     ],\n     extras_require={\n'

