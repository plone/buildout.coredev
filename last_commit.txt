Repository: Products.CMFPlone


Branch: refs/heads/4.3.x
Date: 2020-07-28T00:37:50+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/Products.CMFPlone/commit/8fdb5dec4bee981bdacc85b7f8e7654d11821b66

Depend on new package Products.isurlinportal.

This contains the `isURLInPortal` method that was split off from our `URLTool`.
See https://github.com/plone/Products.CMFPlone/issues/3150.

We depend on a version less than 2.0.0.
This is in the expectancy that such a breaking version will be released at some point,
probably when dropping support for Python 2 or for Zope 2.

Files changed:
A news/3150.bugfix
M Products/CMFPlone/URLTool.py
M setup.py

b'diff --git a/Products/CMFPlone/URLTool.py b/Products/CMFPlone/URLTool.py\nindex bb98640b32..14beed3eeb 100644\n--- a/Products/CMFPlone/URLTool.py\n+++ b/Products/CMFPlone/URLTool.py\n@@ -1,91 +1,9 @@\n-from HTMLParser import HTMLParser\n-from Products.CMFCore.URLTool import URLTool as BaseTool\n-from Products.CMFCore.utils import getToolByName\n+# -*- coding: utf-8 -*-\n from AccessControl import ClassSecurityInfo\n-from App.class_init import InitializeClass\n+from AccessControl.class_init import InitializeClass\n+from Products.CMFCore.URLTool import URLTool as BaseTool\n from Products.CMFPlone.PloneBaseTool import PloneBaseTool\n \n-from posixpath import normpath\n-from urlparse import urlparse, urljoin\n-import re\n-import string\n-import unicodedata\n-\n-\n-hp = HTMLParser()\n-# These schemas are allowed in full urls to consider them in the portal:\n-# A mailto schema is an obvious sign of a url that is not in the portal.\n-# This is a whitelist.\n-ALLOWED_SCHEMAS = [\n-    \'https\',\n-    \'http\',\n-]\n-# These bad parts are not allowed in urls that are in the portal:\n-# This is a blacklist.\n-BAD_URL_PARTS = [\n-    \'\\\\\\\\\',\n-    \'<script\',\n-    \'%3cscript\',\n-    \'javascript:\',\n-    \'javascript%3a\',\n-]\n-\n-# Determine allowed ascii characters.\n-# We want to allow most printable characters,\n-# but no whitespace, and no punctuation, except for a few exceptions.\n-# This boils down to ascii letters plus digits plus exceptions.\n-# Exceptions:\n-# - dot and slash for relative or absolute paths.\n-# - @ because we have views starting with @@\n-# - + because we have ++resource++ urls\n-allowed_ascii = string.ascii_letters + string.digits + "./@+"\n-\n-def safe_url_first_char(url):\n-    # For character code points higher than 127, the bytes representation of a character\n-    # is longer than the unicode representation, so url[0] may give different results\n-    # for bytes and unicode.  On Python 2:\n-    # >>> unichr(128)\n-    # u\'\\x80\'\n-    # >>> len(unichr(128))\n-    # 1\n-    # >>> unichr(128).encode("latin-1")\n-    # \'\\x80\'\n-    # >>> len(unichr(128).encode("latin-1"))\n-    # 1\n-    # >>> unichr(128).encode("utf-8")\n-    # \'\\xc2\\x80\'\n-    # >>> len(unichr(128).encode("utf-8"))\n-    # 2\n-    # >>> unichr(128).encode("utf-8")[0]\n-    # \'\\xc2\'\n-    # So make sure we have unicode here for comparing the first character.\n-    if isinstance(url, bytes):\n-        # Remember, on Python 2, bytes == str.\n-        try:\n-            first = url.decode("utf-8")[0]\n-        except UnicodeDecodeError:\n-            # We don\'t trust this\n-            return False\n-    else:\n-        first = url[0]\n-    if ord(first) < 128:\n-        if first not in allowed_ascii:\n-            # The first character of the url is ascii but not in the allowed range.\n-            return False\n-    else:\n-        # This is non-ascii, which has lots of control characters, which may be dangerous.\n-        # Check taken from django.utils.http._is_safe_url.  See\n-        # https://github.com/django/django/blob/2.1.5/django/utils/http.py#L356-L382\n-        # Forbid URLs that start with control characters. Some browsers (like\n-        # Chrome) ignore quite a few control characters at the start of a\n-        # URL and might consider the URL as scheme relative.\n-        # For categories, see 5.7.1 General Category Values here:\n-        # http://www.unicode.org/reports/tr44/tr44-6.html#Property_Values\n-        # We look for Control categories here.\n-        if unicodedata.category(first)[0] == "C":\n-            return False\n-    return True\n-\n \n class URLTool(PloneBaseTool, BaseTool):\n \n@@ -93,79 +11,26 @@ class URLTool(PloneBaseTool, BaseTool):\n     security = ClassSecurityInfo()\n     toolicon = \'skins/plone_images/link_icon.png\'\n \n-    security.declarePublic(\'isURLInPortal\')\n+    @security.public\n     def isURLInPortal(self, url, context=None):\n-        # Check if a given url is on the same host and contains the portal\n-        # path.  Used to ensure that login forms can determine relevant\n-        # referrers (i.e. in portal).  Also return true for some relative\n-        # urls if context is passed in to allow for url parsing. When context\n-        # is not provided, assume that relative urls are in the portal. It is\n-        # assumed that http://portal is the same portal as https://portal.\n-\n-        # External sites listed in \'allow_external_login_sites\' of\n-        # site_properties are also considered within the portal to allow for\n-        # single sign on.\n-\n-        if url and not safe_url_first_char(url):\n-            return False\n-\n-        # sanitize url\n-        url = re.sub(\'^[\\x00-\\x20]+\', \'\', url).strip()\n-        cmp_url = url.lower()\n-        for bad in BAD_URL_PARTS:\n-            if bad in cmp_url:\n-                return False\n-\n-        p_url = self()\n-\n-        schema, u_host, u_path, _, _, _ = urlparse(url)\n-        if schema and schema not in ALLOWED_SCHEMAS:\n-            # Redirecting to \'data:\' may be harmful,\n-            # and redirecting to \'mailto:\' or \'ftp:\' is silly.\n+        # Note: no docstring, because the method is publicly available\n+        # but does not need to be callable on site-url/portal_url/isURLInPortal.\n+        #\n+        # This method is overridden by Products.isurlinportal,\n+        # but the public declaration still seems needed.\n+        #\n+        # Also, in tests/testURLTool.py we do not use layers,\n+        # which means the Products code is not loaded,\n+        # so we need to import it explicitly.\n+        # This is done once.\n+        try:\n+            from Products.isurlinportal import isURLInPortal\n+        except ImportError:\n+            # If this somehow fails, it seems better to have a safe fallback,\n+            # instead of a hard failure.\n             return False\n \n-        # Someone may be doing tricks with escaped html code.\n-        unescaped_url = hp.unescape(url)\n-        if unescaped_url != url:\n-            if not self.isURLInPortal(unescaped_url):\n-                return False\n-\n-        if not u_host and not u_path.startswith(\'/\'):\n-            if context is None:\n-                return True  # old behavior\n-            if not context.isPrincipiaFolderish:\n-                useurl = context.aq_parent.absolute_url()\n-            else:\n-                useurl = context.absolute_url()\n-        else:\n-            useurl = p_url  # when u_path.startswith(\'/\')\n-        if not useurl.endswith(\'/\'):\n-            useurl += \'/\'\n-\n-        # urljoin to current url to get an absolute path\n-        _, u_host, u_path, _, _, _ = urlparse(urljoin(useurl, url))\n-\n-        # normalise to end with a \'/\' so /foobar is not considered within /foo\n-        if not u_path:\n-            u_path = \'/\'\n-        else:\n-            u_path = normpath(u_path)\n-            if not u_path.endswith(\'/\'):\n-                u_path += \'/\'\n-        _, host, path, _, _, _ = urlparse(p_url)\n-        if not path.endswith(\'/\'):\n-            path += \'/\'\n-        if host == u_host and u_path.startswith(path):\n-            return True\n-\n-        props = getToolByName(self, \'portal_properties\').site_properties\n-        for external_site in props.getProperty(\'allow_external_login_sites\', []):\n-            _, host, path, _, _, _ = urlparse(external_site)\n-            if not path.endswith(\'/\'):\n-                path += \'/\'\n-            if host == u_host and u_path.startswith(path):\n-                return True\n-        return False\n+        return isURLInPortal(self, url, context=context)\n \n \n URLTool.__doc__ = BaseTool.__doc__\ndiff --git a/news/3150.bugfix b/news/3150.bugfix\nnew file mode 100644\nindex 0000000000..baf995f9e1\n--- /dev/null\n+++ b/news/3150.bugfix\n@@ -0,0 +1,4 @@\n+Depend on new package ``Products.isurlinportal``.\n+This contains the ``isURLInPortal`` method that was split off from our ``URLTool``.\n+See `issue 3150 <https://github.com/plone/Products.CMFPlone/issues/3150>`_.\n+[maurits]\ndiff --git a/setup.py b/setup.py\nindex 004000ae6b..0424f47176 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -61,6 +61,7 @@\n           \'Products.ExtendedPathIndex\',\n           \'Products.ExternalEditor\',\n           \'Products.GenericSetup >= 1.8.0\',\n+          \'Products.isurlinportal <= 2.0.0\',\n           \'Products.MimetypesRegistry\',\n           \'Products.PasswordResetTool\',\n           \'Products.PlacelessTranslationService\',\n'

Repository: Products.CMFPlone


Branch: refs/heads/4.3.x
Date: 2020-07-28T11:36:44+02:00
Author: Maurits van Rees (mauritsvanrees) <m.van.rees@zestsoftware.nl>
Commit: https://github.com/plone/Products.CMFPlone/commit/636165534608d522f8499db9bf5650966f634415

Merge pull request #3156 from plone/maurits/products-isurlinportal-43

Depend on new package Products.isurlinportal. [4.3]

Files changed:
A news/3150.bugfix
M Products/CMFPlone/URLTool.py
M setup.py

b'diff --git a/Products/CMFPlone/URLTool.py b/Products/CMFPlone/URLTool.py\nindex bb98640b32..14beed3eeb 100644\n--- a/Products/CMFPlone/URLTool.py\n+++ b/Products/CMFPlone/URLTool.py\n@@ -1,91 +1,9 @@\n-from HTMLParser import HTMLParser\n-from Products.CMFCore.URLTool import URLTool as BaseTool\n-from Products.CMFCore.utils import getToolByName\n+# -*- coding: utf-8 -*-\n from AccessControl import ClassSecurityInfo\n-from App.class_init import InitializeClass\n+from AccessControl.class_init import InitializeClass\n+from Products.CMFCore.URLTool import URLTool as BaseTool\n from Products.CMFPlone.PloneBaseTool import PloneBaseTool\n \n-from posixpath import normpath\n-from urlparse import urlparse, urljoin\n-import re\n-import string\n-import unicodedata\n-\n-\n-hp = HTMLParser()\n-# These schemas are allowed in full urls to consider them in the portal:\n-# A mailto schema is an obvious sign of a url that is not in the portal.\n-# This is a whitelist.\n-ALLOWED_SCHEMAS = [\n-    \'https\',\n-    \'http\',\n-]\n-# These bad parts are not allowed in urls that are in the portal:\n-# This is a blacklist.\n-BAD_URL_PARTS = [\n-    \'\\\\\\\\\',\n-    \'<script\',\n-    \'%3cscript\',\n-    \'javascript:\',\n-    \'javascript%3a\',\n-]\n-\n-# Determine allowed ascii characters.\n-# We want to allow most printable characters,\n-# but no whitespace, and no punctuation, except for a few exceptions.\n-# This boils down to ascii letters plus digits plus exceptions.\n-# Exceptions:\n-# - dot and slash for relative or absolute paths.\n-# - @ because we have views starting with @@\n-# - + because we have ++resource++ urls\n-allowed_ascii = string.ascii_letters + string.digits + "./@+"\n-\n-def safe_url_first_char(url):\n-    # For character code points higher than 127, the bytes representation of a character\n-    # is longer than the unicode representation, so url[0] may give different results\n-    # for bytes and unicode.  On Python 2:\n-    # >>> unichr(128)\n-    # u\'\\x80\'\n-    # >>> len(unichr(128))\n-    # 1\n-    # >>> unichr(128).encode("latin-1")\n-    # \'\\x80\'\n-    # >>> len(unichr(128).encode("latin-1"))\n-    # 1\n-    # >>> unichr(128).encode("utf-8")\n-    # \'\\xc2\\x80\'\n-    # >>> len(unichr(128).encode("utf-8"))\n-    # 2\n-    # >>> unichr(128).encode("utf-8")[0]\n-    # \'\\xc2\'\n-    # So make sure we have unicode here for comparing the first character.\n-    if isinstance(url, bytes):\n-        # Remember, on Python 2, bytes == str.\n-        try:\n-            first = url.decode("utf-8")[0]\n-        except UnicodeDecodeError:\n-            # We don\'t trust this\n-            return False\n-    else:\n-        first = url[0]\n-    if ord(first) < 128:\n-        if first not in allowed_ascii:\n-            # The first character of the url is ascii but not in the allowed range.\n-            return False\n-    else:\n-        # This is non-ascii, which has lots of control characters, which may be dangerous.\n-        # Check taken from django.utils.http._is_safe_url.  See\n-        # https://github.com/django/django/blob/2.1.5/django/utils/http.py#L356-L382\n-        # Forbid URLs that start with control characters. Some browsers (like\n-        # Chrome) ignore quite a few control characters at the start of a\n-        # URL and might consider the URL as scheme relative.\n-        # For categories, see 5.7.1 General Category Values here:\n-        # http://www.unicode.org/reports/tr44/tr44-6.html#Property_Values\n-        # We look for Control categories here.\n-        if unicodedata.category(first)[0] == "C":\n-            return False\n-    return True\n-\n \n class URLTool(PloneBaseTool, BaseTool):\n \n@@ -93,79 +11,26 @@ class URLTool(PloneBaseTool, BaseTool):\n     security = ClassSecurityInfo()\n     toolicon = \'skins/plone_images/link_icon.png\'\n \n-    security.declarePublic(\'isURLInPortal\')\n+    @security.public\n     def isURLInPortal(self, url, context=None):\n-        # Check if a given url is on the same host and contains the portal\n-        # path.  Used to ensure that login forms can determine relevant\n-        # referrers (i.e. in portal).  Also return true for some relative\n-        # urls if context is passed in to allow for url parsing. When context\n-        # is not provided, assume that relative urls are in the portal. It is\n-        # assumed that http://portal is the same portal as https://portal.\n-\n-        # External sites listed in \'allow_external_login_sites\' of\n-        # site_properties are also considered within the portal to allow for\n-        # single sign on.\n-\n-        if url and not safe_url_first_char(url):\n-            return False\n-\n-        # sanitize url\n-        url = re.sub(\'^[\\x00-\\x20]+\', \'\', url).strip()\n-        cmp_url = url.lower()\n-        for bad in BAD_URL_PARTS:\n-            if bad in cmp_url:\n-                return False\n-\n-        p_url = self()\n-\n-        schema, u_host, u_path, _, _, _ = urlparse(url)\n-        if schema and schema not in ALLOWED_SCHEMAS:\n-            # Redirecting to \'data:\' may be harmful,\n-            # and redirecting to \'mailto:\' or \'ftp:\' is silly.\n+        # Note: no docstring, because the method is publicly available\n+        # but does not need to be callable on site-url/portal_url/isURLInPortal.\n+        #\n+        # This method is overridden by Products.isurlinportal,\n+        # but the public declaration still seems needed.\n+        #\n+        # Also, in tests/testURLTool.py we do not use layers,\n+        # which means the Products code is not loaded,\n+        # so we need to import it explicitly.\n+        # This is done once.\n+        try:\n+            from Products.isurlinportal import isURLInPortal\n+        except ImportError:\n+            # If this somehow fails, it seems better to have a safe fallback,\n+            # instead of a hard failure.\n             return False\n \n-        # Someone may be doing tricks with escaped html code.\n-        unescaped_url = hp.unescape(url)\n-        if unescaped_url != url:\n-            if not self.isURLInPortal(unescaped_url):\n-                return False\n-\n-        if not u_host and not u_path.startswith(\'/\'):\n-            if context is None:\n-                return True  # old behavior\n-            if not context.isPrincipiaFolderish:\n-                useurl = context.aq_parent.absolute_url()\n-            else:\n-                useurl = context.absolute_url()\n-        else:\n-            useurl = p_url  # when u_path.startswith(\'/\')\n-        if not useurl.endswith(\'/\'):\n-            useurl += \'/\'\n-\n-        # urljoin to current url to get an absolute path\n-        _, u_host, u_path, _, _, _ = urlparse(urljoin(useurl, url))\n-\n-        # normalise to end with a \'/\' so /foobar is not considered within /foo\n-        if not u_path:\n-            u_path = \'/\'\n-        else:\n-            u_path = normpath(u_path)\n-            if not u_path.endswith(\'/\'):\n-                u_path += \'/\'\n-        _, host, path, _, _, _ = urlparse(p_url)\n-        if not path.endswith(\'/\'):\n-            path += \'/\'\n-        if host == u_host and u_path.startswith(path):\n-            return True\n-\n-        props = getToolByName(self, \'portal_properties\').site_properties\n-        for external_site in props.getProperty(\'allow_external_login_sites\', []):\n-            _, host, path, _, _, _ = urlparse(external_site)\n-            if not path.endswith(\'/\'):\n-                path += \'/\'\n-            if host == u_host and u_path.startswith(path):\n-                return True\n-        return False\n+        return isURLInPortal(self, url, context=context)\n \n \n URLTool.__doc__ = BaseTool.__doc__\ndiff --git a/news/3150.bugfix b/news/3150.bugfix\nnew file mode 100644\nindex 0000000000..baf995f9e1\n--- /dev/null\n+++ b/news/3150.bugfix\n@@ -0,0 +1,4 @@\n+Depend on new package ``Products.isurlinportal``.\n+This contains the ``isURLInPortal`` method that was split off from our ``URLTool``.\n+See `issue 3150 <https://github.com/plone/Products.CMFPlone/issues/3150>`_.\n+[maurits]\ndiff --git a/setup.py b/setup.py\nindex 004000ae6b..0424f47176 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -61,6 +61,7 @@\n           \'Products.ExtendedPathIndex\',\n           \'Products.ExternalEditor\',\n           \'Products.GenericSetup >= 1.8.0\',\n+          \'Products.isurlinportal <= 2.0.0\',\n           \'Products.MimetypesRegistry\',\n           \'Products.PasswordResetTool\',\n           \'Products.PlacelessTranslationService\',\n'

